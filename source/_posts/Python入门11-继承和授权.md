---
title: Python入门11-继承和授权
date: 2017-01-13 11:48:46
category: Python
tags: Python

---

## 继承

### 简介
描述基类的属性遗传给派生类。
1. `__doc___`类属性不会从基类中遗传过来。
2. `__bases__`类属性是包含父类集合的元组。
3. 可以在子类中定义同名函数覆盖父类的函数方法(多态)。可以在子类中显式地(需要知道父类名)或通过`super()`内建方法(默认传递`self`)调用父类方法。
4. 需要注意如果覆盖构造器`__init__()`方法，子类实例化时并不会自动调用父类的构造器，应该在子类中明确地调用父类的构造器。
	+ `super(obj, ins)`传入两个参数，类和类的实例，Python3中参数默认值是当前类和`self`(当前类的实例)。

### 派生标准类型
正如元类调用`type()`，是类的类一样，标准类型也可以看做是类型的类，来派生出新的类型。

#### 不可变类型的派生
1. 应该覆盖`__new__()`特殊方法来定制我们的对象，因为这个方法在`__init__(self)`执行之前执行并返回一个对象传入初始化方法`__init__(self)`(即这里的`self`)。
2. [python 类中__new__ 和 __init__方法区别](https://zhuanlan.zhihu.com/p/21379984)

#### 可变类型的派生
一般情况下，对可变类型继承到的类型的默认行为就是你想要的。


### 多重继承
多重继承一般有两个问题，第一，找到合适的属性；第二，如何调用父类的方法以发挥他们的作用。
1. 方法解释顺序MRO(`Method Resolution Order`)，新式类出现之前是深度优先，之后是广度优先，新式类的`__mro__`属性会返回查找顺序。
	+ [python super()](http://www.cnblogs.com/lovemo1314/archive/2011/05/03/2035005.html)
2. 菱形效应引起的MRO问题，因为新式类都会从`object`中派生，如果采用深度优先，会多次回溯到`object`。这是不期望的。
	+ 1中的链接很好的说明了这个问题，F的mro顺序FEBCDAob，E的MRO顺序EBCAob，C的MRO顺序CAob。、

### 内建函数
1. `subclass(sub,sup)`判断一个类是不是另一个类的子类或者子孙类。
2. `isinstance(obj,OBJ)`判定一个对象是不是另一个给定类的实例。
	+ 第二个参数是类。
	+ 他不会有性能上的问题，因为他只用来搜索类族集成结构，而且它是用C写的。
3. `hasattr(ins,attr)` 判断一个对象是否有特定的属性。
4. `getattr(ins,attr)` 取得对象的属性。
5. `setattr(ins,attr)` 赋值给对象的属性。
6. `delattr(ins,attr)` 从一个对象中删除属性。
7. `dir()`
	+ 作用于实例上，显示实例变量，还有实例所在类及所有他的基类中定义的方法和类。
	+ 作用于类上，显示类以及他的所有基类的`__dict__`中的内容。但他不会显示定义在元类(`metaclass`)中的类属性。
	+ 作用在模块上，显示模块的`__dict__`内容。
	+ 不带参数时，显示调用者的局部变量。
8. `super()` 帮助程序员找出相应的父类，然后方便调用相应的属性。
	+ 使用`super()`来简化搜索一个合适祖先的任务，其主要是用来查找父类的属性。
	+ 实际上，`super()`是一个工厂函数，他创造了一个`super object`，为一个给定的类使用`__mro__`去查找相应的父类。
9. `var()` 内建函数与`dir()`相似，只是给定的对象参数必须有一个`__dict__`属性。返回一个字典，包含对象存储于其`__dict__`中的属性(键)和值。
	+ 如果没有提供参数，他将显示一个包含本地名字空间的属性(键)及其值的字典，也就是`locals()`。

### 定制类
之前的`__init__()`和`__del__()`也是自定义特殊方法的一部分，另外，Python的类定制包含：模拟标准类型，重载操作符。
1. 可以定制的方法有，属性方法，二进制操作符，一元操作符，数值转换，基本表示法，序列类型，映射类型。
	+ Python中有两个除法，`/`真除法`__truediv__()`是准确的浮点除法，`//`是`__floordiv__()`C++中的整型除法。
	+ [Difference between __str__ and __repr__ in Python](http://stackoverflow.com/questions/1436703/difference-between-str-and-repr-in-python)，**unambiguous v.s. readable**，从编译器角度和从读者角度，另外，如果`__repr__()`定义了，但`__str__()`没有定义，默认会有`__str__=__repr__`。
	+ `__str__()`只返回一个字符串(这是`print()`的重载)，如果想要打印多个字符串，请自定义其他类型的打印函数。
2. 重载`__iter__`和`next()`方法可以定制迭代器，无穷迭代可以通过随机选择`choice()`或者处理异常来实现。
	+ **所谓的安全模式**：只是一个标识flag，在抓取到异常时，采用不同的决策。
3. `__nonzeros__()`可以为`object`定义`FALSE`值。
4. `__cmp__`对象比较。

---

## 私有化

### 类的访问控制
1. 在类的属性和方法名字前面加上**双下划线**提供了初步的类的私有化，不允许直接访问。在访问时，要在名字前边加上**单下划线和类名**来指定访问的是哪一个类的变量(`self._OBJ__attr`)。
	+ 保证`__XXX`变量不与父类的名称空间冲突。

### 模块级访问控制
1. 之前提到过模块级的私有化，在属性(或方法，因为这是严格基于作用域的)名称前加**单下划线**，这样不会被`from XXX import *`加载，但是可以显式载入。

---

## 授权(enabling)
授权是包装的一个特性，包装一个类型通常是对已存在的类型的一些定制，可以新建、修改、删除原有产品的功能。其他保持原样或保留已存功能或行为。授权的过程，即所有更新的功能都是由新类的某部分来处理，但已存的功能就授权给对象的默认属性。
1. 关键：<font color=red>覆盖`__getattr__()`</font>方法，代码中包含对`getattr()`内建函数的访问。
	+ 引用一个属性时，Python解释器会依次在局部名称空间，类名称空间中搜索，如果都没有找到，搜索对原对象开始授权申请，`__getattr__()`会被调用。
	+ 对这些属性的访问，是通过`getattr(obj,atrr)`方法，授权给对象。而且只有已存在的属性是在此代码中授权的。
	+ 在包装中实现`get()`方法返回一个对象，因为有时需要访问实际对象和他的切片能力。
2. 时间戳。[2015/9/29 Python基础(20)：类的授权](http://www.cnblogs.com/SRL-Southern/archive/2015/09/30/4848590.html)

---
