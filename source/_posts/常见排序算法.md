---
title: 常见排序算法
date: 2016-06-25 11:21:03
category: 数据结构与算法
tags: Algorithm

---

虽然接触各种排序，但恐才疏学浅一直以来未开始总结。今日先列出一个提纲，慢慢填充。
[wikipedia - 排序算法](https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95)
什么是排序算法的稳定性？
1. 不稳定的排序算法可能在相等的键值中改变记录的相对次序，但是稳定排序算法从不会如此。
2. 不稳定排序算法可以扩充第二键值的比较，实现为稳定的排序算法。

---

## 冒泡排序

从无序区通过交换找出最大元素放到有序区前端；
代码都比较简单，略过不谈；
1. 数据对象：数组(并不是说链表不能用冒泡，确实是毫无优势)；
2. 相邻交换并不会改变相同值元素的相对位置，因此冒泡排序时<font color = red>稳定</font>的；
3. 时间复杂度：平均O(n^2),最坏O(n^2)；
4. 额外空间复杂度：O(1)。

---

## 选择排序

从无序区找出一个最小的元素跟在有序区的后面。
代码比较简单，依然略过不谈。
[知乎 - 选择排序究竟属于稳定排序还是不稳定排序？](https://www.zhihu.com/question/20926405)
1. 数据对象：数组，链表。
2. 对数组就地排序：<font color=red>不稳定</font>，因为他包含交换操作，破坏了相对顺序，比如`5^1，5^2，2`->`2,5^2,5^1`；
   对链表和新数组的排序：本质上时插入排序，因此他是<font color=red>稳定</font>的；
3. 时间复杂度：平均O(n^2),最坏O(n^2)；
4. 额外空间复杂度：O(1)。

---

## 插入排序

把无序区的第一个元素插入到有序区合适的位置。
代码比较简单，依然略过不谈。
1. 数据对象：数组，链表。
2. 他是<font color=red>稳定</font>的排序方式，通常采用就地实现，即用O(1)的额外空间取出无序区的元素，后移有序区小于/大于他的元素。
3. 时间复杂度：平均O(n^2),最坏O(n^2)；
4. 额外空间复杂度：O(1)。

---

## 堆排序

从堆顶把根卸出来放在有序区之前，再恢复堆。
[堆排序 - C++](https://github.com/applefishsky009/DataStructuresAndAlgorithms/blob/master/3%20-%20HeapSort/HeapSort.cpp)
1. 数据对象：数组；
2. 堆排序是<font color=red>不稳定</font>的，因为建立堆的过程有交换操作，会破坏相对顺序，比如`5^1,5^2,9`->`9,5^2,5^1`；
3. 时间复杂度：O(n*logn);
4. 额外空间复杂度：O(1)。

---

## 

---

## 桶排序

桶排序是常见排序算法中最快的排序，时间复杂度为O(n)，他的核心思想是将每一个元素放在他"应该"在的位置，数据结构是指针数组，每个指针是一个链表。
举两个实际中的例子：
1. [github](https://github.com/applefishsky009/LeetCode)组织文件夹的方式就是桶排序；
2. 用程序(已测试过C++,MATLAB)读取一个文件夹的所有文件时，不管文件夹中文件如何排序，程序的遍历方式是(按文件名)桶排序的。

算法实例：
1. [First Missing Positive](https://github.com/applefishsky009/LeetCode/blob/master/41%20-%20First%20Missing%20Positive/41%20-%20First%20Missing%20Positive.cpp)
	+ O(n)时间复杂度，首先想到Hash Table，但是必然会有O(n)的空间复杂度，也不能用两个指针来简化；
	+ 考虑到桶排序，将所有的元素放在他应该在的位置，再遍历一次就得到异常元素；
	+ 注意避免无限交换(比如[1,1]序列)。
2. [Sort Colors](https://github.com/applefishsky009/LeetCode/blob/master/75%20-%20Sort%20Colors/75%20-%20Sort%20Colors.cpp)
	+ 两个指针排序，我也不知道该分类为什么排序算法 = =

