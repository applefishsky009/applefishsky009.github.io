---
title: Python入门11-面向对象编程
date: 2017-01-10 20:22:02
category: Python
tags: Python

---

## 类简介

### 类
1. 类是对象的定义(蓝图)，而实例是真正的实物。
	+ 类的定义：`class A(object):`，类就像一个Python类型容器；
	+ 通过继承来创建子类，子类继承基类的属性和方法，每个子类最好定义它自己的构造器，不然基类的构造器就会被调用(`__init__()`没有被覆盖)。
	+ 标准惯例：类名通常大写大头。
	+ 尽管类是对象，但正被定义时他还不是对象的实现(实例化才是)。
2. 所有的新式类必须继承至少一个类，`object`是所有类之母，如果一个类没有继承任何其他类，`object`将作为默认的父类，他位于所有类结构的最上层。一定在类名称后边加上`(object)`！
	+ `__doc__`属性是类的文档字符串，他必须紧跟头行，并且不能被派生类继承，默认情况下派生类的这个属性为`None`。
3. 创建一个实例的过程称为实例化，通过函数操作符，以**函数调用**的形式出现。
	+ 实例化认为是对`__init__()`的一种隐式的调用；
	+ 函数有下划线表示一般情况下这个函数不是直接供调用的。
4. 最简单的类可以仅作为容器来共享容器空间。
5. 实例的属性是动态的，不需要在任何地方预先声明或者赋值。
	+ 通过句点标识符访问类的属性。

### 方法
通常的实例方法调用：定义类；创建实例；通过实例调用方法。
1. 实例方法传`self`(约定俗成，相当于`this指针)，类方法传`cls`(约定俗成)，静态方法不需要强制传任何参数。
2. 类方法和类属性不能重名。

[Python的实例方法，类方法，静态方法](http://rylcode.cn/2017/01/11/Python%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%8C%E7%B1%BB%E6%96%B9%E6%B3%95%EF%BC%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/)

---

## 面对对象

[OOP特性](http://rylcode.cn/2016/05/21/%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E4%B8%8E%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0/)

1. 抽象：对现实世界和实体的本质表现、行为和特征建模。
	+ 对模型接口以及抽象数据的现实化(`realization`)
2. 封装/接口：对数据/信息进行隐藏，对数据属性提供接口和访问函数。
	+ 限制不规范的操作对数据属性的访问。
3. 合成：扩充了对类的描述，使得多个不同类合成为一个大的类，来解决现实问题。
4. 派生/继承/继承结构：子类保存父类中所有需要的数据和类型，但允许修改或定义其他的自定义操作，但不会修改父类的定义。
5. 泛化/特化：子类与其父类以及祖先类有一样的特点，即`is-a`关系。
6. 多态：对象通过共同的属性或动作来操作访问，不需要考虑具体的类。即动态(运行时)绑定，允许重载以及运行时类型确定和验证。
7. 自省/反射：对象在运行时取得自身信息。即Java中的反射，C++中的运行阶段类型推断RTTI。
	+ `type()`判断类型。
	+ `dir()`返回对象的属性列表。
	+ `var(obj)`返回实例属性构成的字典，即`__dict__`特殊属性。

---

## 类属性，实例，实例属性

### 类属性
1. 属性就是属于一个对象的数据或者函数元素，属性同时也是一个对象，他拥有自己的属性，因此会有属性链这一现象。
2. 主要使用的属性是实例属性，当且仅当需要更加静态的数据时才会使用类数据属性，即静态变量，静态数据。
3. 通常的方法必须绑定(`binding`)才能被直接调用，非绑定方法可以被调用，但实例对象一定要明确给出，才能确保调用成功(派生类构造函数通过基类调用基类的构造函数)。
4. 使用`dir()`和特殊类属性`__dict__`来查看类的属性。
	+ `dir()`内建函数可接受模块，类，实例对象。如果不传入参数，和`locals()`一样。
5. `type()`被调用对象的类型，他的类型是`type`，被调用对象的类型`type().__name__`来访问。
6. `__doc__`特殊属性，不能被派生类继承。
7. `__bases__`用来处理继承，包含由所有父类组成的元组。
8. `__module__`返回类所有模块的字符串表示。

### 实例
1. 类是一种数据结构定义类型，实例则声明了一个这种类型的变量。当你定义了一个类后，已经创建了一个新的类型。
2. 定义或覆盖`__init__()`方法。缺省时不进行任何操作，注意对于不可变类型的类属性，同名的实例属性会覆盖他，但对于可变类型的类属性，二者是同一个对象，这样类、所有实例都可以修改这个属性。
3. `__new__()`方法来继承不可变数据类型(`int`,`str`,`tuple`等)来定制数据类型；或者用在元类，定制创建类对象。
	+ `__new__()`方法是一个静态方法，他在`__init__(self)`执行之前执行并返回一个对象传入初始化方法`__init__(self)`(即这里的`self`)
	+ [python 类中__new__ 和 __init__方法区别](https://zhuanlan.zhihu.com/p/21379984)
	+ [深刻理解Python中的元类(metaclass)](http://blog.jobbole.com/21351/)
	+ [What is a metaclass in Python?](http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python)
4. `__del__()`解构器方法，由于Python的垃圾回收机制是靠引用计数的，这个函数要直到该实例对象所有的引用计数都被清除掉后才会执行。
	+ 也就是说这个函数只会被调用一次(引用计数为0的时候)；
	+ 在子类`__del__()`中不要忘记调用父类的`__del__()`;
	+ `del x`表示引用计数减1，不表示结构器方法被调用。

### 实例属性
1. 实例属性是与实例相关联的数据值，构造器`__init__()`是设置这些属性的关键点。
2. 可以使用默认参数来设置默认的实例属性(注意默认参数应该是不变的对象)。
3. `__init__()`应该返回`None`，因为实例对象是在实例化调用后返回的，如果返回其他值会产生冲突。
4. `dir()`内建函数和`__dict__`属性可以查看所有的属性。
	+ 不要修改`__dict__`字典，使用句点标识符来修改属性；
	+ 内建类型也是类，他可以`dir()`，但不存在`__dict__`属性(因为这个属性只有通过类工厂`type()`产生的类才有)。

### NOTE
1. 类属性可通过类或实例来访问，但是任何对实例属性的赋值都会创建一个实例属性(如果不存在)并且对其赋值(这里指不可变对象，因为不可变对象在赋值时会创建一个新的对象)。
2. 但是在类属性是可变类型的情况下会不同，可变对象在赋值过程中并没有必要产生新的对象，这样会造成实例和类的数据污染。
3. 类属性是静态成员，当一个实例被修改后才创建，那么更新的值就将生效，类属性的修改会影响到所有的实例。

---

## 绑定，组合

### 绑定
1. 实例方法是绑定在实例上的，只有通过实例才能调用这种绑定方法。没有实例时方法就是未绑定的。`self`变量用于在实例中引用方法所绑定的实例。
2. 没有实例调用非绑定方法，例如在子类中覆盖父类的构造方法，这时没有父类实例，需要将子类中的`self`传入父类的构造方法，因为这时子类对象没有进行任何定制，可用来代替父类对象，构造后再进行定制。

### 组合
1. 通过组合(`composition`)让不同的类混合并加入到其他类中，来增加功能和可重用性。这是`has-a`关系(这在C++中通过包含或者私有/保护继承来体现)，因为这些类都不相同，每一个类管理他们自己的名字空间和行为。
2. 另一种方法通过派生(`derived`)，它们具有更接近的关系，强调`is-a`关系，用于当你需要一些相似的对象，但却有少许不同不同功能的时候。

---