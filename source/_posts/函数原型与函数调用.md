---
title: 函数原型与函数调用
date: 2016-04-18 19:25:05
category: C++基础
tags: C++

---

## 函数原型

### 为什么需要原型
原型是函数到编译器的接口，他将函数返回值的类型以及参数的类型和数量告诉编译器。
1. 原型告诉编译器函数参数类型和数量，如果不准确，它让编译器捕获这种错误
2. 函数完成计算后，将返回值放在指定的位置(**CPU寄存器或者内存**)以供调用函数取得。
3. 原型指出返回类型，让编译器知道应检索多少字节以及如何*解释*他们。

### 原型语法
以`void cheers(int);`为例，
1. 函数原型是一条语句，必须以分号结尾；
2. 函数原型不要求提供变量名，有类型列表就够了(这与函数调用有关，原型中的变量名其实就是栈中的占位符)

### 原型功能
1. 编译器正确处理函数返回值(就是说在**指定位置如何解释**)；
2. 编译器检查使用的参数数目是否正确(**不正确让编译器捕获错误**)；
3. 编译器检查参数类型是否正确，如果不正确，可能的话转换为正确类型(编译阶段进行的原型化，静态类型检查)。如下
![函数原型进行类型转化](http://i.imgur.com/5aaLwcA.png)

---

## 函数调用

详细过程见[这里](http://www.zhihu.com/question/22444939#answer-4080329 "函数调用中栈的变化")

### 相关寄存器
1. 栈指针寄存器：指向系统栈最上面一个帧栈栈底的指针；
2. 基址指针寄存器：指向系统栈最上面一个帧栈栈底的指针；
3. 指令寄存器：指向下一条待执行的指令地址。

### 函数调用步骤
1. 参数入栈：C++将参数从右向左依次入栈；
2. 返回地址入栈：将*当前*代码区调用指令的*下一条*指令地址压入栈，函数返回时继续执行；
3. 代码区跳转：从当前代码区跳转到被调函数入口处；
4. 栈帧调整：
	+ 当前栈帧的EPB入栈；
	+ 切换到新栈帧,ESP装入EBP；
	+ 给新栈帧分配空间；

### 思考
#### 为什么参数要入栈？
为了保存现场，例如一个递归：
	```
	int sum(int n)
	{
		if (n == 0)
			return 0;
		return sum(n-1)+n
	}
	```

当`sum(n-1)`返回，他的栈帧被释放，还原到`sum(n)`的栈帧，那么n的值怎么获得？假如`sum`是在`main()`调用的，n在调用时压入了`main()`的栈帧，并对一个匿名对象拷贝了n的值供`sum()`计算，如果传地址或者引用就可以直接修改栈帧中的值。
这就可以解释为什么按值传递时不能修改上一级函数的数值，因为栈帧会还原，按值传递修改的也不是栈帧中的值。