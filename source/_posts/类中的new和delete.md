---
title: 类中的new和delete
date: 2016-05-26 14:27:21
category: C++的类
tags: C++

---

之前提到过浅拷贝和深拷贝的问题，现在详细讲一讲类中的`new`和`delete`。

---

## 构造函数中的`new`

1. 构造函数中使用`new`来初始化，析构函数中应该用`delete`;
2. `new`和`delete`必须相互兼容，`new`对应于`delete`，`new[]`对应于`delete[]`;
3. 多个构造函数必须以相同的方式`new`，因为只有一个析构函数，所有的构造函数必须与之兼容。注意，`delete`可以用于看那个指针，因此指针可以初始化为`nullptr`;
4. 应定义复制构造函数进行深度复制;
5. 应定义赋值运算符重载，将一个对象深度复制给另一个对象。
6. 逐成员复制将使用**成员类型定义**的复制构造函数和赋值运算符(如`String`作为成员对象赋值时会调用自身的复制构造函数和赋值运算符)。

---

## 析构函数的调用

1. 动态变量在代码块结束时调用;
2. 静态变量，程序结束时调用;
3. `new`创建的，使用`delete`删除或者程序结束时。

---

## `new`与指针

考虑这一常见语句:
```
TreeNode *head = new TreeNode(1);
```
1. 使用`new`来初始化指针，这将调用相应的类构造函数来创建一个对象;
2. `->`运算符用于对象指针访问类方法;
3. `*`运算符用于对象指针获得对象;

---

## 定位`new`运算符

考虑这一个例子：
```
p = new(buffer+N*sizeof(B)) B();
```
定位`new`运算符能在分配内存时指定内存位置`buffer`(需要包含头文件`new`)，但是这里有一个问题，在`delete buffer`时编译器并不知道你对`buffer`做了什么，因此不会调用对象的析构函数，那么如何保证析构函数与构造函数的数量一致?
1. 之前强调过析构函数只销毁对象不释放内存，因此需要在`buffer`内存释放前销毁对象;
2. 用指向对象的指针显示地调用析构函数;
3. 应注意调用析构函数的正确顺序。对于使用定位`new`运算符创建的对象，应该和创建的顺序相反。因为，晚创建的对象可能依赖于早创建的对象。另外，仅当所有对象都被销毁后，才能释放用于存储这些对象的缓冲区。