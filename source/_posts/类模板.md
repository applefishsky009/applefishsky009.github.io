---
title: 类模板
date: 2016-06-21 10:04:37
category: C++的类
tags: C++

---

泛型编程的一种，即将具体类型作为参数传递给类。

---

## 模板类

### 定义
模板类应该这样开头：
```C++
template<typename Type>
```
模板成员函数的每个函数头(函数定义之前)将以相同的模板声明打头：
```C++
template<typeName Type>
```

### 实例化
泛型标识符要求必须对类型变量实例化才能使用，通过`<Type>`来实例化类型。

### 指针变量
若将指针作为类型变量，需要注意：
1. 指针作为参数类型，必须让调用程序提供**指针数组**，因其满足这四个条件：空间，左值，可赋值，不同的指向；
2. 创建不同指针是调用程序的职责，而不是泛型模板类的职责；
3. 以指针为参数的模板类涉及到动态内存，因此必须包含析构函数，复制构造函数和赋值运算符。
4. 制定返回类型或作用域解析符时，必须使用完整的实例化类型`classA<Type>`;
5. 构造函数使用`new`创建一个用于保存指针的数组，析构函数删除该数组，而不是数组元素指向的内容。

### 非类型参数
举例：
```C++
template<class T,int n>
```
1. 相比在构造函数和析构函数中`new`和`delete`，非类型参数使用自动变量维护的内存栈，速度更快；
2. 但每个不同的非类型参数都会生成自己的模板类;
3. 构造函数更通用(参数优于硬编码)，便于赋值和创建大小可变的类。

### 递归，多参，默认参数
1. 递归使用模板：`array<array<int,5>,10> a`；
2. 多个类型参数：`template<typename T1,typename T2>`；
3. 默认类型模板参数：`template<typename T1,typename T2 = int>`。

### 具体化
模板以泛型的方式描述类，具体化是使用具体的类型生成类声明。具体化(具体的行为)包括，隐式实例化(最常用)，显式实例化，显式具体化。
1. **隐式实例化**：在创建对象时，编译器根据参数类型生成类定义，再根据类定义生成对象；
2. **显式实例化**：使用关键字`template`指出所需类型来声明类，编译器生成类声明的显式实例化；
3. **显示具体化**：特定类型的定义，特殊类型实例化时，对模板修改使其行为不同，这要求**必须有自己的函数定义**，使用前缀`template<>`(`<>`内声明的是没有被具体化的参数，因此这表示全部被具体化了),<font color=red>这是一种多态？</font>。
4. 显示具体化的匹配优先级高于通用模板。
5. **部分具体化**：使部分特定类型的行为不同，`template<typename T1>`表示T1的行为不显式具体化，而余下的T2被显示具体化：
	```C++
	template <typename T1> class Pair<T1,int>{};	//T2部分具体化为int
	```

### 成员模板
模板可以作为结构，类或模板类的成员。
1. 在模板中声明模板类和模板方法(模板函数)，在模板外面定义他们；
2. 因为模板是嵌套的，外部定义必须使用下面语法：
	```C++
	template <typename T>
		template<typename V>
			fatherClass::method/childClass{
				...
			}
	```
3. 使用作用域解析符指明他们是哪一类的成员。

### 模板参数
模板可以包含类型参数和非类型参数，也可以接受模板作为参数。递归使用模板就是参数是自身这一模板的特殊情况。
```C++
template<template <typename T> class Example>;
Example<int>;	//1作为类数据成员
Example<double>;	//2作为类数据成员
Father<Stack> result;	//将1实例化为Stack<int>,将2实例化为Stack<double>
```
1. 模板参数和常规参数可以混合使用.

### 模板类和友元
模板的友元有三类：
1. 非模板友元(普通友元函数，只不过模板具体化使他成为很多具体化之后的类的友元)；
2. 约束模板友元()；
3. 非约束模板友元(模板友元函数，)。

约束是指友元函数是某一具体化的友元还是所有实例化的友元；模板是指友元函数本身是不是模板。

#### 非模板友元
1. 使函数成为模板所有实例化的友元，他的用处：
	+ 访问全局对象；
	+ 使用全局指针访问非全局对象；
	+ 创建自己的对象；
	+ 访问独立于对象的模板类的静态数据成员。
	```C++
	friend void counts();
	```
2. 为友元函数提供模板类参数，必须为友元定义显式具体化：
	```C++
	template <typename T>
	clasee A{
		friend void report (A<T> &a);
	}
	```

#### 约束模板友元
将友元函数本身成为模板(类外部声明)，即对友元函数的类型加以约束，使每个类型都有自己的友元函数，这是**类具体化获得函数具体化来约束了友元类型**。
```C++
template<typename T> void counts();
template<typename T> void report(T &t);
template<typename TT>
class A{
	friend void counts<TT>();
	friend void report<>(A<TT> &a);	//省略了<>中的A<TT>,因为可以从参数推断
}
```
1. 和模板类参数的非模板友元区别，有无`<>`来约束类型，总的来说包含以下三步；
2. 在类定义前面声明每个模板函数；
3. 在类中将具体化的模板函数声明为友元；
4. 为友元提供模板定义。

#### 非约束模板友元
通过在类内部声明模板，创建非约束模板友元，**每个函数具体化是每个类具体化的友元**，友元模板参数类型与模板类类型参数是不同的，也就是说类具体化不能约束友元函数类型，因此每个函数具体化都是所有类具体化的友元。
```C++
template <typename T>
class A{
	template<typename C,typename D> friend void show2(C &c,D &d);
}
```

### 模板别名
使用typedef为模板具体化指定别名：
```C++
typedef std::array<double,12> arrd;
typedef std::array<int 12> arri;
typedef std::array<std::string,12> arrst;
```
使用模板提供一系列别名(`using`关键字)：
```C++
template<typename T>
using arrtype = std::array<T,12>;
array<double> arrd;
array<int> arri;
array<std::string> arrst;
```