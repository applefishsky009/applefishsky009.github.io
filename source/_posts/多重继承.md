---
title: 多重继承
date: 2016-06-20 10:11:03
category: C++的类
tags: C++

---

多重继承(Multiple Inherit)/MI是指一个类别可以同时从多于一个父类继承行为和特征。这增加了编程的复杂度，主要是派生类通过多条途径继承同一基类引起的。有一点注意和两个问题：
1. 使用`public`关键字限定**每一个**基类，否则默认为私有派生；
2. 如何从两个基类继承同名方法？(作用域解析符或者隐藏)
3. 从两个基类或更多相关基类继承同一个类的多个实例造成不期望的多个组成部分，引入虚基类来解决问题。

---

## 虚基类/或者叫做虚拟继承更好

引入虚基类来解决重复的基类组成问题。
1. 将可能重复的基类在派生时使用`virtual`关键字，其和`public`的关键字的顺序不关紧要(区分虚函数，纯虚函数)；
2. 虚函数和虚基类之间没有明显联系，`virtual`关键字重载；
3. 将基类声明为虚要求额外的计算，因此不能使虚行为成为默认的MI准则；
4. 虚基类通过禁止信息通过中间类自动传递给基类来解决上述问题，因此采用一种<font color=red>特殊的构造函数</font>，但是注意这种形式只适用于虚基类，对于非虚基类是非法的。

```C++
// not this(class Work is not virtual,SingerWaiter has an unexpected objects)
SingerWaiter(const Worker &wk,int p = 0,int v = Singer::other):Waiter(wk,p),Singer(wk,v){}	//other是class Singer中的枚举量

//but this
SingerWaiter(const Worker &wk,int p = 0,int v = Singer::other):Worker(wk),Waiter(wk,p),Singer(wk,v){}	//必须在构造派生对象之前构造基类，否则将采用默认的构造函数
```

---

## 选择方法

使用作用域解析符或多态的方法定义一个新的函数指明调用的方法。另外使用模块化的方法(这将要求一些方法声明为保护而不是私有以便于派生类的模块化)防止重复访问。
1. 私有方法一般是外部接口(公有方法)的辅助方法，为了模块化，可以将这些辅助方法(私有方法)声明为保护的，在派生类中和派生类的辅助方法(只访问派生类的数据模块)构成完整的模块；
2. 祖先相同时，使用MI必须引入虚基类，并修改构造函数列表初始化规则。

---

## 其他问题

### 混合使用基类和非虚基类
1. 当类通过多条非虚途径继承某个特定的基类时，该类将包含一个表示所有的虚途径的基类子对象和分别表示各条非虚途径的多个基类子对象。

### 虚基类和支配
1. 使用非虚基类，类从不同类继承了同名成员(数据或方法)，将导致二义性；
2. 使用虚基类，派生类中的名称优先于这个派生类直接或间接祖先中的名称(也就是说这两个方法所在的类必须有继承关系才不会导致二义性)；
3. 虚二义性和访问规则无关，例如，基类中`public`方法，他的派生类中`private`方法，当前类从派生类继承而来，在不用作用域解析符时默认调用派生类的`private`方法(这对实例对象来说是不可访问的)。