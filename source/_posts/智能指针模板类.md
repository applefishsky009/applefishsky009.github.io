---
title: 智能指针模板类
date: 2016-07-22 09:36:02
category: C++的类
tags: C++

---

智能指针模板添加了指针的析构函数，用delete释放动态内存，方式内存泄漏，有三种：
1. auto_ptr		(C++98)
2. unique_ptr	(C++11)
3. shared_ptr	(C++11)

---

## 智能指针简介

智能指针语法需要头文件`<memory>`，将初始化指针语法改为构造智能指针语法，删除`delete`，他可以将`new`返回的地址赋给智能指针对象，在智能指针过期时，智能指针对象调用析构函数释放指针和动态内存而不用手动释放。
```C++
double *p = new double;
auto_ptr<double> p(new double);	//可以看到这是模板语法，模板位于名称空间std中
```

三种指针详解：
1. 智能指针类不接受从普通指针的隐式转化(赋值运算符转化)，只能显示转化(将普通指针作为参数传递给构造函数)
2. `auto_ptr`和`unique_ptr`都采用<font color=red>所有权策略</font>，即赋值操作表示转让所有权对象,但其中`auto_ptr`会有野指针的问题，而`unique_ptr`不允许留下悬挂的空指针，因此其更为安全。
3. `shared_ptr`采用<font color=red>引用计数策略</font>，他会跟踪引用特定对象的智能指针数，仅当最后一个指针过期时才会释放内存。

注意事项：
1. `unique_ptr`不允许留下危险的悬挂指针(赋值操作转让所有权)，仅限于左值，对临时右值，因其无法引用，因此允许赋值。
2. `unique_ptr`可用于数组的变体(调用`delete`或`delete[]`,对应构造方式),`auto_ptr`不能(只能调用`delete`)

---

## 使用智能指针

1. 如果使用多个指向同一对象的指针，应选择`shared_ptr`；
2. 如果不需要多个指向同一个对象的指针，使用`unique_ptr`；
3. 考虑到`unique_ptr`的特性，谨慎使用STL中的算法，因为STL中算法很可能将指针复制或赋给另一个方法或算法(左值),自定义的函数体中一定要按引用传递指针。
4. `shared_ptr`有一个显式构造函数可以将**右值**`unique_ptr`转换为`shared_ptr`,`unique_ptr`所指对象不可同时出现两个左值智能指针的特性依然满足。