---
title: 类的复制构造函数和赋值运算符重载
date: 2016-04-18 11:51:12
category: C++的类
tags: C++

---

C++会自动提供以下成员函数：
1. 默认构造函数；
2. 默认析构函数
3. 复制构造函数
4. 赋值运算符
5. 地址运算符

之前讨论过构造函数与析构函数，今天讨论复制构造函数与赋值运算符。

## 类的复制构造函数

原型：`A::A(const A &a);`

### 简介
1. 作用：复制构造函数用于将一个对象复制到新创建的对象中。也就是用于初始化过程（包括按值传递）,而不是常规的赋值过程。**隐式构造函数<font color = red>按值</font>逐个复制非静态成员**,静态成员属于整个类，不属于某一个对象，因此不受影响。
2. 何时调用：新建一个对象并将其初始化为同类现有对象。有以下四种可能语法：
	+ `StringBad ditto(motto)`;
	+ `StringBad *pStringBad = new StringBad(motto)`;
	+ `StringBad metoo = motto`;
	+ `StringBad also = StringBad(motto)`。

1、2两种声明没有临时匿名对象(或者说临时匿名对象有外部载体);3、4两种声明值是接创建metoo和also还是用复制构造函数构造临时对象然后对象赋值给metoo和also，取决于具体实现。<font color = red>特点是有赋值运算符的非指针构造</font>，在本人的编译器上(VS2012 32)是有临时对象并析构的。
#### 注：
1. 无论哪种编译器，按值传递和返回对象时，都将调用复制构造函数。
2. 由于1，复制构造函数必须**接受类对象的常量引用**作为参数，否则会无限递归调用自身导致堆栈溢出。

### 默认复制构造函数的缺陷(浅复制)
1. 对象计数器：默认构造函数+显式构造函数+显式构造函数=析构函数。
2. 隐式复制构造函数是**按值复制**，对于指针指向的new出来的空间(动态分配的内存)，它会使两个指针指向同一块内容，因此在析构时，编译器尝试两次释放同一块内存，这会导致不确定的可能有害的结果。必须定义一个显式复制构造函数给指针开辟新的内存、

---

## 类的复制运算符重载(深度复制)

C++的类对象赋值通过自动为类重载赋值运算符实现。赋值运算符是只能由类成员函数重载的运算符之一。
如上所说四种新建对象方法，*初始化时总会调用复制构造函数，而是用`=`运算符也允许调用赋值运算符。*但是！赋值运算符的隐式实现也是对成员逐个赋值。那么如上也有两次析构的问题，因此应该提供赋值运算符进行深度复制。
其与复制构造函数的差别：
1. 应该首先检查自我复制，相同返回自身。否则未复制前释放了自身；
2. 释放拷贝对象之前引用的数据，否则会内存泄露(因为要深度复制会申请新的内存空间并指向他进行数据拷贝，之前的内存指针就丢失了)。
3. 返回一个指向调用对象的引用以便连续赋值。

下面这个例子同时犯了复制构造函数和赋值运算符重载的浅复制错误：
![典型的浅复制错误](http://i.imgur.com/OwHR2qp.png)

---

## 链表的陷阱

考虑类中的数据成员有链表，显然对于默认的复制构造和赋值运算符是不安全的，而<font color = red>假设</font>我们不需要复制构造函数和赋值运算符重载，怎么忽略他们?

将这些方法**私有化**。

这样不会有默认的复制构造函数和赋值运算符重载，而且因为私有不能被广泛使用


---

## 思考

1. 为什么赋值运算符重载返回类型是引用？之前在`*this`指针中提过，返回类型为引用意味着返回对象本身而不是其副本。这样在一些含有赋值运算符的初始化中也可以防止递归调用。
2. 为什么参数类型为引用？对*复制构造函数*和*赋值运算符重载*，都是为了防止递归调用。


