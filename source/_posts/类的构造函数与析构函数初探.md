---
title: 类的构造函数与析构函数初探
date: 2016-04-07 19:03:11
category: C++的类
tags: [类的构造函数,类的析构函数]

---

首先强调很重要的一点，<font color = red>类声明只描述如何分配内存，但其并不会分配内存。</font>，只有调用构造函数的时候才会分配内存。

---

## 类的简介

### 类的规范由两部分组成：
1. 类声明（declaration） – 类的蓝图
	+ 以数据成员的方式描述数据，以成员函数的方式描述公有接口；
	+ **数据**通常放在私有部分，组成类接口的**成员函数**放在公有部分，另外**私有成员函数**用来处理不属于公有接口的实现细节。
	+ 定义位于声明中的函数都将自动成为内联函数，若定义位于声明之外，使用`inline`关键字成为内联函数。
2. 类方法定义 – 类的实现细节
	+ C++通常把接口（类声明）放在头文件中，并将实现（类方法代码）放在源代码中；
	+ 定义成员函数时，使用作用域解析符（`::`）来表示函数所属的类；
	+ 类方法可以访问类的`private`组件。
	+ 只要类方法不修改调用对象，就应将其声明为`const`，如`void Stock::show() const`。

类所创建的每个新对象都有自己的存储空间，用于存储其内部变量和类成员；但同一个类的所有对象**共享同一组类方法**。

### 类成员的访问控制（封装）
数据隐藏：防止程序直接访问数据。
+ 例如`int a`是类的私有数据成员，`cout<<a`是不对的，只有公有成员函数或友元函数才能访问。可以定义一个`show()`方法访问a用来输出。

数据封装：实现细节放在一起并与抽象分开。
+ 数据隐藏（数据放在类的私有部分）
+ 私有成员函数（实现细节隐藏在私有部分）
+ 类函数定义和类声明放在不同的文件中。

---

## 类的构造函数与析构函数

### 类的构造函数
1. 如果没有提供任何构造函数，C++自动提供默认构造函数，他不做任何工作，也就是说**他的值在初始化时是未知的**；但是如果定义了构造函数，程序员必须为他提供默认构造函数，用户定义的默认构造函数通常给所有成员提供隐式初始值（已知合理值）。
2. 构造函数被用来创造对象，而不能通过对象来调用。（因为在通过构造函数构造出对象之前，对象是不存在的）。

### 构造函数的列表初始化
开始就说过，类声明只描述如何分配内存，并不会分配内存。那么考虑如果初始化一个队列，队列长度是`const`常量，他应该是在构造函数执行之前被创建，因为他可以初始化但是不能赋值；同理，引用也**只能在被创建时**进行初始化。这时候需要一个列表初始化：
```
Queue::Queue(int qs):qsize(qs),front(nullptr),rear(nullptr),items(0);
```
1. 这种格式只能用于构造函数；
2. 必须用这种格式来初始化非静态`const`数据成员；
3. 必须用这种格式来初始化引用数据成员；
4. 列表初始化时的初始化顺序是按照数据成员定义的顺序，而不是列表顺序来初始化的。

### 类的析构函数

1. 对象过期时，程序自动调用析构函数；如果程序员没有声明，编译器隐式声明一个默认析构函数。
2. 注意窗口环境中，窗口关闭之前的代码包含在同一个代码块中，才能保证析构函数在窗口关闭之前执行。
3. 若构造函数中有`new`，则析构函数必须`delete`。
4. 析构函数指示在代码块结束之前的扫尾工作(销毁对象)，并不会释放内存(对自动变量这是在代码块结束时自动进行的)。注意，**析构函数只销毁对象不释放内存**

### [构造函数的语法](https://github.com/applefishsky009/Leetcode/blob/master/26%20-%20Remove%20Duplicates%20from%20Sorted%20Array/26%20-%20Remove%20Duplicates%20from%20Sorted%20Array.cpp)

```
Num nums(initVector);
Num nums;
Num();
Num nums = Num();
Num nums = Num(initVector);
```

+ 1一定不会创建一个临时对象并析构；
+ 2会调用默认构造函数，没有析构过程；
+ 3中由于没有类的对象，因此会调用默认构造函数并析构；
+ 4在本人两个编译器上执行了2的构造过程(实际上没有调用重载的`=`运算符)，因此没有匿名对象的构造析构；
+ 5在编译器(VS2012)上会，编译器会先调用构造函数构造匿名对象，再调用复制构造函数，再析构匿名对象。但在编译器(VS2015不会)，直接将匿名对象给`nums`；

但是对于5这种创建**有指定值的对象**(使用运算符`=`允许调用赋值运算符(5)，也可以不调用(4))。因此是否有临时对象是不确定的(取决于具体的实现是4还是5这种方式)。

总之，1的效率最高。