---
title: 公有继承，多态继承和抽象基类
date: 2016-06-08 15:35:46
category: C++的类
tags: [继承,is-a,vtbl,ABC]

---

通过本篇的学习，可以看到如何通过类继承来实现`代码复用`(可重用性)，不得让人感慨设计的精妙。
简单来讲，类继承可以完成以下工作：
1. 已有类的基础上添加功能；
2. 给类添加数据；
3. 修改类方法的行为。

但以下是不能被继承的：
1. 构造函数(派生类调用基类)；
2. 析构函数(派生类调用基类)；
3. 赋值运算符(成员赋值)；
4. 友元函数(非成员函数，通过指针强制类型转化改变作用域访问)。

---

## 公有继承

简单继承有三种：公有继承，保护继承，私有继承。最常用简单公有继承是is-a关系，也就是**包含**关系，这种关系通常是不可逆的(除非相互包含)。

### C风格字符串参数
简单来说，C风格字符串作为函数参数时，函数原型必须是`const string`才行(否则参数类型不匹配)，如下:
```C++
A a("test",x,y);	//A的实例1
A b(str2,x,y);	//A的实例2
A::A (const string &first,int x,int y);	//A的构造函数原型
```
对“test”可以引用，但显然他是常量，因此引用之后不能改变。那么这个引用必须声明为`const`，否则构造函数只于实例2匹配。置于传入的是`const char*`还是`string`并不重要，因为string类有`const char*`的构造函数(其实就是告诉编译器，可以将`const char*`解释为`string`。
1. 注意这里的const和A类构造函数中的const不是一个概念；
2. 即使在赋值过程中构造了string，其是一个中间计算过程，也不能作为左值出现。

### 公有派生的特性
公有派生必须使用`public`关键字，如下
```C++
class B:public A {
	...
}
```
1. 派生类对象存储了积累的数据成员(继承了基类的实现)；
2. 派生类可以使用基类的方法(派生类继承了基类的接口)；
3. 派生类需要自己的**构造函数**；
4. 派生类可以添加额外的数据成员和成员函数。

### 公有继承的构造函数
构造函数必须给新成员和继承的成员提供数据，由于派生类只能通过基类的公有方法来访问基类的私有数据，因此**派生类构造函数必须使用基类的构造函数**来初始化(基类部分的)数据。有以下几个要点：
1. 创建基类对象；
2. 派生类通过**成员初始化列表**(非构造函数不能使用成员初始化列表语法)来指明要使用的基类构造函数，否则将会调用默认构造函数；
3. 派生类初始化其新增的数据成员。

### 基类指针/引用 指向/引用派生类对象
将公有派生类和基类之间的特殊关系总结(从概念上将，公有派生是包含关系，2,3点也就好理解了)如下：
1. 公有派生的派生类可以使用基类的非私有(公有或保护)方法；
2. 基类指针在不进行显示类型转化的情况下指向派生类对象；
3. 基类引用在不进行显示类型转化的情况下可以引用派生类对象。

2,3(这是<font color=red>公有派生(is-a关系)的核心</font>)有几个常用的场景，
1. 对象数组中，可以是基类对象和派生类对象(-.-因为派生类对象是一种特殊的基类对象)；
2. 指向基类对象的指针数组，可以指向基类对象会派生类对象；
3. 形参为基类引用，实参可以是基类或派生类对象；
4. 形参是指向基类的指针，实参可以传入基类或派生类对象的地址；
5. 基类对象可以初始化为派生类对象(调用复制构造函数)；
6. 派生类对象可以赋给基类对象(调用重载的赋值运算符)。

这一特性在使用隐藏的多态中会出现问题，虚函数的出现解决了这个问题。

### 不能被继承的赋值运算符
派生类继承的方法特征标与基类完全相同，但赋值运算符的特征标只与类本身有关。因此其不能被继承。
1. 默认的赋值运算符采用成员赋值的方式。如果是派生类对象，对其中属于基类对象的部分调用基类的赋值运算符(默认或显式)；
2. 派生类中使用`new`，必须提供显式的赋值运算符重载；
3. 派生类对象赋给基类对象，将调用基类的赋值运算符重载，只涉及基类的成员；
4. 在满足下列两个条件之一时，基类可以赋值给派生类：
	+ 从基类到派生类的转换构造函数；
	+ 定义一个用于将基类赋给派生类的赋值运算符。

---

## 多态继承

考虑继承的多态行为，就是说同一个函数在派生类中和基类中行为不同(函数名相同，具体代码有区别)，有两种方式：
1. 隐藏，即在派生类中重新定义基类方法(派生类隐藏基类同名方法)；
2. 虚方法(vtbl)。

### 隐藏的规则：
隐藏是指**在派生类的函数中屏蔽了与其同名的基类函数**。
(1)如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无 `virtual`关键字，基类的函数将被隐藏。
(2)如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏。

### 隐藏的缺陷
在隐藏的时候，程序根据指针或者引用类型选择方法。但是公有继承中基类的指针/引用可以指向/引用派生类对象，这样会导致多态行为不稳定。而虚方法会解决这一问题。他会根据指针指向或引用的对象类型来调用方法而不是指针/引用类型。

### 使用虚方法
在基类中将派生类会重写(覆盖)的方法声明为虚方法(在函数声明最前端使用`virtual`关键字)。
1. 要将析构函数声明为虚的(保证调用正确的析构函数)；
	+ 如果析构函数不是虚的，只会调用指针/引用类型的析构函数，而不是对象类型，这会有隐患；
	+ 在重写(覆盖)的虚析构函数里，应该调用基类的析构函数并释放派生类动态申请的空间。
2. 在派生类中定义虚函数时，如果要调用基类同名方法，需要使用作用域解析符，否则编译器会视为递归调用。

### 虚函数对静态联编的困扰
静态联编(C++默认选择)的必要性：
1. 静态联编效率高；
2. 指出不要重新定义该函数(因为是静态的)。
考虑派生类引用或指针转换为基类引用或指针，被称为向上强制转换。这种关系是不可逆的(因为是包含关系)。这种情况下肯定需要动态联编来调用正确重写的函数。

### 虚函数实现机制vtbl
C++规定了虚函数的行为，编译器执行他的实现。实现方式为为每个对象添加**一个**隐藏成员，他是一个指向函数地址数组的指针，这个数组称为**虚函数表(vtbl)**。虚函数多少决定了这个地址数组大小。实现机制：
1. 如果重写虚方法，vtbl保存新函数地址；
2. 如果没有重写虚方法，vtbl指向基类原始方法地址；
3. 如果定义新的虚方法，vtbl加入新成员。
虚函数具有了动态联编的能力，同时使用虚函数的成本：
1. 每个对象都将增大(指针成员和存储地址的空间)；
2. 编译器为每一个类创建一个虚函数地址表(数组)(对象是类的实例)；
3. 每个虚函数调用，都需要到表中查找地址。

### 虚函数注意事项
之前关于虚函数大体上说有三个要点：
1. 需要重写就声明虚函数；
2. 使用`virtual`关键字；
3. (由于向上强制转化)使用动态联编。

还有一些注意事项：
1. 构造函数不能是虚函数，而应该在派生类中调用基类的构造函数；
2. 不管是否用作基类，析构函数应该是虚的(只是不用做基类时效率略低)；
3. 友元不能是虚函数，因为友元不是成员函数。只有成员函数才能被申明为虚；
	+ **友元函数**不是成员函数，不能被继承；
	+ 如果想派生类使用基类的友元函数，可以通过强制类型转换，将派生类引用或指针转换为基类引用或指针，使用转换后的引用或指针来调用基类的友元函数。
4. 基类中声明为虚，但派生类中没有重写，依然会调用基类方法
	+ 因为vtbl初始状态是基类方法地址，重写一个虚方法才更新；
	+ 由<font color=red>C++的隐藏规则</font>可推断，应该是先删掉所有的同名函数地址，然后加入新的虚方法地址。
5. 由4中所说，重写才将隐藏方法。

2条经验规则：
1. 重写的继承方法确保与原来的原型完全相同，但<font color=red>返回类型协变</font>例外。返回类型协变：如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针。只适用于返回类型不适用于参数；
2. 如果基类声明被重载了，派生类中应重写所有的基类版本(先重写的版本**隐藏**所有的同名函数)。
	+ 如果只重写一个版本，另外两版本会被隐藏，派生类将无法使用；
	+ 如果想使用基类方法但是又不要修改方法，在重写的派生类方法中调用基类方法即可。

### protected访问控制
`protected`关键字使类成员在类外是`public`权限，在派生类内是`public`权限。但是其类成员的选择值得注意：
1. 数据成员最好采用私有访问控制。因为数据成员一般被封装，只能通过成员函数访问，如果被声明为`protected`，在派生类中其成为公有数据，与数据隐藏的概念相矛盾，可以调用基类方法来修改私有数据成员；
2. 对**成员函数**来讲，保护访问控制很有用。对基类，一些方法的实现细节被封装(外部不可见)；对派生类，我们依然可以调用这些成员函数来完成更多的工作(可作为派生类方法的实现细节)。

---

## 抽象基类(ABC)

一些情况下的公有派生是很笨拙的，例如圆是一种椭圆。可以通过抽象基类(ABC)来抽象出他们的共性，ABC使用纯虚函数(`virtual`与原型`=0`)来提供未实现的函数接口(由于实现接口的一些数据不是共性，在派生类中才能添加)。注意，<font color=red>至少含一个纯虚函数的类才是ABC</font>。一个例子：
```C++
virtual double Area() const = 0;
```

### ABC特征
1. 在ABC派生的具体类中实现纯虚方法的定义；
2. 使用ABC指针数组管理所有具体类；
3. ABC是一种必须实现的接口。