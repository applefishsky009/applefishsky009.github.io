---
title: 页置换算法FIFO和LRU
date: 2016-08-29 16:39:44
category: 操作系统
tags: [FIFO,LRU]

---

## FIFO页置换算法

这是最简单的页置换算法。

用一个FIFO队列来管理内存中的所有页，队列中的首页会被置换。需要调入页时，将他加入到队列的尾部；
实现思想如下：
1. 使用`vector`模拟维护一个队列记录页调入的顺序(这样可以建立页(key)和迭代器的哈希映射)；
2. 调入页时，`map`的`capacity`未满(即内存的页容量)，建立`map`，页信息入队列，建立迭代器映射；
3. 更新页时，队列`pop()`(即先调入的先更新)，然后根据`pop()`的这个页信息置换内存中对应的页。

对于FIFO页置换算法，有一个难以置信的结果：
Belady异常：对有的页置换算法，页错误率可能会随着所分配的帧数的增加而增加，而期望进程增加内存可以改善性能。

---

## LRU页置换算法

最优页置换算法：置换最长时间不会使用的页，确保对于给定数量的帧会产生最低可能的页错误率。
LRU算法将过去最近作为不远将来的近似，置换最长时间没有使用的页，即最近最少使用算法。

有两种可行实现：
1. 计数器 - 页关联时间域；
2. 栈 - 页码栈；

可以用双向链表来管理内存中的所有页，可以在O(1)的时间内查找，而且双向链表的插入和删除效率高；
实现思想如下：
1. 使用`list`维护一个双向链表按顺序记录最近使用的页信息(建立页(key)和迭代器的哈希映射)；
2. 调入页时，`map`的`capacity`未满(即内存的页容量)，建立`map`，页信息插入双向链表首端，建立迭代器映射；
3. 更新页时，`map`中如果有页信息，调整双向链表顺序是该页信息位于链表首端，如果没有页信息，删除双向链表尾端(最近最少使用的页)，将该页信息插入双向链表首端。

---

## 近似LRU页置换 - 二次机会页置换算法

很少有计算机能提供足够的硬件来支持真正的LRU页置换。因此必须使用其他页置换算法。

对于内存中的页保留引用位(引用位是0或1)，采用循环队列。当需要置换一个帧时，指针向前直到找到一个引用位为0的页，向前移动时，清除引用位，引用位在其访问的时候设置为1。

---

参考资料：
1. [LeetCode - 146. LRU Cache](https://leetcode.com/problems/lru-cache/) - 解答：[146 - LRU Cache](https://github.com/applefishsky009/LeetCode/blob/master/146%20-%20LRU%20Cache/146%20-%20LRU%20Cache.cpp);
2. 操作系统概念,Peter Bare Galvin等.

