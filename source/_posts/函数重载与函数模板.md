---
title: 函数重载与函数模板
date: 2016-06-03 14:34:40
category: C++基础
tags: C++

---

简单介绍重载和模板，具体可以参考[OPP特性分析](http://rylcode.cn/2016/05/21/%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E4%B8%8E%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0/)
函数重载是一种多态，一种消息对不同对象有多个动作；
函数模板是一种泛型编程，简化了重载函数的函数体设计，使代码的可重用性大大提高。到之后的类模板设计中可以体会到他的优美。

---

## 函数重载

关键：函数参数列表也就是特征标不同。
1. 如果没有完全匹配，C++尝试标准类型转换强制匹配；
2. 编译器检查函数特征标时，将类型引用和类型本身视为同一个特征标；
3. 非`const`参数只匹配非`const`调用，`const`参数同时匹配`const`调用和非`const`调用。(`const`参数不能传给非`const`参数，因为有改变的风险)
4. 三个原型的可能匹配(优先最佳匹配)，注意`r2`匹配范围最广
```C++
void sink(double &r1);	//可修改的左值
void sink(const double &r2);	//可修改的左值，'const'左值，右值
void sink(double &&r3);	//右值
```

仅当函数基本上执行相同的任务，但是用不同形式的数据时，才应采用函数重载。

---

## 函数模板

### 简介
假设维护一个大项目，对于两个数据相加，其数据类型可能是`char`,`int`,`short`,`double`,`float`甚至自定义的类，不可能对每种可能的类型提供重载，这就需要泛型编程。

1. 函数模板允许以任意类型的方式来定义函数,可用于将同一种算法用于不同类型的数据，如下：
```C++
template <typename T>
T swap(const T &a,const T & b，int n = 0) {
	T c = a+b;
	return c;
}
```
2. 函数模板不能缩短可执行程序。最终的代码只包含为程序生成的史记汉书，并不包含任何模板。
3. 模板函数参数不一定必须是模板的参数类型；
4. 模板函数中使用的运算符在具体化的模板中可能并未重载，这时候可以为具体化的模板重载运算符。


### 具体化
1. 匹配顺序：非模板函数>显式具体化函数>模板函数；
2. 实例化指的是模板参数(上例中的T)的指定，这样就可以生成一个定义。实例化是指对特定类型的显式定义，**这些原型必须有自己的函数定义**(也就是说这个类型和通用模板的行为不同时使用显示具体(具体指的是具体行为)化)，<font color=red>这是一种多态？</font>。
3. 重载解析将寻找最匹配的函数。
	+ 如果只有一个，选择它；
	+ 如果有多个，只有一个非模板函数，选择它；
	+ 如果有多个，且都是模板函数，选择更具体的模板；
	+ 如果这些模板函数都不比其他模板具体，编译器会困惑，这是错误的；
	+ 没有匹配也是错误的。
4. 自定义选择调用模板或者具体化的模板(即使不是最匹配，因为是先具体化再调用)
```C++
//提供非模板函数，模板函数，具体化的模板函数
int m,n;double x,y;
lesser(m,n)	//调用非模板函数
template<>lesser(m,n)	//调用模板函数，使用int具体化
template<int>lesser(x,y)	//地用模板函数，使用int具体化
```

### 类型的困惑
1. `decltype(expression)`关键字用于类型获取`decltype(x+y) xpy = x+y`
2. `decltype`关键字的核对表：
	+ 如果是没有用括号括起来的标识符，则得到的类型与标识符相同；
	+ 如果获取函数调用，得到类型与函数返回值相同；
	+ 将标识符用括号括起来，可以得到标识符引用；
	+ 如果都不满足，得到`expression`类型。
	```C++
	int x;
	decltype(x);	//int
	decltype(sqrt(x));	//int
	decltype((x));	//int &
	decltype(x+6).	//int
	```
3. 后置返回类型，函数返回类型在函数声明之前，如果是需要在函数内推断的类型，如何获得?使用后置返回类型，用`auto`占位，将`decltype`置于函数声明之后。
```C++
template<typename T1,typename T2>
auto gt(T1 x,T2 y)->decltype(x+y) {
	return x+y;
}
```