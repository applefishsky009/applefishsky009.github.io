---
title: 访问网站时到底发生了什么？
date: 2016-06-04 13:39:20
category: 计算机网络
tags: [DNS,UDP,IP,ARP,RIP,TCP,HTTP]

---

之前有学习过计算机网络，但并没有理解他到底是什么，直到现在，决定重温计算机网络。首先推荐一本书，谢希仁编著的《计算机网络》，还有一个[计算机网络总结](https://mp.weixin.qq.com/s?__biz=MzA5ODUxOTA5Mg==&mid=2652549492&idx=1&sn=1ee3f3ac7e3939c2d043475ee94fc84a&scene=0&key=f5c31ae61525f82ee719b6a9891804cfdb17bfef968860d6549e72f709c44f8858691a090c5bb18f36988dc88354c172&ascene=7&uin=MTI5MjI0NzEyMQ%3D%3D&devicetype=android-23&version=26031031&nettype=WIFI&pass_ticket=Y%2F%2FFA4XRBgzEZc7TWnpUSOgilSIZ%2BwlAC7IVjUZZxQ8%2BeVY%2BsyubOhQ6ThMU3jn%2F)。直到看了这本书，我才认识到，国内教材还是有可取之处的。。。

第一篇计算机网络的博客，回答这样一个问题，我们**访问一个网站的时候经历了怎样的过程**？以后的内容基本都是基于这一解释的扩展。

---

## 获得网站的IP

我知道他的名字，但是不知道他的联系方式，怎么玩耍呢？
只有获得网站的IP(联系方式)才能建立TCP连接(通话约好玩耍)，因此第一步就是获得网站的IP。
1. 查看浏览器DNS缓存有没有URL对应的IP，(还要查看系统缓存)，若没有，浏览器需要向DNS服务器发出DNS请求；
	+ 简单将DNS服务器理解为：URL转IP(域名解析)；
2. 浏览器向本地DNS模块发出DNS请求，DNS模块生成相关的DNS报文；
3. 会话层/应用层的DNS模块将生成的DNS报文传递给传输层的UDP协议单元；
4. UDP协议单元将数据封装成UDP数据报，传递给网络层的IP协议单元；
5. IP单元将数据封装成IP数据包，其中目的IP是电脑设置的默认DNS地址(DNS服务器地址，路由器根据这个IP进行路由选择)，将封装好的数据包传递给数据链路层的协议单元；
6. 封装好的IP数据包传递给数据链路层，数据链路层需要封装到达目的IP的MAC地址(下一跳地址)，这时候IP协议需要使用ARP协议获得下一跳的MAC地址(路由的MAC)，如ARP缓存没有相关数据，发送ARP广播(广播信道CSMA/CD协议)请求，等待ARP回应；
	+ ARP协议解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题。
7. 收到ARP单播回应(使用PPP->IPCP协议(包含NCP协议))，将对应信息写入ARP缓存，这时候数据链路层就可以封装IP数据包和下一跳MAC地址(路由器或目的主机)并发送(单播)；
8. 多次经过路由器解封/封装MAC帧，DNS请求到达DNS服务器的数据链路层(协议单元)->IP->UDP->DNS(->表示经过协议单元并解析报文)，解析DNS域名，如果DNS服务器有相关数据，则产生DNS回应报文。
	+ 主机向本地域名服务器采用**递归查询**，就是说，如果这里没有相关数据，由本地域名服务器向其他根域名服务器继续发出DNS请求(每次DNS请求从1开始)；
	+ 本地域名服务器向跟域名服务器采用**迭代查询**，就是说，被查询的根域名服务器产生DNS回应报文，其中要么给出目的IP，要么说：“我不知道，你去问我下边的那个顶级域名服务器吧！”，同理顶级域名服务器如果还是不知道，就会说：“我不知道，你去问我下边的这个权限域名服务器吧”，然后就得到了所需要的DNS回应报文。
9. DNS回应报文在本地域名服务器上，DNS回应报文->UDP->IP->数据链路层(MAC)。
10. 本机得到DNS回应报文，数据链路层->IP->UDP->DNS,解析得到URL对应的IP->浏览器写入DNS缓存表。


---

## TCP链接的三次握手

我知道了他的联系方式，现在我需要和他联系约好一起愉快的玩耍。
现在浏览器直到了目标URL的IP地址，下一步和这个IP建立TCP连接。
1. 浏览器向目的IP发送TCP连接请求报文，TCP(SYN=1，ACK=0)->IP->ARP(MAC)->网关->目的主机；
3. 目的主机得到TCP请求报文，数据链路层->IP->TCP；
4. 发送请求应答报文，TCP(SYN=1,ACK=1)->IP->数据链路层；
4. 本机得到请求应答报文，数据链路层->IP->TCP；
5. 本机回应请求确认报文，TCP->IP->数据链路层；
6. 目的主机得到请求应答报文，数据链路层->IP->TCP,连接建立完成。

### 为什么需要三次握手
如果不是三次握手：
1. 本机请求报文阻塞时，本机超时后会再次发送连接请求，服务器建立多个响应等待。
2. 若2次握手，再考虑目的主机回应报文阻塞了(这时候服务器已经响应了)。主机会再次发送连接请求，造成服务器再次响应，依然有服务器资源浪费。
3. 采用三次握手，如果服务器没有收到确认报文的确认，他会有一个重传次数和半连接存活时间，超过重传次数或半连接存活时间，就知道本机并没有想要建立连接，因此不会响应。
4. <font color=red>TCP的漏洞</font>,如上所说，有一个重传次数和半连接存活时间,如果有一个主机不停地伪装不存在的IP，对服务器发出连接请求，无法响应确认报文，服务器需要不停重发确认报文直到超时，这些伪造的SYN包长时间占用未连接队列，正常的SYN请求被丢弃，服务器系统会运行缓慢，严重时引起网络堵塞升值系统瘫痪。

---

## 浏览器访问过程

怎么愉快的玩耍呢？
通过HTTP协议的方法来交互，比如：
1. HTTP.GET方法报文->TCP->IP->MAC(ARP)->网关->主机；
2. 主机数据链路层->IP->TCP->HTTP,HTTP协议产生封装好的HTML超文本形式数据；
3. HTTP-HTML->TCP->IP->MAC(ARP)->网关->本机；
4. 本机收到数据帧，数据链路层->IP->TCP->HTTP,浏览器显示HTML超文本。

---

## TCP断开连接的四次握手

愉快地玩耍了，各回各家吧！
断开连接是也是一个平等的过程，本机需要主机同意，主机也需要本机同意。
1. 浏览器发送结束请求报文，TCP(FIN=1)->IP->MAC(ARP)->网关->主机，本机等待关闭1；
2. 主机收到数据帧，数据链路层->IP->TCP,并回应应答报文，主机等待关闭，TCP(FIN=1,ACK=1)->IP->MAC(ARP)->网关->主机，本机等待关闭2。
3. 主机发送结束请求报文，TCP(FIN=1)->IP->MAC(ARP)->网关->本机；
4. 本机收到数据帧，数据链路层->IP->TCP,并回应应答报文，关闭连接，TCP(FIN=1,ACK=1)->IP->MAC(ARP)->网关->主机。

### 为什么要四次握手
1. 考虑主机将数据发送完了，发送结束请求报文，主机收到了，但是主机没有将需要大宋的个数据发完，因此会告诉主机，“你先等等，我发完数据再断开”，主机就在等待。
2. 主机告诉本机，“我发完了，可以关闭了”，本机收到后回应，“好的，那就关闭吧”
3. 主机收到最后一句话会断开连接，但是，本机发送后不能立刻关闭连接(TIME WAIT)，若回应报文丢失，主机会重新发送结束请求报文，本机还需要响应，因此需要TIME WAIT(一般是30s)。

---

参考[访问一个网站的过程](http://www.voidcn.com/blog/zbuger/article/p-5713349.html)。至此回答了**访问一个网站经历了哪些过程？**，作为一个入门级的计算机网络，其中每一层都值得深思。以后会慢慢补充。


