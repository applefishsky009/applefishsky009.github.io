---
title: 数据存储与二进制运算
date: 2016-04-09 20:07:02
category: C++基础
tags: [数据存储,二进制运算,INT_MIN]

---

## 数据存储

### 为什么需要反码和补码(2016.5.23添加)
之前几乎在所有的课本上看到为了方便计算，所以有了反码和补码，但是为什么?这两天在看斯坦福的公开课的时候恍然大悟，一个例子说明，`1+-1=0`在内存中怎么计算?
```
00000001+10000001=10000010;1+-1=-2? WTF?
\therefore
00000001+11111110(反码)=11111111;
11111111+00000001=0;
```
因此很显然，反码存在就是和原码相加之后得到所有位都是1，然后加1就得到了0。
多么美妙的二进制运算,以前太多孤陋寡闻,居然不知道这个道理。

### 原、反、补码
计算机为方便计算，内存中的数据都是以补码的形式储存、运算。

| 数		| 原码	| 反码	| 补码	|
| :---:	| :--:	| :--:	| :--:	|
| 正数	| 二进制表示	| 与原码相同	| 与原码相同
| 负数	| 对应正数符号位（最高位）置1	| 负数原码**非符号位**按位取反	| 负数反码加1

举个例子，数据类型为`char`：

| 原数字	| 原码	| 反码	| 补码
| :---:	| :--:	| :--:	| :--:	|
| `+3`	| `00000011`| `00000011`| `00000011`
| `-3`	| `10000011`| `11111100`| `11111101`
值得注意的是，如果这个数据为`unsigned char`，`11111101`对应的是253，这里涉及到溢出，详细讨论见下一博客。

### 消失的原码
对于`unsigned char`原反补相同，计算机存储的补码就是原码，原码二进制经典编码有256个；但是对于`signed char`，最高位是符号位，因此原码的取值范围是-127-127，只有**255个编码**，但是对内存来说，8bits可以编码256个，那多余的补码与消失的原码去了哪里？

考虑到编码效率，补码与原码必须是一一对应的关系。很容易想到在有符号数中有`00000000`、`10000000`两个原码表示+0与-0，而这是没有意义的。我们保证`00000000`这个原码与`00000000`这个补码相对应来表示0就可以。这样找到了消失的原码：`10000000`。

在这个基于256的数值域中，观察补码的**重置点（溢出中非常重要的概念）**127的补码`01111111`，-127的补码`10000001`，那么可以清楚的看到`127+1=？`、`？+1=127`。因此很好理解，多余的补码是`10000000`（与消失的原码相同，通过计算他的原码可以得到验证）。那么剩下的事情就是设置重置点了，有两个选择，128或者-128。考虑到符号位是1，我们人为规定-128是重置点。即**-128的原码**是`10000000`，**补码**也是`10000000`（显然它的**反码**是`01111111`）。

### 数据扩充和缩窄

1. 数据扩充在之前[LeetCode编程技巧说明](http://rylcode.cn/2016/04/08/LeetCodeC1%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%E8%AF%B4%E6%98%8E/)提到过，有符号扩充符号位，无符号扩充0;
2. 数据缩窄，编译器认为你只对低位感兴趣，因此会丢掉高位(栈中从变量开始字节访问固定的字节结束)。列表初始化和枚举是不允许缩窄的。

---

## 二进制运算（移位得到CHAR_MAX和CHAR_MIN）

明白上述数据存储概念之后，可以通过位运算来获得`char`的最大最小值。注意，其实在`climit`文件中有各种宏定义的最大最小值，比如`CHAR_MAX = 127`;`UCHAR_MAX = 0xff`;等。但是这里想利用位运算来实现这一目标(注意重置点)：

| CHAR_MAX	| CHAR_MIN	|
| :----:	| :------:	|
| `unsigned char max = 0-1`	| `unsigned char min = 0`;
| `char max = (1<<7)-1`	| `char min = 1<<7`(得到`10000000`);
1. 上述表格中`unsigned char max`本质为`signed char = -1`的强制类型转化
2. `char max` 是利用重置点`CHAR_MIN`得到`01111111`
3. `char min` 是利用-128的特殊补码(而且与原码相同)赋值的
4. `+`、`-`运算的优先级是高于`<<`、`>>`的，因此`1<<7`要加括号
注意右值中运算表达式中的数字默认都是`int`类型的，这与C++整型提升有关，详情见另一篇博客。

另，由以上解读可以很容易的得出`abs(int_X)`的工作原理，正数不变，负数求得原码后符号位取反，即原码也是补码。但是有**例外**：`abs(INT_MIN) = INT_MIN`。他是不变的。

解读下边两式的区别（使用中`unsigned`与`signed`操作注意符号位扩充）：

| `char a = abs((char)(1<<7)-1)`| `char b = abs((1<<7)-1)`|
| :-------------------------:	| :------------------:	|
| `(char)(1<<7)-1 = (int)-129`	| `(1<<7)-1 = (int)127`	|
| 	`1·`	| `2·`		|
| `a = -127`	| `b = 127`	|
1. `11111111 11111111 11111111 10000000`+`11111111 11111111 11111111 11111111`=`11111111 11111111 11111111 01111111`(`char` 原码`10000001`)	
2. `00000000 00000000 00000000 1000000`-`00000000 00000000 00000000 0000001`=`00000000 00000000 00000000 01111111`

---

## 编译器的困惑

在编程过程中碰到了[这个疑惑](http://www.hankcs.com/program/cpp/error-c4146-%E4%B8%80%E5%85%83%E8%B4%9F%E8%BF%90%E7%AE%97%E7%AC%A6%E5%BA%94%E7%94%A8%E4%BA%8E%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B%EF%BC%8C%E7%BB%93%E6%9E%9C%E4%BB%8D%E4%B8%BA%E6%97%A0.html),后来发现，明明 int 最小值是 -2147483648，但我们就是**无法**用`int n = -2147483648`;表示。这是因为这个语句会让编译器产生困惑：
1. 判断2147483648 > INT_MAX，编译器决定用unsigned int;
2. 编译器发现负号，对2147483648取反(*编译器取反原理是将从高位到第一个1之间的位取反*)来尝试表达-2147483648；
3. 那么在圆图中可以发现，取反操作对2147483648来说依然表达原值。

因此编译器会提示error:一元负运算符应用于无符号类型，结果仍为无符号类型。那么对-2147483648有两种可用的赋值：
1. int n = INT_MIN;
2. int n = (-2147483647 - 1);

<font color = red>但是</font>，如果涉及到取反操作`-n`的计算,对于`n=INT_MIN`依然存在这个问题，因此需要分解'-n = INT_MAX+1'来分别计算`INT_MAX`与1的情况并组合。例如[这里][中括号很烦]
[中括号很烦]:https://github.com/applefishsky009/LeetCode/blob/master/50%20-%20Pow(x%2C%20n)/50%20-%20Pow(x%2C%20n)%20.cpp