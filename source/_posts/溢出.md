---
title: 溢出
date: 2016-04-11 20:35:24
category: C++基础
tags: [数值溢出,运算溢出,堆栈溢出,缓冲区溢出]

---

## 数值溢出原理
![数值圆图](http://i.imgur.com/W3CYdOb.png)
C++Plus在P44已经说的很清楚，如下。
有几点需要注意的地方：

1. 上图下图中的圆在进行**强制类型转化**时也是**对应**的，这就是说`(uchar)-1 = 65535`。
2. 无符号数没有溢出，只有**进/借位**(微机原理`CF`标示)，因为C++确保无符号数类型超越限制后在另一极端取值的行为。
3. 有符号数没有进/借位，只有**溢出**(微机原理`OF`标示)，因为C++无法确保有符号数上溢下溢后在另一极端取值的行为。(在我测试的时候并没有发现违背这一现象，可能有特殊情况)。

(2016.5.23更新)，明白了反码存在的意义，很显然就清楚数值转化的原理，也就是说，补码中没有任何变化(因为硬件没有有符号无符号，只能根据输出设置标识位让编译器去解释)，就只是最高位解释为数字还是符号位!!!
[汇编的一个标准两套指令](http://blog.sina.com.cn/s/blog_6e44841b0100n2h6.html)

---

## 运算溢出

### 判断加法溢出

可以像这里一样分情况或者根据圆图分析，会发现
1. 所有上溢结果都小于任何一个操作数；
2. 所有下溢结果都大于任何一个操作数。

### 判断乘法溢出

1. 在这里提到，可以用检测`a*b/b`是否等于a来判断是否乘法溢出；
2. 在这里提到，可以先扩展再强制类型转化到低位，在判断是否相等来判断。

值得注意的是，在之前的帖子中提到过判断是否相等对**浮点数**和整型的判断方式是不一样的。

### 除零是不是溢出？
任何数除以零的计算“不是”算术溢出的一种。在数学上只能明显算是不明确的定义；它计算出来的结果只能当成是“没有”值，而不是非常大的无限数值。

应付溢出最佳的方法还是防范，充分了解数据类型，选择恰当的变量类型。比如，`c = a*b`一般都会选择c的长度为a的长度与b的长度之和。

---

## [堆栈溢出](https://zh.wikipedia.org/wiki/%E5%A0%86%E7%96%8A%E6%BA%A2%E4%BD%8D)

一般编译器默认的堆栈内存是1MB，若使用过多的堆栈内存时就会导致调用堆栈产生的溢出。一般产生于递归，或者静态申请过多的临时变量，比如`int a[1024[1024]`。

1. 若是静态内存导致的堆栈溢出，可以用动态申请使用堆内存。
2. 若是递归调用导致递归堆栈无法容纳调用的返回地址，要添加错误检查机制。注意数据类型或用循环处理来避免堆栈溢出。

---

## 缓冲区溢出

[缓冲区溢出](http://jingyan.baidu.com/article/e9fb46e1acc1267521f76633.html)源于这样一个编程错误：复制一个内存区域的内容到另一个内存区域，而目标内存区域容量太小无法容纳。它允许传入函数的内存块以一种特定方式修改堆栈。

此外的溢出还包括[算术下溢](https://zh.wikipedia.org/wiki/%E7%AE%97%E6%9C%AF%E4%B8%8B%E6%BA%A2)(浮点数溢出)等。