---
title: 动态规划
date: 2016-04-22 17:07:05
category: 数据结构与算法
tags: 动态规划

---

持续更新，记录在编程过程中关于动态规划(DP)的心得体会。算法分析以算法导论为主。主要是用于求解最优化问题，不同于递归用于解决互不相交的子问题，动态规划应用于子问题重叠的情况。简单来说，动态规划就是当前状态由前一状态所决定(也许有更前相关)。在实际应用中发现他有两个关键点：
1. 子问题的**状态转移方程**(递推关系式)；
2. 保存子问题的解用于递归(自顶向下);

它有两种等价的实现方式：
1. 带备忘的自顶向下；
2. 自底向上。

一般来说自底向上更容易实现。实际中哪一种更容易编程取决于具体问题。

1. [triangle](https://github.com/applefishsky009/LeetCode/blob/master/120%20-%20Triangle/120%20-%20Triangle.cpp)
2. [Unique Paths](https://github.com/applefishsky009/LeetCode/tree/master/62%20-%20Unique%20Paths)
3. [LeetCode:Maximum Subarray](https://github.com/applefishsky009/LeetCode/blob/master/53%20-%20Maximum%20Subarray/53%20-%20Maximum%20Subarray.cpp)和[BeautyOfProgramming:一维数组的最大子数组](https://github.com/applefishsky009/BeautyOfProgramming/blob/master/2.14%20-%20%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/2.14.cpp)
	+ 注意递推关系式(未改进版)(主要是理清逻辑，需要一个\\( nStart[i] \\)的递推):
	+ \\( nStart[i] = max(nStart[i-1]+A[i],nAll[i-1]) \\);
	+ \\( nAll[i] = max(nStart[i],nAll[i-1]) \\) 
4. [Best Time to Buy and Sell Stock](https://github.com/applefishsky009/LeetCode/blob/master/121%20-%20Best%20Time%20to%20Buy%20and%20Sell%20Stock/121%20-%20Best%20Time%20to%20Buy%20and%20Sell%20Stock.cpp)
	+ 每新一步，记录这一步与前面最小值最大差价，也就是利润
	+ 更新最小值用于下一步
5. [Palindrome Partitioning II](https://github.com/applefishsky009/LeetCode/blob/master/132%20-%20Palindrome%20Partitioning%20II/132%20-%20Palindrome%20Partitioning%20II.cpp)
	+ 每次从i向右扫描(i的遍历)，每找到一个回文(j的遍历)就算一次DP，可以转换成f(i)=min{f(j+1)+1} ,i<=j<n
	+ 定义状态 \\( P[i][j] = true\ if [i,j] \\)是回文，那么\\( P[i][j] = str[i]==str[j]\&\&P[i+1][j-1] \\)
	+ 注意上边转移函数\\(P[i][j]\\)依赖于\\(P[i+1][j-1]\\)，因此i递减，j递增，否则要做备忘录
6. [Best Time to Buy and Sell Stock III](https://github.com/applefishsky009/LeetCode/blob/master/123%20-%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20III/123%20-%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20III.cpp)
	+ 每个节点有四种可能:
	+ 二次卖出，所得利润最高；
	+ 二次持有，买入价格最低；
	+ 首次卖出，所得利润最高；
	+ 首次持有，买入价格最低。
	+ 第二种思路：设状态f(i)表示区间[0,i],状态g(i)表示状态[i+1,n-1]的最大利润，则最终答案为max(f(i)+g(i))。
7. [Best Time to Buy and Sell Stock IV](https://github.com/applefishsky009/LeetCode/blob/master/188%20-%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20IV/188%20-%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20IV.cpp)
	+ 这道题找到(v,p)之后的DP有四种转移状态：
	+ 待转换：考虑(1,5)->(2,4),利润不仅由下一次决定(此状态p可能转移从而跳入状态2)，还可能与下下次相关，->(3,6)就需要两次利润转换，因此加入转换队列；若->(0,6)就在待转化栈中计算了两次利润；
	+ 需要转换:考虑(1,5)->(2,6),利润转换5+3=4+4,小利润3，大利润5对应(1,6)还要看下一步；
	+ 利润:考虑(1,5)->(0,3),利润是4,(0,3)由下次决定；
	+ 利润:考虑(1,5)->(0,6),利润是4,(0,6)由下次决定。
8. [Maximal Rectangle](https://github.com/applefishsky009/LeetCode/blob/master/85%20-%20Maximal%20Rectangle/85%20-%20Maximal%20Rectangle.cpp)
	+ 直方图面积的计算;
9. [Interleaving String](https://github.com/applefishsky009/LeetCode/blob/master/97%20-%20Interleaving%20String/97%20-%20Interleaving%20String.cpp)
	+ 初始化，第零行或者第零列意味着s3和另一字符串做匹配，实际匹配时的路径只与左或下的取值(还有字符是否匹配)相关；
	+ 这是二维数组是否通路的问题，就像走<font color=red>迷宫</font>一样，DFS会走完所有的路径，但DP会记录某一结点是否可抵达。
10. [Regular Expression Matching](https://github.com/applefishsky009/LeetCode/blob/master/10%20-%20Regular%20Expression%20Matching/10%20-%20Regular%20Expression%20Matching.cpp)
	+ `*`匹配0个或者多个前个字符 - 重点；
	+ 注意当前匹配条件`*p == *s || (*p == '.' && *s != '\0')`，'.'唯一不能匹配'\0'。
