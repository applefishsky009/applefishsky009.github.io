---
title: 共用体、枚举和浮点数存储
date: 2016-04-21 10:38:14
category: C++基础
tags: C++

---

## 共用体

是一种数据格式，简单来说，在同一块内存地址，可以同时起不同数据类型的名字，用这些名字来取值时，名字所对应的数据类型告诉编译器怎么去解释内存中的数据。他的特点：
1. 它的长度是最大数据类型长度，可以节省空间；
2. 数据不共存；
3. 关键字`union`，声明方式与结构体相同；

---

## 枚举

创建符号常量的方式，简单来说就是将一个“标签”与枚举量对应起来。特点：
1. 可以提升(常到`int`)，但`int`不能缩窄到它；
2. 可以显式设置枚举量，枚举范围内即使没有枚举量，也合法；
3. 关键词`enum`，声明方式与结构体相似；
4. 他没有算术运算，一般常用于`swith`语句中的标签。

---

## 浮点数存储方式

### 浮点数表示
不管是什么数据类型，在内存中的表示方式都是一样的(0或者1)，数据类型的作用只是告诉编译器如何去解释内存中的数据，那么编译器是如何解释浮点型的？
首先，二进制科学法表示中，一个浮点型S = M*2^N，内存会存储三部分：符号位+阶码(N)+尾数(M)；

| 数据	| 符号位	| 阶码	| 尾数	|
| :---:	| :---:	| :---:	| :---:	|
| `float`| 1位	| 8位	| 23位	|
| 内存位	| 31	| 30-23	| 22-0	|
| `double`| 1位	| 11位	| 52位	|
| 内存位	| 63	| 62-52	| 51-0	|
其次，阶码使用中间偏置(固定量为2^N-1)的移码表示的,M的整数部分为1,不存储，只存储尾数即可。
例如，
1. 125.5f = `1111101.1` = 1.1111011*2^6 =>移码127+6 = 133 = `10000101` =>正数符号位是0，尾数补0到够23位,那么计算机中：`01000010 11111101 00000000 0000000`。
2. 253.5f = `11111101.1` = 1.11111011*2^7 =>移码127+7 = 134 = `10000110` =>正数符号位是0，尾数补0到够23位,那么计算机中：`01000011 01111110 10000000 0000000`。

### 浮点整型转化
讨论`float`型与`int`的相互转化(字节数相等)，值转化使用强制类型转换`float(int x)`和`int(float x)`可以完成，这个操作中内存中的位发生了变化，那么，现在不想让位变化，转变编译器解释数据的方式该如何操作?
之前提到过，对一个指定的编译器，任何指针的大小都是一定的。因此可以对指针(指针类型可以告诉编译器解释内存的方式)强制类型转化(缩窄转换取低位)来完成。如：
```
float f = 253.5;
unsigned short s = *(unsigned short*)&f;
short s1 = *(short*)&f;
```
s = 2**15 = 32768;
s1 = `10000000 00000000` = -32768;


### 补充
1. 整型常量默认情况下是int型,浮点常量在默认情况下是`double`型,如果需要`float`型，需要这样表示：`3.25f`；
