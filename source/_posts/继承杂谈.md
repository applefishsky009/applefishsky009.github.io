---
title: 继承杂谈
date: 2016-06-12 15:36:46
category: C++的类
tags: 继承

---

在上一篇提到过，不能被继承的一些情况：
1. 构造函数(派生类调用基类)；
2. 析构函数(派生类调用基类)；
3. 赋值运算符(成员赋值)；
4. 友元函数(非成员函数，通过指针强制类型转化改变作用域访问)。

这篇详细说明这些。

---

## 友元函数

继承只针对成员函数，但友元不是成员函数，因此不能被继承。如果希望派生类可以使用基类的友元函数，可以使用指针强制转化将基类指针指向派生类指针，通过基类指针调用友元函数。

---

## 继承中动态内存分配

派生类构造函数使用列表初始化调用基类的构造函数。余下的复制构造函数，析构函数，赋值运算符重载，都是与动态内存分配相关(这三种成员函数总是需要特别注意分配的动态内存)，放在一起来分析。

### 派生类不使用new
1. 默认析构函数是合适的(销毁自身构造的对象部分后调用基类的析构函数)；
2. 复制构造函数是合适的(成员复制，基类对象部分调用基类对象的复制构造函数)；
3. 同上，赋值运算符也是合适的(赋值运算符一般需要用复制构造函数)。

### 派生类使用new
必须为派生类定义显式析构函数，复制构造函数和赋值运算符。
1. 析构函数需要对派生类构造执行工作进行清理(delete new出来的空间)；
2. 派生类复制构造函数，初始化列表中将派生类对象直接传递给基类对象用来复制派生类中的基类部分(因为基类引用可以引用派生类对象，这调用基类复制构造函数)，在代码块中执行剩下的工作。
3. 派生类赋值运算符使用作用域解析符显式调用基类的复制构造函数。例如：`base::operator=(a)`，其作用相当于`*this=a`(但这个语法是错的)，只不过将后者的赋值运算符显式声明为基类赋值运算符。