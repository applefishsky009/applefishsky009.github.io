[{"title":"The Skyline Problem","url":"https://applefishsky009.github.io/2017/04/14/The-Skyline-Problem/","content":"<p><a href=\"https://leetcode.com/problems/the-skyline-problem/#/description\" target=\"_blank\" rel=\"noopener\">218. The Skyline Problem</a>这个问题非常有意思，与<a href=\"https://github.com/applefishsky009/FunnyIssues/blob/master/6-SJF/6-SJF.cpp\" target=\"_blank\" rel=\"noopener\">SJF(短作业优先算法)</a>极为相似，使用<code>priority_queue</code>配合<code>pair</code>来解题非常方便。由此延伸到<code>utility</code>和<code>tuple</code>头文件的理解与关联。</p>\n<hr>\n<h2 id=\"解题\"><a href=\"#解题\" class=\"headerlink\" title=\"解题\"></a>解题</h2><p>关于这个题的理解<a href=\"https://briangordon.github.io/2014/08/the-skyline-problem.html\" target=\"_blank\" rel=\"noopener\">The skyline problem</a>阐述的较为清楚。解题的重点在于高权值在存活时间内覆盖低权值的“活动”，而所要求的<code>keyPoint</code>就是每当权值发生变化时的横坐标-权值对。</p>\n<h3 id=\"普通解法\"><a href=\"#普通解法\" class=\"headerlink\" title=\"普通解法\"></a>普通解法</h3><p>在简单的解法中，每有一个活动开始，更新它存活时间内的权值最大值，由此就得到所谓天际线，得到<code>keyPoint</code>。但在这个解法中，时间复杂度和空间复杂度都与这个活动可能的持续总时间相关，而与活动个数<code>n</code>没有直接关系，也就是说，极可能出现<code>kn</code>的时间复杂度，<code>k</code>值非常大，<code>k</code>的空间复杂度，这里的<code>k</code>甚至会引起<code>bad_alloc</code>。</p>\n<p>普通解法代码，仅供理解。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;pair&lt;int, int&gt;&gt; getSkyline(const vector&lt;vector&lt;int&gt;&gt; &amp;buildings)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;&gt; keyPoint;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!buildings.<span class=\"built_in\">size</span>())</span><br><span class=\"line\">            <span class=\"keyword\">return</span> keyPoint;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n = buildings[buildings.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">segTree</span><span class=\"params\">(n + <span class=\"number\">2</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> x : buildings)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = x[<span class=\"number\">0</span>]; i &lt; x[<span class=\"number\">1</span>]; i++)</span><br><span class=\"line\">                segTree[i] = <span class=\"built_in\">max</span>(x[<span class=\"number\">2</span>], segTree[i]);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; n + <span class=\"number\">2</span>; i++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (segTree[i] != segTree[i - <span class=\"number\">1</span>])</span><br><span class=\"line\">                keyPoint.push_back(make_pair(i, segTree[i]));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> keyPoint;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"优先级队列\"><a href=\"#优先级队列\" class=\"headerlink\" title=\"优先级队列\"></a>优先级队列</h3><p>之前提到解题的重点在于高权值在权值时间内覆盖低权值的“活动”，显然，一个以权值为<code>key</code>的优先级队列可以满足需要，同时需要携带<code>Y</code>值信息来判断活动是否结束，由于活动按照<code>X</code>值排好序，那么沿<code>X</code>轴进行扫描(只在活动开始或者结束时检查)，可能的操作有：</p>\n<ol>\n<li>在当前时间点开始的所有活动入队列，检查权值是否发生变化，如果变化则产生一个关键点。</li>\n<li>随着<code>X</code>的扫描，所有超过存活时间的活动出队列，同时检查权值是否发生变化，如果变化则产生一个关键点。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;pair&lt;int, int&gt;&gt; getSkyline(vector&lt;vector&lt;int&gt;&gt; &amp;buildings)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;&gt; res;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cur = <span class=\"number\">0</span>, cur_X = <span class=\"number\">0</span>, cur_H = <span class=\"number\">-1</span>, len = buildings.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        priority_queue&lt;pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt;&gt; liveBlg;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur &lt; len || !liveBlg.empty())</span><br><span class=\"line\">        &#123;                                     </span><br><span class=\"line\">            cur_X = liveBlg.empty() ? buildings[cur][<span class=\"number\">0</span>] : liveBlg.top().second;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur &gt;= len || buildings[cur][<span class=\"number\">0</span>] &gt; cur_X)</span><br><span class=\"line\">            &#123; </span><br><span class=\"line\">                <span class=\"keyword\">while</span> (!liveBlg.empty() &amp;&amp; (liveBlg.top().second &lt;= cur_X))</span><br><span class=\"line\">                    liveBlg.pop();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                cur_X = buildings[cur][<span class=\"number\">0</span>];</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (cur &lt; len &amp;&amp; buildings[cur][<span class=\"number\">0</span>] == cur_X)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    liveBlg.push(make_pair(buildings[cur][<span class=\"number\">2</span>], buildings[cur][<span class=\"number\">1</span>]));</span><br><span class=\"line\">                    cur++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur_H = liveBlg.empty() ? <span class=\"number\">0</span> : liveBlg.top().first;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (res.empty() || (res.back().second != cur_H))</span><br><span class=\"line\">                res.push_back(make_pair(cur_X, cur_H));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"http://blog.csdn.net/xiajun07061225/article/details/8556786\" target=\"_blank\" rel=\"noopener\">【STL学习】优先级队列Priority Queue详解与C++编程实现</a></p>\n<blockquote>\n<p>优先级队列内部的元素并不是按照添加的顺序排列，而是自动依照元素的<strong>权值</strong>排列。权值最高者排在最前面。缺省情况下，优先级队列利用一个<font color=\"red\"><strong>大顶堆</strong></font>完成。</p>\n</blockquote>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E5%84%AA%E5%85%88%E4%BD%87%E5%88%97\" target=\"_blank\" rel=\"noopener\">优先队列</a></p>\n<blockquote>\n<p>标准模板库（STL）以及1998年的C++标准确定优先队列是标准模板库的容器适配器模板。其实现了一个需要三个参数的最大优先队列：比较函数（缺省情况是小于函数less<t>）、存储数据所用的容器类型（缺省情况是向量vector<t>）以及指向序列开始和结束位置的两个迭代器。和标准模板库中其他的真实容器不同，优先队列不允许使用其元素类型的迭代器，而必须使用优先队列抽象数据类型的迭代器。标准模板库还实现了支持随机访问数据容器的优先队列–二叉最大堆。Boost C++库也在其中实现了堆结构。</t></t></p>\n</blockquote>\n<hr>\n<h2 id=\"从utillity到tuple\"><a href=\"#从utillity到tuple\" class=\"headerlink\" title=\"从utillity到tuple\"></a>从utillity到tuple</h2><p>在优先级队列中发现了一个很有意思的现象，没有重写<code>pair</code>类型的比较函数就能构造一个默认的<code>grater</code>优先级队列，这是如何进行的？</p>\n<h3 id=\"utility\"><a href=\"#utility\" class=\"headerlink\" title=\"utility\"></a>utility</h3><p><a href=\"https://en.wikipedia.org/wiki/Utility_(C%2B%2B)\" target=\"_blank\" rel=\"noopener\">utility (C++)</a>头文件包括两个关键部分：</p>\n<ol>\n<li><code>rel_ops</code>(relational operators)是一个命名空间，它包含一组模板，这些模板定义了同类型的关系运算符(<code>！=</code>,<code>&gt;</code>,<code>&lt;=</code>,<code>&gt;=</code>)的默认行为。这些默认行为是基于用户定义的<code>==</code>,<code>&lt;</code>两个行为的(也就是说这两个关系<font color=\"red\">必须被定义</font>)。</li>\n<li><code>pair</code>是一个容器模板，他可以包含任意类型的两个成员对象。通过(<code>first</code>和<code>second</code>来访问成员)，值得注意的是，头文件定义了他<font color=\"red\"><strong>所有的</strong></font>关系运算符。从这里<a href=\"http://www.cplusplus.com/reference/utility/pair/operators/\" target=\"_blank\" rel=\"noopener\">relational operators (pair)</a>也能看到。<ul>\n<li><code>pair</code>使用默认的构造函数对数据成员进行值初始化。</li>\n<li><code>pair</code>的数据成员是<code>public</code>的，两个成员啊分别命名为<code>first</code>和<code>second</code>。</li>\n<li>新标准下，我们可以对返回值进行列表初始化，就像<code>python</code>中那样，但旧的标准中必须显式构造返回值。另外还可以用<code>mnake_pair</code>来生成<code>pair</code>对象。</li>\n</ul>\n</li>\n</ol>\n<p>这就就容易解释<code>pair</code>在优先级队列中并不需要重写比较函数这一现象。另外，在<a href=\"http://www.cplusplus.com/reference/utility/pair/\" target=\"_blank\" rel=\"noopener\">pair</a>中可以看到以下描述，而<code>tuple</code>这个结构不能不让人想到<code>Python</code>中的<code>tuple</code>。</p>\n<blockquote>\n<p>Pairs are a particular case of tuple.</p>\n</blockquote>\n<h3 id=\"tuple\"><a href=\"#tuple\" class=\"headerlink\" title=\"tuple\"></a>tuple</h3><p>上节提到<code>pair</code>是<code>tuple</code>的特例，其实他是类似<code>pair</code>的模板，</p>\n<ol>\n<li><code>tuple</code>的默认构造函数会对每个成员进行值初始化。</li>\n<li><code>tuple</code>的成员都是未命名的，可以使用<code>get&lt;i&gt;(t)</code>来访问成员。</li>\n<li>可以使用辅助类模板<code>tuple_size&lt;tupleType&gt;::value</code>和<code>tuple_element&lt;i,tupleType&gt;::type</code>来查询<code>tuple</code>成员的数量和类型。<code>tupleType</code>可以通过<code>typedef decltype(t) tupleType</code>来推断。</li>\n<li>同类型的<code>tuple</code>才可以进行比较。</li>\n<li><code>tuple</code>常用来从一个函数返回多个值。</li>\n</ol>\n<hr>\n<p>一个简单的tips:<br>关于出栈顺序的题目，以1,2,3,4,5,6元素为例，如果当前位出现了6,之后小于6的元素肯定是<font color=\"red\"><strong>逆序</strong></font>，从思维上来说，不必使用DFS的思路来找正确答案，类似于一个DP问题，当前当前位是否合理与他之后的元素顺序有关。</p>\n","categories":["数据结构与算法"],"tags":["Algorithm"]},{"title":"再解KMP","url":"https://applefishsky009.github.io/2017/04/06/再解KMP/","content":"<p>之前在<a href=\"http://rylcode.cn/2016/05/03/BP%E3%80%81KMP%E3%80%81%E6%94%B9%E8%BF%9B%E7%9A%84KMP/\" target=\"_blank\" rel=\"noopener\">BP、KMP、改进的KMP</a>博文中介绍了计算KMP的方式以及程序理解，经过一段时间的沉淀，现在从算法角度和编程两个角度结合其他算法探求沉思KMP算法的本质。</p>\n<hr>\n<h2 id=\"算法角度\"><a href=\"#算法角度\" class=\"headerlink\" title=\"算法角度\"></a>算法角度</h2><p>结合DP思维，记录了前后缀匹配长度。<br>DP的思想体现首先在于<font color=\"red\"><strong>无后效性</strong></font>，<code>next[j]</code>代表<code>j</code>位以前字符串中真前后缀的最大公共元素长度，即不包含<code>j</code>自身。<code>j</code>位以前的记录和<code>j</code>位以后无关，这就是无后效性。但注意在之前博文中改进的KMP算法使用到了<code>j</code>位的字符比较。<br>其次体现在状态转移上，<code>j</code>位的记录仅由<code>j-1</code>位和当前字符和前缀指针是否匹配来共同决定，这就引出了编程使用双指针fail pointer的决策实现。</p>\n<hr>\n<h2 id=\"编程角度\"><a href=\"#编程角度\" class=\"headerlink\" title=\"编程角度\"></a>编程角度</h2><p>fail pointer问题。在编程实现中，可以用失配指针来解决，双指针一个指向真前缀，失配则回溯，一个指向真后缀，由前一状态和当前是否匹配来共同决定。<br>值得注意的是，在<code>nextTemp[j]</code>的计算中，如果<code>i</code>的值代表了后缀指针，那么<code>nextTemp[i-1]</code>的值就代表了前缀指针，</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">next</span><span class=\"params\">(l.<span class=\"built_in\">size</span>(), <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; l.<span class=\"built_in\">size</span>(); i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = next[i - <span class=\"number\">1</span>];    <span class=\"comment\">// 前一状态，同时这个值也是相同的真前缀长度</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &gt; <span class=\"number\">0</span> &amp;&amp; l[i] != l[j])   <span class=\"comment\">//失配</span></span><br><span class=\"line\">        j = next[j - <span class=\"number\">1</span>];    <span class=\"comment\">//  回溯，因为next[j]记录了匹配位置</span></span><br><span class=\"line\">    next[i] = (j += l[i] == l[j]);<span class=\"comment\">//回溯后再判断是否匹配</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<a href=\"http://www.rudy-yuan.net/archives/182/\" target=\"_blank\" rel=\"noopener\">一幅图让你彻底理解KMP算法</a>这个博文中对回溯的过程解释的比较清楚，即在回溯到的子字符串中，其实也经过了前缀后缀的匹配过程，因此需要多次回溯，回溯的跳出条件为回溯到底或者完全匹配为止。因此从<code>nextTemp[j]</code>到<code>next[j]</code>到<code>nextVal[j]</code>的算法优化过程如下：</p>\n<p><code>nextTemp[j]</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">next</span><span class=\"params\">(l.<span class=\"built_in\">size</span>(), <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; l.<span class=\"built_in\">size</span>(); i++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = next[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &gt; <span class=\"number\">0</span> &amp;&amp; l[i] != l[j])</span><br><span class=\"line\">        j = next[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">    next[i] = (j += l[i] == l[j]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>next[j]</code>，在这里做了两件事情，将i,j初始值减一，j作为前缀指针进行了更强有力的控制。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">-1</span>;</span><br><span class=\"line\">next[<span class=\"number\">0</span>] = <span class=\"number\">-1</span>; </span><br><span class=\"line\"><span class=\"keyword\">while</span>(i &lt; l.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(j &gt;= <span class=\"number\">0</span> &amp;&amp; l[i] != l[j])</span><br><span class=\"line\">\t\tj = next[j];</span><br><span class=\"line\">\tj++;</span><br><span class=\"line\">\ti++;</span><br><span class=\"line\">\tnext[i] = j;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再写<code>next[j]</code>，这里做了两件事情，去掉内层循环仅有外层循环控制，转换判断逻辑。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">-1</span>;</span><br><span class=\"line\">next[<span class=\"number\">0</span>] = <span class=\"number\">-1</span>; </span><br><span class=\"line\"><span class=\"keyword\">while</span> (i &lt; s2.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (j == <span class=\"number\">-1</span> || s2[i]==s2[j])</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\ti++;</span><br><span class=\"line\">\t\tj++;</span><br><span class=\"line\">\t\tnext[i] = j;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tj = next[j];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>优化至<code>nextVal[j]</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (i &lt; needle.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>) <span class=\"comment\">//注意i少一个值</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (j == <span class=\"number\">-1</span> || needle[i] == needle[j]) <span class=\"comment\">//前一次失配 或 当前匹配，真前后缀长度加1</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tj++;</span><br><span class=\"line\">\t\ti++;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (needle[i] != needle[j])</span><br><span class=\"line\">\t\t\tnextVal[i] = j;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\tnextVal[i] = nextVal[j];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tj = nextVal[j];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>参考题目：<br><a href=\"https://leetcode.com/problems/shortest-palindrome/#/description\" target=\"_blank\" rel=\"noopener\">214. Shortest Palindrome</a><br><a href=\"https://leetcode.com/problems/implement-strstr/\" target=\"_blank\" rel=\"noopener\">28. Implement strStr()</a></p>\n","categories":["数据结构与算法"],"tags":["Algorithm"]},{"title":"前缀树的实现","url":"https://applefishsky009.github.io/2017/03/30/前缀树的实现/","content":"<p>前缀树也叫字典树或Trie树，可以查询某个单词或者前缀在所有单词中出现的次数(假设单词中只包含字符’a’-‘z’)，查询和插入的时间复杂度都是O(n)，是一种以时间换空间的方法。<br>在下述实现中，根结点不对应空字符，而是首字符(这样保证了数据结构的一致性)，每个结点包含上一结点的<strong>超尾</strong>。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><p>创建一个结构体或类，其中包含一个26大小的指针数组(指向本数据类型，用是否空指针判断字符是否存在)，一个endFlag或nCount用来标识是否字符尾(判断前缀使用)或统计字符个数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> endFlag;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;node *&gt; pre;</span><br><span class=\"line\">    node() : endFlag(<span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        pre = <span class=\"built_in\">vector</span>&lt;node *&gt;(<span class=\"number\">26</span>, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h3><p>前缀树的实现除构造函数外需要四种基本操作，插入，辅助操作<strong>寻找指针</strong>用来<strong>查找</strong>或<strong>判断是否前缀</strong>。</p>\n<p>构造函数即创建根节点，注意在出现空字符后<code>endflag</code>才会为真，符合逻辑。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Trie()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    trie = <span class=\"keyword\">new</span> node();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>插入。按单词顺序往前缀树中插入单词，可以将单词看做数据结构之间的“线”。即路径。注意在叶子节点中除<code>endFlag</code>为<code>True</code>外，指针数组中的指针全是空指针。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"built_in\">string</span> <span class=\"keyword\">word</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    node *p = trie;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">word</span>.<span class=\"built_in\">size</span>(); i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!p-&gt;pre[<span class=\"keyword\">word</span>[i] - <span class=\"string\">'a'</span>])</span><br><span class=\"line\">            p-&gt;pre[<span class=\"keyword\">word</span>[i] - <span class=\"string\">'a'</span>] = <span class=\"keyword\">new</span> node();</span><br><span class=\"line\">        p = p-&gt;pre[<span class=\"keyword\">word</span>[i] - <span class=\"string\">'a'</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    p-&gt;endFlag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>寻找指针。沿单词顺序在前缀树中查找，有三种可能。</p>\n<ol>\n<li>该单词恰好在前缀树中，返回超尾指针，超尾指针的<code>endFlag</code>为<code>True</code>，指针数组中的值由其他单词决定。</li>\n<li>若该单词是一个前缀(单词是前缀)，而不是作为单词插入前缀树，不需要检查<code>endFlag</code>，只需要返回非空指针即可。</li>\n<li>若单词不在前缀树中，在查找中间过程失配的时候就返回了空指针(因为前缀树中没有初始化过对应的数据结构)。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">node *<span class=\"title\">find</span><span class=\"params\">(<span class=\"built_in\">string</span> <span class=\"keyword\">word</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    node *p = trie;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">word</span>.<span class=\"built_in\">size</span>() &amp;&amp; p; i++)</span><br><span class=\"line\">        p = p-&gt;pre[<span class=\"keyword\">word</span>[i] - <span class=\"string\">'a'</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>查找。返回非空指针且<code>endFlag</code>为<code>True</code>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"built_in\">string</span> <span class=\"keyword\">word</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    node *p = <span class=\"built_in\">find</span>(<span class=\"keyword\">word</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p &amp;&amp; p-&gt;endFlag;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>判断是否前缀。返回非空指针。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">startsWith</span><span class=\"params\">(<span class=\"built_in\">string</span> prefix)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">find</span>(prefix);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>参考资料：<br><a href=\"http://blog.csdn.net/pirage/article/details/6977730\" target=\"_blank\" rel=\"noopener\">字典树（前缀树）的应用</a><br><a href=\"https://zh.wikipedia.org/wiki/Trie\" target=\"_blank\" rel=\"noopener\">Trie</a></p>\n","categories":["数据结构与算法"],"tags":["Algorithm"]},{"title":"基本图算法和拓扑排序","url":"https://applefishsky009.github.io/2017/02/10/基本图算法和拓扑排序/","content":"<h2 id=\"图的表示\"><a href=\"#图的表示\" class=\"headerlink\" title=\"图的表示\"></a>图的表示</h2><p>对于图G(graph) = (V(vertex),E(edge))，有两种标准表示方法。</p>\n<ol>\n<li>邻接链表，一般用于表示稀疏图(边的条数|E|远远小于|V|*|V|)时非常紧凑。<ul>\n<li>对于有向图，邻接链表长度之和是|E|；对于无向图，邻接链表长度之和是2*|E|。</li>\n<li>邻接链表表示法的储存空间需求是O(V+E)，他的一个潜在缺陷是无法在O(1)时间判断边(u,v)是否在图中，需要在邻接链表Adj[u]中搜索结点v。</li>\n<li>可以将边(u,v)∈E的权重值w(u,v)存放在结点u的邻接链表里。</li>\n</ul>\n</li>\n<li>邻接矩阵，在稠密图(边的条数|E|接近|V|*|V|)时通常选择这种表示。<ul>\n<li>无向图的邻接矩阵是一个对称矩阵。</li>\n<li>邻接矩阵的空间需求为O(V*V)，付出更大的储存空间消耗，可以进行快速边搜索。</li>\n<li>直接将边(u,v)∈E的权重值w(u,v)存放在邻接矩阵第u行第v列。</li>\n</ul>\n</li>\n</ol>\n<p>图规模较小时，倾向于使用邻接矩阵表示法，他每个记录项只需要一位空间。另外，结点和边的属性，可以通过数组或者子类实例变量来表示。</p>\n<hr>\n<h2 id=\"图的遍历\"><a href=\"#图的遍历\" class=\"headerlink\" title=\"图的遍历\"></a>图的遍历</h2><p>图搜索算法分为广度优先算法(BFS)(Prim最小生成树，Dijkstra单元最短路径)和深度优先算法(DFS)，他们也是很多重要图算法的原型。在搜索的过程中，对结点进行涂色来指明结点的状态。</p>\n<h3 id=\"BFS\"><a href=\"#BFS\" class=\"headerlink\" title=\"BFS\"></a>BFS</h3><p>一般用于解决路径问题。所有结点初始颜色都是白色，凡是黑色和灰色结点都是已被发现的结点。所有与黑色结点邻接的点都已被发现，灰色结点所代表的就是已知和未知两个集合的边界(即白色结点还未入队列，灰色结点都在队列中，黑色结点已经出队列)。</p>\n<ol>\n<li><code>u.color</code>存放结点u的颜色属性。</li>\n<li><code>u.π</code>存放结点u的前驱结点。</li>\n<li><code>u.d</code>记录广度优先算法所计算出的从源节点s到结点u之间的距离。</li>\n</ol>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BFS(G,s)</span><br><span class=\"line\">  for each vertex u ∈ G.V - &#123;s&#125;</span><br><span class=\"line\">    u.color = WHITE</span><br><span class=\"line\">    u.d = ∞</span><br><span class=\"line\">    u.π = NIL</span><br><span class=\"line\">  s.color = GRAY</span><br><span class=\"line\">  s.d = 0</span><br><span class=\"line\">  s.π = NIL</span><br><span class=\"line\">  Q = ∅</span><br><span class=\"line\">  ENQUEUE(Q, s)</span><br><span class=\"line\">  while Q ≠ ∅</span><br><span class=\"line\">    u = DEQUEUE(Q)</span><br><span class=\"line\">    for each v ∈ G.Adj[u]</span><br><span class=\"line\">      if v.color == WHITE</span><br><span class=\"line\">        v.color = GRAY</span><br><span class=\"line\">        v.d = u.d + 1</span><br><span class=\"line\">        v.π = u</span><br><span class=\"line\">        ENQUEUE(Q, v)</span><br><span class=\"line\">    u.color = BLACK</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"聚合分析\"><a href=\"#聚合分析\" class=\"headerlink\" title=\"聚合分析\"></a>聚合分析</h4><ol>\n<li>初始化操作结束后，广度优先搜索不会再给任何结点涂上白色，因此每个结点入队最多为一次，那么出队最多也为一次，即队列操作的总时间阿伟O(V)。</li>\n<li>队列只在结点出队时对该结点的邻接链表进行扫描，即每个邻接链表最多扫描一次，所有邻接链表的长度之和是O(E)，那么扫描邻接链表总时间是O(E)。</li>\n<li>初始化操作的时间成本是O(V)，因此广度优先搜索的运行总时间是O(E+V)。</li>\n</ol>\n<p>另外可以证明，<code>v.d</code>即为源结点s到结点v的最短路径。</p>\n<h4 id=\"广度优先树\"><a href=\"#广度优先树\" class=\"headerlink\" title=\"广度优先树\"></a>广度优先树</h4><p>BFS算法搜索过程中创建一颗广度优先树，对应π属性。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PRINT-PATH(G,s,v)</span><br><span class=\"line\">  if v == s</span><br><span class=\"line\">    print s</span><br><span class=\"line\">  elseif v.π == NIL</span><br><span class=\"line\">    print \"no path from s to v exists\"</span><br><span class=\"line\">  else PRINT-PATH(G,s,v.π)</span><br><span class=\"line\">    print v</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DFS\"><a href=\"#DFS\" class=\"headerlink\" title=\"DFS\"></a>DFS</h3><p>一般用于解决拓扑排序问题。每个结点初始颜色都是白色，在结点被发现后变为灰色，在其邻接链表被扫描完成后变为黑色。</p>\n<ol>\n<li><code>v.color</code>存放结点v颜色属性。</li>\n<li><code>v.π</code>存放结点v的前驱结点。</li>\n<li>第一个时间戳<code>v.d</code>记录结点v第一次被发现的时间(涂上灰色的时候)。</li>\n<li>第二个时间戳<code>v.f</code>记录的是搜索完成对v的邻接链表扫描的时间(涂上黑色的时候)。</li>\n</ol>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DFS(G)</span><br><span class=\"line\">  for each vertex u ∈ G.V</span><br><span class=\"line\">    u.color = WHITE</span><br><span class=\"line\">    u.π = NIL</span><br><span class=\"line\">  time = 0</span><br><span class=\"line\">  for each vertex u ∈ G.V</span><br><span class=\"line\">    if u.color == WHITE</span><br><span class=\"line\">      DFS-VISIT(G,u)</span><br><span class=\"line\"></span><br><span class=\"line\">DFS-VISIT(G,u)</span><br><span class=\"line\">  time = time + 1</span><br><span class=\"line\">  u.d = time</span><br><span class=\"line\">  u.color = GRAY</span><br><span class=\"line\">  for each v ∈ G:Adj[u]</span><br><span class=\"line\">    if v.color == WHITE</span><br><span class=\"line\">      v.π = u</span><br><span class=\"line\">      DFS-VISIT(G,v)</span><br><span class=\"line\">  u.color = BLACK</span><br><span class=\"line\">  time = time + 1</span><br><span class=\"line\">  u.f = time</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"聚合分析-1\"><a href=\"#聚合分析-1\" class=\"headerlink\" title=\"聚合分析\"></a>聚合分析</h4><ol>\n<li>排除调用DFS-VISIT(G,u)的时间，DFS(G)中两个循环的时间复杂度都是O(V)。</li>\n<li>只有结点u是白色时才能调用DFS-VISIT(G,u)，而他所做的第一件事情是将结点涂灰，而在初始化之后结点不会被涂白，因此对每个结点来说，刚好调用了一次DFS-VISIT(G,v)。</li>\n<li>每个结点调用DFS-VISIT(G,v)时扫描邻接矩阵，由于∑|Adj[v]| = O(E)，因此总的算法运行时间是O(V+E)。</li>\n</ol>\n<hr>\n<h2 id=\"无环图\"><a href=\"#无环图\" class=\"headerlink\" title=\"无环图\"></a>无环图</h2><h3 id=\"kahn算法\"><a href=\"#kahn算法\" class=\"headerlink\" title=\"kahn算法\"></a>kahn算法</h3><ol>\n<li>计算图中所有点的入度，把入度为0的点加入栈。</li>\n<li>如果栈非空：<ul>\n<li>取出栈顶顶点a，输出该顶点值，删除该顶点。</li>\n<li>从图中删除所有以a为起始点的边，如果删除的边的另一个顶点入度为0，则把它入栈。</li>\n</ul>\n</li>\n<li>如果图中还存在顶点，则表示图中存在环；否则输出的顶点就是一个拓扑排序序列。</li>\n</ol>\n<p>以上算法可以判断是否有环，但是并不是所有最后剩余的点都是环中的顶点。<br>参考资料：<a href=\"http://www.cnblogs.com/TenosDoIt/p/3644225.html\" target=\"_blank\" rel=\"noopener\">判断一个图是否有环</a></p>\n<h3 id=\"有向无环图的拓扑排序\"><a href=\"#有向无环图的拓扑排序\" class=\"headerlink\" title=\"有向无环图的拓扑排序\"></a>有向无环图的拓扑排序</h3><p>经过拓扑排序后的结点次序，和结点的完成时间刚好相反。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TOPOLOGICAL-SORT(G)</span><br><span class=\"line\">  call DFS(G) to compute finishing times v.f for each vertex v.</span><br><span class=\"line\">  as each vertex is finished, insert it onto the front of a linked list.</span><br><span class=\"line\">  return the linked list of vertices.</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/207-CourseSchedule/207-CourseSchedule.cpp\" target=\"_blank\" rel=\"noopener\">CourseSchedule</a></p>\n<hr>\n<h2 id=\"强连通分量\"><a href=\"#强连通分量\" class=\"headerlink\" title=\"强连通分量\"></a>强连通分量</h2><p>有向图的强连通分量是一个最大结点集合C⊆V，对于该集合中的任意一对结点u和v来说，可以互相到达。<br>在O(E+V)时间使用两次DFS来计算有向图G = (V,E)的强连通分量，Kosaraju算法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">STRONGLY-CONNECTED</span><br><span class=\"line\">  call DFS(G) to compute finishing times u.f for each vertex u.</span><br><span class=\"line\">  compute G^T.</span><br><span class=\"line\">  call DFS(G^T), but in main loop of DFS, consider the vertices in order of decreasing u.f.</span><br><span class=\"line\">  output the vertices of each tree in the depth-first forest formed in last step as a separate strongly connected component.</span><br></pre></td></tr></table></figure>\n\n<p>参考资料：<a href=\"http://www.cnblogs.com/bamboo-talking/archive/2011/08/25/2153740.html#!comments\" target=\"_blank\" rel=\"noopener\">算法导论 拓扑排序、强连通分量（备忘）</a></p>\n<hr>\n","categories":["数据结构与算法"],"tags":["Algorithm"]},{"title":"VSCode配置Python环境","url":"https://applefishsky009.github.io/2017/01/19/VSCode配置Python环境/","content":"<h2 id=\"VSCode与插件\"><a href=\"#VSCode与插件\" class=\"headerlink\" title=\"VSCode与插件\"></a>VSCode与插件</h2><ol>\n<li>VSCode安装省略。</li>\n<li>插件选择<code>Python</code>，作者是Don Jayamanne，下载量最多的那个。</li>\n</ol>\n<hr>\n<h2 id=\"Python环境\"><a href=\"#Python环境\" class=\"headerlink\" title=\"Python环境\"></a>Python环境</h2><p>安装环境时注意重启VSCode，powershell，计算机。</p>\n<ol>\n<li>安装Python，注意安装的时候<a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001374738150500472fd5785c194ebea336061163a8a974000\" target=\"_blank\" rel=\"noopener\">Add python.exe to Path</a>，<a href=\"https://www.zhihu.com/question/22621185\" target=\"_blank\" rel=\"noopener\">一招搞定windows安装路径配置</a>，如果安装的时候没有选择，手动添加<code>Python.exe</code>到环境变量即可。</li>\n<li>配好环境变量在cmd中输入<code>python</code>，可以看到版本信息。因为我用的是powershell，在cmd中可以看到版本信息而在powershell中看不到，解决方案是<a href=\"http://stackoverflow.com/questions/19676403/running-python-in-powershell\" target=\"_blank\" rel=\"noopener\">Running Python in powershell?</a></li>\n<li>参数配置：</li>\n</ol>\n<p>launch.json</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"version\"</span>: <span class=\"string\">\"0.2.0\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"configurations\"</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"Python\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"python\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"request\"</span>: <span class=\"string\">\"launch\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"stopOnEntry\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"program\"</span>: <span class=\"string\">\"$&#123;file&#125;\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"debugOptions\"</span>: [</span><br><span class=\"line\">                <span class=\"string\">\"WaitOnAbnormalExit\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"WaitOnNormalExit\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"RedirectOutput\"</span></span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"Python Console App\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"python\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"request\"</span>: <span class=\"string\">\"launch\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"stopOnEntry\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"program\"</span>: <span class=\"string\">\"$&#123;file&#125;\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"externalConsole\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"debugOptions\"</span>: [</span><br><span class=\"line\">                <span class=\"string\">\"WaitOnAbnormalExit\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"WaitOnNormalExit\"</span></span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"Django\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"python\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"request\"</span>: <span class=\"string\">\"launch\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"stopOnEntry\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"program\"</span>: <span class=\"string\">\"$&#123;workspaceRoot&#125;/manage.py\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"args\"</span>: [</span><br><span class=\"line\">                <span class=\"string\">\"runserver\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"--noreload\"</span></span><br><span class=\"line\">            ],</span><br><span class=\"line\">            <span class=\"attr\">\"debugOptions\"</span>: [</span><br><span class=\"line\">                <span class=\"string\">\"WaitOnAbnormalExit\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"WaitOnNormalExit\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"RedirectOutput\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"DjangoDebugging\"</span></span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"Watson\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"python\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"request\"</span>: <span class=\"string\">\"launch\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"stopOnEntry\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"program\"</span>: <span class=\"string\">\"$&#123;workspaceRoot&#125;/console.py\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"args\"</span>: [</span><br><span class=\"line\">                <span class=\"string\">\"dev\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"runserver\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"--noreload=True\"</span></span><br><span class=\"line\">            ],</span><br><span class=\"line\">            <span class=\"attr\">\"debugOptions\"</span>: [</span><br><span class=\"line\">                <span class=\"string\">\"WaitOnAbnormalExit\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"WaitOnNormalExit\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"RedirectOutput\"</span></span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>tasks.json</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"version\"</span>: <span class=\"string\">\"0.1.0\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"command\"</span>: <span class=\"string\">\"python\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"isShellCommand\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"args\"</span>: [<span class=\"string\">\"$&#123;file&#125;\"</span>],</span><br><span class=\"line\">    <span class=\"attr\">\"showOutput\"</span>: <span class=\"string\">\"always\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"options\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"env\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"PYTHONIOENCODING\"</span>: <span class=\"string\">\"UTF-8\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"Run-Build-Task-中文乱码-BUG\"><a href=\"#Run-Build-Task-中文乱码-BUG\" class=\"headerlink\" title=\"Run Build Task 中文乱码 BUG\"></a>Run Build Task 中文乱码 BUG</h2><p>安装好之后F5运行，在dubug窗口显示的输出格式并不正确，按<code>ctrl + shift + B</code>运行(tasks指令)，安装好其他两个插件之后<code>Configure Task Runner</code>，即写好tasks配置文件，运行后可能出现乱码。<br>解决方案：<br><a href=\"https://segmentfault.com/a/1190000005986197\" target=\"_blank\" rel=\"noopener\">VSCode Python 配置</a><br>我采用在tasks.json中配置options参数来解决。</p>\n<hr>\n<h2 id=\"task配置\"><a href=\"#task配置\" class=\"headerlink\" title=\"task配置\"></a>task配置</h2><p>详细信息查看官网。<br><a href=\"http://code.visualstudio.com/docs/editor/tasks\" target=\"_blank\" rel=\"noopener\">Integrate with External Tools via Tasks</a></p>\n<blockquote>\n<p>The final command line is constructed as follows:</p>\n</blockquote>\n<blockquote>\n<p>If suppressTaskName is true, the command line is <font color=\"red\">command ‘global args’ ‘task args’</font>.<br>If suppressTaskName is false, it is <font color=\"red\">command ‘global args’ taskName ‘task args’</font>.</p>\n</blockquote>\n<hr>\n","categories":["VSCode"],"tags":["VSCode"]},{"title":"并查集-不相交集合算法","url":"https://applefishsky009.github.io/2017/01/18/并查集-不相交集合算法/","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>资料：<br><a href=\"https://en.wikipedia.org/wiki/Disjoint-set_data_structure\" target=\"_blank\" rel=\"noopener\">Disjoint-set data structure</a><br>算法导论第21章</p>\n<p>联合-查找算法（union-find algorithm）定义了两个操作用于此数据结构：</p>\n<ol>\n<li>Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。</li>\n<li>Union：将两个子集合并成同一个集合。</li>\n</ol>\n<p>实际使用：</p>\n<ol>\n<li>无向图的连通分量个数。</li>\n<li>最近公共祖先(LCA)。</li>\n<li>带限制的作业排序。</li>\n<li>实现Kruskar算法求最小生成树。</li>\n<li>求二值图像连通域个数。</li>\n</ol>\n<hr>\n<h2 id=\"代码实现和优化\"><a href=\"#代码实现和优化\" class=\"headerlink\" title=\"代码实现和优化\"></a>代码实现和优化</h2><h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> N 13 <span class=\"comment\">//总结点数</span></span></span><br><span class=\"line\"><span class=\"comment\">// 先搞一个充分大的数组模拟树</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> parent[N + <span class=\"number\">1</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> nRank[N + <span class=\"number\">1</span>] = &#123;<span class=\"number\">0</span>&#125;; <span class=\"comment\">//按秩合并</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化时， 将自己初始化为集合代表</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">makeSet</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>; i &lt;= N; i++)</span><br><span class=\"line\">        parent[i] = i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Find-AND-Union\"><a href=\"#Find-AND-Union\" class=\"headerlink\" title=\"Find AND Union\"></a>Find AND Union</h3><p>采用迭代的方式求集合代表。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查找集合代表， 看看究竟是谁(实际上， 还可以进行路径压缩优化)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r = n;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (parent[r] != r)</span><br><span class=\"line\">        r = parent[r]; <span class=\"comment\">// 没找到的话， 一直往上找</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将parentX和parentY所在的集合融合</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">union1</span><span class=\"params\">(<span class=\"keyword\">int</span> parentX, <span class=\"keyword\">int</span> parentY)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    parent[parentX] = parentY; <span class=\"comment\">// parent[parentY] = parentX;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但这样创建的树可能严重不平衡，树深度会影响查找效率。</p>\n<h3 id=\"路径压缩优化-path-compression\"><a href=\"#路径压缩优化-path-compression\" class=\"headerlink\" title=\"路径压缩优化(path compression)\"></a>路径压缩优化(path compression)</h3><p>采用递归的方式进行路径压缩优化，在<font color=\"red\">执行“查找”操作</font>时，扁平化树结构的方法，将路径上的每个节点都都直接连在根上。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//路径压缩,O(n)查找-&gt;O(1)查找，沿叶子往上找的时候将叶子和根全连在一起</span></span><br><span class=\"line\"><span class=\"comment\">//无论什么时候只要搜索发生就可能产生优化。初始化或者测试的时候。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find1</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (parent[n] != n)</span><br><span class=\"line\">        <span class=\"comment\">//等式右边第一趟沿着查找路径向上直到找到根，等式左边递归回溯沿着搜索树向下更新每个节点</span></span><br><span class=\"line\">        parent[n] = find1(parent[n]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> parent[n];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"按秩合并-union-by-rank\"><a href=\"#按秩合并-union-by-rank\" class=\"headerlink\" title=\"按秩合并(union by rank)\"></a>按秩合并(union by rank)</h3><p>使具有较少结点的树的根指向具有较多结点的树的根，来控制树的深度，只使用这个方法将使最坏运行时间(Union，Find)为log(n)。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">union2</span><span class=\"params\">(<span class=\"keyword\">int</span> parentX, <span class=\"keyword\">int</span> parentY)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nRank[parentX] &gt; nRank[parentY])</span><br><span class=\"line\">        parent[parentY] = parentX;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        parent[parentX] = parentY;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nRank[parentX] == nRank[parentY])</span><br><span class=\"line\">            ++nRank[parentY];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同时采用两种方法优势互补，将每个操作的平均时间仅为O(a(n))，这是渐进最优算法。</p>\n<hr>\n<h2 id=\"Note\"><a href=\"#Note\" class=\"headerlink\" title=\"Note\"></a>Note</h2><p>对于集合中的非数字元素，可以建立Hash Map将元素与数字进行编码，然后采用上述方式(数组)模拟树结构求解。<br><a href=\"https://github.com/applefishsky009/DataStructuresAndAlgorithms/blob/master/UnionSet/UnionSet.cpp\" target=\"_blank\" rel=\"noopener\">ryl的并查集</a><br><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/200-NumberOfIslands/200-NumberOfIslands.cpp\" target=\"_blank\" rel=\"noopener\">NumberOfIslands</a><br>为什么叫并查集？因为核心的两个功能(API)就是合并(Union)和查找(Find)。</p>\n<hr>\n","categories":["数据结构与算法"],"tags":["Algorithm"]},{"title":"Python入门12-执行环境","url":"https://applefishsky009.github.io/2017/01/17/Python入门12-执行环境/","content":"<h2 id=\"可调用对象\"><a href=\"#可调用对象\" class=\"headerlink\" title=\"可调用对象\"></a>可调用对象</h2><p>函数，方法，类，类的实例。</p>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><ol>\n<li>内建函数(BIF:Built-in Function)，C/C++所写，可以用<code>dir()</code>列出所有内建函数的属性。<ul>\n<li><code>type(BIF) -&gt; type &#39;builtin_funciotn_or_method&#39;</code>，但不用于工厂函数，工厂函数会返回类型<code>type</code>。</li>\n</ul>\n</li>\n<li>用户自定义函数(UDF:User-Defind Function)，Python所写，用户自定义函数是函数类型的。<ul>\n<li><code>type(UDF) -&gt; &lt;type &#39;function&#39;&gt;</code>。</li>\n</ul>\n</li>\n<li><code>lambda</code>表达式，创建匿名函数，通过别名来引用，享有和UDF相同的属性。</li>\n</ol>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><ol>\n<li>内建方法(BIM:built-in Method)，只有内建类型(BIT:built-in type)有内建方法，通过内建对象来访问内建方法。<ul>\n<li>BIF和BIM有相同的属性，不同的是BIM的<code>__self__</code>属性指向一个Python对象，而BIF指向<code>None</code>。</li>\n</ul>\n</li>\n<li>用户定义的方法(UDM:User-Defined Method)，与类对象关联/非绑定，通过类的实例来调用(绑定的)。<ul>\n<li>访问对象本身会揭示你正在引用一个绑定方法还是非绑定方法。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h3><ol>\n<li>利用类的可调用性来创建实例。</li>\n</ol>\n<h3 id=\"类的实例\"><a href=\"#类的实例\" class=\"headerlink\" title=\"类的实例\"></a>类的实例</h3><ol>\n<li>类有一个特别方法<code>__call__()</code>，该方法允许程序员创建可调用的实例。默认情况下，这个方法是没有被实现的，即大部分实例是不可调用的。</li>\n</ol>\n<hr>\n<h2 id=\"代码对象\"><a href=\"#代码对象\" class=\"headerlink\" title=\"代码对象\"></a>代码对象</h2><p>函数对象仅是代码对象的包装，方法则是给函数对象的包装。</p>\n<ol>\n<li><code>callable(object)</code>判断一个对象是否可调用。</li>\n<li><code>compile(source,filename,mode,flag=0,dont_inherit=False,optimize=-1)</code>编译source为code或AST对象 code可以通过调用<code>exec()</code>和<code>eval()</code>执行。<ul>\n<li>source可以为字符串或AST对象，第二个参数是代码所有文件，通常设置为<code>None</code>。</li>\n</ul>\n</li>\n<li><code>eval(expression,globals=None,locals=None)</code>执行一个表达式，可以是字符串或内建函数<code>compile()</code>创建的预编译代码对象。</li>\n<li><code>exec(obj)</code>执行代码对象或字符串形式的Python代码。<ul>\n<li>注意使用这个执行文件操作时，依然要<code>tell()</code>，<code>seek()</code>，<code>close()</code>，<code>getsize()</code>。</li>\n</ul>\n</li>\n<li><code>input(prompt)</code>输出提示符，读取用户输入。把输入作为Python对象来求值并返回表达式的结果。</li>\n<li>模块导入：<code>__name__</code>系统变量可以在运行时检测该模块是被导入还是被直接执行。<ul>\n<li>如果模块是被导入，<code>__name__</code>的值为模块名字。</li>\n<li>如果模块是被直接执行，<code>__name__</code>的值是<code>__main__</code>。</li>\n<li>利用这个特性在主程序中书写测试代码。</li>\n</ul>\n</li>\n<li>使用命令行从工作目录直接调用脚本。(如果是标准库的一部分会比较复杂)</li>\n<li><code>os.system()</code>通常不会和产生输出的命令一起使用，他通过退出状态显示成功或失败而不是通过输入和/或输出通信。通常的约定是利用退出状态，0表示成功，非0表示其他类型的错误。</li>\n<li><code>os.popen()</code>建立一个指向程序的单向链接，然后像访问文件一样访问程序。</li>\n<li><code>os.fork(), os.exec*(), os.wait*()</code>，进程控制函数，各种<code>os.exec*()</code>函数接受加载到新进程的参数列表。<ul>\n<li>子进程返回的pid是0，父进程返回的pid是子进程的进程号。</li>\n</ul>\n</li>\n<li><code>os.spawn*()</code>在新进程中执行命令。</li>\n<li><code>subprocess</code>模块，允许生成新进程，连接到输入/输出/错误管道，并获取返回码。此模块旨在替换多个旧模块和功能。</li>\n</ol>\n<hr>\n<h2 id=\"终止执行的方法\"><a href=\"#终止执行的方法\" class=\"headerlink\" title=\"终止执行的方法\"></a>终止执行的方法</h2><ol>\n<li><code>sys.exit()</code> 调用时，引发<code>systemExit</code>异常，这是唯一不看做错误的异常，如果没有给出状态参数，默认为0。</li>\n<li><code>os._exit()</code> 不执行任何清理便立即退出Python，不应该在一般应用中使用，因为他是平台相关的。</li>\n<li><code>os.kill(pid,sig)</code> 发给pid你想要发送的信号sig。 </li>\n</ol>\n<hr>\n","categories":["Python"],"tags":["Python"]},{"title":"Python入门11-类的高级特性","url":"https://applefishsky009.github.io/2017/01/15/Python入门11-类的高级特性/","content":"<h2 id=\"通用特性\"><a href=\"#通用特性\" class=\"headerlink\" title=\"通用特性\"></a>通用特性</h2><ol>\n<li>类和类型统一，所有Python内建转换函数都是工厂函数。类名以及工厂函数可以创建类的新对象，还可以作为基类去子类化类型，还可以用于<code>instance()</code>内建函数。    </li>\n<li>注意<code>instance(obj,OBJ)</code>内建函数不是严格比较的，如果obj是一个给定类型的实例或其子类的实例，都会返回<code>TRUE</code>。</li>\n<li>严格比较使用<code>is</code>操作符。</li>\n</ol>\n<hr>\n<h2 id=\"slots类属性\"><a href=\"#slots类属性\" class=\"headerlink\" title=\"slots类属性\"></a><strong>slots</strong>类属性</h2><p><a href=\"http://stackoverflow.com/questions/472000/usage-of-slots\" target=\"_blank\" rel=\"noopener\">Usage of <strong>slots</strong>?</a></p>\n<ol>\n<li>字典对实例很重要，<code>__dict__</code>属性跟踪所有实例属性。使用<code>inst.foo</code>和<code>inst.__dict__[&#39;foo&#39;]</code>访问属性是一样的。</li>\n<li>字典会占用大量内存，如果有一个属性数量很少的类，但有很多实例，基于内存上的考虑，可以使用<code>__slots__</code>属性来代替<code>__dict__</code>属性。</li>\n<li><code>__slots__</code>属性是一个类变量，由一序列型对象组成，由所有合法标识构成的实例属性的集合来表示，可以是列表，元组，可迭代对象，甚至在实例属性唯一时他可以是字符串。</li>\n<li><code>__slots__</code>属性是“类型安全”的，不允许用户动态增加实例属性。带<code>__slots__</code>属性的类定义不会存在<code>__dict__</code>了。</li>\n<li><code>__slots__</code>属性主要有两个优势，节约内存，访问属性速度更快。</li>\n</ol>\n<hr>\n<h2 id=\"getattribute-特殊方法\"><a href=\"#getattribute-特殊方法\" class=\"headerlink\" title=\"getattribute()特殊方法\"></a><strong>getattribute</strong>()特殊方法</h2><ol>\n<li>回忆<code>__getattr__()</code>特殊方法，当属性不能在实例或他的类或他的祖先类中的<code>__dict__</code>找到时，调用这个方法(在授权中，调用这个方法后调用<code>getattr()</code>内建函数来实现授权)。</li>\n<li>使用一个函数来执行每一个函数的访问，不光是属性不能找到的情况。如果类同时定义了<code>__getattribute__()</code>及<code>__getattr__()</code>方法，除非明确从<code>__getattribute__()</code>调用<code>__getattr__()</code>或者引发<code>AttributeError</code>(<code>__getattr__()</code>捕获这个异常并执行)，否则后者不会被调用。</li>\n<li>如果在<code>__getattribute__()</code>中不知何故再次调用了<code>__getattribute__()</code>，会引起无穷递归调用。因此总应该先调用祖先类的同名方法。</li>\n</ol>\n<hr>\n<h2 id=\"描述符\"><a href=\"#描述符\" class=\"headerlink\" title=\"描述符\"></a>描述符</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>描述符是表示对象属性的一个代理。</p>\n<ol>\n<li>描述符可以是任何类，至少实现了<code>__get__()</code>,<code>__set__()</code>,<code>__del__()</code>三个方法中的一个，这三个方法充当描述符协议的作用。实现方法不同具有不同的读写权限。</li>\n<li>非数据描述符实现<code>__get__()</code>方法，是只读数据，也叫做方法描述符。数据描述符具有读写权限，实现了<code>__set__()</code>和<code>__get__()</code>方法。</li>\n<li>如果想为一个属性写个代理，必须把他作为一个类的属性，让这个代理来完成所有的工作。考虑到上一节中每个属性实例都会调用的特殊方法<code>__getattribute__()</code>，他是描述符的核心。</li>\n<li>如果<code>super()</code>被调用了，它会沿着<code>obj.__class__.__mro__</code>紧接着的继承树来查找属性。</li>\n</ol>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def __get__(self, obj, type=None) =&gt; value</span><br><span class=\"line\">类X的实例x  x.foo    equals    type(x).__dict__[<span class=\"string\">'foo'</span>].__get__(x,type(x))</span><br><span class=\"line\">类X        X.foo    equals    X.__dict__[<span class=\"string\">'foo'</span>].__get__(<span class=\"literal\">None</span>,X)</span><br><span class=\"line\">类X的子类Y  super(Y,obj).foo   X.__dict__[<span class=\"string\">'foo'</span>].__get__(obj,X)</span><br><span class=\"line\"></span><br><span class=\"line\">def __set__(self, obj, val) =&gt; None</span><br><span class=\"line\">def __delete__(self, obj) =&gt; None</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"优先级别\"><a href=\"#优先级别\" class=\"headerlink\" title=\"优先级别\"></a>优先级别</h3><ol>\n<li>类属性 &gt; 数据描述符 &gt; 实例属性 &gt; 非数据描述符 &gt; 默认为<code>__getattr__()</code>。</li>\n<li>非数据描述符的目的只是当实例属性值不存在时，提供的一个值而已。当没有找到非数据描述符，<code>__getattribute__()</code>将会抛出一个<code>AttributeError</code>异常，接着会调用<code>__getattr__()</code>作为最后一个操作。</li>\n<li>优先级高的可以隐藏优先级低的属性。</li>\n<li>函数是非数据描述符，实例属性有更高的优先级，可以遮蔽任何一个非数据描述符。只要把(另)一个(非数据描述符)对象赋给实例(属性)就行了。</li>\n<li>静态方法、类方法、属性，甚至所有的函数都是描述符，描述符会根据函数的类型确定如何“封装”这个函数和函数被绑定的对象，然后返回调用对象。</li>\n</ol>\n<hr>\n<h2 id=\"属性和property内建函数\"><a href=\"#属性和property内建函数\" class=\"headerlink\" title=\"属性和property内建函数\"></a>属性和property内建函数</h2><p><a href=\"http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143186781871161bc8d6497004764b398401a401d4cce000\" target=\"_blank\" rel=\"noopener\">使用@property</a><br><a href=\"http://www.howsoftworks.net/python/function/property.html\" target=\"_blank\" rel=\"noopener\">property</a></p>\n<ol>\n<li>可以使用<code>property()</code>方法来处理实例属性的获取(<code>x.getter</code>)、赋值(<code>x.setter</code>)、删除(<code>x.deleter</code>)操作，在操作中可以对属性做一些合法值判断等功能。</li>\n<li><code>property()</code>方法是他所在类被创建时调用的，实际上是将函数作为参数传递进去，这些方法(其实就是函数)是非绑定的。</li>\n</ol>\n<hr>\n<h2 id=\"元类-metaclass\"><a href=\"#元类-metaclass\" class=\"headerlink\" title=\"元类(metaclass)\"></a>元类(metaclass)</h2><p><a href=\"http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319106919344c4ef8b1e04c48778bb45796e0335839000\" target=\"_blank\" rel=\"noopener\">使用元类</a><br><a href=\"http://blog.jobbole.com/21351/\" target=\"_blank\" rel=\"noopener\">深刻理解Python中的元类(metaclass)</a><br><a href=\"http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python\" target=\"_blank\" rel=\"noopener\">What is a metaclass in Python?</a></p>\n<ol>\n<li>元类是类的类，即由元类创建类，由类创建实例，关键是元类中的<code>__new__()</code>方法和<code>type()</code>内建函数(唯一可以创建类的东西)。</li>\n<li>元类一般用于创建类，解释器首先会查找类的关键字参数<code>metaclass</code>，如果没有传入，他会继续查找父类的关键字参数<code>metaclass</code>，直到<code>object</code>，<code>type(object)</code>即<code>type</code>类型，可以看到一个令人震惊的事实，<code>object</code>是<code>type</code>创建的。</li>\n<li>元类用于改变类的默认行为和创建方式。</li>\n</ol>\n<p>运行以下代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding:utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> ctime</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'1'</span>)</span><br><span class=\"line\">print(<span class=\"string\">'2'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MetaA</span><span class=\"params\">(type)</span>:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(cls,name,bases,attrd)</span>:</span></span><br><span class=\"line\">        super(MetaA,cls).__init__(name,bases,attrd)</span><br><span class=\"line\">        print(<span class=\"string\">'4'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'3'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span><span class=\"params\">(object,metaclass=MetaA)</span>:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'6'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'5'</span>)</span><br><span class=\"line\">c = C()</span><br><span class=\"line\">print(<span class=\"string\">'7'</span>)</span><br></pre></td></tr></table></figure>\n\n<p>输出为</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n","categories":["Python"],"tags":["Python"]},{"title":"Python入门11-继承和授权","url":"https://applefishsky009.github.io/2017/01/13/Python入门11-继承和授权/","content":"<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>描述基类的属性遗传给派生类。</p>\n<ol>\n<li><code>__doc___</code>类属性不会从基类中遗传过来。</li>\n<li><code>__bases__</code>类属性是包含父类集合的元组。</li>\n<li>可以在子类中定义同名函数覆盖父类的函数方法(多态)。可以在子类中显式地(需要知道父类名)或通过<code>super()</code>内建方法(默认传递<code>self</code>)调用父类方法。</li>\n<li>需要注意如果覆盖构造器<code>__init__()</code>方法，子类实例化时并不会自动调用父类的构造器，应该在子类中明确地调用父类的构造器。<ul>\n<li><code>super(obj, ins)</code>传入两个参数，类和类的实例，Python3中参数默认值是当前类和<code>self</code>(当前类的实例)。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"派生标准类型\"><a href=\"#派生标准类型\" class=\"headerlink\" title=\"派生标准类型\"></a>派生标准类型</h3><p>正如元类调用<code>type()</code>，是类的类一样，标准类型也可以看做是类型的类，来派生出新的类型。</p>\n<h4 id=\"不可变类型的派生\"><a href=\"#不可变类型的派生\" class=\"headerlink\" title=\"不可变类型的派生\"></a>不可变类型的派生</h4><ol>\n<li>应该覆盖<code>__new__()</code>特殊方法来定制我们的对象，因为这个方法在<code>__init__(self)</code>执行之前执行并返回一个对象传入初始化方法<code>__init__(self)</code>(即这里的<code>self</code>)。</li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/21379984\" target=\"_blank\" rel=\"noopener\">python 类中<strong>new</strong> 和 <strong>init</strong>方法区别</a></li>\n</ol>\n<h4 id=\"可变类型的派生\"><a href=\"#可变类型的派生\" class=\"headerlink\" title=\"可变类型的派生\"></a>可变类型的派生</h4><p>一般情况下，对可变类型继承到的类型的默认行为就是你想要的。</p>\n<h3 id=\"多重继承\"><a href=\"#多重继承\" class=\"headerlink\" title=\"多重继承\"></a>多重继承</h3><p>多重继承一般有两个问题，第一，找到合适的属性；第二，如何调用父类的方法以发挥他们的作用。</p>\n<ol>\n<li>方法解释顺序MRO(<code>Method Resolution Order</code>)，新式类出现之前是深度优先，之后是广度优先，新式类的<code>__mro__</code>属性会返回查找顺序。<ul>\n<li><a href=\"http://www.cnblogs.com/lovemo1314/archive/2011/05/03/2035005.html\" target=\"_blank\" rel=\"noopener\">python super()</a></li>\n</ul>\n</li>\n<li>菱形效应引起的MRO问题，因为新式类都会从<code>object</code>中派生，如果采用深度优先，会多次回溯到<code>object</code>。这是不期望的。<ul>\n<li>1中的链接很好的说明了这个问题，F的mro顺序FEBCDAob，E的MRO顺序EBCAob，C的MRO顺序CAob。、</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"内建函数\"><a href=\"#内建函数\" class=\"headerlink\" title=\"内建函数\"></a>内建函数</h3><ol>\n<li><code>subclass(sub,sup)</code>判断一个类是不是另一个类的子类或者子孙类。</li>\n<li><code>isinstance(obj,OBJ)</code>判定一个对象是不是另一个给定类的实例。<ul>\n<li>第二个参数是类。</li>\n<li>他不会有性能上的问题，因为他只用来搜索类族集成结构，而且它是用C写的。</li>\n</ul>\n</li>\n<li><code>hasattr(ins,attr)</code> 判断一个对象是否有特定的属性。</li>\n<li><code>getattr(ins,attr)</code> 取得对象的属性。</li>\n<li><code>setattr(ins,attr)</code> 赋值给对象的属性。</li>\n<li><code>delattr(ins,attr)</code> 从一个对象中删除属性。</li>\n<li><code>dir()</code><ul>\n<li>作用于实例上，显示实例变量，还有实例所在类及所有他的基类中定义的方法和类。</li>\n<li>作用于类上，显示类以及他的所有基类的<code>__dict__</code>中的内容。但他不会显示定义在元类(<code>metaclass</code>)中的类属性。</li>\n<li>作用在模块上，显示模块的<code>__dict__</code>内容。</li>\n<li>不带参数时，显示调用者的局部变量。</li>\n</ul>\n</li>\n<li><code>super()</code> 帮助程序员找出相应的父类，然后方便调用相应的属性。<ul>\n<li>使用<code>super()</code>来简化搜索一个合适祖先的任务，其主要是用来查找父类的属性。</li>\n<li>实际上，<code>super()</code>是一个工厂函数，他创造了一个<code>super object</code>，为一个给定的类使用<code>__mro__</code>去查找相应的父类。</li>\n</ul>\n</li>\n<li><code>var()</code> 内建函数与<code>dir()</code>相似，只是给定的对象参数必须有一个<code>__dict__</code>属性。返回一个字典，包含对象存储于其<code>__dict__</code>中的属性(键)和值。<ul>\n<li>如果没有提供参数，他将显示一个包含本地名字空间的属性(键)及其值的字典，也就是<code>locals()</code>。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"定制类\"><a href=\"#定制类\" class=\"headerlink\" title=\"定制类\"></a>定制类</h3><p>之前的<code>__init__()</code>和<code>__del__()</code>也是自定义特殊方法的一部分，另外，Python的类定制包含：模拟标准类型，重载操作符。</p>\n<ol>\n<li>可以定制的方法有，属性方法，二进制操作符，一元操作符，数值转换，基本表示法，序列类型，映射类型。<ul>\n<li>Python中有两个除法，<code>/</code>真除法<code>__truediv__()</code>是准确的浮点除法，<code>//</code>是<code>__floordiv__()</code>C++中的整型除法。</li>\n<li><a href=\"http://stackoverflow.com/questions/1436703/difference-between-str-and-repr-in-python\" target=\"_blank\" rel=\"noopener\">Difference between <strong>str</strong> and <strong>repr</strong> in Python</a>，<strong>unambiguous v.s. readable</strong>，从编译器角度和从读者角度，另外，如果<code>__repr__()</code>定义了，但<code>__str__()</code>没有定义，默认会有<code>__str__=__repr__</code>。</li>\n<li><code>__str__()</code>只返回一个字符串(这是<code>print()</code>的重载)，如果想要打印多个字符串，请自定义其他类型的打印函数。</li>\n</ul>\n</li>\n<li>重载<code>__iter__</code>和<code>next()</code>方法可以定制迭代器，无穷迭代可以通过随机选择<code>choice()</code>或者处理异常来实现。<ul>\n<li><strong>所谓的安全模式</strong>：只是一个标识flag，在抓取到异常时，采用不同的决策。</li>\n</ul>\n</li>\n<li><code>__nonzeros__()</code>可以为<code>object</code>定义<code>FALSE</code>值。</li>\n<li><code>__cmp__</code>对象比较。</li>\n</ol>\n<hr>\n<h2 id=\"私有化\"><a href=\"#私有化\" class=\"headerlink\" title=\"私有化\"></a>私有化</h2><h3 id=\"类的访问控制\"><a href=\"#类的访问控制\" class=\"headerlink\" title=\"类的访问控制\"></a>类的访问控制</h3><ol>\n<li>在类的属性和方法名字前面加上<strong>双下划线</strong>提供了初步的类的私有化，不允许直接访问。在访问时，要在名字前边加上<strong>单下划线和类名</strong>来指定访问的是哪一个类的变量(<code>self._OBJ__attr</code>)。<ul>\n<li>保证<code>__XXX</code>变量不与父类的名称空间冲突。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"模块级访问控制\"><a href=\"#模块级访问控制\" class=\"headerlink\" title=\"模块级访问控制\"></a>模块级访问控制</h3><ol>\n<li>之前提到过模块级的私有化，在属性(或方法，因为这是严格基于作用域的)名称前加<strong>单下划线</strong>，这样不会被<code>from XXX import *</code>加载，但是可以显式载入。</li>\n</ol>\n<hr>\n<h2 id=\"授权-enabling\"><a href=\"#授权-enabling\" class=\"headerlink\" title=\"授权(enabling)\"></a>授权(enabling)</h2><p>授权是包装的一个特性，包装一个类型通常是对已存在的类型的一些定制，可以新建、修改、删除原有产品的功能。其他保持原样或保留已存功能或行为。授权的过程，即所有更新的功能都是由新类的某部分来处理，但已存的功能就授权给对象的默认属性。</p>\n<ol>\n<li>关键：<font color=\"red\">覆盖<code>__getattr__()</code></font>方法，代码中包含对<code>getattr()</code>内建函数的访问。<ul>\n<li>引用一个属性时，Python解释器会依次在局部名称空间，类名称空间中搜索，如果都没有找到，搜索对原对象开始授权申请，<code>__getattr__()</code>会被调用。</li>\n<li>对这些属性的访问，是通过<code>getattr(obj,atrr)</code>方法，授权给对象。而且只有已存在的属性是在此代码中授权的。</li>\n<li>在包装中实现<code>get()</code>方法返回一个对象，因为有时需要访问实际对象和他的切片能力。</li>\n</ul>\n</li>\n<li>时间戳。<a href=\"http://www.cnblogs.com/SRL-Southern/archive/2015/09/30/4848590.html\" target=\"_blank\" rel=\"noopener\">2015/9/29 Python基础(20)：类的授权</a></li>\n</ol>\n<hr>\n","categories":["Python"],"tags":["Python"]},{"title":"Python的实例方法，类方法，静态方法","url":"https://applefishsky009.github.io/2017/01/11/Python的实例方法，类方法，静态方法/","content":"<h2 id=\"静态方法和类方法\"><a href=\"#静态方法和类方法\" class=\"headerlink\" title=\"静态方法和类方法\"></a>静态方法和类方法</h2><p>参考资料：</p>\n<ol>\n<li><a href=\"http://www.jianshu.com/p/212b6fdb2c50\" target=\"_blank\" rel=\"noopener\">python类的静态方法和类方法区别</a>强调使用场景和继承。</li>\n<li><a href=\"http://stackoverflow.com/questions/12179271/python-classmethod-and-staticmethod-for-beginner\" target=\"_blank\" rel=\"noopener\">Python @classmethod and @staticmethod for beginner?</a>最高赞答案强调了重载，次高赞答案强调了继承。</li>\n<li><a href=\"https://www.zhihu.com/question/20021164\" target=\"_blank\" rel=\"noopener\">Python 中的 classmethod 和 staticmethod 有什么具体用途</a>最高赞答案强调了封装和使用场景。来自于<a href=\"https://link.zhihu.com/?target=http%3A//www.pythoncentral.io/difference-between-staticmethod-and-classmethod-in-python/\" target=\"_blank\" rel=\"noopener\">Difference between @staticmethod and @classmethod in Python</a></li>\n</ol>\n<h3 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h3><ol>\n<li>实例方法提供与类的实例对象进行交互的方法(针对实例特有的数据)，因此第一个参数必须传入实例对象，<code>一般习惯用self</code>。</li>\n<li>类方法提供与类本身(类也是对象)交互的方法()，我们可以在类外定义一个简单方法将类作为参数传入来交互。这个参数如果传入实例对象，需要通过实例对象的<code>__class__</code>属性来访问类，如果是类对象，可以直接访问。但是这样就会将类代码关系扩散到类定义的外部，违背了OOP封装的特性。因此采用<code>@classmethod</code>装饰器来创建类方法与类交互，注意要与类交互，因此类方法的第一个参数必须传入类对象。</li>\n<li>有一些与类有关系的功能但不需要类对象或者实例对象，这就需要静态对象，比如更改环境变量(控制一部分类功能)或者修改其他类的属性。用外部函数依然可以解决，但同样会扩散类内部代码，造成维护困难。因此采用<code>@staticmethod</code>装饰器，因为这些功能不需要类对象与实例对象，因此默认不需要传入任何参数。</li>\n</ol>\n<p>代码参见参考资料3，但代码对齐有一些问题。</p>\n<h3 id=\"重载\"><a href=\"#重载\" class=\"headerlink\" title=\"重载\"></a>重载</h3><ol>\n<li>考虑C++中类构造函数的多样化可以通过函数重载(<code>overloading</code>)来实现，但Python中没有这个概念，如果只能有一个构造函数，对于不同的初始化参数，只能在类外做一些重复性的工作后传入唯一的构造函数来初始化。因此类方法<code>@classmethod</code>,通过给不同的类方法传入不同的初始化参数来实现多样化的初始化。<ul>\n<li>可重复利用(reusable)，针对构造函数外部重复性的处理。</li>\n<li>封装(Encapsulation)，将类代码关系封装在类内。</li>\n<li>继承(inherit)，类方法与类关联，因此继承后依然存在于子类，但其属于子类。</li>\n</ul>\n</li>\n<li>静态方法与类方法非常相似，但其不需要强制参数，因此可以做一些与类控制相关的环境变量或其他类属性的判断或更改。</li>\n</ol>\n<p>代码见参考资料2,3。</p>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>如果子类继承父类方法，子类覆盖了父类的静态方法；</p>\n<ol>\n<li>子类实例继承父类的静态方法，调用该方法，还是调用父类的方法和类属性。其实可以认为是提供了一个子类访问父类属性的接口(就算子类重载了任何函数，这个静态函数的搜索也是从父类开始向上的，即屏蔽了子类的名称空间)。</li>\n<li>子类实例继承父类的类方法，调用该方法，调用子类的方法和类属性。可以通过继承来覆盖类方法。</li>\n</ol>\n<p>代码参见资料1,2。</p>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><ol>\n<li>实例方法，只能被实例对象调用，第一个参数必须要传实例对象，一般习惯用<code>self</code>；</li>\n<li>类方法(在类中由<code>@classmethod</code>装饰)，可以被实例对象和类调用，第一个参数必须要传类，一般习惯用<code>cls</code>；</li>\n<li>静态方法(在类中由<code>@staticmethod</code>装饰)，可以被实例对象和类调用，参数没有要求。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">foo</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">print_my1</span><span class=\"params\">(self)</span>:</span>    </span><br><span class=\"line\">        print(<span class=\"string\">'实例方法&#123;&#125;'</span>.format(self.__class__))</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"meta\">    @classmethod</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">print_my2</span><span class=\"params\">(cls)</span>:</span> <span class=\"comment\">#所属的类名</span></span><br><span class=\"line\">        print(<span class=\"string\">'类方法&#123;&#125;'</span>.format(cls.__name__))</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"meta\">    @staticmethod</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">print_my3</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'静态方法'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">x = foo()</span><br><span class=\"line\"><span class=\"comment\">#实例初始化只有两个属性__dict__(包含可用的属性名-属性字典)和__class__(指出该实例属于哪一类)</span></span><br><span class=\"line\"><span class=\"comment\">#foo.print_my1() 类不能调用实例方法</span></span><br><span class=\"line\">foo.print_my2()</span><br><span class=\"line\">foo.print_my3()</span><br><span class=\"line\">x.print_my1()</span><br><span class=\"line\">x.print_my2()</span><br><span class=\"line\">x.print_my3()</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#error</span></span><br><span class=\"line\">类方法foo</span><br><span class=\"line\">静态方法</span><br><span class=\"line\">实例方法&lt;<span class=\"class\"><span class=\"keyword\">class</span> '<span class=\"title\">__main__</span>.<span class=\"title\">foo</span>'&gt;</span></span><br><span class=\"line\"><span class=\"class\">类方法<span class=\"title\">foo</span></span></span><br><span class=\"line\"><span class=\"class\">静态方法</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n","categories":["Python"],"tags":["Python"]},{"title":"Python入门11-面向对象编程","url":"https://applefishsky009.github.io/2017/01/10/Python入门11-面向对象编程/","content":"<h2 id=\"类简介\"><a href=\"#类简介\" class=\"headerlink\" title=\"类简介\"></a>类简介</h2><h3 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h3><ol>\n<li>类是对象的定义(蓝图)，而实例是真正的实物。<ul>\n<li>类的定义：<code>class A(object):</code>，类就像一个Python类型容器；</li>\n<li>通过继承来创建子类，子类继承基类的属性和方法，每个子类最好定义它自己的构造器，不然基类的构造器就会被调用(<code>__init__()</code>没有被覆盖)。</li>\n<li>标准惯例：类名通常大写大头。</li>\n<li>尽管类是对象，但正被定义时他还不是对象的实现(实例化才是)。</li>\n</ul>\n</li>\n<li>所有的新式类必须继承至少一个类，<code>object</code>是所有类之母，如果一个类没有继承任何其他类，<code>object</code>将作为默认的父类，他位于所有类结构的最上层。一定在类名称后边加上<code>(object)</code>！<ul>\n<li><code>__doc__</code>属性是类的文档字符串，他必须紧跟头行，并且不能被派生类继承，默认情况下派生类的这个属性为<code>None</code>。</li>\n</ul>\n</li>\n<li>创建一个实例的过程称为实例化，通过函数操作符，以<strong>函数调用</strong>的形式出现。<ul>\n<li>实例化认为是对<code>__init__()</code>的一种隐式的调用；</li>\n<li>函数有下划线表示一般情况下这个函数不是直接供调用的。</li>\n</ul>\n</li>\n<li>最简单的类可以仅作为容器来共享容器空间。</li>\n<li>实例的属性是动态的，不需要在任何地方预先声明或者赋值。<ul>\n<li>通过句点标识符访问类的属性。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><p>通常的实例方法调用：定义类；创建实例；通过实例调用方法。</p>\n<ol>\n<li>实例方法传<code>self</code>(约定俗成，相当于<code>this指针)，类方法传</code>cls`(约定俗成)，静态方法不需要强制传任何参数。</li>\n<li>类方法和类属性不能重名。</li>\n</ol>\n<p><a href=\"http://rylcode.cn/2017/01/11/Python%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%8C%E7%B1%BB%E6%96%B9%E6%B3%95%EF%BC%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/\" target=\"_blank\" rel=\"noopener\">Python的实例方法，类方法，静态方法</a></p>\n<hr>\n<h2 id=\"面对对象\"><a href=\"#面对对象\" class=\"headerlink\" title=\"面对对象\"></a>面对对象</h2><p><a href=\"http://rylcode.cn/2016/05/21/%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E4%B8%8E%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0/\" target=\"_blank\" rel=\"noopener\">OOP特性</a></p>\n<ol>\n<li>抽象：对现实世界和实体的本质表现、行为和特征建模。<ul>\n<li>对模型接口以及抽象数据的现实化(<code>realization</code>)</li>\n</ul>\n</li>\n<li>封装/接口：对数据/信息进行隐藏，对数据属性提供接口和访问函数。<ul>\n<li>限制不规范的操作对数据属性的访问。</li>\n</ul>\n</li>\n<li>合成：扩充了对类的描述，使得多个不同类合成为一个大的类，来解决现实问题。</li>\n<li>派生/继承/继承结构：子类保存父类中所有需要的数据和类型，但允许修改或定义其他的自定义操作，但不会修改父类的定义。</li>\n<li>泛化/特化：子类与其父类以及祖先类有一样的特点，即<code>is-a</code>关系。</li>\n<li>多态：对象通过共同的属性或动作来操作访问，不需要考虑具体的类。即动态(运行时)绑定，允许重载以及运行时类型确定和验证。</li>\n<li>自省/反射：对象在运行时取得自身信息。即Java中的反射，C++中的运行阶段类型推断RTTI。<ul>\n<li><code>type()</code>判断类型。</li>\n<li><code>dir()</code>返回对象的属性列表。</li>\n<li><code>var(obj)</code>返回实例属性构成的字典，即<code>__dict__</code>特殊属性。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"类属性，实例，实例属性\"><a href=\"#类属性，实例，实例属性\" class=\"headerlink\" title=\"类属性，实例，实例属性\"></a>类属性，实例，实例属性</h2><h3 id=\"类属性\"><a href=\"#类属性\" class=\"headerlink\" title=\"类属性\"></a>类属性</h3><ol>\n<li>属性就是属于一个对象的数据或者函数元素，属性同时也是一个对象，他拥有自己的属性，因此会有属性链这一现象。</li>\n<li>主要使用的属性是实例属性，当且仅当需要更加静态的数据时才会使用类数据属性，即静态变量，静态数据。</li>\n<li>通常的方法必须绑定(<code>binding</code>)才能被直接调用，非绑定方法可以被调用，但实例对象一定要明确给出，才能确保调用成功(派生类构造函数通过基类调用基类的构造函数)。</li>\n<li>使用<code>dir()</code>和特殊类属性<code>__dict__</code>来查看类的属性。<ul>\n<li><code>dir()</code>内建函数可接受模块，类，实例对象。如果不传入参数，和<code>locals()</code>一样。</li>\n</ul>\n</li>\n<li><code>type()</code>被调用对象的类型，他的类型是<code>type</code>，被调用对象的类型<code>type().__name__</code>来访问。</li>\n<li><code>__doc__</code>特殊属性，不能被派生类继承。</li>\n<li><code>__bases__</code>用来处理继承，包含由所有父类组成的元组。</li>\n<li><code>__module__</code>返回类所有模块的字符串表示。</li>\n</ol>\n<h3 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h3><ol>\n<li>类是一种数据结构定义类型，实例则声明了一个这种类型的变量。当你定义了一个类后，已经创建了一个新的类型。</li>\n<li>定义或覆盖<code>__init__()</code>方法。缺省时不进行任何操作，注意对于不可变类型的类属性，同名的实例属性会覆盖他，但对于可变类型的类属性，二者是同一个对象，这样类、所有实例都可以修改这个属性。</li>\n<li><code>__new__()</code>方法来继承不可变数据类型(<code>int</code>,<code>str</code>,<code>tuple</code>等)来定制数据类型；或者用在元类，定制创建类对象。<ul>\n<li><code>__new__()</code>方法是一个静态方法，他在<code>__init__(self)</code>执行之前执行并返回一个对象传入初始化方法<code>__init__(self)</code>(即这里的<code>self</code>)</li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/21379984\" target=\"_blank\" rel=\"noopener\">python 类中<strong>new</strong> 和 <strong>init</strong>方法区别</a></li>\n<li><a href=\"http://blog.jobbole.com/21351/\" target=\"_blank\" rel=\"noopener\">深刻理解Python中的元类(metaclass)</a></li>\n<li><a href=\"http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python\" target=\"_blank\" rel=\"noopener\">What is a metaclass in Python?</a></li>\n</ul>\n</li>\n<li><code>__del__()</code>解构器方法，由于Python的垃圾回收机制是靠引用计数的，这个函数要直到该实例对象所有的引用计数都被清除掉后才会执行。<ul>\n<li>也就是说这个函数只会被调用一次(引用计数为0的时候)；</li>\n<li>在子类<code>__del__()</code>中不要忘记调用父类的<code>__del__()</code>;</li>\n<li><code>del x</code>表示引用计数减1，不表示结构器方法被调用。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"实例属性\"><a href=\"#实例属性\" class=\"headerlink\" title=\"实例属性\"></a>实例属性</h3><ol>\n<li>实例属性是与实例相关联的数据值，构造器<code>__init__()</code>是设置这些属性的关键点。</li>\n<li>可以使用默认参数来设置默认的实例属性(注意默认参数应该是不变的对象)。</li>\n<li><code>__init__()</code>应该返回<code>None</code>，因为实例对象是在实例化调用后返回的，如果返回其他值会产生冲突。</li>\n<li><code>dir()</code>内建函数和<code>__dict__</code>属性可以查看所有的属性。<ul>\n<li>不要修改<code>__dict__</code>字典，使用句点标识符来修改属性；</li>\n<li>内建类型也是类，他可以<code>dir()</code>，但不存在<code>__dict__</code>属性(因为这个属性只有通过类工厂<code>type()</code>产生的类才有)。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"NOTE\"><a href=\"#NOTE\" class=\"headerlink\" title=\"NOTE\"></a>NOTE</h3><ol>\n<li>类属性可通过类或实例来访问，但是任何对实例属性的赋值都会创建一个实例属性(如果不存在)并且对其赋值(这里指不可变对象，因为不可变对象在赋值时会创建一个新的对象)。</li>\n<li>但是在类属性是可变类型的情况下会不同，可变对象在赋值过程中并没有必要产生新的对象，这样会造成实例和类的数据污染。</li>\n<li>类属性是静态成员，当一个实例被修改后才创建，那么更新的值就将生效，类属性的修改会影响到所有的实例。</li>\n</ol>\n<hr>\n<h2 id=\"绑定，组合\"><a href=\"#绑定，组合\" class=\"headerlink\" title=\"绑定，组合\"></a>绑定，组合</h2><h3 id=\"绑定\"><a href=\"#绑定\" class=\"headerlink\" title=\"绑定\"></a>绑定</h3><ol>\n<li>实例方法是绑定在实例上的，只有通过实例才能调用这种绑定方法。没有实例时方法就是未绑定的。<code>self</code>变量用于在实例中引用方法所绑定的实例。</li>\n<li>没有实例调用非绑定方法，例如在子类中覆盖父类的构造方法，这时没有父类实例，需要将子类中的<code>self</code>传入父类的构造方法，因为这时子类对象没有进行任何定制，可用来代替父类对象，构造后再进行定制。</li>\n</ol>\n<h3 id=\"组合\"><a href=\"#组合\" class=\"headerlink\" title=\"组合\"></a>组合</h3><ol>\n<li>通过组合(<code>composition</code>)让不同的类混合并加入到其他类中，来增加功能和可重用性。这是<code>has-a</code>关系(这在C++中通过包含或者私有/保护继承来体现)，因为这些类都不相同，每一个类管理他们自己的名字空间和行为。</li>\n<li>另一种方法通过派生(<code>derived</code>)，它们具有更接近的关系，强调<code>is-a</code>关系，用于当你需要一些相似的对象，但却有少许不同不同功能的时候。</li>\n</ol>\n<hr>\n","categories":["Python"],"tags":["Python"]},{"title":"Python入门10-模块","url":"https://applefishsky009.github.io/2017/01/09/Python入门10-模块/","content":"<h2 id=\"模块基础\"><a href=\"#模块基础\" class=\"headerlink\" title=\"模块基础\"></a>模块基础</h2><ol>\n<li>自我包含并且有组织的代码片段就是模块。把其他模块中属性附件到你的模块中的操作叫做导入。</li>\n<li>模块按照逻辑来组织Python代码方法，文件是物理层组织模块的方法。<ul>\n<li>一个文件被看作一个独立模块，一个模块也被看作是一个文件。</li>\n<li>模块的文件名就是模块的名字加上扩展名.py。</li>\n</ul>\n</li>\n<li>一个名称空间就是一个从名称到对象的关系集合映射。所以每个模块都定义了自己的唯一的名称空间。<ul>\n<li>即使属性之间有名称冲突，但他们的完整授权名称——据点属性标识指定了各自的名称空间(防止名称冲突)。</li>\n</ul>\n</li>\n<li>默认搜索路径是在编译时或者安装时指定的。他可以在一个或者两个地方修改。路径模块<code>import sys</code>。<ul>\n<li><code>sys.path</code>包含每个独立路径的列表，那么显然<code>sys.path.append()</code>可以添加搜索的路径，<code>sys.path.insert(pos, val)</code>可以指定插入位置。</li>\n<li><code>sys.modules</code>可以找到当前导入了哪些模块以及他们来自哪里，返回值是一个字典，模块名是<code>key</code>，对应物理地址是<code>val</code>。</li>\n</ul>\n</li>\n<li>名称空间是名称到对象的映射，改变一个名字叫做重新绑定，删除一个名字叫做解除绑定。<ul>\n<li>局部名称空间，全局名称空间，内建名称空间(<code>__buildins__</code>模块中的名字)，从前往后搜索名称，从后往前加载。</li>\n<li><code>globals()</code>和<code>locals()</code>内建函数得到全局/当前符号表字典。可以用于判断某一名字属于哪个名称空间。</li>\n</ul>\n</li>\n<li><code>__name__</code>系统变量可以在运行时检测该模块是被导入还是被直接执行。<ul>\n<li>如果模块是被导入，<code>__name__</code>的值为模块名字。</li>\n<li>如果模块是被直接执行，<code>__name__</code>的值是<code>__main__</code>。</li>\n<li>利用这个特性在主程序中书写测试代码。</li>\n</ul>\n</li>\n<li>明白名称查询的规则，就很容易理解遮蔽效应。名称查询首先从局部名称空间开始，然后查找全局名称空间，然后在内建名称空间里查找。</li>\n<li>可以在任何需要防止数据的地方获得一个名称空间，比如可以在任何时候给函数添加属性。 </li>\n</ol>\n<hr>\n<h2 id=\"模块导入\"><a href=\"#模块导入\" class=\"headerlink\" title=\"模块导入\"></a>模块导入</h2><ol>\n<li>建议按顺序导入模块，Python标准库模块-&gt;Python第三方模块库-&gt;应用程序自定义模块。</li>\n<li>可以在模块中导入指定属性。即吧指定名称导入当前作用域。</li>\n<li>多行导入，使用逗号分隔属性，使用<code>\\</code>来自动换行，建议使用Python标准分组机制(圆括号)来创建更合理的多行导入语句。</li>\n<li>在<code>import</code>语句之后使用<code>as</code>在导入的同时指定局部绑定名称。</li>\n<li>一个模块只能被加载一次，加载只在第一次导入时发生。<ul>\n<li>限制使用<code>from module import *</code>，因为会污染名称空间。</li>\n<li>在交互解释器或者目标模块属性非常多时可以全部导入。</li>\n</ul>\n</li>\n<li>属性名称可能冲突时，建议使用<code>import</code>和完整的标识符名称(句点属性标识)。</li>\n<li><code>__future__</code>导入新的特性。</li>\n<li>警告框架，警告用户不要使用一个即将改变或不支持的操作，包含几个部分：<ul>\n<li>API：调用API发布警告，使用warnings模块。</li>\n<li>一些警告异常类的集合：Warning，UserWarning，DeprecationWarning,SyntaxWarning和RunningWarning等。</li>\n<li>警告过滤器：不仅仅收集关于警告的信息(如信号，警告原因等)，控制是否忽略警告，是否显示警告(可以自定义格式)，或者转化为错误生成一个异常等。</li>\n</ul>\n</li>\n<li>从zip文件中导入模块。</li>\n<li>编写可调用的<code>import</code>类来重新实现整个导入机制，需要实现查找器和载入器。<ul>\n<li><code>import</code>语句调用<code>__import()__</code>函数完成工作，提供这个函数是为了让有特殊需求的用户覆盖他，实现自定义的导入算法。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"包和其他特性\"><a href=\"#包和其他特性\" class=\"headerlink\" title=\"包和其他特性\"></a>包和其他特性</h2><h3 id=\"包\"><a href=\"#包\" class=\"headerlink\" title=\"包\"></a>包</h3><ol>\n<li>包是一个有层次的文件目录结构，他定义了一个由模块和子包组成的Python应用程序执行环境。</li>\n<li>可以通过<code>最顶层的包.子包.模块</code>来导入；也可以通过<code>from 最顶层的包 import 子包</code>然后使用 属性/点 操作符向下引用子包树；也可以<code>from 最顶层的包.子包 import 模块</code>来导入模块；甚至可以沿着子包的树状结构导入子包中模块的名称空间<code>from 最顶层的包.子包.子包中模块 import something</code>。</li>\n<li>绝对导入是指导入的包通过Python路径(<code>sys.path</code>或者<code>PYTHONPATH</code>)，<code>.</code>表示导入同目录下的模块，<code>..</code>表示导入不同目录下的模块(他们都包含在同一个最顶层的包中)。<ul>\n<li><a href=\"http://python3-cookbook.readthedocs.io/zh_CN/latest/c10/p03_import_submodules_by_relative_names.html\" target=\"_blank\" rel=\"noopener\">使用相对路径名导入包中子模块</a></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"其他特性\"><a href=\"#其他特性\" class=\"headerlink\" title=\"其他特性\"></a>其他特性</h3><ol>\n<li>自动载入的模块：内建模块，在Python2.x中命名是<code>__builtin__</code>，在Python3.x中命名是<code>builtins</code>。而不论是2还是3中，<code>__builtins__</code>都是对内建模块的引用。不同的是，在主模块<code>__main()__</code>中，其是对内建模块本身的引用；而在非<code>__main()__</code>中，其仅仅是对<code>__buildin__/builtins.__dict__</code>的引用，他的类型是字典。<ul>\n<li><a href=\"http://www.52ij.com/jishu/665.html\" target=\"_blank\" rel=\"noopener\">Python中的内建模块</a></li>\n</ul>\n</li>\n<li>阻止属性导入：如果不想让某个模块被<code>from module import *</code>导入，可以在模块中给不想导入的属性名称加下划线(<code>_</code>，例如<code>bar</code>-&gt;<code>_bar</code>)，但是加上下划线之后怎么导入模块？可以导入整个模块(<code>import foo</code>)或者显式导入这个属性(<code>import foo._bar</code>)。</li>\n<li>不区分大小写的导入，必须指定一个<code>PYTHONCASEOK</code>的变量。</li>\n<li>源代码编译，<a href=\"http://www.crifan.com/python_head_meaning_for_usr_bin_python_coding_utf-8/\" target=\"_blank\" rel=\"noopener\">关于Python脚本开头两行的：#!/usr/bin/python和# -<em>- coding: utf-8 -</em>-的作用 – 指定文件编码类型</a></li>\n<li>导入循环，循环引用的问题。删除导入语句；或者将导入语句移到最后；或者将导入语句放在函数内部，只在调用函数的时候导入这个模块。</li>\n<li>模块执行：通过命令行，shell，execfile()，模块导入，解释器的<code>-m</code>选项等。</li>\n</ol>\n<hr>\n","categories":["Python"],"tags":["Python"]},{"title":"Python入门9-函数和函数式编程","url":"https://applefishsky009.github.io/2017/01/06/Python入门9-函数和函数式编程/","content":"<h2 id=\"函数基础\"><a href=\"#函数基础\" class=\"headerlink\" title=\"函数基础\"></a>函数基础</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ol>\n<li>python的过程就是函数，因此解释器会隐式返回默认值<code>None</code>。即如果保存一个没有返回值的函数的返回值，该值就为<code>None</code>。</li>\n<li>Python里的函数可以返回一个值或者对象。由于元组语法上不一定需要圆括号，会让人以为可以返回多个对象，实际上是一个元组。<ul>\n<li>元组的保存方式也有三种，整个元组变量，单一变量，带圆括号的单一变量。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"调用\"><a href=\"#调用\" class=\"headerlink\" title=\"调用\"></a>调用</h3><ol>\n<li>函数操作符<code>()</code>相当于类的实例化。</li>\n<li>允许参数缺失或者不按顺序，解释器能通过给出的关键字来匹配参数的值。关键字参数结合默认参数可以跳过缺失参数。</li>\n<li>默认参数，给参数赋予默认值，和C++中一样。</li>\n<li>使用<code>*</code>和<code>**</code>指定元组和字典作为非关键字参数和关键字参数组。完整语法为(所有参数都是可选的)：<br> <code>func(positional_args,keyword_args,*tuple_grp_nonkw_args,**dict_grp_kw_args)</code></li>\n</ol>\n<h3 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h3><ol>\n<li><code>def</code>关键字，函数的名字，参数集合。建议添加文档字串和函数体。</li>\n<li>定义和声明有区别的语言，往往是因为函数的定义可能和其声明放在不同的文件中。Python将二者视为一体，函数由声明的标题和随后的定义体组成。</li>\n<li>在a函数定义中的b函数调用不会出现前向引用问题，除非在a函数调用的时候b函数依然没有被定义。</li>\n<li>句点属性标识，意味着不同的命名空间。函数声明中不能访问属性，因为此时函数体还没有被创建。定义后通过<font color=\"red\">函数名</font>(而不是实例名)和句点属性标识来访问修改属性值。</li>\n<li>内部/内嵌函数：整个函数体在外部函数的作用域，或者lambda表达式。<ul>\n<li>如果内部函数定义包含了外部函数内定义的对象的引用，内部函数会成为<strong>闭包</strong>(传递了作用域)。</li>\n</ul>\n</li>\n<li>装饰器：以<code>@</code>开头，需要返回<font color=\"red\">函数对象</font>，实际上是把要装饰的函数参数传递给装饰器。其返回的函数对象是一个包装了的函数。并将其重新赋值为原来的标识符，并永久失去对原始函数对象的访问。<ul>\n<li><a href=\"http://coolshell.cn/articles/11265.html\" target=\"_blank\" rel=\"noopener\">PYTHON修饰器的函数式编程</a></li>\n<li>下边是类式的装饰器。</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">myDecorator</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, fn)</span>:</span>\t\t<span class=\"comment\">#装饰时调用</span></span><br><span class=\"line\">        print(<span class=\"string\">\"inside myDecorator.__init__()\"</span>)</span><br><span class=\"line\">        self.fn = fn</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__call__</span><span class=\"params\">(self)</span>:</span>\t\t<span class=\"comment\">#调用时调用</span></span><br><span class=\"line\">        self.fn()</span><br><span class=\"line\">        print(<span class=\"string\">\"inside myDecorator.__call__()\"</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">@myDecorator</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">aFunction</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"inside aFunction()\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">\"Finished decorating aFunction()\"</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\">aFunction()</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inside myDecorator.__init__()</span><br><span class=\"line\">Finished decorating aFunction()</span><br><span class=\"line\">inside aFunction()</span><br><span class=\"line\">inside myDecorator.__call__()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"函数传递\"><a href=\"#函数传递\" class=\"headerlink\" title=\"函数传递\"></a>函数传递</h3><ol>\n<li>所有对象都是通过引用传递的，函数也不例外。因此可以将函数作为参数传入其他函数来调用。函数内部通过函数操作符<code>()</code>来调用函数。</li>\n</ol>\n<h3 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h3><ol>\n<li>按照被调用函数中定义的顺序来准确传递参数(就像C++一样)</li>\n<li>默认参数：和C++一样，在函数声明中使用赋值运算符。<ul>\n<li>所有的必需的参数都必须在默认参数之前。否则编译器无法确定匹配方式。</li>\n<li>使用关键字参数可以不按顺序提供参数，也可以用于跳过缺失参数。 </li>\n<li>默认参数<font color=\"red\">一定要是不可变对象</font>，否则不同的实例会操作同一个对象，实例之间会有数据污染。参考<a href=\"http://cenalulu.github.io/python/default-mutable-arguments/\" target=\"_blank\" rel=\"noopener\">Python函数参数默认值的陷阱和原理深究</a>。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"可变长度参数\"><a href=\"#可变长度参数\" class=\"headerlink\" title=\"可变长度参数\"></a>可变长度参数</h3><ol>\n<li>函数调用时，形参将值赋给函数声明中相对应的局部变量。剩下的非关键字参数按顺序插入到一个元组中便于访问，关键字参数按顺序插入到一个字典中便于访问。</li>\n<li>使用星号操作符<code>*</code>和双星号操作符<code>**</code>之后标识的形参将参数传递给函数。<ul>\n<li><code>**</code>是被重载的，因为他也可以表达幂运算。</li>\n<li>函数声明中所有的形参必须位于非正式的参数之前。</li>\n<li>关键字字典必须是最后一个参数且非关键字参数在他之前。</li>\n</ul>\n</li>\n<li>如果在函数调用之外创建传入的字典和元祖，函数内部最终接受的元组和字典是被调函数的超集。</li>\n</ol>\n<hr>\n<h2 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h2><h3 id=\"lambda\"><a href=\"#lambda\" class=\"headerlink\" title=\"lambda\"></a>lambda</h3><ol>\n<li>这种语句的目的是由于性能的原因，在调用时绕过函数的栈分配。</li>\n<li>默认参数和可变参数是允许的。</li>\n</ol>\n<h3 id=\"内建函数\"><a href=\"#内建函数\" class=\"headerlink\" title=\"内建函数\"></a>内建函数</h3><ol>\n<li><code>filter(function, iterable)</code>-&gt;<code>function</code>重构为<code>labmda</code>-&gt;<code>filter</code>重构为列表解析式(<code>filter</code>相当于列表解析中的<code>if</code>)-&gt;重构为嵌套的列表解析。</li>\n<li><code>map(function, iterable, ...)</code>映射函数-&gt;<code>function</code>重构为<code>labmda</code>-&gt;(在处理单个序列时)重构为列表解析(<code>for...in...</code>迭代循环)。<ul>\n<li><code>...</code>表示多个序列传入<code>function</code>。</li>\n<li><code>map</code>函数在<code>function</code>为<code>None</code>时可以将不相关的序列归并在一起，相当于<code>zip</code>。</li>\n<li><code>map</code>独特的优势在于处理多个序列的映射。</li>\n</ul>\n</li>\n<li><code>functools.reduce(function, iterable,initializer)</code>将列表元素减少为单一的值，如果给定初始化器，那么一开始的迭代会用初始化器和一个序列的元素进行，接着会正常进行。<ul>\n<li><a href=\"https://docs.python.org/3/library/functools.html\" target=\"_blank\" rel=\"noopener\">functools.reduce(function, iterable[, initializer]</a>可以看到代码逻辑。</li>\n<li><code>reduce((labmda:x,y:x+y),range(5))</code> = <code>((((0 + 1) + 2) + 3) + 4)</code></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"偏函数\"><a href=\"#偏函数\" class=\"headerlink\" title=\"偏函数\"></a>偏函数</h3><p>PFA:<a href=\"https://docs.python.org/3/library/functools.html\" target=\"_blank\" rel=\"noopener\">Partial Function Apply</a></p>\n<ol>\n<li><code>functools.partial(func, *args, **keywords)</code>创建PFA。</li>\n<li>参数顺序传入<code>func</code>，可以使用关键字参数且其总是出现在形参之后。</li>\n</ol>\n<hr>\n<h2 id=\"变量作用域\"><a href=\"#变量作用域\" class=\"headerlink\" title=\"变量作用域\"></a>变量作用域</h2><h3 id=\"全局变量和局部变量\"><a href=\"#全局变量和局部变量\" class=\"headerlink\" title=\"全局变量和局部变量\"></a>全局变量和局部变量</h3><ol>\n<li>全局变量的一个特征是除非被删除掉，否则他们会存活到脚本运行结束。</li>\n<li>Python会先从局部作用域开始搜索，如果在局部作用域内没有找到，那么会在全局作用域或者内建作用域中找到这个变量，否则就会抛出<code>NameError</code>异常(LGB原则)。</li>\n<li>由2的规则可知，通过创建一个局部变量来隐藏全局变量是有可能的。</li>\n<li><code>if</code>,<code>try</code>,<code>for</code>不会产生新的作用域，<code>def</code>,<code>class</code>,<code>lambda</code>等才会产生。</li>\n</ol>\n<h3 id=\"global语句\"><a href=\"#global语句\" class=\"headerlink\" title=\"global语句\"></a>global语句</h3><ol>\n<li>在局部作用域中通过<code>global</code>语句来明确引用一个已命名的全局变量。</li>\n<li>如果不明确引用，只要不定义同名变量局部编译器依然会搜索到全局变量。</li>\n</ol>\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><ol>\n<li>如果在一个函数内，对外部作用域(但不是全局作用域)的变量进行引用，那么内部函数就被认为是闭包。这是函数式编程中一个很重要的概念。</li>\n<li>闭包仅仅是带了额外特征的函数—另外的作用域。</li>\n</ol>\n<h3 id=\"lambda-1\"><a href=\"#lambda-1\" class=\"headerlink\" title=\"lambda\"></a>lambda</h3><ol>\n<li><code>lambda</code>表达式定义了新的作用域。</li>\n</ol>\n<h3 id=\"变量作用域和名称空间\"><a href=\"#变量作用域和名称空间\" class=\"headerlink\" title=\"变量作用域和名称空间\"></a>变量作用域和名称空间</h3><ol>\n<li>从函数内部，局部作用域包围了局部名称空间，第一个搜寻名字的地方。如果名字存在的话，那么将跳过检查全局作用域。</li>\n</ol>\n<hr>\n<h2 id=\"递归与生成器\"><a href=\"#递归与生成器\" class=\"headerlink\" title=\"递归与生成器\"></a>递归与生成器</h2><h3 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h3><ol>\n<li>函数内部包含对函数自身的调用，和C++一样。</li>\n</ol>\n<h3 id=\"生成器\"><a href=\"#生成器\" class=\"headerlink\" title=\"生成器\"></a>生成器</h3><h4 id=\"生成器的动机\"><a href=\"#生成器的动机\" class=\"headerlink\" title=\"生成器的动机\"></a>生成器的动机</h4><ol>\n<li>函数可以在迭代中以某种方式生成下一个值并且返回和<code>next()</code>调用一样。</li>\n<li>协同程序：函数可以暂停或者挂起，并从程序离开的地方继续或者开始。</li>\n<li>挂起返回出中间值并多次继续的协同程序被成为生成器。</li>\n</ol>\n<h4 id=\"生成器的定义\"><a href=\"#生成器的定义\" class=\"headerlink\" title=\"生成器的定义\"></a>生成器的定义</h4><ol>\n<li>函数中使用<code>yield</code>关键字，当到达一个真正的返回或者函数结束没有更多的值返回，会抛出一个<code>StopIteration</code>异常。</li>\n<li>获得和保存一个生成器对象之后，使用<code>next(obj)</code>或者<code>obj.__next__()</code>来生成下一个值。</li>\n<li>生成器不停的挂起或者继续，其状态是保留的，那么当在生成的过程中如何动态调整生成的值？这就需要介绍<code>send()</code>函数。<ul>\n<li><code>yield val</code>这个表达式是有返回值的，<code>next(obj)</code>其实相当于<code>send(None)</code>，默认情况下返回的是<code>None</code>，可以通过<code>send(val)</code>将值传入生成器。用参数接收表达式的值。</li>\n<li><code>send(val)</code>让生成器继续，将表达式的值赋给变量(必须要有接受输入的参数)，然后调用<code>next(obj)</code>。</li>\n</ul>\n</li>\n</ol>\n<p>输入：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">counter</span><span class=\"params\">(start_at = <span class=\"number\">0</span>)</span>:</span></span><br><span class=\"line\">\tcount = start_at</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">\t\tval = (<span class=\"keyword\">yield</span> count)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> val <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">\t\t\tcount = val</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t\t\tcount += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">cnt = counter(<span class=\"number\">5</span>)</span><br><span class=\"line\">next(cnt)</span><br><span class=\"line\">next(cnt)</span><br><span class=\"line\">cnt.send(<span class=\"number\">9</span>)</span><br><span class=\"line\">next(cnt)</span><br><span class=\"line\">cnt.close()</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n","categories":["Python"],"tags":["Python"]},{"title":"Python入门8-错误和异常","url":"https://applefishsky009.github.io/2017/01/04/Python入门8-错误和异常/","content":"<p>错误是语法和逻辑上的，当Python检测到一个错误时，解释器就会指出当前流已经无法继续执行下去了，这时候就出现了异常。</p>\n<hr>\n<h2 id=\"Python中的异常\"><a href=\"#Python中的异常\" class=\"headerlink\" title=\"Python中的异常\"></a>Python中的异常</h2><p><a href=\"https://docs.python.org/3/library/exceptions.html\" target=\"_blank\" rel=\"noopener\">Exception hierarchy</a>，所有的标准/内建异常都是从根异常派生的。目前的Python3有4个直接从BaseException派生的异常子类：</p>\n<ol>\n<li>SystemExit</li>\n<li>KeyboardInterrupt</li>\n<li>GeneratorExit</li>\n<li>Exception</li>\n</ol>\n<p>其他所有的内建异常都是Exception的子类。</p>\n<hr>\n<h2 id=\"检测和处理异常\"><a href=\"#检测和处理异常\" class=\"headerlink\" title=\"检测和处理异常\"></a>检测和处理异常</h2><h3 id=\"try…except…\"><a href=\"#try…except…\" class=\"headerlink\" title=\"try…except…\"></a>try…except…</h3><ol>\n<li>使用<font color=\"red\"><code>as</code></font>关键字将错误捕获为异常参数。</li>\n<li>为用户可能遇到的返回错误写文档。比如显式的返回None或者负数(如果可以表征无效值)，来规范代码。</li>\n<li>带有多个<code>except</code>的<code>try</code>语句，匹配不同的异常来执行对应的动作。</li>\n<li>处理多个异常的<code>except</code>语句，可以在一个<code>except</code>语句中处理多个异常，但使用<code>as</code>捕获异常参数时，被赋值的是所触发的特定异常。</li>\n<li>不指定任何异常，可以捕获所有异常。</li>\n<li>不要捕获并忽略(<code>pass</code>)所有错误，可以捕获并忽略特定错误。</li>\n<li>异常参数是导致异常的代码的诊断信息的类实例。</li>\n</ol>\n<h3 id=\"try…finally…\"><a href=\"#try…finally…\" class=\"headerlink\" title=\"try…finally…\"></a>try…finally…</h3><ol>\n<li>这个语句不用来捕捉异常，无论<code>try</code>是否有异常被触发，<code>finally</code>代码段都会被执行。</li>\n<li>当<code>try</code>范围中产生一个异常时，会立即跳转到<code>finally</code>语句段。当<code>finally</code>中的所有代码都执行完毕后，会继续向上一层引发异常。</li>\n<li>如果<code>finally</code>中的代码引发了另一个由于<code>return</code>,<code>break</code>,<code>continue</code>语法而终止，原来的异常将丢失且无法重新引发。</li>\n</ol>\n<h3 id=\"try…except…finally…\"><a href=\"#try…except…finally…\" class=\"headerlink\" title=\"try…except…finally…\"></a>try…except…finally…</h3><ol>\n<li>无论异常是否发生，是否捕捉都会执行的一段代码。</li>\n</ol>\n<h3 id=\"try…except…else…\"><a href=\"#try…except…else…\" class=\"headerlink\" title=\"try…except…else…\"></a>try…except…else…</h3><ol>\n<li>在<code>try</code>范围内没有异常被检测到时，执行<code>else</code>子句。</li>\n</ol>\n<h3 id=\"try…except…else…finally…\"><a href=\"#try…except…else…finally…\" class=\"headerlink\" title=\"try…except…else…finally…\"></a>try…except…else…finally…</h3><ol>\n<li>无论选择什么语法，至少需要一个<code>except</code>，<code>else</code>和<code>finally</code>都是可选的。</li>\n</ol>\n<p>所有的异常处理语法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">\tdoSomething</span><br><span class=\"line\"><span class=\"keyword\">except</span> Exception1:</span><br><span class=\"line\">\tdoSomethingForE1</span><br><span class=\"line\"><span class=\"keyword\">except</span> (Exception2,Exception3,Exception4):</span><br><span class=\"line\">\tdoSomethingForE2||E3||E4</span><br><span class=\"line\"><span class=\"keyword\">except</span> Exception5 <span class=\"keyword\">as</span> e5:</span><br><span class=\"line\">\tdoSomethingForE5</span><br><span class=\"line\"><span class=\"keyword\">except</span> (Exception6,Exception7,Exception8) <span class=\"keyword\">as</span> e6||e7||e8</span><br><span class=\"line\">\tdoSomethingForE6||E7||E8</span><br><span class=\"line\">\tnote that e6||e7||e8 <span class=\"keyword\">is</span> only the one Exception that cause error.</span><br><span class=\"line\"><span class=\"keyword\">except</span>:</span><br><span class=\"line\">\tcatch all the other exceptions</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"上下文管理\"><a href=\"#上下文管理\" class=\"headerlink\" title=\"上下文管理\"></a>上下文管理</h2><p><code>with</code>语句的目的在于从流程图中把<code>try</code>,<code>except</code>,<code>finally</code>关键字和资源分配释放相关代码统统去掉。<br>支持上下文管理协议的成员：</p>\n<ol>\n<li>file</li>\n<li>decimal.Context</li>\n<li>thread.LockType</li>\n<li>threading.Lock</li>\n<li>threading.RLock</li>\n<li>threading.Condition</li>\n<li>threading.Semaphore</li>\n<li>threading.BoundedSemaphore</li>\n</ol>\n<p>file是最常见且最易于演示的(通常见到<code>with</code>用于打开文件)。</p>\n<hr>\n<h2 id=\"触发异常\"><a href=\"#触发异常\" class=\"headerlink\" title=\"触发异常\"></a>触发异常</h2><p>异常除了由解释器引发，还可以由程序员明确触发：<code>raise</code>语句。<br><code>raise SomeException args traceback</code></p>\n<ol>\n<li><code>SomeException</code>:触发异常的名字。</li>\n<li><code>args</code>:异常参数，可以是一个单独对象，或者是一个元组。</li>\n<li><code>traceback</code>:跟踪记录对象，用于重新引发异常。</li>\n</ol>\n<hr>\n<h2 id=\"断言\"><a href=\"#断言\" class=\"headerlink\" title=\"断言\"></a>断言</h2><p><code>assert</code>和C++中用法基本相同，只不过不需要括号需要空格分隔关键字和表达式。</p>\n<hr>\n<h2 id=\"sys模块和异常\"><a href=\"#sys模块和异常\" class=\"headerlink\" title=\"sys模块和异常\"></a>sys模块和异常</h2><p><code>sys</code>模块中的<code>exc._info()</code>函数返回一个三元组来提供关于异常更多的消息。</p>\n<ol>\n<li><code>exc_type</code>:异常类；</li>\n<li><code>exc_value</code>:异常类的实例；</li>\n<li><code>exc_traceback</code>:跟踪记录对象。</li>\n</ol>\n<hr>\n","categories":["Python"],"tags":["Python"]},{"title":"缺月挂疏桐，漏断人初静","url":"https://applefishsky009.github.io/2017/01/03/缺月挂疏桐，漏断人初静/","content":"<p>本来打算在元旦附近写年终总结，关于学习生活，思考回忆。可后来越回忆内容越多越发散，思维无法集中。只有勉强扩充好的一个章节和一些关键字。</p>\n<h2 id=\"关于思考\"><a href=\"#关于思考\" class=\"headerlink\" title=\"关于思考\"></a>关于思考</h2><p>这一节都与所谓情商有关，<a href=\"https://zh.wikipedia.org/wiki/%E6%83%85%E7%B7%92%E5%95%86%E6%95%B8#.E7.A4.BE.E6.9C.83.E6.8A.80.E5.B7.A7\" target=\"_blank\" rel=\"noopener\">WIKI - 情绪商数</a>有五个向度：</p>\n<ol>\n<li>自我察觉 认识自身的情绪</li>\n<li>自我规范 妥善管理情绪</li>\n<li>自我激励 激发个人潜力</li>\n<li>同理心 感同他人的情绪</li>\n<li>社会技巧 人际关系的管理</li>\n</ol>\n<h3 id=\"感情动物\"><a href=\"#感情动物\" class=\"headerlink\" title=\"感情动物\"></a>感情动物</h3><p>很久之前，在我开始思考的时候，就意识到这个世界上最难改变的就是一个人的思想，因为有太多的画地为牢，我们做好自己就好。</p>\n<p>MacTalk在年终总结中说，人的一生兜兜转转，要么是找到自己的阈值，要么去突破某种界限，要么走得远，要么原地打转，莫不如是。恰好最近在生活中遇到几个在感情上画地为牢的人，“我不能失去她所以怎么挽回？”，“为什么我这么‘厉害’，他们还是不愿意理我？”，很可怕的是不自知或者拒绝承认(“我不会这么差的，一定是别人的问题”)，我习惯称这种人为直男癌。</p>\n<p>《暗时间》&lt;逃出你的肖申克(3)&gt;-遇见20万年前的自己，节中提出一个非常有趣的说法。我们大脑中同时存在着远古的自我和现代的自我，远古自我代表原始的情绪系统和条件反射模块，在千万年的进化长河中忠实的保护着我们在自然环境生存下来并努力繁衍后代。这个天性使得我们在决策方面倾向于立即获得愉悦，而且不会导致立即的损失。现代的自我代表更先进生产力的高级认知模块。他偏好于能够积累知识和技的长远计划。而我们都只是生活在信息社会的远古人。一般来说决策的目光短浅是由于未来的惩罚和收益估计不足产生的。</p>\n<p>巧合的是，采铜在《精进-如何成为一个很厉害的人》&lt;对五年后的自己提问&gt;中也提到如何解决“远期未来和近期未来的冲突”，文中指出研究时间的心理学家按照五年的长度把未来分为“近期未来”和“远期未来”，两者视角的来回切换有助于我们决策。如果二者之间有冲突，可以采取的策略有，通过增强远期未来，抑制近期未来(增加近期未来“非期望行为的成本”)。<br>在&lt;我们总是在重复的抓沙子-把时间花在值得做的事情上&gt;根据收益和半衰期组合成四类事件：</p>\n<ol>\n<li>高收益值，长半衰期；</li>\n<li>高收益值，短半衰期；</li>\n<li>低收益值，短半衰期；</li>\n<li>低收益值，长半衰期；</li>\n</ol>\n<p>这是多么相似！前者更为理性而有说服力，后者充满人情味。</p>\n<p>简而言之，这一小节主要是关于自我察觉。</p>\n<h3 id=\"换位思考\"><a href=\"#换位思考\" class=\"headerlink\" title=\"换位思考\"></a>换位思考</h3><p>如果说一个人情商低智商高，虽然在长期可能会有收益(非自己可控因素，风险很大)，但在近期的相处过程中可能不仅不会获得立即的愉悦，反而会导致立即的损失(情感)，那么不管是别人有意识或是本能反应，他所处的环境就显而易见了。在这种情况下，他就会急于开拓新的圈子新的领域，陷入新的循环。</p>\n<p>12年底在我极度迷茫的时候，受到过来自师兄的指点。12年除夕在西区图书馆自习，恰好碰到当年社会实践带队，保研本校，当时就读研一，算起来刚好入学半年的师兄。他笑了笑说，别人看起来他无比光鲜，多厉害多厉害，但保研之后别人玩的时候，他读论文做实验，更加努力，可能他们都没有看到吧。虽然家就在当地城市，但在这个时间点还在图书馆看论文已经很能说明问题了。不过和他不同的是，我是三观尽碎挂科之后去还债的= =。师兄提及当年社会实践正值他的人生低谷，和我们一起度过一段时间也挺开心。当时收获颇多，然后傻傻的问了一句“你为什么(愿意)对我说这些？”，可见三观崩溃到什么程度了。师兄感到比较奇怪，回答：”你是我师弟啊，能帮则帮”，这句话我能记一辈子，永远的USTCer~。</p>\n<p>历史总是惊人的相似，在研究生二年级的时候碰到国君，非科班出身的计算机大牛。偶尔聊天说过一句别人都看他现在这么牛逼(正值找工作)，但其实一年多是死磕过来的。当时就想起来那年寒假的那个师兄~，虽然没多说，但真的能理解。</p>\n<p>换个角度来想，“别人为什么那么厉害”，还是站在自己的角度去看别人，这只有一个维度。如果这么想：“他收获这么多一定付出了不少”。这就有两个维度。是不是会好很多？</p>\n<p>要真诚，真挚诚恳。不要站在道德高地。往往越是满口仁爱的人越是面目可疑。站在别人的角度来看看，没有人是傻瓜。</p>\n<p>Note0：关于我的大学生活，虽然是学渣。但最大的收获是见到了一些人一些事，各种闪闪发光的地方。在不经意的时候总能想起。</p>\n<p>Note1：我个人不愿意称为牛人，语言中的大腿，大牛其实更多的是一种打趣。这个称呼在我看来是偏颇的，他只聚焦于一个人光鲜的一面而忽略了背后的付出。</p>\n<p>Note2：女生尤其是感情动物，在当下的情感愉悦和<strong>可能</strong>的长期收益之间往往会选择前者。如果懂得换位思考，相信总会有收获。比如说，“我不能失去她”(一元思维)为什么不是唤起美好的记忆调动曾经美好的情绪让她觉得“她也需要我”(另一元思维，二者结合并突出这一点是不是会杀伤力很大？)？比如一加一就说过他感觉女生总是“笨笨”的，喜欢钻牛角尖。如果让她直接做什么不做什么十有八九都会让自己无可奈何。但如果换个说法，表达这次就这样，但我们说好下次怎样怎样~并表达出这样的做法对她的好处(包括自己的担心blabla)，那就基本没问题了。我只能说他情商很高(他一直是我学习的对象)。这不仅仅照顾到长期收益，最重要的是照顾到女生的当下感情(立即获得的愉悦)。经常可以看到知乎不少人说男生和女生不同，男生注重结果，女生注重当下感受而不是解决方法，就是这个道理。</p>\n<p>Note3:</p>\n<blockquote>\n<p>People will forget what you did.<br>People will forget what you said.<br>But people will not forget what you made them feel.</p>\n</blockquote>\n<p>这一节是在与他人交往中最重要的一部分，同理心。</p>\n<h3 id=\"画地为牢\"><a href=\"#画地为牢\" class=\"headerlink\" title=\"画地为牢\"></a>画地为牢</h3><p>那我们如何保证自己目前不是在画地为牢或者未来不要画地为牢？</p>\n<p>要谦虚谨慎，本科时期有幸在邱本胜教授和李斌教授实验室短暂学习过，说的俗气一点就是见识到了“大牛的风采”。时隔已久，邱老师说过的话我依然记不清了，只记得他给我的feeling(做人就该这样子！)，并时时刻刻影响着我。李老师改毕业论文的时候咬文嚼字，精确到标点符号，但和他相处发现他是一个无比温和的人。他们闪光的品质对我产生深远的影响。那么如何保持谦虚谨慎？在我看来要明白<font color=\"red\">反馈</font>调节的重要性，负反馈这一概念的出现在电子领域甚至是革命性的。学习的过程从来都是需要不断输入(降低偏差bias)不断输出(降低方差var)来反馈调节的，而不是一蹴而就。没有绝对正确的东西，学无止境，在不断的反馈调节中才能无限接触真实。</p>\n<p>要往远看，《一代宗师》里有说，人要往远看，过了山，眼界就阔了。大昊神说站在身边的是伙伴，未知的才是敌人。过来人告诫我们，学习成长，干活拿钱，年轻人格局要大。有人说，真正的棱角是过人的才华，是坚定的志向，是对理想孜孜不倦的追求，是与生俱来的强大的意志力。这种棱角只会被社会越磨越锋利，最终成就一代大神。甚至大成若缺都是一个道理。</p>\n<p>简而言之，自我规范，自我激励。</p>\n<h3 id=\"交流的陷阱\"><a href=\"#交流的陷阱\" class=\"headerlink\" title=\"交流的陷阱\"></a>交流的陷阱</h3><p>讲故事，谈感受，少评论，就事论事。这里写的很好，就不献丑了。<a href=\"https://zhuanlan.zhihu.com/p/24656107\" target=\"_blank\" rel=\"noopener\">交流时，我们为什么总在人身攻击</a></p>\n<p>这是关于社会技巧。</p>\n<hr>\n<h2 id=\"2016关键字\"><a href=\"#2016关键字\" class=\"headerlink\" title=\"2016关键字\"></a>2016关键字</h2><h3 id=\"克己-克制\"><a href=\"#克己-克制\" class=\"headerlink\" title=\"克己(克制)\"></a>克己(克制)</h3><p>觉知，自制。</p>\n<h3 id=\"靠谱\"><a href=\"#靠谱\" class=\"headerlink\" title=\"靠谱\"></a>靠谱</h3><p>解决问题的能力。<br>坦坦荡荡。人生如棋，落子无悔。</p>\n<hr>\n<h2 id=\"2017关键字\"><a href=\"#2017关键字\" class=\"headerlink\" title=\"2017关键字\"></a>2017关键字</h2><h3 id=\"make-love-not-commit-OR-push\"><a href=\"#make-love-not-commit-OR-push\" class=\"headerlink\" title=\"make love, not commit OR push\"></a>make love, not commit OR push</h3><p>如果不知道怎么做，那么就开始做并持续做。<br>2016 for push/commit 培养习惯。<br>2017 for love。</p>\n<h3 id=\"专注\"><a href=\"#专注\" class=\"headerlink\" title=\"专注\"></a>专注</h3><p>长时间保持专注的能力。</p>\n<h3 id=\"写作与思考\"><a href=\"#写作与思考\" class=\"headerlink\" title=\"写作与思考\"></a>写作与思考</h3><p>多读书，读书与书写是为了更好的思考。<br>如《暗时间》所说，如果没有写作，思维过程就像黑暗中的手电筒，总是在原地打转。</p>\n<hr>\n<blockquote>\n<p>缺月挂疏桐，漏断人初静。<br>谁见幽人独往来？<br>缥缈孤鸿影。<br>惊起却回头，有恨无人省。<br>拣尽寒枝不肯栖，<br>寂寞沙洲冷。<br>宋 苏轼 《卜算子》</p>\n</blockquote>\n","categories":["ryl"],"tags":["ryl"]},{"title":"Python入门7-文件","url":"https://applefishsky009.github.io/2016/12/24/Python入门7-文件/","content":"<p>首先介绍一个keyword:<code>with</code>，Python引入了<code>with</code>关键字来自动帮助我们调用<code>close()</code>方法。另外<code>as</code>关键字可以作为shorthands。<br>其次介绍一个内建函数<code>help()</code>：</p>\n<ol>\n<li><code>help(object)</code> 显示帮助信息，一般用于交互环境查询帮助信息。</li>\n<li>参数<code>object</code>是对象。<ul>\n<li>内建(工厂)函数直接输入函数名即可，例如<code>help(help)</code>;</li>\n<li>对象的方法，首先实例化一个对象(基本数据类型可以用关键字来代替)，然后通过对象和方法名来调用帮助。</li>\n<li>在很多文档中方法或属性不全面或者版本误差，可以这样来查看最全面的帮助文档。例如打开一个文件f，<code>help(f)</code>。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h1 id=\"Functions\"><a href=\"#Functions\" class=\"headerlink\" title=\"Functions\"></a>Functions</h1><h2 id=\"open\"><a href=\"#open\" class=\"headerlink\" title=\"open()\"></a>open()</h2><p><code>open(file, mode=&#39;r&#39;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True)</code><br>返回文件对象，如果是文本文件，返回TextIOWrapper。如果是二进制文件，读时返回BufferedReader，写时返回BufferedWriter。访问模式：<code>r/w/a/r+/w+/a+</code> <code>rb/wb/ab/rb+/wb+/ab+</code><br>参考资料：<br><a href=\"https://docs.python.org/3/library/io.html\" target=\"_blank\" rel=\"noopener\">io — Core tools for working with streams</a><br>Zeal<br><a href=\"http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431917715991ef1ebc19d15a4afdace1169a464eecc2000\" target=\"_blank\" rel=\"noopener\">廖雪峰的博客</a><br><a href=\"http://www.w3cschool.cn/python3/python3-file-methods.html\" target=\"_blank\" rel=\"noopener\">Python3 File 方法</a></p>\n<h2 id=\"Iteration\"><a href=\"#Iteration\" class=\"headerlink\" title=\"Iteration\"></a>Iteration</h2><p>打开文件之后，文件迭代(一行一行访问)很简单，使用<code>for each in f</code>比<code>for each in f.readline()</code>更高效。</p>\n<hr>\n<h1 id=\"Methods\"><a href=\"#Methods\" class=\"headerlink\" title=\"Methods\"></a>Methods</h1><ol>\n<li>file.read([size]) 从文件读取指定的字节数，如果未给定或为负则读取所有。</li>\n<li>file.readline([size]) 读取整行，包括 “\\n” 字符。</li>\n<li>file.readlines([size int]) 读取所有行并返回列表，若给定size int &gt; 0，返回总和<font color=\"red\">大约</font>为size int字节的行, 实际读取值可能比size int较大, 因为需要填充缓冲区。<ul>\n<li>注意read相关方法都不会删除行结束符，这个工作要通过<code>str.strip()</code>(默认情况下删除空白字符，<code>\\t\\ \\n</code>)来完成。</li>\n</ul>\n</li>\n<li>file.write(str) 将字符串写入文件，没有返回值。</li>\n<li>file.writelines(sequence) 向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。</li>\n<li>file.seek(offset, whence) 设置文件当前位置。</li>\n<li>file.tell() 返回文件当前位置。</li>\n<li>file.next() 返回文件下一行。</li>\n<li>file.truncate([size]) 截取文件，截取的字节通过size指定，默认为当前文件位置。<ul>\n<li>注意这个和<code>file.seek()</code>配合时，截断后返回文件开头。</li>\n</ul>\n</li>\n<li>file.flush() 刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。</li>\n<li>file.close() 关闭文件。关闭后文件不能再进行读写操作。</li>\n<li>file.fileno() 返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。</li>\n<li>file.isatty() 如果文件连接到一个终端设备返回 True，否则返回 False。</li>\n</ol>\n<h1 id=\"Attributes\"><a href=\"#Attributes\" class=\"headerlink\" title=\"Attributes\"></a>Attributes</h1><ol>\n<li>file.closed 表示文件已经被关闭，否则为<code>false</code>。</li>\n<li>file.encoding 返回文件所使用的编码。</li>\n<li>file.mode 文件打开时所使用的模式。</li>\n<li>file.name 文件名。</li>\n<li>file.error</li>\n<li>file.newlines</li>\n<li>file.buffer</li>\n</ol>\n<hr>\n<h1 id=\"Standard-File\"><a href=\"#Standard-File\" class=\"headerlink\" title=\"Standard File\"></a>Standard File</h1><h2 id=\"sys\"><a href=\"#sys\" class=\"headerlink\" title=\"sys\"></a>sys</h2><p>Python中通过sys模块来访问文件句柄。</p>\n<ol>\n<li><code>print()</code>通常输出到<code>sys.stdout</code>。</li>\n<li><code>input()</code>通常从<code>sys.stdin</code>接受输入。</li>\n<li><code>sys.*</code>是文件，所以必须自己处理好换行符。<br>sys模块有argv属性，<code>sys.argv</code>返回一个列表，列表长度<code>len(sys.argv)</code>即参数个数(C中的argc，即argument count)，列表本身就是参数向量(C中的argv，即argument vector)。</li>\n<li><code>sys.argv</code>是命令行参数列表。</li>\n<li><code>len(sys.argv)</code>是命令行参数个数。</li>\n</ol>\n<h2 id=\"os\"><a href=\"#os\" class=\"headerlink\" title=\"os\"></a>os</h2><p>Python中通过这个模块访问文件系统。</p>\n<h2 id=\"os-path\"><a href=\"#os-path\" class=\"headerlink\" title=\"os.path\"></a>os.path</h2><p>完成一些针对路径名的操作。</p>\n<h2 id=\"pickle-cPickle\"><a href=\"#pickle-cPickle\" class=\"headerlink\" title=\"pickle/cPickle\"></a>pickle/cPickle</h2><p>保存Python对象到文件中，而不需要转换成字符串。两个主要函数<code>dump()</code>，<code>load()</code>。</p>\n<hr>\n","categories":["Python"],"tags":["Python"]},{"title":"Python入门6-条件和循环","url":"https://applefishsky009.github.io/2016/12/21/Python入门6-条件和循环/","content":"<h1 id=\"Condition\"><a href=\"#Condition\" class=\"headerlink\" title=\"Condition\"></a>Condition</h1><ol>\n<li><code>if</code>子句<ul>\n<li>单一语句的代码块可以放在<code>if</code>同一行上，但建议使用合理的缩进。</li>\n</ul>\n</li>\n<li><code>else</code>子句<ul>\n<li>Python使用缩进在避免<font color=\"red\">悬挂<code>else</code></font>时非常有用，因为C/C++中else与最近的if搭配，这在他本想与内部if搭配时发生错误。不要忘记花括号可以避免这个问题。</li>\n</ul>\n</li>\n<li><code>elif</code>子句，即<code>else if</code>语句</li>\n<li>Conditional expression. Python很长一段时间内都没有条件表达式<code>C ? X : Y</code>，P2.5加入并确定语法为<ul>\n<li><code>X if C else Y</code>.</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h1 id=\"Loop\"><a href=\"#Loop\" class=\"headerlink\" title=\"Loop\"></a>Loop</h1><h2 id=\"Conditional-Loop-while\"><a href=\"#Conditional-Loop-while\" class=\"headerlink\" title=\"Conditional Loop(while)\"></a>Conditional Loop(while)</h2><p><code>while</code>是条件循环语句，常用在计数循环(配合自增或自减语句)、无限循环中。</p>\n<h2 id=\"Iterative-Loop-for\"><a href=\"#Iterative-Loop-for\" class=\"headerlink\" title=\"Iterative Loop(for)\"></a>Iterative Loop(for)</h2><p><code>for</code>是Python中最强大的循环结构，他是迭代循环语句，可用于列表解析和生成器表达式中，自动调用<code>next(iter)</code>工厂函数(Python2是迭代器方法)，最终捕获StopIterator异常并结束循环。</p>\n<ol>\n<li>可用于序列类型，包括字符串，列表以及元组等。<ul>\n<li>通过序列项迭代。</li>\n<li>配合<code>range(len())</code>通过序列索引迭代，但显然效率不如序列迭代高，这是由迭代器的特性决定的。</li>\n<li>使用索引和项迭代，这就是<code>enumerate()</code>的威力。</li>\n</ul>\n</li>\n<li>用于迭代器类型，因为可以调用<code>next(iter)</code>函数，调用后返回下一条目所有条目迭代完毕后迭代器引发一个StopIteration异常告诉程序循环结束，这都是<code>for</code>语句内部发生的。</li>\n<li>内建函数<code>range()</code>可以将原本类似于<code>foreach</code>的语句变成更熟悉的语句。<ul>\n<li><code>range(start, end, step = 1)</code> step要求start。</li>\n<li><code>range(end)</code></li>\n<li><code>range(start, end)</code></li>\n<li>注意不能将<code>range()</code>简略成一种语法<code>range(start = 0, end, step = 1)</code>，这是因为这个语法的两个参数调用版本有歧义。</li>\n</ul>\n</li>\n<li>相关内建函数，<code>sorted()</code>(返回list),<code>zip()</code>(返回tuple指针)是序列相关，<code>enumerate()</code>,<code>reversed()</code>返回迭代器。</li>\n</ol>\n<h2 id=\"break\"><a href=\"#break\" class=\"headerlink\" title=\"break\"></a>break</h2><p>用于<code>while</code>和<code>for</code>循环中打断列表的迭代。</p>\n<h2 id=\"continue\"><a href=\"#continue\" class=\"headerlink\" title=\"continue\"></a>continue</h2><p>终止当前循环并验证条件表达式(<code>while</code>)或验证是否有元素可以迭代(<code>for</code>)，验证成功的情况下开始下一次循环。</p>\n<h2 id=\"pass\"><a href=\"#pass\" class=\"headerlink\" title=\"pass\"></a>pass</h2><p>提供<code>pass</code>语句表示不做任何事，在Python中如果在需要有语句块的地方不写任何语句，会提示语法错误。<code>pass</code>也可以作为调试中的小技巧，标记你后来要完成的代码。</p>\n<h2 id=\"else\"><a href=\"#else\" class=\"headerlink\" title=\"else\"></a>else</h2><p>Python中可以在<code>while</code>和<code>for</code>循环中使用<code>else</code>语句做循环后处理(post-processing)，相当于设置了一个完整执行循环的flag，即<code>break</code>语句也会跳过<code>else</code>块，因为循环并没有被完整执行。</p>\n<hr>\n<h1 id=\"Iterator\"><a href=\"#Iterator\" class=\"headerlink\" title=\"Iterator\"></a>Iterator</h1><p>迭代器从根本上来说就是一个有<code>next()</code>方法的对象，因此他能无缝支持序列对象。(next()方法迭代和StopIteration异常告诉外部调用者迭代结束)，内建函数<code>reversed()</code>,<code>enumerate()</code>,<code>any()</code>,<code>all()</code>都返回迭代器。</p>\n<ol>\n<li>序列 内建函数iter()和next()；</li>\n<li>字典 for迭代，方法缺省时迭代键；</li>\n<li>文件 for，行迭代。</li>\n</ol>\n<p>不要在迭代不可变对象时改变值，比如字典的key，但是使用<code>dict.key()</code>方法是可以的，因为这个方法返回独立于字典的列表。一个实现了<code>__iter__()</code>和<code>__next__()</code>方法的类可以作为迭代器使用。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#for的工作原理</span></span><br><span class=\"line\">fetch = iter(seq)</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">try</span>:</span><br><span class=\"line\">\t\ti = next(fetch)</span><br><span class=\"line\">\t<span class=\"keyword\">except</span> StopIteration:</span><br><span class=\"line\">\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\tdo_something_to(i)</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h1 id=\"List-Comprehensions\"><a href=\"#List-Comprehensions\" class=\"headerlink\" title=\"List Comprehensions\"></a>List Comprehensions</h1><h2 id=\"lambda\"><a href=\"#lambda\" class=\"headerlink\" title=\"lambda\"></a>lambda</h2><p>定义匿名函数，这个语句作为function传入其它函数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">lambda</span> x: doSomethingAboutX</span><br><span class=\"line\">f = <span class=\"keyword\">lambda</span> x:x+<span class=\"number\">1</span></span><br><span class=\"line\">print(f(<span class=\"number\">2</span>))</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"List-Comprehensions-1\"><a href=\"#List-Comprehensions-1\" class=\"headerlink\" title=\"List Comprehensions\"></a>List Comprehensions</h2><p>Python独有的语法，比lambda更具优势，两个表达式及例子：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[expr <span class=\"keyword\">for</span> iter_var <span class=\"keyword\">in</span> iterable]</span><br><span class=\"line\">[expr <span class=\"keyword\">for</span> iter_var <span class=\"keyword\">in</span> iterable <span class=\"keyword\">if</span> condexpr]</span><br><span class=\"line\"></span><br><span class=\"line\">[(x + <span class=\"number\">1</span>, y + <span class=\"number\">1</span>) <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>) <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>)]</span><br><span class=\"line\">len([word <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> f <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> line.split()])</span><br><span class=\"line\">sum([len(word) <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> f <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> line.split()])</span><br></pre></td></tr></table></figure>\n\n<p>那么列表如何解析？</p>\n<ol>\n<li>对嵌套循环，for语句的顺序是与原顺序相同的；</li>\n<li>条件表达式的作用域是前一个语句(for或者其他表达式)；</li>\n<li>循环和条件之前的表达式是列表元素(核心部分)，如果还原回来这个语句应该在循环和条件的最内层。</li>\n</ol>\n<hr>\n<h1 id=\"Generator-Expression\"><a href=\"#Generator-Expression\" class=\"headerlink\" title=\"Generator Expression\"></a>Generator Expression</h1><p>列表解析的一个缺点就是要生成所有数据用于创建整个列表。生成器表达式是列表解析的一个扩展。它使用了对内存使用更友好的结构。几他不创建真正的列表，而是返回一个生成器，这个生成器每次计算出一个条目之后，把这个条目“产生(<code>yield</code>)出来”，使用“延迟计算”(lazy evaluation)。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(expr <span class=\"keyword\">for</span> iter_var <span class=\"keyword\">in</span> iterable <span class=\"keyword\">if</span> cond_expr)</span><br><span class=\"line\"></span><br><span class=\"line\">((i, j) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>) <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>))</span><br><span class=\"line\"><span class=\"keyword\">return</span> max([len(x.strip()) <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> open(<span class=\"string\">'ect/motd'</span>)])\t<span class=\"comment\">#List Comprehensions</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> max(len(x.strip()) <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> open(<span class=\"string\">'/ect/motd'</span>))\t<span class=\"comment\">#Generator Expression</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n","categories":["Python"],"tags":["Python"]},{"title":"Python入门5-字典和集合","url":"https://applefishsky009.github.io/2016/12/19/Python入门5-字典和集合/","content":"<p>映射类型：字典(dict)<br>集合类型：集合(set) 可变集合/不可变集合</p>\n<hr>\n<h1 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h1><h2 id=\"dict\"><a href=\"#dict\" class=\"headerlink\" title=\"dict\"></a>dict</h2><h3 id=\"Assignment\"><a href=\"#Assignment\" class=\"headerlink\" title=\"Assignment\"></a>Assignment</h3><ol>\n<li>赋值运算符<code>=</code>和花括号<code>{}</code>，键值之间的对应用冒号<code>:</code>。</li>\n<li>工厂方法dict(),键值之间可以用赋值运算符<code>=</code>。</li>\n<li>使用内建方法dict.fromkeys(seq,value),创建一个默认的字典，字典中的元素具有相同的值。</li>\n</ol>\n<h3 id=\"Access\"><a href=\"#Access\" class=\"headerlink\" title=\"Access\"></a>Access</h3><ol>\n<li>键值访问 dict[key]返回value</li>\n<li>迭代器访问 for key in dict</li>\n</ol>\n<h3 id=\"Update\"><a href=\"#Update\" class=\"headerlink\" title=\"Update\"></a>Update</h3><ol>\n<li>方括号和赋值运算符新建/更新字典，dict[key] = newValue;<ul>\n<li>如果没有key,则新建，如果有则更新；</li>\n</ul>\n</li>\n<li>使用内建方法dict.update(dict)将整个字典的内容添加到另一个字典。</li>\n</ol>\n<h3 id=\"Delete\"><a href=\"#Delete\" class=\"headerlink\" title=\"Delete\"></a>Delete</h3><ol>\n<li>del dict[key] 删除键为key的条目。</li>\n<li>dict.clear() 删除dict中所有的条目。</li>\n<li>dict.pop(key) 删除并返回键为key的条目的值。</li>\n</ol>\n<h3 id=\"Operator\"><a href=\"#Operator\" class=\"headerlink\" title=\"Operator\"></a>Operator</h3><ol>\n<li>赋值运算符<code>=</code>，Python3中取消了关系运算符<code>&gt;</code>,<code>&lt;</code>，等相关的运算符，但是<code>==</code>依然可用。</li>\n<li>Python3中取消了<code>cmp()</code>内建函数。</li>\n<li>字典的键查找操作符<code>[]</code>，给某元素赋值或者查询字典中某元素的值。</li>\n<li>键成员关系操作<code>in/not in</code>。</li>\n</ol>\n<h2 id=\"Functions\"><a href=\"#Functions\" class=\"headerlink\" title=\"Functions\"></a>Functions</h2><ol>\n<li>type() 返回对象的类型或创建一个新的类型对象。</li>\n<li>str() 得到对象的str()版本。</li>\n<li>len() 返回对象长度或者集合个数。</li>\n<li>dict() 创建字典。<ul>\n<li>如果参数是可迭代的，必须成对出现才能创建字典，zip或者列表，列表解析等；</li>\n<li>如果输入参数是一个映射对象，此函数会返回该映射对象的浅拷贝版本，但是效率没有dict.copy()高。</li>\n</ul>\n</li>\n<li>hash() 得到对象的哈希值。<ul>\n<li>一般用来判断对象是否是可哈希的，如果可哈希返回哈希值；</li>\n<li>如果不可哈希，返回错误。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Methods\"><a href=\"#Methods\" class=\"headerlink\" title=\"Methods\"></a>Methods</h2><ol>\n<li>dict.clear() 删除dictionary中的所有键值对，字典变为空。</li>\n<li>dict.copy() 浅拷贝dictionary。</li>\n<li>dict.fromkeys(iterater, value=None) 新建一个dictionary，键由可迭代对象组成，所有的值都是value。</li>\n<li>dict.get(key, d) 返回dictionary中键为key的值，如果不存在key，则返回d(默认为None)，这可以判断键key是否存在。</li>\n<li>dict.items() 返回dictionary中所有键值对，类型为dict_items，可以使用迭代器访问。</li>\n<li>dict.keys() 返回dictionary中所有的键集合，类型为dict_keys，可以使用迭代器访问。</li>\n<li>dict.values() 返回dictionary中所有的值集合，类型为dict_values，可以使用迭代器访问。</li>\n<li>dict.pop(key) 删除dictionary中指定key，并返回key的值。如果没有key，会抛出KeyError。</li>\n<li>dict.popitem() 删除dictionary中key-value对，类型是tuple()，如果dict是空，抛出异常。</li>\n<li>dict.setdefault(k,d) 如果dictionary中不存在k,设置dict[k] = d,并返回d；如果k存在，则返回原有键k的值。</li>\n<li>dict.update(dict/iterable) 使用一个字典或者可迭代容器(比如zip)更新字典(添加内容)。</li>\n</ol>\n<h2 id=\"Warning\"><a href=\"#Warning\" class=\"headerlink\" title=\"Warning\"></a>Warning</h2><ol>\n<li>不允许一个键对应多个值，以最后一次的赋值/更新为准。</li>\n<li>键必须是可哈希的<ul>\n<li>所有的不可变类型都是可哈希的，因为字典中的键用来计算数据存储位置，如果可变，存取数据就变得不可靠了。</li>\n<li>数字和字符串都可以作为键，但对元组来说，元组只包括数字和字符串这样的不可变参数，才能作为字典中有效的值。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h1 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h1><p>分为可变集合和不可变集合，可变集合可以添加删除元素，不可哈希。不可变集合刚好相反。</p>\n<h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><h3 id=\"Assignment-1\"><a href=\"#Assignment-1\" class=\"headerlink\" title=\"Assignment\"></a>Assignment</h3><p>只能通过工厂方法来创建，集合具有无序性，确定性，互异性。</p>\n<ol>\n<li>set() 可变集合。</li>\n<li>frozenset() 不可变集合。</li>\n</ol>\n<h3 id=\"Access-1\"><a href=\"#Access-1\" class=\"headerlink\" title=\"Access\"></a>Access</h3><ol>\n<li><code>in/not in</code>。</li>\n</ol>\n<h3 id=\"Update-1\"><a href=\"#Update-1\" class=\"headerlink\" title=\"Update\"></a>Update</h3><ol>\n<li>set.add() 往set中添加一个元素。</li>\n<li>set.remove() 从set中删除一个元素，这个操作和set.add()相对应。</li>\n<li>set.update(set) 往set中添加一个set的所有元素。</li>\n<li>set <code>-=</code> set() 从set中删去一个set的所有元素，这个操作与set.update()相对应。</li>\n</ol>\n<h3 id=\"Delete-1\"><a href=\"#Delete-1\" class=\"headerlink\" title=\"Delete\"></a>Delete</h3><ol>\n<li><code>del set</code>清除出当前的名称空间，如果引用计数为0，会被垃圾回收。</li>\n</ol>\n<h3 id=\"Operator-1\"><a href=\"#Operator-1\" class=\"headerlink\" title=\"Operator\"></a>Operator</h3><p>注意<code>+</code>不是集合类型操作符，最接近<code>+</code>的逻辑是或(OR<code>|</code>)。</p>\n<ol>\n<li><code>in/not in</code> 成员关系操作符。</li>\n<li><code>==/!=</code> 等价/不等价。</li>\n<li><code>&lt;/&lt;=,&gt;/&gt;=</code> 严格子集/非严格子集(<code>&lt;=</code>相当于set.issubset())，严格超集/非严格超集(<code>&gt;=</code>相当于set.issuperset())。</li>\n<li><code>|</code> 联合，相当于OR,等价方法set.union()。</li>\n<li><code>&amp;</code> 交集，相当于ADD，等价方法set.intersection()。</li>\n<li><code>-</code> 差补/相对补集，等价方法set.difference()。</li>\n<li><code>^</code> 对称差分,即异或，等价方法set.symmetric_difference()。</li>\n</ol>\n<p>以下仅适用于可变集合：</p>\n<ol>\n<li><code>|=</code> 从已存在的集合中添加多个成员，此方法和update()等价。</li>\n<li><code>&amp;=</code> 保留(交集更新)，保留与其他集合的共有成员，此方法和intersection_update()等价。</li>\n<li><code>-=</code> 差更新，返回除去右集合后剩余元素组成的集合，此方法和difference_update()等价。</li>\n<li><code>^=</code> 差分更新，返回仅是左集合或者仅是右集合的元素组成的集合。</li>\n</ol>\n<h2 id=\"Functions-1\"><a href=\"#Functions-1\" class=\"headerlink\" title=\"Functions\"></a>Functions</h2><ol>\n<li>len() 返回集合基数。</li>\n<li>set()/frozenset() 生成可变/不可变集合。<ul>\n<li>默认生成空集合；</li>\n<li>如果有一个参数，该参数必须是可迭代的。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Methods-1\"><a href=\"#Methods-1\" class=\"headerlink\" title=\"Methods\"></a>Methods</h2><ol>\n<li>set.add() 往set中添加一个元素。</li>\n<li>set.clear() 从set中移除所有元素。</li>\n<li>set.copy() 返回set的浅拷贝。</li>\n<li>set.difference() 返回两个或多个set中不同的元素组成的set，差分。</li>\n<li>set.difference_update() 从当前set中移除其他set中所有元素。</li>\n<li>set.discard() 从set中删除一个元素，如果该元素存在。无论该元素存在与否，返回值都是None。</li>\n<li>set.intersection() 返回两个或多个set的交集。</li>\n<li>set.intersection_update() 更新当前set，只保留所有set中都存在的元素、</li>\n<li>set.isdisjoint() 判断两个set有没有交集。</li>\n<li>set.issubset()/set.issuperset() 判断是否非严格子集/非严格超集。 </li>\n</ol>\n<hr>\n","categories":["Python"],"tags":["Python"]},{"title":"VSCode配置Go环境","url":"https://applefishsky009.github.io/2016/12/16/VSCode配置Go环境/","content":"<p>安装VSCode以及VSCode中Go扩展，git的过程省略</p>\n<hr>\n<h2 id=\"配置git环境\"><a href=\"#配置git环境\" class=\"headerlink\" title=\"配置git环境\"></a>配置git环境</h2><p>安装Go插件需要git指令因此首先要配置git环境,由于之前使用的是github桌面版，要在cmd下使用还需要配置环境变量。</p>\n<ol>\n<li>gitshell使用powershell启动是由于gitshell的原因，并不是powershell可以使用git指令；</li>\n<li>因此在将VSCode shell改成powershell之后会无法识别git指令；</li>\n<li>将git的bin目录添加在环境变量PATH中，但github安装时是不能选择安装目录的，一般情况下是安装在<code>C:\\Users\\***\\AppData\\Local\\GitHub</code>目录下，然后有些英文不知道什么意思的文件夹，进去之后只看有没有bin目录。有的话就说明进对了。注意不一定是一级目录，也不一定只有一个bin目录，比如我有两个bin目录<code>PortableGit_d7effa1a4a322478cd29c826b52a0c118ad3db11\\mingw32\\bin</code>和<code>PortableGit_d7effa1a4a322478cd29c826b52a0c118ad3db11\\usr\\bin</code>,其中前一个是有效的。</li>\n<li>如果安装的是git for windows，可以选择安装目录，这个问题比较容易解决。</li>\n</ol>\n<p>参考资料：<a href=\"http://blog.csdn.net/bugmeout/article/details/21335609\" target=\"_blank\" rel=\"noopener\">GitHub cmd下环境变量设置</a></p>\n<p>–</p>\n<h2 id=\"插件配置\"><a href=\"#插件配置\" class=\"headerlink\" title=\"插件配置\"></a>插件配置</h2><h3 id=\"插件配置选项\"><a href=\"#插件配置选项\" class=\"headerlink\" title=\"插件配置选项\"></a>插件配置选项</h3><p>Preferrence-&gt;WorkSpaces Settings中设置插件：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"files.autoSave\"</span>: <span class=\"string\">\"onFocusChange\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"go.buildOnSave\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"go.lintOnSave\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"go.vetOnSave\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"go.buildFlags\"</span>: [],</span><br><span class=\"line\">    <span class=\"attr\">\"go.lintFlags\"</span>: [],</span><br><span class=\"line\">    <span class=\"attr\">\"go.vetFlags\"</span>: [],</span><br><span class=\"line\">    <span class=\"attr\">\"go.useCodeSnippetsOnFunctionSuggest\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"go.formatOnSave\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"go.formatTool\"</span>: <span class=\"string\">\"goreturns\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"go.goroot\"</span>: <span class=\"string\">\"D:\\\\Go\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"go.gopath\"</span>: <span class=\"string\">\"D:\\\\GoWorks\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装这些插件\"><a href=\"#安装这些插件\" class=\"headerlink\" title=\"安装这些插件\"></a>安装这些插件</h3><p>这些工具默认的安装方式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go get -u -v github.com/nsf/gocode</span><br><span class=\"line\">go get -u -v github.com/rogpeppe/godef</span><br><span class=\"line\">go get -u -v github.com/golang/lint/golint</span><br><span class=\"line\">go get -u -v github.com/lukehoban/go-outline</span><br><span class=\"line\">go get -u -v sourcegraph.com/sqs/goreturns</span><br><span class=\"line\">go get -u -v golang.org/x/tools/cmd/gorename</span><br><span class=\"line\">go get -u -v github.com/tpng/gopkgs</span><br><span class=\"line\">go get -u -v github.com/newhook/go-symbols</span><br><span class=\"line\">go get -u -v golang.org/x/tools/cmd/guru</span><br><span class=\"line\">go get -u -v github.com/lukehoban/go-find-references</span><br><span class=\"line\">go get -v -u github.com/peterh/liner github.com/derekparker/delve/cmd/dlv\t//调试工具</span><br></pre></td></tr></table></figure>\n\n<p>最终目的是在gopath中bin文件夹生成一些exe文件，如果以上命令运行成功，会自动编译生成，但我运行时有5个安装失败，因此在网上找到已经生成好的exe包。</p>\n<p>不过<font color=\"red\">最终我还是通过命令安装成功了</font>，个人觉得终端提示的所有错误都可以无视，因为我开了两个VSCode换着一直输入指令，然后突然就全都好了，个人猜测是长城的原因。终端提示有以下几种：</p>\n<ol>\n<li>is not using a known version control system.</li>\n<li>git remote error.</li>\n<li>timeout 这是正确原因，由于长城的存在导致的。</li>\n</ol>\n<p>参考资料:<br><font color=\"red\">特别重要</font><a href=\"https://marketplace.visualstudio.com/items?itemName=lukehoban.Go\" target=\"_blank\" rel=\"noopener\">Go for Visual Studio Code</a><br><a href=\"http://www.cnblogs.com/JerryNo1/p/5412864.html\" target=\"_blank\" rel=\"noopener\">windows下visual studio code搭建golang开发环境</a><br><a href=\"https://duosoftware.com/blog/how-to-setup-visual-studio-code-to-debug-golang-with-delve/\" target=\"_blank\" rel=\"noopener\">HOW TO SETUP VISUAL STUDIO CODE TO DEBUG GOLANG WITH DELVE</a></p>\n<h2 id=\"launch和settings\"><a href=\"#launch和settings\" class=\"headerlink\" title=\"launch和settings\"></a>launch和settings</h2><p>以下是simple项目的配置，复杂项目的配置以后慢慢研究。</p>\n<p>launch.json</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"version\"</span>: <span class=\"string\">\"0.2.0\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"configurations\"</span>: [</span><br><span class=\"line\">        </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"Launch\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"type\"</span>: <span class=\"string\">\"go\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"request\"</span>: <span class=\"string\">\"launch\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"mode\"</span>: <span class=\"string\">\"debug\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"remotePath\"</span>: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"port\"</span>: <span class=\"number\">2345</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"host\"</span>: <span class=\"string\">\"127.0.0.1\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"program\"</span>: <span class=\"string\">\"$&#123;workspaceRoot&#125;\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"env\"</span>: &#123;&#125;,</span><br><span class=\"line\">            <span class=\"attr\">\"args\"</span>: [],</span><br><span class=\"line\">            <span class=\"attr\">\"showLog\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>settings.json</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"files.autoSave\"</span>: <span class=\"string\">\"onFocusChange\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"go.buildOnSave\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"go.lintOnSave\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"go.vetOnSave\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"go.buildFlags\"</span>: [],</span><br><span class=\"line\">    <span class=\"attr\">\"go.lintFlags\"</span>: [],</span><br><span class=\"line\">    <span class=\"attr\">\"go.vetFlags\"</span>: [],</span><br><span class=\"line\">    <span class=\"attr\">\"go.useCodeSnippetsOnFunctionSuggest\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"go.formatOnSave\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"go.formatTool\"</span>: <span class=\"string\">\"goreturns\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"go.goroot\"</span>: <span class=\"string\">\"D:\\\\Go\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"go.gopath\"</span>: <span class=\"string\">\"D:\\\\GoWorks\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n","categories":["VSCode"],"tags":["VSCode"]},{"title":"Python入门4-列表和元组","url":"https://applefishsky009.github.io/2016/12/14/Python入门4-列表和元组/","content":"<p>序列容器之列表和元组<br>列表，可变类型。<br>元组，不可变类型。</p>\n<hr>\n<h1 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h1><h2 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h2><h3 id=\"Operator\"><a href=\"#Operator\" class=\"headerlink\" title=\"Operator\"></a>Operator</h3><ol>\n<li><code>=</code>,<code>==</code>,<code>&gt;</code>,<code>&lt;</code>。列表的比较逻辑：两个列表元素分别比较，直到有一方的元素胜出。如果某两个元素相互之间不能比较会抛出一个TypeError。注意他的比较只是比较值，不会比较<code>id()</code>。</li>\n<li><code>in/not in</code> 成员关系操作</li>\n<li><code>+</code> 连接操作符，<code>extend()</code>方法可以代替连接操作符吧一个列表内容添加到另一个中去，而不是新建一个列表。<ul>\n<li><code>+=</code> 替换连接操作也支持；</li>\n<li>注意连接操作符不能新建一个元素到列表，只能连接两个列表。</li>\n</ul>\n</li>\n<li><code>*</code> 重复操作符</li>\n</ol>\n<h3 id=\"Assignment\"><a href=\"#Assignment\" class=\"headerlink\" title=\"Assignment\"></a>Assignment</h3><p>使用赋值运算符和方括号<code>[]</code>，或者内建的构造函数list(iterable)，可以从参数看到，传入可迭代对象，即可以从tuple,list,range,str创建list对象。</p>\n<h3 id=\"Access\"><a href=\"#Access\" class=\"headerlink\" title=\"Access\"></a>Access</h3><p>可以使用索引，或者切片操作符来访问列表值，并且类似于多维数组，可以在切片的结果上再次切片。</p>\n<h3 id=\"Update\"><a href=\"#Update\" class=\"headerlink\" title=\"Update\"></a>Update</h3><p>通过索引或者索引范围来更新列表，因为列表是可变的。</p>\n<h3 id=\"List-Comprehension\"><a href=\"#List-Comprehension\" class=\"headerlink\" title=\"List Comprehension\"></a>List Comprehension</h3><p>结合列表的方括弧和for循环，在逻辑上描述要创建的列表.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[i*<span class=\"number\">2</span> <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> [<span class=\"number\">8</span>, <span class=\"number\">-2</span>, <span class=\"number\">5</span>]] = [<span class=\"number\">16</span>, <span class=\"number\">-4</span>, <span class=\"number\">10</span>]</span><br><span class=\"line\">[i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range[<span class=\"number\">8</span>] <span class=\"keyword\">if</span> i % <span class=\"number\">2</span> == <span class=\"number\">0</span>] = [<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Functions\"><a href=\"#Functions\" class=\"headerlink\" title=\"Functions\"></a>Functions</h2><ol>\n<li>len() 列表大小</li>\n<li>max()/min() 最大最小值</li>\n<li>sorted()/reversed() 字典序排序(排序后是另外一个对象)，反转(注意反转返回的是迭代器，需要list()转化，但这是另外一个对象了)</li>\n<li>enumerate()/zip() 枚举，打包为元组</li>\n<li>sum() 求和</li>\n</ol>\n<h2 id=\"Methods\"><a href=\"#Methods\" class=\"headerlink\" title=\"Methods\"></a>Methods</h2><ol>\n<li>list.append() 附件一个对象到list</li>\n<li>list.clear() 删除list中的所有元素</li>\n<li>list.copy() 浅拷贝list<ul>\n<li><a href=\"http://www.cnblogs.com/wilber2013/p/4645353.html\" target=\"_blank\" rel=\"noopener\">图解Python深拷贝和浅拷贝</a>,简单来说，深拷贝会对每一个对象创造一个副本，而浅拷贝在能使用引用的时候绝对不用拷贝。</li>\n</ul>\n</li>\n<li>list.count() 指定参数在list中出现的次数</li>\n<li>list.extend() 附加指定的元素到迭代器</li>\n<li>list.index() 返回指定值在list中第一次出现的位置，如果不存在指定值则抛出错误</li>\n<li>list.insert() 在list指定位置插入对象</li>\n<li>list.pop() 删除并返回指定位置的对象，默认为最后位置，如果越界或者列表为空则抛出异常</li>\n<li>list.remove() 从list中删除第一次出现的指定值，如果指定值不存在，抛出异常</li>\n<li>list.reverse() 原地反转list中的元素</li>\n<li>list.sort() 对列表排序(原地)</li>\n</ol>\n<hr>\n<h1 id=\"元组\"><a href=\"#元组\" class=\"headerlink\" title=\"元组\"></a>元组</h1><h2 id=\"Tuple\"><a href=\"#Tuple\" class=\"headerlink\" title=\"Tuple\"></a>Tuple</h2><p>元组和列表一个重要的区别：不可变类型，因此可以做一些列表不能做的事情，比如做字典的key.</p>\n<h3 id=\"Assignment-1\"><a href=\"#Assignment-1\" class=\"headerlink\" title=\"Assignment\"></a>Assignment</h3><p>使用赋值运算符和圆括号，值得注意的是<font color=\"red\">只有一个元素时需要添加一个逗号<code>,</code></font>，来区分工厂方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type((<span class=\"number\">1</span>)) = <span class=\"string\">'int'</span></span><br><span class=\"line\">type((<span class=\"number\">1</span>,)) = <span class=\"string\">'tuple'</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Acess\"><a href=\"#Acess\" class=\"headerlink\" title=\"Acess\"></a>Acess</h3><p>与列表切片操作一样，用方括号作为切片操作符，里边写上索引值或索引范围。</p>\n<h3 id=\"Update-1\"><a href=\"#Update-1\" class=\"headerlink\" title=\"Update\"></a>Update</h3><p>因为元组是不可变的，因此不能更新或者改变元组的值，字符串必须通过现有字符串片段再构造一个新的字符串的方式来解决，对元组也必须这样。</p>\n<h3 id=\"Delete\"><a href=\"#Delete\" class=\"headerlink\" title=\"Delete\"></a>Delete</h3><p>因为元组不可变，删除一个单独的元素是不可能的，只有通过<code>del</code>来减少对象的引用计数。引用计数为0时会析构对象。Python中大部分时候并不需要显式析构。</p>\n<h3 id=\"Operator-1\"><a href=\"#Operator-1\" class=\"headerlink\" title=\"Operator\"></a>Operator</h3><ol>\n<li><code>=</code>,<code>*</code>,<code>+</code> 创建，重复和连接</li>\n<li><code>in/not in</code>,<code>[]</code>成员关系操作符，切片操作</li>\n<li><code>&lt;</code>,<code>&gt;</code>,<code>==</code> 运算符</li>\n</ol>\n<h2 id=\"Functions-1\"><a href=\"#Functions-1\" class=\"headerlink\" title=\"Functions\"></a>Functions</h2><p>元组没有自己专用的内建函数，列表中描述的一些函数与其可变性有关，不适用于元祖。除此之外的一些适用于不可变迭代器的内建函数就可以用于元组。</p>\n<h2 id=\"Methods-1\"><a href=\"#Methods-1\" class=\"headerlink\" title=\"Methods\"></a>Methods</h2><ol>\n<li>tuple.count() 指定参数在tuple中出现的次数</li>\n<li>tuple.index() 指定参数在tuple中第一次出现的次数，如果没有出现抛出错误。</li>\n</ol>\n<h2 id=\"元组的不可变性\"><a href=\"#元组的不可变性\" class=\"headerlink\" title=\"元组的不可变性\"></a>元组的不可变性</h2><ol>\n<li>不可变不完全是坏事，比如将数据传入一个不了解的API，不可变可以保证数据不被修改。而如果要修改函数返回的元组，可以用list()内建函数来转化。</li>\n<li>元组的不可变也没有那么可怕，通过连接，复制我们依然可以得到新的元组(尽管id不同了)，另外我们可以改变元组内部的一个可变对象来达到修改元组的目的(比如修改元组内部的列表元素)。</li>\n<li>所有的逗号分隔的没有明确符号定义的集合，默认类型都是元组，但最好是显式定义类型。</li>\n</ol>\n<h2 id=\"list-amp-amp-tuple\"><a href=\"#list-amp-amp-tuple\" class=\"headerlink\" title=\"list &amp;&amp; tuple\"></a>list &amp;&amp; tuple</h2><ol>\n<li>维护敏感数据-&gt;tuple</li>\n<li>管理动态数据集合-&gt;list</li>\n</ol>\n<hr>\n<h2 id=\"Python浅拷贝和深拷贝\"><a href=\"#Python浅拷贝和深拷贝\" class=\"headerlink\" title=\"Python浅拷贝和深拷贝\"></a>Python浅拷贝和深拷贝</h2><p>浅拷贝：</p>\n<ol>\n<li>完全切片操作</li>\n<li>利用工厂函数</li>\n<li>使用copy模块的copy函数<br>深拷贝：</li>\n<li>使用copy.decopy()函数</li>\n</ol>\n<p>Waring:赋值运算符<code>=</code>并不会拷贝，这是类似于原引用的别名的东西(是同一个引用)。</p>\n<ol>\n<li>浅拷贝实际上是原对象的引用(新建的)，现在如果要改变其中的一个可变对象，那这两个对象访问的结果都会发生变化，如果这是一个联合账户(C++类中的静态对象)，那么这是期望的结果。但如果希望是相互独立的，这就导致了不期望的结果，此时需要深拷贝。</li>\n<li>但如果改变的对象是不可变对象(比如字符串)，由于这是不同的引用，这会导致在这个改变的操作中这个不可变对象被显式拷贝，因此改变前后的对象元素已经是不同的了。</li>\n<li>结合C++中的引用和类中的静态变量，以及Python中的引用计数机制，很容易理解。</li>\n</ol>\n<hr>\n<p>参考资料：</p>\n<ol>\n<li><a href=\"http://www.howsoftworks.net/python.api/builtins/\" target=\"_blank\" rel=\"noopener\">howsoftworks-builtins</a></li>\n<li><a href=\"http://www.howsoftworks.net/python/function/\" target=\"_blank\" rel=\"noopener\">howsoftworks-Builtin Function</a></li>\n</ol>\n<hr>\n","categories":["Python"],"tags":["Python"]},{"title":"Python入门3-字符串","url":"https://applefishsky009.github.io/2016/12/13/Python入门3-字符串/","content":"<p>序列篇:字符串(str)，列表(list)，元组(tuple)，range<br>在python中list,tuple,range是序列容器，而str单独作为文本序列类型，因此很多特性都不尽相同。建议多看官方文档。</p>\n<p>参考： <a href=\"https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range\" target=\"_blank\" rel=\"noopener\">序列类型</a></p>\n<hr>\n<h2 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"操作符\"></a>操作符</h2><h3 id=\"成员关系操作符\"><a href=\"#成员关系操作符\" class=\"headerlink\" title=\"成员关系操作符\"></a>成员关系操作符</h3><p><code>in/not in</code>，判断一个元素是否属于某一个序列。</p>\n<h3 id=\"连接操作符\"><a href=\"#连接操作符\" class=\"headerlink\" title=\"连接操作符\"></a>连接操作符</h3><p>连接操作符，<code>+</code>，但其效率并不是最高。</p>\n<ol>\n<li>对字符串来说，不如在列表或可迭代对象中调用<code>join</code>方法来把所有的内容连接在一起节约内存。</li>\n<li>对列表来说，可以用<code>extend</code>方法来把两个或者多个列表对象合并</li>\n</ol>\n<h3 id=\"重复操作符\"><a href=\"#重复操作符\" class=\"headerlink\" title=\"重复操作符\"></a>重复操作符</h3><p><code>*</code>，返回一个序列的多份拷贝。</p>\n<h3 id=\"切片操作符\"><a href=\"#切片操作符\" class=\"headerlink\" title=\"切片操作符\"></a>切片操作符</h3><p><code>[],[:][::]</code>,参数为头(2)+超尾(1)+步长(3)</p>\n<ol>\n<li>序列索引范围：<code>-len &lt;= index &lt;= len - 1</code>,越界会引发<code>IndexError</code>异常；</li>\n<li>切片的返回值是原类型；</li>\n<li><code>None</code>可以作切片的索引，返回原字符串，但是Python3中<code>range()</code>的返回类型是<code>&lt;class &#39;range&#39;&gt;</code>,可以转换后连接。</li>\n</ol>\n<p>每次砍掉一个字符串：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">'abcde'</span></span><br><span class=\"line\">i = <span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> [<span class=\"literal\">None</span>] + list(range(<span class=\"number\">-1</span>, -len(s), <span class=\"number\">-1</span>)):</span><br><span class=\"line\">    print(s[:i])</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"Funtions\"><a href=\"#Funtions\" class=\"headerlink\" title=\"Funtions\"></a>Funtions</h2><p>迭代的概念本身是从序列，迭代器，或者其他支持迭代操作的对象中泛化而来的。因此序列本身就包含了迭代的概念。</p>\n<h3 id=\"类型转化\"><a href=\"#类型转化\" class=\"headerlink\" title=\"类型转化\"></a>类型转化</h3><p>各种序列的相互转化：</p>\n<ol>\n<li><code>str()</code>一般在一个对象需要打印对象的信息输出时特别有用，但通常对字符串应用<code>list()</code>和<code>tuple()</code>得不到我们想要的结果；</li>\n<li><code>list()</code>和<code>tuple()</code>在列表和元组互换时非常有效。</li>\n</ol>\n<h3 id=\"可操作函数\"><a href=\"#可操作函数\" class=\"headerlink\" title=\"可操作函数\"></a>可操作函数</h3><p>iter表示可迭代对象,seq表示序列。</p>\n<ol>\n<li>len(seq) 返回seq长度;</li>\n<li>max(iter, key = None),key是传给sort()的回调函数;<ul>\n<li>max(arg0, arg1, …, key = None)</li>\n</ul>\n</li>\n<li>min()用法同max</li>\n<li>seq.index(x, start, end) 返回[start， end)区间x元素首次出现的位置。</li>\n<li>seq.count() 返回x在seq中出现的次数。</li>\n<li>str是不可变文本序列，可以通过切片来得到他的转置序列<code>str1 = str[-1:-len(str)-1:-1]</code>。</li>\n</ol>\n<hr>\n<h1 id=\"str\"><a href=\"#str\" class=\"headerlink\" title=\"str\"></a>str</h1><p>字符串是不可变类型的，就是说改变一个元素需要创建一个新的字符串。</p>\n<h2 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h2><ol>\n<li>创建和赋值 不区分<code>&#39;&#39;,&quot;&quot;，</code>，他是直接量或者标量，不包含其他Python类型，考虑到他不可变以及不能单独改变字符串的一个字符或者一个子串。这些内容都是相互呼应的。</li>\n<li>访问字符串的值 索引方式来访问</li>\n<li>改变字符串 变量赋值，可以使用切片和连接符来得到</li>\n<li>删除字符串 <code>del</code>，一般情况下并不需要显式删除字符串。</li>\n</ol>\n<h2 id=\"操作符-1\"><a href=\"#操作符-1\" class=\"headerlink\" title=\"操作符\"></a>操作符</h2><ol>\n<li>标准类型 <code>=</code>,<code>&lt;</code>,<code>&gt;</code>,<code>!=</code></li>\n<li>序列操作符切片 头，超尾， 步长</li>\n<li>成员操作符 <code>in/not in</code>判断字符或者子串是否在另一个字符串中</li>\n<li>运行时字符串连接(<code>+</code>)</li>\n<li>编译时字符串连接(在源码中用<code>&#39;&#39;</code>或者<code>&quot;&quot;</code>)</li>\n<li>普通字符串转为unicode字符串，连接处理中如果有一个字符串是unicode字符串，Python会进行转化<code>u&#39;abc&#39;</code></li>\n</ol>\n<h2 id=\"只适用于字符串的操作符\"><a href=\"#只适用于字符串的操作符\" class=\"headerlink\" title=\"只适用于字符串的操作符\"></a>只适用于字符串的操作符</h2><ol>\n<li>格式化操作符(<code>%</code>) <code>&#39;we are at %d%%&#39; % 100</code>，另外，<code>repr()</code>和<code>str()</code>函数来辅助调试。<ul>\n<li>格式化操作符后边的可以是列表，元组等，可以在输出时避免迭代，尤其好用。</li>\n</ul>\n</li>\n<li>原始字符串操作(<code>r/R</code>) 让程序员不必过多关注如何转义，编译器会完成这个工作。<ul>\n<li><code>r/R</code>必须紧靠在第一个引号之前；</li>\n</ul>\n</li>\n<li>Unicode字符串操作(<code>u/U</code>)<ul>\n<li>Unicode操作符必须出现在原始字符串操作符之前。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Funtions-1\"><a href=\"#Funtions-1\" class=\"headerlink\" title=\"Funtions\"></a>Funtions</h2><ol>\n<li>len()</li>\n<li>max(),min()</li>\n<li>enumerate()</li>\n<li>zip()<ul>\n<li>注意返回类型是zip，转化成list可视化</li>\n<li>可以使用解析符号<code>*</code>unzip，<code>x,y=zip(*c)</code>，返回值x,y是tuple类型。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"Methods\"><a href=\"#Methods\" class=\"headerlink\" title=\"Methods\"></a>Methods</h2><p>共44个str相关方法，详见<a href=\"http://www.howsoftworks.net/python.api/builtins/str_capitalize.html\" target=\"_blank\" rel=\"noopener\">How Soft Works.net Logo - str</a>。常见方法总结：</p>\n<ol>\n<li>str.find() 返回子字符串在字符串中第一次出现的位置；如没找到返回-1。</li>\n<li>str.format() 执行字符串格式化操作，替换字段使用{}分割。<ul>\n<li>str.format_map()的替换字段可能是字典<a href=\"https://segmentfault.com/a/1190000004598007\" target=\"_blank\" rel=\"noopener\">Python 的内置字符串方法</a></li>\n</ul>\n</li>\n<li>str.isalnum() 判断字符串是否至少有一个字符，并且所有字符都是数字或者字符。<ul>\n<li>判断字符系列，共12个</li>\n</ul>\n</li>\n<li>str.join() 使用str连接多个数据，可以是字典，列表，元组。</li>\n<li>str.split() 拆分字符串，返回一个列表。</li>\n<li>str.translate() 根据映射关系，将字符串中的每个字符转换成另外一个字符。<ul>\n<li>和str.maketrans()配合，返回值是一个字典</li>\n</ul>\n</li>\n<li>str.upper()/str.lower() 字符串大小写转换。</li>\n<li>str.zfill() 字符串左边填充0，不会截断字符串。</li>\n</ol>\n<h2 id=\"转义字符\"><a href=\"#转义字符\" class=\"headerlink\" title=\"转义字符\"></a>转义字符</h2><ol>\n<li>和其他语言一样，反斜杠转义</li>\n<li>三引号允许字符串跨行，字符串中可以包含换行符，制表符，以及其他特殊字符。<ul>\n<li>这个特性可以让程序员从特殊字符串的转义工作中解放出来(比如繁琐的html或者sql语句中)。</li>\n</ul>\n</li>\n<li>字符串不可变，修改实际上都是新建字符串。</li>\n</ol>\n<h2 id=\"Unicode\"><a href=\"#Unicode\" class=\"headerlink\" title=\"Unicode\"></a>Unicode</h2><ol>\n<li>ASCII字符只能表示233个字符，而Unicode可以表示超过9w个。</li>\n<li>编码与解码 encode()/decode()</li>\n<li>Python3中str()和chr()已经是Unicode(默认utf-8编码)，没有unicode()内建函数。</li>\n</ol>\n","categories":["Python"],"tags":["Python"]},{"title":"Python入门2-数字","url":"https://applefishsky009.github.io/2016/12/10/Python入门2-数字/","content":"<p>数字篇</p>\n<hr>\n<h2 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h2><p>他的更新与删除在Python对象介绍中已经说过，注意只缓存<font color=\"red\">简单整型</font>。</p>\n<hr>\n<h2 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h2><ol>\n<li>布尔型</li>\n<li>整型(类似于C中长整型)</li>\n<li>浮点(类似于C中双精度浮点型)</li>\n<li>复数,属性如下：<ul>\n<li>num.real 返回实部</li>\n<li>num.imag 返回虚部</li>\n<li>num.conjugate 返回共轭复数</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"操作符\"></a>操作符</h2><h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><ol>\n<li>如果有一个操作数是复数，另一个操作数被转换为复数；</li>\n<li>否则，如果有一个操作数是浮点型，另一个操作数被转化为浮点型；</li>\n<li>否则，如果一个操作数是长整型，则另一个操作数被转化为长整型；</li>\n<li>否则，两者必然普通整型，无需类型转化。</li>\n</ol>\n<h3 id=\"标准类型操作符\"><a href=\"#标准类型操作符\" class=\"headerlink\" title=\"标准类型操作符\"></a>标准类型操作符</h3><p><code>==</code>,<code>&gt;=</code>,<code>&lt;=</code>,<code>&lt;</code>,<code>&gt;</code>,<code>!=</code>,and,or</p>\n<h3 id=\"算术操作符\"><a href=\"#算术操作符\" class=\"headerlink\" title=\"算术操作符\"></a>算术操作符</h3><p><code>+</code>,<code>-</code>,<code>*</code>,<code>/</code>,<code>%</code>,<code>//</code>,<code>**</code></p>\n<ol>\n<li>取余运算的本质：x/y的余数 = x - x//y*y</li>\n</ol>\n<h3 id=\"整型的位操作符\"><a href=\"#整型的位操作符\" class=\"headerlink\" title=\"整型的位操作符\"></a>整型的位操作符</h3><p><code>~</code>,<code>&lt;&lt;</code>,<code>&gt;&gt;</code>,<code>&amp;</code>,<code>^</code>,<code>|</code></p>\n<hr>\n<h2 id=\"Funtions\"><a href=\"#Funtions\" class=\"headerlink\" title=\"Funtions\"></a>Funtions</h2><p>以前叫做内建函数，这以后统一为工厂函数。</p>\n<h3 id=\"转换工厂函数\"><a href=\"#转换工厂函数\" class=\"headerlink\" title=\"转换工厂函数\"></a>转换工厂函数</h3><ol>\n<li>bool(obj)</li>\n<li>int(obj,base = 10),(Python3中取消了函数工厂long()，因为逐渐不区分整型和长整型)、</li>\n<li>float(obj)</li>\n<li>complex(str) or complex(real, imag = 0.0)</li>\n</ol>\n<h3 id=\"功能函数\"><a href=\"#功能函数\" class=\"headerlink\" title=\"功能函数\"></a>功能函数</h3><ol>\n<li>abs() 返回绝对值</li>\n<li>coerce(num1, num2) 转换为同一类型并返回元组</li>\n<li>divmod(num1, num2) 除法-取余运算的结合，返回一个元组(num1/num2, num1%num2)</li>\n<li>pow(num1, num2, mod = 1) 幂函数，提供余数时候效率比<code>**</code>高</li>\n<li>round(flt,ndig = 0) 返回最接近原数的整型(浮点型)，可以设置小数点位数<ul>\n<li>int()直接截去小数部分，返回整型</li>\n<li>math.floor()，得到的是最接近原数但小于原数的整型</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"仅用于整型的函数\"><a href=\"#仅用于整型的函数\" class=\"headerlink\" title=\"仅用于整型的函数\"></a>仅用于整型的函数</h3><h4 id=\"进制转化\"><a href=\"#进制转化\" class=\"headerlink\" title=\"进制转化\"></a>进制转化</h4><ol>\n<li>八进制oct()，返回一个对应值的字符串对象</li>\n<li>十进制hex()</li>\n</ol>\n<h4 id=\"ASCII转换函数\"><a href=\"#ASCII转换函数\" class=\"headerlink\" title=\"ASCII转换函数\"></a>ASCII转换函数</h4><ol>\n<li>返回字符串chr()</li>\n<li>返回整型值ord()</li>\n</ol>\n<hr>\n<h2 id=\"其他数字类型\"><a href=\"#其他数字类型\" class=\"headerlink\" title=\"其他数字类型\"></a>其他数字类型</h2><h3 id=\"布尔型\"><a href=\"#布尔型\" class=\"headerlink\" title=\"布尔型\"></a>布尔型</h3><ol>\n<li>布尔型是整型的子类，但不能再被继承而生成他的子类<ul>\n<li><code>True + 100 = 101</code></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"十进制浮点型\"><a href=\"#十进制浮点型\" class=\"headerlink\" title=\"十进制浮点型\"></a>十进制浮点型</h3><p>由于C中二进制浮点型的精度问题，Python提供了十进制浮点型的包</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> decimal <span class=\"keyword\">import</span> Decimal</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"数学相关模块\"><a href=\"#数学相关模块\" class=\"headerlink\" title=\"数学相关模块\"></a>数学相关模块</h2><ol>\n<li>decimal</li>\n<li>array</li>\n<li>math/cmath</li>\n<li>operator</li>\n<li>random<ul>\n<li>randint() 左闭右闭区间</li>\n<li>randrange() range()函数一样，可以传递起始值(默认为0)，步长(默认为1)，超尾(不可缺少)。</li>\n<li>uniform() 几乎和randint一样，只不过返回的是浮点型</li>\n<li>random() 类似于uniform()，只不过下线恒等于0.0，上限恒等于1.0</li>\n<li>choice() 随机返回给定序列的一个元素<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> random <span class=\"keyword\">import</span> randint</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ol>\n<p><a href=\"http://stackoverflow.com/questions/4534438/typeerror-module-object-is-not-callable\" target=\"_blank\" rel=\"noopener\">TypeError: ‘module’ object is not callable</a></p>\n","categories":["Python"],"tags":["Python"]},{"title":"Python入门1-概述","url":"https://applefishsky009.github.io/2016/12/09/Python入门1-概述/","content":"<h2 id=\"风格\"><a href=\"#风格\" class=\"headerlink\" title=\"风格\"></a>风格</h2><h3 id=\"字符\"><a href=\"#字符\" class=\"headerlink\" title=\"字符\"></a>字符</h3><ol>\n<li># 行注释</li>\n<li>‘’’<br>块注释<br>‘’’</li>\n<li>下划线_在解释其中表示最后一个表达式的值。</li>\n<li>反斜杠<code>\\</code>分解一行过长的语句，闭合操作符和三引号字符串可以跨行书写。</li>\n<li><code>“”</code>在线文档</li>\n<li><code>:</code>代码组</li>\n<li><code>；</code>同一行书写多个子句，不提倡这么做。</li>\n<li>_xxx表示变量是私有的，__xxx__对python来说有特殊的含义，普通的变量应当避免这种命名风格。</li>\n<li>Obj.<strong>doc</strong>可以访问模块，类声明，函数声明中第一个没有赋值的字符串。</li>\n</ol>\n<h3 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h3><ol>\n<li>Python对内存中的对象采用引用计数(类似于C++中的智能指针模板<code>shared_ptr</code>)，引用计数减少：<ul>\n<li>本地引用离开其作用范围</li>\n<li>对象别名被显示销毁(<code>del</code>)</li>\n<li>对象的别名被赋值给其他对象</li>\n<li>对象被从一个窗口对象中移除(列表和元组)</li>\n<li>对象本身被销毁</li>\n</ul>\n</li>\n<li><code>del</code>语句会产生两个结果<ul>\n<li>从名称空间中删除变量名</li>\n<li>对象的引用计数减一</li>\n</ul>\n</li>\n<li>python的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器</li>\n</ol>\n<h3 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h3><ol>\n<li>python异常处理：<code>try...except...else...</code></li>\n</ol>\n<hr>\n<h2 id=\"输入与输出\"><a href=\"#输入与输出\" class=\"headerlink\" title=\"输入与输出\"></a>输入与输出</h2><ol>\n<li><p>str = input(‘str1’):不管是数字还是字符，存储方式都为’str’</p>\n</li>\n<li><p>密码输入：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> getpass <span class=\"keyword\">import</span> getpass</span><br><span class=\"line\">password = getpass(str1 = <span class=\"string\">'Password：'</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>print(str)</p>\n<ul>\n<li><code>print(str, end = &#39; &#39;)</code>可以改变默认输出之后接空格而不是回车；</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"python对象\"><a href=\"#python对象\" class=\"headerlink\" title=\"python对象\"></a>python对象</h2><ol>\n<li>身份，内建函数<code>id()</code>访问，看作对象的内存地址</li>\n<li>类型，内建函数<code>type()</code>访问，查看对象类型</li>\n<li>值，数据项</li>\n<li>标准类型<ul>\n<li>Integer 整型(实际上等同于C语言中的长整型)</li>\n<li>Boolean 布尔型</li>\n<li>Long integer 长整型</li>\n<li>Floating point real number 浮点型</li>\n<li>Complex number 复数型</li>\n<li>String字符串</li>\n<li>List 列表</li>\n<li>Tuple 元组</li>\n<li>Dictionary 字典</li>\n</ul>\n</li>\n<li>其他内建类型<ul>\n<li>类型(Python标准类的默认元类，所有标准对象的类型都是type)</li>\n<li>null 对象</li>\n<li>文件</li>\n<li>集合/固定集合</li>\n<li>函数/方法，实际上所有的内建函数都是工厂函数，也就是说实际上他们都是类，调用时生成了该类型的一个实例。</li>\n<li>模块</li>\n<li>类</li>\n</ul>\n</li>\n<li>内部类型<ul>\n<li>compile()得到代码对象</li>\n<li>exec命令或者eval()执行代码对象</li>\n<li>切片对象，步进切片，多维切片</li>\n<li>省略对象用于扩展切片语法中，起记号作用，唯一名字<code>Ellipsis</code>，布尔值始终为<code>true</code>.</li>\n<li>xrange()生成Xrange对象。</li>\n</ul>\n</li>\n<li>数值比较大小，对象比较身份<ul>\n<li>is/is not比较相当于比较id()</li>\n</ul>\n</li>\n<li>python仅缓存简单整型(id相同)，因为他认为这些会被经常用到，浮点型则不会。另外，被缓存的字符串不会永生不灭，没有引用后会被销毁。</li>\n<li>标准类型内建函数<ul>\n<li>type()</li>\n<li>cmp()</li>\n<li>用户友好的字符串str()，python友好的字符串repr()(等同于``运算符)。</li>\n<li>对象身份比较(is)提高效率</li>\n<li>通过导入尽可能精确的包来提高查询次数</li>\n<li><code>isinstance(object,Tuple)</code>来简化<code>if</code>语句或者判断对象类型。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"模型\"><a href=\"#模型\" class=\"headerlink\" title=\"模型\"></a>模型</h2><h3 id=\"存储模型\"><a href=\"#存储模型\" class=\"headerlink\" title=\"存储模型\"></a>存储模型</h3><ol>\n<li>标量/原子类型：数值，字符串(自我包含)</li>\n<li>容器类型：列表，元组，字典</li>\n</ol>\n<h3 id=\"更新模型\"><a href=\"#更新模型\" class=\"headerlink\" title=\"更新模型\"></a>更新模型</h3><ol>\n<li>可变模型：列表，字典</li>\n<li>不可变模型：数字，字符串，元组</li>\n</ol>\n<h3 id=\"访问模型\"><a href=\"#访问模型\" class=\"headerlink\" title=\"访问模型\"></a>访问模型</h3><ol>\n<li>直接访问：数字</li>\n<li>顺序访问：字符串，列表，元组</li>\n<li>映射访问：字典</li>\n</ol>\n<hr>\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><p>import之后help(module)可以查看module的帮助文档<br><a href=\"https://docs.python.org/3/library/index.html\" target=\"_blank\" rel=\"noopener\">标准模块列表</a></p>\n<hr>\n<h2 id=\"分拆代码\"><a href=\"#分拆代码\" class=\"headerlink\" title=\"分拆代码\"></a>分拆代码</h2><ol>\n<li>文件夹和文件名称中不能使用中划线(-)</li>\n<li>尽早组织文件夹，不要将主文件和类文件放在一个文件夹下</li>\n</ol>\n<hr>\n","categories":["Python"],"tags":["Python"]},{"title":"人生天地间，忽如远行客","url":"https://applefishsky009.github.io/2016/12/08/人生天地间，忽如远行客/","content":"<p>找工作终于告一段落，过程虽然历经坎坷，但是结果还不错。拿到了南瑞软件开发，讯飞研究院，华为软件开发，海康研究院的offer。最终还是去杭州海康做算法，和Cathy~小姑凉双宿双栖(●’◡’●)。</p>\n<p>感谢龙老湿，进入大学之后在和他相处的过程中打破了我闭塞的思维。<br>感谢今年和伟健的交流，让我学到了很多。如果说有那么一个人，是自我上大学以来对我影响最大的人，那么一定是伟健！因为他身上有着我之前极度缺乏的一种闪光的品质，那就是<font color=\"red\">脚踏实地</font>。<br>感谢国君，在找工作过程中的相互交流。研究生阶段从他身上学到了很多东西。<br>非常感谢讯飞的师兄BOSS对我的厚爱与照顾，对不能去讯飞还是感到有些遗憾的，毕竟找工作之前唯一的目标就是讯飞。<br>非常感谢牛客网，极大的扩宽了我的眼界。</p>\n<p>忍不住回首2016(虽然不到年底)。</p>\n<p>3月份的动荡，后来买了域名(2017.03.31)写博客记笔记，从WordPress到GitPage，还把之前csdn的内容迁移了部分。</p>\n<p>5，6月份基本是在论文和《C++ Primer Plus》(当时年轻还不懂，应该好好学习《C++ Primer》的)中度过的，还有一部分LeetCode。感谢那段时间枯燥的积累，让我从当初搞不清楚链表指针规律的菜鸟到现在刷LeetCode很流畅。截至昨天，陆陆续续几个月终于刷完了<a href=\"http://www.acmerblog.com/leetcode-solutions-6422.html\" target=\"_blank\" rel=\"noopener\">LeetCode分类题解</a>。感谢那段时间在论文上的付出。</p>\n<p>7月份开始主要是找工作的事情，回想起来找工作面试和同学交流实在是我进步最快的一个阶段，也是最怀疑人生的时期。</p>\n<p>8月份内推，腾讯挂，微店挂。</p>\n<p>9月初讯飞拿到之后松了一口气，懒懒散散继续找。这又是焦虑的一个月。只有滴滴一次面试，挂了。</p>\n<p>10月上旬一面二面招银，10.12面招银。10.13分手，结束了93天的被冷处理，1132天的初恋。并且非常艰难的做出了一个决定，不去讯飞。10.15面百度，二面结果并不好，然后过了三面挂了(虽然挂了，但是我非常欣赏百度的面试官，而且对百度的负面印象也去除了不少)。之后得知之后半年要去无锡培养。然后和家人的关系缓和了很多，决定去南京或者杭州。10月底面试了华为，南瑞。</p>\n<p>11月份，华为可以签南京，但是给我最低价。当时感到非常不满意，但是害怕错过华为就没有机会了，签了华为。当天晚上南瑞就发了，然后得知讯飞给我涨薪了。又是一番纠结要不要违约。11月中旬之前收到海康语音组补录的短信，没抱希望的投了一下，然后错过了两次电话面试，语音组的面试官面试之后说把我推荐给图像组。当时没抱希望，心里想着图像组不一定缺人啊。后来来了无锡，住宿条件真是没得说。打电话要求去杭州面试，这时候依然没抱希望，甚至没有和任何人讲(我家人，Cathy非常希望我去杭州，害怕他们失望)，后来面试完感觉还不错，经过一周的纠结，终于拿到海康研究院的offer，还是做算法的。很开森。然后打算毁约华为签海康，希望一切都能顺利。并且在这一个月中感觉自己的算法能力突破了一个小瓶颈，开心o(<em>￣▽￣</em>)ブ</p>\n<p>12月份，感谢Cathy近两个月在我艰难时期的陪伴，还有好的助攻(●’◡’●)，3号我们在一起了。希望我们有一个幸福的未来。</p>\n<p>最后，十年树木，百年树人。脚踏实地。加油！</p>\n<blockquote>\n<p>青青陵上柏，磊磊涧中石。<br>人生天地间，忽如远行客。<br>斗酒相娱乐，聊厚不为保。<br>驱车策驽马，游戏宛与洛。<br>洛中何郁郁，冠带自相索。<br>长衢罗夹巷，王侯多第宅。<br>两宫遥踵望，双阙百余尺。<br>极宴娱心意，戚戚何所迫?<br>汉 无名氏 《古诗十九首》</p>\n</blockquote>\n","categories":["ryl"],"tags":["ryl"]},{"title":"编写MakeFile","url":"https://applefishsky009.github.io/2016/11/26/编写MakeFile/","content":"<h2 id=\"代码并非越灵活越好\"><a href=\"#代码并非越灵活越好\" class=\"headerlink\" title=\"代码并非越灵活越好\"></a>代码并非越灵活越好</h2><p><a href=\"http://www.zhihu.com/question/52951851\" target=\"_blank\" rel=\"noopener\">把代码写得太灵活不好吗？</a>,总结起来大概有以下几个方面的考量：</p>\n<ol>\n<li>更高的弹性可能增加复杂性，开发/维护成本，代码体积，性能开销等。</li>\n<li>使用复杂性的增加，比如泛型<code>ListNode</code>或<code>TreeNode</code>时需要使用<code>&lt;&gt;</code>携带类型，但平常使用的接口是用得不到的。</li>\n<li>好的代码应该体现在架构设计上，具体到代码片段，反而是简单直白的好。</li>\n<li>KISS - Keep IT Simple,Stupid.</li>\n<li>没有需求不要加功能。</li>\n</ol>\n<hr>\n<h2 id=\"为什么需要MakeFile\"><a href=\"#为什么需要MakeFile\" class=\"headerlink\" title=\"为什么需要MakeFile?\"></a>为什么需要MakeFile?</h2><p>在之前的VSCode介绍中已经配置过使用<code>gdb</code>编译简单短小的c++程序，但是在实际的项目中会有非常多的.h和.cpp文件相互配合，这时候直接通过g++编译可执行文件就会比较复杂，而<code>make</code>这个强大的项目构建工具就能完美的解决这个问题，帮助我们构建和组织项目代码。</p>\n<p>参考资料：<a href=\"http://www.cnblogs.com/zhxilin/p/5881080.html\" target=\"_blank\" rel=\"noopener\">在Linux中使用VS Code编译调试C++项目</a></p>\n<p>可以根据参考资料，将所有的g++指令写在<code>MakeFile</code>中，这样适用于大项目或者小项目。</p>\n<hr>\n<h2 id=\"如何编写MakeFile\"><a href=\"#如何编写MakeFile\" class=\"headerlink\" title=\"如何编写MakeFile?\"></a>如何编写MakeFile?</h2><p>第一节中的参考资料做出了简单的解释，基本语法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target : prerequisites</span><br><span class=\"line\">\tcommand\t#前面必须是tab</span><br></pre></td></tr></table></figure>\n\n<p><code>target</code>可以是：</p>\n<ol>\n<li>目标文件(Object File) :<ul>\n<li><a href=\"http://stackoverflow.com/questions/3045603/what-does-an-object-file-contain\" target=\"_blank\" rel=\"noopener\">What does an object file contain?</a></li>\n<li>即编译，根据需要的.cpp生成.o文件；</li>\n</ul>\n</li>\n<li>可执行文件:<ul>\n<li>即链接，链接所有的.o文件生成.exe文件；</li>\n</ul>\n</li>\n<li>标签：<ul>\n<li>动作名字。在<code>make</code>后指出整个动作的名字即可执行该命令。</li>\n</ul>\n</li>\n</ol>\n<p>举例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">build : main.o init.o</span><br><span class=\"line\">\tg++ -std=c++0x -o build main.o init.o\t</span><br><span class=\"line\">main.o :</span><br><span class=\"line\">\tg++ -std=c++0x -g -c main.cpp </span><br><span class=\"line\">init.o : init.cpp init.h</span><br><span class=\"line\">\tg++ -std=c++0x -g -c init.cpp\t</span><br><span class=\"line\">clean :</span><br><span class=\"line\">\trm main.o init.o build</span><br></pre></td></tr></table></figure>","categories":["VSCode"],"tags":["VSCode"]},{"title":"Windows快捷键","url":"https://applefishsky009.github.io/2016/11/22/Windows快捷键/","content":"<h2 id=\"win键\"><a href=\"#win键\" class=\"headerlink\" title=\"win键\"></a>win键</h2><h3 id=\"win-R-console\"><a href=\"#win-R-console\" class=\"headerlink\" title=\"win + R console\"></a>win + R console</h3><p>在<code>C:/windows/</code>下添加软件的快捷方式，然后重命名一个简单的名字，比如将VsCode重命名为C，然后按<code>win + R</code>打开控制台，输入<code>C</code>即能打开该软件。</p>\n<h3 id=\"常用\"><a href=\"#常用\" class=\"headerlink\" title=\"常用\"></a>常用</h3><ol>\n<li>win + D    //显示桌面</li>\n<li>win + Tab    //多任务视图</li>\n<li>win + M    //最小化所有窗口</li>\n<li>win + shfit + M    //还原最小化窗口到桌面上</li>\n<li>win + home //最小化所有窗口，除了当前窗口</li>\n<li>win + L    //锁定计算机</li>\n<li>win + E    //打开我的电脑？</li>\n</ol>\n<h3 id=\"不常用\"><a href=\"#不常用\" class=\"headerlink\" title=\"不常用\"></a>不常用</h3><ol>\n<li>ctrl + win + F    //查找计算机</li>\n<li>win + G    //打开游戏录制工具</li>\n<li>win + U    //打开轻松使用</li>\n<li>win + T    //切换任务栏上的程序(alt + ESC会直接切换，这个是预览)</li>\n<li>win + P    //分屏屏幕设置</li>\n<li>win + X    //移动中心，计算机管理，磁盘管理等</li>\n<li>win + F    //反馈中心</li>\n<li>win + 上下左右    //最大最小化窗口到上下左右侧的屏幕</li>\n<li>win + S //有问题尽管问我</li>\n</ol>\n<hr>\n<h2 id=\"ctrl-amp-alt\"><a href=\"#ctrl-amp-alt\" class=\"headerlink\" title=\"ctrl &amp; alt\"></a>ctrl &amp; alt</h2><p>ctrl + shift + F//快速简繁体转化<br>alt + CapsLock + ? //软件设置</p>\n<hr>\n<h2 id=\"ctrl-shift\"><a href=\"#ctrl-shift\" class=\"headerlink\" title=\"ctrl + /shift + ?\"></a>ctrl + /shift + ?</h2><p>shift可以反向，例如：</p>\n<ol>\n<li><code>shift + tab</code> 其实并无卵用，开关大小写。</li>\n<li><code>ctrl + shift + z</code> 返回撤销，<code>ctrl + z</code>的返回。</li>\n</ol>\n<hr>\n","categories":["Others"],"tags":["Windows"]},{"title":"Fork解析","url":"https://applefishsky009.github.io/2016/11/10/Fork解析/","content":"<h2 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h2><p>测试：<a href=\"https://github.com/applefishsky009/OperationSystem/tree/master/1-Fork\" target=\"_blank\" rel=\"noopener\">Fork测试</a></p>\n<p>参考unix环境高级编程，主要是测试fork的机制，其中两个函数和一个宏值得注意：</p>\n<h3 id=\"pid-t-pidTmp-fork\"><a href=\"#pid-t-pidTmp-fork\" class=\"headerlink\" title=\"pid_t pidTmp = fork();\"></a><code>pid_t pidTmp = fork();</code></h3><p>创建一个进程(vfork才保证子进程先运行)，id是pidTmp，子进程的返回值是0，父进程的返回值是新建子进程的id，<font color=\"red\">因为父进程无法获得所有子进程的id。</font></p>\n<h3 id=\"pid-waitpid-pidTmp-amp-status-0\"><a href=\"#pid-waitpid-pidTmp-amp-status-0\" class=\"headerlink\" title=\"pid = waitpid(pidTmp,&amp;status,0);\"></a><code>pid = waitpid(pidTmp,&amp;status,0);</code></h3><p>请注意不要在<code>waitpid</code>函数之前判断<code>pidTmp &gt; 0</code>来 在父进程中等待子进程完成。如果指定的进程或进程组不存在，或者参数<code>pidTmp</code>指定的进程不是调用进程的子进程，或者<font color=\"red\">不存在子进程</font>，该函数会出错，<code>status</code>为0，返回值pid为-1(出错)。<br>参考资料：<br><a href=\"http://www.programgo.com/article/85414485023/\" target=\"_blank\" rel=\"noopener\">僵尸进程的产生和避免,以及wait，waitpid的使用</a><br><a href=\"http://blog.csdn.net/mybelief321/article/details/9066359\" target=\"_blank\" rel=\"noopener\">LINUX编程基础之进程等待（WAIT()函数）</a></p>\n<h3 id=\"WEXITSTATUS-status\"><a href=\"#WEXITSTATUS-status\" class=\"headerlink\" title=\"WEXITSTATUS(status)\"></a>WEXITSTATUS(status)</h3><p>如果直接输出<code>status</code>可以看到其与<code>exit()</code>的返回码并不相同，这是由于<code>status</code>主要有三部分组成：</p>\n<ol>\n<li>bits 0-6 为 termination signal;</li>\n<li>bits 7 为 core dump flags;</li>\n<li>bits 8-15 为 exit status;</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\"></th>\n<th align=\"center\"></th>\n<th align=\"center\"></th>\n<th align=\"center\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">status</td>\n<td align=\"center\">0 0 0 0 0 0 0 0</td>\n<td align=\"center\">0</td>\n<td align=\"center\">0 0 0 0 0 0 0</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">bits</td>\n<td align=\"center\">8 - 15</td>\n<td align=\"center\">7</td>\n<td align=\"center\">0 - 6</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">mean</td>\n<td align=\"center\">exit status</td>\n<td align=\"center\">coredump generated</td>\n<td align=\"center\">termination signal</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>因此从<code>status</code>转化到返回码就需要一个宏<code>WEXITSTATUS(status)</code>。</p>\n<p>参考资料：<br><a href=\"http://cs-cjl.com/2015/11_18_linux_process_exit_status\" target=\"_blank\" rel=\"noopener\">关于 Linux 进程结束状态</a></p>\n<hr>\n<h2 id=\"循环中的fork机制\"><a href=\"#循环中的fork机制\" class=\"headerlink\" title=\"循环中的fork机制\"></a>循环中的fork机制</h2><p>参考资料：<a href=\"http://coolshell.cn/articles/7965.html\" target=\"_blank\" rel=\"noopener\">一个fork的面试题</a><br>测试：<a href=\"https://github.com/applefishsky009/OperationSystem/blob/master/1-Fork/fork2.cpp\" target=\"_blank\" rel=\"noopener\">Fork in Loop测试</a></p>\n<p>参考资料讲得非常好。除了进程示意图，还有一点非常重要，<font color=\"red\">标准输出是行缓冲，所以遇到<code>\\n</code>的时候会刷出缓冲区</font>，如果不想见到<code>\\n</code>也可以使用<a href=\"http://www.cplusplus.com/reference/ostream/flush-free/?kw=flush\" target=\"_blank\" rel=\"noopener\">std::flush</a>将数据刷出缓冲区，另外，一个进程退出时也会将数据刷出缓冲区。</p>\n<p>根据以上规则,另外已知<code>fork()</code>能拷贝缓冲区，很容易就推出(假设循环次数为2,也就是说应该输出6个字符)：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">......</span><br><span class=\"line\"><span class=\"keyword\">if</span> (pid &gt; <span class=\"number\">0</span>) <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"B\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;\t<span class=\"comment\">//主进程</span></span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"A\"</span> ;</span><br><span class=\"line\">......</span><br><span class=\"line\">输出：</span><br><span class=\"line\">AAAB\t<span class=\"comment\">//第一个子进程A保留在缓冲区被fork，到达第二次循环就会这么输出</span></span><br><span class=\"line\">B\t<span class=\"comment\">//主进程的B</span></span><br><span class=\"line\">AB\t<span class=\"comment\">//主进程在第二次循环中的输出</span></span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\"><span class=\"keyword\">if</span> (pid &gt; <span class=\"number\">0</span>) <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"B\"</span>;\t<span class=\"comment\">//主进程</span></span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"A\"</span>;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"comment\">//cout &lt;&lt; flush;</span></span><br><span class=\"line\">......</span><br><span class=\"line\">输出：</span><br><span class=\"line\">AA</span><br><span class=\"line\">AB</span><br><span class=\"line\">BA</span><br><span class=\"line\">BB</span><br><span class=\"line\"><span class=\"comment\">//AAABBABB\t</span></span><br><span class=\"line\"><span class=\"comment\">//在第一次循环中都没有输出，fork在子进程第二次循环</span></span><br><span class=\"line\"></span><br><span class=\"line\">......</span><br><span class=\"line\"><span class=\"keyword\">if</span> (pid &gt; <span class=\"number\">0</span>) <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"B\"</span> &lt;&lt; <span class=\"built_in\">flush</span>;<span class=\"comment\">// &lt;&lt; endl\t//主进程</span></span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"A\"</span> &lt;&lt; <span class=\"built_in\">flush</span>;<span class=\"comment\">// &lt;&lt; endl;</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"comment\">//cout &lt;&lt; flush;</span></span><br><span class=\"line\">......</span><br><span class=\"line\">标准输出：</span><br><span class=\"line\">AABBAB</span><br><span class=\"line\"><span class=\"comment\">//A</span></span><br><span class=\"line\"><span class=\"comment\">//A</span></span><br><span class=\"line\"><span class=\"comment\">//B</span></span><br><span class=\"line\"><span class=\"comment\">//B</span></span><br><span class=\"line\"><span class=\"comment\">//A</span></span><br><span class=\"line\"><span class=\"comment\">//B</span></span><br><span class=\"line\"><span class=\"comment\">//理论上的标准输出。</span></span><br></pre></td></tr></table></figure>\n\n<p>因此可以得到结论：</p>\n<ol>\n<li>如果不是需要用<code>fork()</code>拷贝缓冲区的特性，最好在<code>fork()</code>之前<code>flush</code>(刷出缓冲区)，其标准输出是\\( 2^1+….+2^{loopCount} \\)</li>\n<li>如果没有<code>flush</code>没有<code>endl(即\\n)</code>，他的输出次数是\\( 2^{loopCount}*loopCount \\)</li>\n<li>如果子进程和父进程的输出缓冲规则不一致，一个有<code>endl</code>一个没有<code>endl</code>，总数一定为\\( (2^{loopCount}*loopCount+2^1+….+2^{loopCount})/2 \\)，即上述两种情况的平均值。</li>\n<li>如果没有刷出缓存(<code>flush</code>或<code>\\n</code>),但只输出了6个(理论上是8个),考虑到断点设置导致的后先调用的父进程的缓冲区没有刷出，因此会缺少。</li>\n</ol>\n<p>$$ $$</p>\n<hr>\n","categories":["操作系统"],"tags":["Linux"]},{"title":"VSCode使用指南","url":"https://applefishsky009.github.io/2016/11/09/VSCode使用指南/","content":"<h2 id=\"快捷键修改\"><a href=\"#快捷键修改\" class=\"headerlink\" title=\"快捷键修改\"></a>快捷键修改</h2><p><a href=\"https://code.visualstudio.com/docs/customization/keybindings\" target=\"_blank\" rel=\"noopener\">Key Bindings</a><br>由于经常使用<strong>打开文件夹</strong>功能，文件 —&gt; 首选项 -&gt; 键盘快捷方式，然后在<code>keybindings.json</code>中添加：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    &#123; <span class=\"attr\">\"key\"</span>: <span class=\"string\">\"ctrl+a\"</span>,                <span class=\"attr\">\"command\"</span>: <span class=\"string\">\"workbench.action.files.openFolder\"</span> &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>注：<code>command id</code>不知如何对应，这一条是根据打开文件的设置修改测试而来。</p>\n<p><a href=\"https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf\" target=\"_blank\" rel=\"noopener\">VSCode KeyBindings.pdf</a></p>\n<hr>\n<h2 id=\"Ctrl-shift-P模式-主命令框\"><a href=\"#Ctrl-shift-P模式-主命令框\" class=\"headerlink\" title=\"Ctrl + shift + P模式(主命令框)\"></a>Ctrl + shift + P模式(主命令框)</h2><p>调出命令列表，查看所有的命令/快捷键;<code>ctrl + P</code>模式和他可以切换(<code>&gt;</code>和<code>BackSpace</code>)</p>\n<ol>\n<li><strong>alt</strong><ul>\n<li>显示菜单栏(上方)，平时可以在这个模式下输入<code>view: toggle Mebu Bar</code>来切换正常状态下菜单栏是隐藏的还是显示的;</li>\n</ul>\n</li>\n<li><strong>Toggle Activity Bar Visibility</strong><ul>\n<li>切换活动栏显隐性(左方)，参考资料<a href=\"https://www.zhihu.com/question/48285162\" target=\"_blank\" rel=\"noopener\">vscode怎么隐藏左边栏？</a></li>\n</ul>\n</li>\n<li><strong>Conf</strong><ul>\n<li><a href=\"http://colobu.com/2016/04/21/use-vscode-to-develop-go-programs/\" target=\"_blank\" rel=\"noopener\">调整本地语言</a></li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"Ctrl-P模式\"><a href=\"#Ctrl-P模式\" class=\"headerlink\" title=\"Ctrl + P模式\"></a>Ctrl + P模式</h2><ol>\n<li>输入<code>&gt;</code>回到主命令框<code>ctrl + shift + p</code>模式；</li>\n<li>直接输入文件名打开文件(可以用<code>ctrl + o</code>打开文件)；</li>\n<li><code>?</code>显示当前可执行操作；</li>\n<li><code>:</code>跳转到行数；</li>\n<li><code>ctrl + shift + m</code>显示errors或warnings(<code>!</code>模式不能用？);</li>\n<li><code>@</code>查找变量(全局)或函数<code>ctrl + shift + o</code>进入。</li>\n<li><code>@:</code>查找函数或者属性。</li>\n<li><code>#</code>查找符号；<ul>\n<li>比<code>ctrl + F</code>更细化。</li>\n</ul>\n</li>\n<li><strong>ctrl + q</strong><ul>\n<li>Quick Open,相当于在<strong>ctrl + p</strong>模式下输入<code>view</code>。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"编辑器和窗口管理\"><a href=\"#编辑器和窗口管理\" class=\"headerlink\" title=\"编辑器和窗口管理\"></a>编辑器和窗口管理</h2><h3 id=\"同时打开多个窗口\"><a href=\"#同时打开多个窗口\" class=\"headerlink\" title=\"同时打开多个窗口\"></a>同时打开多个窗口</h3><ol>\n<li><strong>ctrl + shift + N</strong><ul>\n<li>打开新的窗口，注意markdown打开新窗口的快捷键也是这个(虽然没有卵用)，chrome打开新窗口的快捷键是<code>ctrl + N</code>,<code>ctrl + shift + N</code>可以打开新窗口并进入隐身模式。</li>\n</ul>\n</li>\n<li><strong>ctrl + shift + W</strong><ul>\n<li>关闭当前窗口。</li>\n</ul>\n</li>\n<li><strong>ctrl + alt + up/down</strong><ul>\n<li>屏幕向上/向下。 </li>\n</ul>\n</li>\n</ol>\n<h3 id=\"同时打开多个编辑器\"><a href=\"#同时打开多个编辑器\" class=\"headerlink\" title=\"同时打开多个编辑器\"></a>同时打开多个编辑器</h3><ol>\n<li>** ctrl + N**<ul>\n<li>新建文件。</li>\n</ul>\n</li>\n<li>** ctrl + tab, alt + left, alt + right**<ul>\n<li>打开文件之间的切换(<code>ctrl + tab</code>)。</li>\n</ul>\n</li>\n<li>** ctrl + **<ul>\n<li>切出一个新的编辑器(最多三个)，也可以<code>ctrl</code> + 点击Explore里边的文件名。</li>\n</ul>\n</li>\n<li>** ctrl + k** + <strong>left/right</strong><ul>\n<li>编辑器换位置。</li>\n</ul>\n</li>\n<li>** ctrl + `**<ul>\n<li>打开集成终端，比如<code>make clean</code>就可以在这里输入，<code>cls</code>指令可以清理屏幕。</li>\n</ul>\n</li>\n<li>** 改变默认的集成终端 **<ul>\n<li><a href=\"https://github.com/Microsoft/vscode/issues/11785\" target=\"_blank\" rel=\"noopener\">Add Powershell as integrated terminal in VSC for Windows?</a></li>\n<li>Put this in your user settings.json:<code>&quot;terminal.integrated.shell.windows&quot;: &quot;\\\\WINDOWS\\\\system32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe&quot;</code>。</li>\n</ul>\n</li>\n<li><strong>ctrl + shift + u</strong><ul>\n<li>打开输出面板</li>\n</ul>\n</li>\n<li><strong>win + k</strong><ul>\n<li>清除终端窗口。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"代码编辑\"><a href=\"#代码编辑\" class=\"headerlink\" title=\"代码编辑\"></a>代码编辑</h2><h3 id=\"格式调整\"><a href=\"#格式调整\" class=\"headerlink\" title=\"格式调整\"></a>格式调整</h3><ol>\n<li><strong>ctrl + \\</strong><ul>\n<li>拆分编辑器。<code>ctrl + 1</code>,<code>ctrl + 2</code>,<code>ctrl + 3</code>左中右三个编辑器的快捷键。</li>\n</ul>\n</li>\n<li><strong>alt + shift + F</strong><ul>\n<li>代码段自动对齐！！！</li>\n</ul>\n</li>\n<li><strong>ctrl + /</strong><ul>\n<li>注释光标所在行。</li>\n</ul>\n</li>\n<li><strong>alt + up/down</strong><ul>\n<li>将光标所在的代码上移或者下移一行。</li>\n</ul>\n</li>\n<li><strong>shift + alt + up/down</strong><ul>\n<li>向上向下复制一行。</li>\n</ul>\n</li>\n<li><strong>ctrl + enter</strong><ul>\n<li>在当前行下方插入一行。</li>\n</ul>\n</li>\n<li><strong>ctrl + shift + enter</strong><ul>\n<li>在当前行上方插入一行。</li>\n</ul>\n</li>\n<li><strong>ctrl + shift + [/]</strong><ul>\n<li>打开/折叠代码块。</li>\n</ul>\n</li>\n<li><strong>ctrl + [/]</strong><ul>\n<li>代码行缩进(注意很方便的一点就是光标不需要在这一行首)。</li>\n</ul>\n</li>\n<li><strong>ctrl + c/v</strong><ul>\n<li>如果不选中，默认复制或者粘贴一整行。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"光标相关\"><a href=\"#光标相关\" class=\"headerlink\" title=\"光标相关\"></a>光标相关</h3><ol>\n<li><strong>home/end</strong><ul>\n<li>移动到行首/行尾。</li>\n</ul>\n</li>\n<li><strong>ctrl + home/end</strong><ul>\n<li>移动到文件开头/结尾。</li>\n</ul>\n</li>\n<li><strong>ctrl + i</strong><ul>\n<li>选中当前行。</li>\n</ul>\n</li>\n<li><strong>shift + home/end</strong>\\<ul>\n<li>选中从光标处到行首/行尾。</li>\n</ul>\n</li>\n<li><strong>ctrl + delete</strong><ul>\n<li>删除光标右侧所有的字(以单词为单位)。</li>\n</ul>\n</li>\n<li><strong>ctrl + shift + l</strong><ul>\n<li>同时选中所有匹配的( = <strong>ctrl + F2</strong>)。</li>\n</ul>\n</li>\n<li><strong>ctrl + u</strong><ul>\n<li>回退上一个光标操作。</li>\n</ul>\n</li>\n<li><strong>ctrl + d</strong><ul>\n<li>下一个匹配的也被选中。</li>\n</ul>\n</li>\n<li><strong>ctrl + shift + left/right</strong><ul>\n<li>光标的左右扩展。</li>\n</ul>\n</li>\n<li><strong>alt + click</strong><ul>\n<li>添加多个光标，连续选择多处一起修改。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"重构代码\"><a href=\"#重构代码\" class=\"headerlink\" title=\"重构代码\"></a>重构代码</h3><ol>\n<li><strong>F5</strong><ul>\n<li>调试。</li>\n</ul>\n</li>\n<li><strong>F9</strong><ul>\n<li>加断点。</li>\n</ul>\n</li>\n<li><strong>F10</strong><ul>\n<li>逐行运行。</li>\n</ul>\n</li>\n<li><strong>F11</strong><ul>\n<li>进入该行的函数内部调试(step into)。</li>\n</ul>\n</li>\n<li><strong>F12</strong><ul>\n<li>跳转到定义处。</li>\n</ul>\n</li>\n<li><strong>alt + F12</strong><ul>\n<li>预览定义而不是跳转。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"查找和替换\"><a href=\"#查找和替换\" class=\"headerlink\" title=\"查找和替换\"></a>查找和替换</h3><ol>\n<li><strong>ctrl + F/H</strong><ul>\n<li>查找/替换。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"显示相关\"><a href=\"#显示相关\" class=\"headerlink\" title=\"显示相关\"></a>显示相关</h3><ol>\n<li><strong>F11</strong><ul>\n<li>全屏。</li>\n</ul>\n</li>\n<li><strong>ctrl + =/-</strong><ul>\n<li>视距放大/缩小(Zoom In/Out)。</li>\n</ul>\n</li>\n<li><strong>ctrl + b</strong><ul>\n<li>侧边栏显/隐。</li>\n</ul>\n</li>\n<li><strong>ctrl + shift + e/f/g/d/x</strong><ul>\n<li>侧边栏五大功能，资源管理器/搜索/git/调试/扩展。</li>\n</ul>\n</li>\n<li><strong>ctrl + shift + v</strong><ul>\n<li>预览<code>markdown</code>。</li>\n</ul>\n</li>\n<li><strong>ctrl + shift + u</strong><ul>\n<li>显示输出窗口。</li>\n</ul>\n</li>\n<li><strong>ctrl + K Z</strong><ul>\n<li>window.fullScreenZenMode,(更好的代码，阅读模式)。</li>\n</ul>\n</li>\n</ol>\n<p>参考资料：<br><a href=\"http://www.jianshu.com/p/1b7b8760504c\" target=\"_blank\" rel=\"noopener\">Vscode中一些方便的快捷键</a><br><a href=\"https://nshen.net/article/2015-11-20/vscode/\" target=\"_blank\" rel=\"noopener\">学会用好 Visual Studio Code</a></p>\n<hr>\n<h2 id=\"皮肤预留\"><a href=\"#皮肤预留\" class=\"headerlink\" title=\"皮肤预留\"></a>皮肤预留</h2><p>在<strong>ctrl + shift + p</strong>模式下输入<code>theme</code>选择文件图标主题韩式编译器颜色主题，然后上下移动光标可以预览。</p>\n<hr>\n<h2 id=\"强大的自定义用户代码块\"><a href=\"#强大的自定义用户代码块\" class=\"headerlink\" title=\"强大的自定义用户代码块\"></a>强大的自定义用户代码块</h2><p>在 文件 -&gt; 首选项 -&gt; 用户代码片段 -&gt; 选择语言，配置弹出的<code>.json</code>可以自定义用户代码块块，比如我的配置的一部分：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//add Ryl module</span></span><br><span class=\"line\">\"include RylModule\": &#123;</span><br><span class=\"line\">\t\"prefix\": \"#include\",</span><br><span class=\"line\">\t\"body\": [</span><br><span class=\"line\">\t\t\t\"#include &lt;E:\\\\RylModule\\\\show.h&gt;\\n\",\t//单斜杠转义，比如\\n</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"$1\"</span>\t<span class=\"comment\">//$id(id = 1,2,...)表示插入代码块后可快速编辑的位置，可用tab切换</span></span><br><span class=\"line\">\t],</span><br><span class=\"line\">\t\"description\": \"RylModule\"</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>参考资料：<a href=\"http://www.jianshu.com/p/85e707cc5c5c\" target=\"_blank\" rel=\"noopener\">Visual Studio Code自定义用户代码块</a></p>\n<hr>\n<h2 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h2><ol>\n<li>File &gt; Preferences &gt; Keymap Extensions.<ul>\n<li>键盘映射扩展。</li>\n</ul>\n</li>\n<li>cannot read property ‘substring’ of undefined<ul>\n<li>最简单的解决方案，在文件最后加一行空的代码。</li>\n</ul>\n</li>\n<li>expected unqualified-id before ‘int’ || expected primary-expression before ‘union’<ul>\n<li>这是由一些变量有歧义造成的，也许有自定义的变量和std名称空间冲突。</li>\n</ul>\n</li>\n</ol>\n<hr>\n","categories":["VSCode"],"tags":["VSCode"]},{"title":"queue容器简介","url":"https://applefishsky009.github.io/2016/09/07/queue容器简介/","content":"<h2 id=\"queue\"><a href=\"#queue\" class=\"headerlink\" title=\"queue\"></a>queue</h2><p>这个是简单的FIFO，不需要多说。</p>\n<hr>\n<h2 id=\"priority-queue\"><a href=\"#priority-queue\" class=\"headerlink\" title=\"priority_queue\"></a>priority_queue</h2><p>他支持的操作与<code>queue</code>相同，唯一的区别在于最大/最小的元素被移动到队首,甚至可以自定义其比较的方式，这是通过对<code>&lt;</code>的运算符重载来实现的；比如最常用的结构体排序方式。<br>详细用法参考<a href=\"http://www.cplusplus.com/reference/queue/priority_queue/\" target=\"_blank\" rel=\"noopener\">cplusplus - priority_queue</a>,主要是构造函数，最常用的模式(只提供模板参数)：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span> <span class=\"title\">Container</span> = <span class=\"title\">vector</span>&lt;T&gt;,</span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"title\">class</span> <span class=\"title\">Compare</span> = <span class=\"title\">less</span>&lt;typename Container::value_type&gt; &gt; <span class=\"title\">class</span> <span class=\"title\">priority_queue</span>;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><code>class</code>:元素类型</li>\n<li><code>Container</code>:容器类型</li>\n<li><code>Compare</code>:二元谓词，可以用STL提供，预定义的关系函数符。可以是函数指针或者函数对象，默认是<code>less&lt;T&gt;</code>，在<code>functional</code>头文件里,可以查看<a href=\"http://www.cplusplus.com/reference/functional/\" target=\"_blank\" rel=\"noopener\">functional</a></li>\n</ol>\n<p>结构体<code>less</code>函数符的关系运算符<code>&lt;</code>重写(因为是调用<code>&lt;</code>的)：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> b;</span><br><span class=\"line\">\tnode(<span class=\"keyword\">int</span> ina,<span class=\"keyword\">int</span> inb):a(ina),b(inb)&#123;&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span> &lt; (<span class=\"keyword\">const</span> node &amp;tmp) <span class=\"keyword\">const</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> b &gt; tmp.b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>举例：</p>\n<ol>\n<li><a href=\"https://github.com/applefishsky009/FunnyIssues/blob/master/7%20-%20SJF/6%20-%20SJF.cpp\" target=\"_blank\" rel=\"noopener\">最短时间作业SJF - GitHub</a></li>\n</ol>\n","categories":["STL"],"tags":["C++"]},{"title":"页置换算法FIFO和LRU","url":"https://applefishsky009.github.io/2016/08/29/页置换算法FIFO和LRU/","content":"<h2 id=\"FIFO页置换算法\"><a href=\"#FIFO页置换算法\" class=\"headerlink\" title=\"FIFO页置换算法\"></a>FIFO页置换算法</h2><p>这是最简单的页置换算法。</p>\n<p>用一个FIFO队列来管理内存中的所有页，队列中的首页会被置换。需要调入页时，将他加入到队列的尾部；<br>实现思想如下：</p>\n<ol>\n<li>使用<code>vector</code>模拟维护一个队列记录页调入的顺序(这样可以建立页(key)和迭代器的哈希映射)；</li>\n<li>调入页时，<code>map</code>的<code>capacity</code>未满(即内存的页容量)，建立<code>map</code>，页信息入队列，建立迭代器映射；</li>\n<li>更新页时，队列<code>pop()</code>(即先调入的先更新)，然后根据<code>pop()</code>的这个页信息置换内存中对应的页。</li>\n</ol>\n<p>对于FIFO页置换算法，有一个难以置信的结果：<br>Belady异常：对有的页置换算法，页错误率可能会随着所分配的帧数的增加而增加，而期望进程增加内存可以改善性能。</p>\n<hr>\n<h2 id=\"LRU页置换算法\"><a href=\"#LRU页置换算法\" class=\"headerlink\" title=\"LRU页置换算法\"></a>LRU页置换算法</h2><p>最优页置换算法：置换最长时间不会使用的页，确保对于给定数量的帧会产生最低可能的页错误率。<br>LRU算法将过去最近作为不远将来的近似，置换最长时间没有使用的页，即最近最少使用算法。</p>\n<p>有两种可行实现：</p>\n<ol>\n<li>计数器 - 页关联时间域；</li>\n<li>栈 - 页码栈；</li>\n</ol>\n<p>可以用双向链表来管理内存中的所有页，可以在O(1)的时间内查找，而且双向链表的插入和删除效率高；<br>实现思想如下：</p>\n<ol>\n<li>使用<code>list</code>维护一个双向链表按顺序记录最近使用的页信息(建立页(key)和迭代器的哈希映射)；</li>\n<li>调入页时，<code>map</code>的<code>capacity</code>未满(即内存的页容量)，建立<code>map</code>，页信息插入双向链表首端，建立迭代器映射；</li>\n<li>更新页时，<code>map</code>中如果有页信息，调整双向链表顺序是该页信息位于链表首端，如果没有页信息，删除双向链表尾端(最近最少使用的页)，将该页信息插入双向链表首端。</li>\n</ol>\n<hr>\n<h2 id=\"近似LRU页置换-二次机会页置换算法\"><a href=\"#近似LRU页置换-二次机会页置换算法\" class=\"headerlink\" title=\"近似LRU页置换 - 二次机会页置换算法\"></a>近似LRU页置换 - 二次机会页置换算法</h2><p>很少有计算机能提供足够的硬件来支持真正的LRU页置换。因此必须使用其他页置换算法。</p>\n<p>对于内存中的页保留引用位(引用位是0或1)，采用循环队列。当需要置换一个帧时，指针向前直到找到一个引用位为0的页，向前移动时，清除引用位，引用位在其访问的时候设置为1。</p>\n<hr>\n<p>参考资料：</p>\n<ol>\n<li><a href=\"https://leetcode.com/problems/lru-cache/\" target=\"_blank\" rel=\"noopener\">LeetCode - 146. LRU Cache</a> - 解答：<a href=\"https://github.com/applefishsky009/LeetCode/blob/master/146%20-%20LRU%20Cache/146%20-%20LRU%20Cache.cpp\" target=\"_blank\" rel=\"noopener\">146 - LRU Cache</a>;</li>\n<li>操作系统概念,Peter Bare Galvin等.</li>\n</ol>\n","categories":["操作系统"],"tags":["Linux"]},{"title":"进程与线程","url":"https://applefishsky009.github.io/2016/08/27/进程与线程/","content":"<p>简单来讲，进程是执行中的程序，他是现代分时系统的工作单元，而线程是CPU利用的基本单元，他与同一进程的其他进程共享代码段，数据段和其他操作系统资源。</p>\n<hr>\n<h2 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h2><ol>\n<li>进程可能包含：<ul>\n<li>程序代码，即文本段；</li>\n<li>当前活动(程序计数器的值和处理器寄存器内容)；</li>\n<li>进程栈(临时数据，如函数参数、返回地址、局部变量)；</li>\n<li>数据段(全局变量)；</li>\n<li>堆(进程运行期间动态分配的内存)；</li>\n</ul>\n</li>\n</ol>\n<p>可以看到，程序本身不是进程；程序是被动实体，而进程是活动实体。</p>\n<ol start=\"2\">\n<li>进程状态：<ul>\n<li>新建；</li>\n<li>运行；</li>\n<li>等待；</li>\n<li>就绪；</li>\n<li>终止。</li>\n</ul>\n</li>\n</ol>\n<p>注意等待I/O操作或时间完成时进程阻塞，必须转到就绪状态通过调度算法分配才能进入运行状态；</p>\n<ol start=\"3\">\n<li>进程间通信有两种模型：<ul>\n<li>共享内存；</li>\n<li>消息传递(信号与信号量，管道与命名管道，消息队列，socket等)；</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><ol>\n<li>线程的优点：<ul>\n<li>响应度高(部分阻塞不影响其他部分)；</li>\n<li>资源共享(线程共享所属进程内存和资源)；</li>\n<li>经济(创建和切换更经济)；</li>\n<li>多处理器体系结构的利用(多线程加强并发功能)；</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"进程与线程关系总结\"><a href=\"#进程与线程关系总结\" class=\"headerlink\" title=\"进程与线程关系总结\"></a>进程与线程关系总结</h2><ol>\n<li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个进程；</li>\n<li>资源分配给进程，同一进程的所有线程共享该进程的所有资源；</li>\n<li>处理器分给线程，即真正在处理器上运行的是线程；</li>\n<li>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</li>\n</ol>\n<p>参考资料：</p>\n<ol>\n<li><a href=\"http://www.jianshu.com/p/9218692cb209\" target=\"_blank\" rel=\"noopener\">线程间的通信、同步方式与进程间通信方式</a></li>\n<li>操作系统概念,Peter Bare Galvin等.</li>\n<li><a href=\"https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B%E9%96%93%E9%80%9A%E8%A8%8A\" target=\"_blank\" rel=\"noopener\">维基百科 - 进程间通信</a></li>\n</ol>\n","categories":["操作系统"],"tags":["Linux"]},{"title":"static的作用","url":"https://applefishsky009.github.io/2016/08/25/static的作用/","content":"<p>首先，<code>static</code>和<code>auto</code>(这里不是自动类型推断，隐式的表示由程序自动控制)是一对成对的关键字,来控制变量的生命周期;</p>\n<p>static可以修饰变量和函数，首先抛出结论：</p>\n<ol>\n<li>限制变量的作用域；</li>\n<li>改变变量的生命周期；</li>\n<li>可以在头文件中定义并初始化，并包含在多个.c文件中，但他们不是同一个变量，只是拷贝。</li>\n<li><a href=\"http://www.jianshu.com/p/e0a444ce533d\" target=\"_blank\" rel=\"noopener\">参考资料</a></li>\n</ol>\n<hr>\n<h2 id=\"static修饰变量\"><a href=\"#static修饰变量\" class=\"headerlink\" title=\"static修饰变量\"></a>static修饰变量</h2><h3 id=\"限制变量作用域\"><a href=\"#限制变量作用域\" class=\"headerlink\" title=\"限制变量作用域\"></a>限制变量作用域</h3><ol>\n<li>如果<code>static</code>不在任何代码块内，这是非局部静态变量，其作用域是整个文件(即实现文件级别的数据封装)，具有内部链接性，功能相当于匿名命名空间，整个文件共享变量；</li>\n<li>若将变量定义在代码块内，这是局部静态变量，就将其作用域限制在代码块中(将数据只暴露给需要的人)，可以统计代码块执行次数。</li>\n<li><a href=\"https://www.zhihu.com/question/22705286\" target=\"_blank\" rel=\"noopener\">参考资料</a></li>\n</ol>\n<h3 id=\"改变变量的生命周期\"><a href=\"#改变变量的生命周期\" class=\"headerlink\" title=\"改变变量的生命周期\"></a>改变变量的生命周期</h3><ol>\n<li>全局变量，非局部静态变量，类的静态成员变量在<code>main()</code>执行之前的静态初始化过程中分配内存并初始化(类的静态成员变量使用类的作用于解析符初始化)；</li>\n<li>局部静态变量在第一次使用时分配内存并初始化，这里的变量包含内置数据类型和自定义数据类型。</li>\n<li><a href=\"https://segmentfault.com/q/1010000004157283\" target=\"_blank\" rel=\"noopener\">参考资料</a></li>\n</ol>\n<h3 id=\"头文件中定义static静态变量的利弊\"><a href=\"#头文件中定义static静态变量的利弊\" class=\"headerlink\" title=\"头文件中定义static静态变量的利弊\"></a>头文件中定义static静态变量的利弊</h3><ol>\n<li>静态全局变量只应该定义在实现文件中，但有时由于一些特殊的目的，也可能定义在头文件中。比如在有些标准库的实现中，就用这种方法来初始化标准流cin, cout，或者在在tr1库中，也用这种方法来定义占位符。每一个包含该头文件的实现文件中都拥有该变量的一份拷贝，这些变量放在运行体的data段或者bss段。</li>\n</ol>\n<hr>\n<h2 id=\"static修饰函数\"><a href=\"#static修饰函数\" class=\"headerlink\" title=\"static修饰函数\"></a>static修饰函数</h2><h3 id=\"类的静态函数\"><a href=\"#类的静态函数\" class=\"headerlink\" title=\"类的静态函数\"></a>类的静态函数</h3><ol>\n<li><code>static</code>是声明型关键字，即定义时不需要使用这个关键字；</li>\n<li>类的静态函数是在该类的范畴内的全局函数，不能访问类的私有成员，只能访问类的静态成员，不需要类的实例即可调用(通过类作用域解析符)；</li>\n<li>一般情况下静态成员函数用于访问同一类中的静态数据成员或全局变量，而不访问非静态成员，如需访问非静态成员，需要将对象作为参数，通过对象名访问该对象的非静态成员。静态成员函数也可以在类外定义，此时不可以用<code>static</code>修饰。静态成员函数存在的原因是什么呢？<font color=\"red\">主要是在建立任何对象之前可用它来访问静态数据成员，普通函数不能实现此功能</font>。普通成员函数可以访问普通数据与静态数据。</li>\n<li>静态成员函数可以继承和覆盖,但无法是虚函数。</li>\n<li><a href=\"http://blog.sina.com.cn/s/blog_78c5ff950102vl8g.html\" target=\"_blank\" rel=\"noopener\">参考资料</a></li>\n</ol>\n<h3 id=\"全局函数\"><a href=\"#全局函数\" class=\"headerlink\" title=\"全局函数\"></a>全局函数</h3><ol>\n<li>这是一种干扰保护机制，不用担心与其他文件的同名函数产生干扰，对函数本身也是一种保护机制。</li>\n</ol>\n<hr>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>至此，<code>static</code>的四种主要情况均已说明，简单总结：</p>\n<ol>\n<li>全局静态变量：全局(频繁使用时效率高，但一直占用内存)，内部链接性；</li>\n<li>局部静态变量：限制作用域，将变量只暴露给需要的块；</li>\n<li>全局静态函数：干扰保护，内部链接性；</li>\n<li>类的静态函数：在对象建立之前访问静态数据成员。</li>\n</ol>\n","categories":["C++基础"],"tags":["C++"]},{"title":"线性约束条件下的函数最优解","url":"https://applefishsky009.github.io/2016/08/07/线性约束条件下的函数最优解/","content":"<p>受同学所托，解决线性约束下的函数最小值问题，这在之前也经常碰到，是个非常有趣的问题。之后使用matlab的<code>fmincon()</code>函数解决。给出解决过程和方案。</p>\n<hr>\n<h2 id=\"fmincon\"><a href=\"#fmincon\" class=\"headerlink\" title=\"fmincon\"></a>fmincon</h2><p>当然，任何语言，包括其函数，方法，说明文档至关重要。<br>这个函数用来查找 约束的非线性多变量函数的最小值 ，线性多变量函数也可以解决；<br>使用方法可以查看文档中的EXAMPLE(在<code>MATLAB Command Window</code>中输入<code>help fmincon</code>,然后点击最后的<code>doc fmincon</code>就可以看到函数说明文档)。</p>\n<hr>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>设函数：<br>f = 0<em>x1+20</em>x2+15<em>x3+15</em>x4+24<em>x5+0</em>x6+0<em>x7+2</em>x8+2<em>x9+2</em>x10+4<em>x11+5</em>x12；(12个变量)<br>约束条件为：</p>\n<ol>\n<li>x1-x12均大于等于零；</li>\n<li>x1+x3+x5&lt;=80;x7+x9+x11&lt;=200;</li>\n<li>x2+x4+x6&lt;=100;x8+x10+x12&lt;=300;</li>\n<li>0.9*x1+0.95*x2&gt;=20;0.98*x7+0.9*x8&gt;=80;</li>\n<li>0.9*x3+0.95*x4&gt;=25;0.98*x9+0.9*x10&gt;=100;</li>\n<li>0.9*x5+0.95*x6&gt;=22;0.98*x11+0.9*x12&gt;=95;</li>\n</ol>\n<p>计算步骤如下：</p>\n<ol>\n<li>写Function函数文件；</li>\n<li>写约束条件左矩阵(将约束条件转化为小于等于的约束)；</li>\n<li>写约束条件右值(常量)；</li>\n<li>调用fmincon函数.</li>\n</ol>\n<p>这个问题的答案是：<br>当取值为66.4 0 0 26.3 0 26.4 89.6 0 102.0 0 0 121.2<br>最小值为598.82</p>\n<p>源代码见这里<a href=\"https://github.com/applefishsky009/Math/tree/master/3%20-%20Function%20Solution%20with%20Linear%20Constraints\" target=\"_blank\" rel=\"noopener\">Function Solution with Linear Constraints</a></p>\n","categories":["Math"],"tags":["Math"]},{"title":"二叉树","url":"https://applefishsky009.github.io/2016/08/05/二叉树/","content":"<p>二叉树的题目见过太多了，有必要专门开一个帖子记录解决二叉树问题的过程。之前解决的很多问题复习的时候会逐一添加。</p>\n<hr>\n<h3 id=\"根据前序遍历的次序将二叉树变为就地链表\"><a href=\"#根据前序遍历的次序将二叉树变为就地链表\" class=\"headerlink\" title=\"根据前序遍历的次序将二叉树变为就地链表\"></a>根据前序遍历的次序将二叉树变为就地链表</h3><ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/114%20-%20Flatten%20Binary%20Tree%20to%20Linked%20List/114%20-%20Flatten%20Binary%20Tree%20to%20Linked%20List.cpp\" target=\"_blank\" rel=\"noopener\">Flatten Binary Tree to Linked List</a><ul>\n<li>思路参照<a href=\"http://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650560140&idx=1&sn=9a8884a2282b51906733c9c149c6db3c&scene=23&srcid=0728pEPY9XPc8RYKpUQF6lfn#rd\" target=\"_blank\" rel=\"noopener\">4张GIF理解BST</a>的最后一张动图；</li>\n<li>注意左孩子接在右子树上时，父节点的左孩子要置空。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"判断一棵树是不是BST-二叉搜索树\"><a href=\"#判断一棵树是不是BST-二叉搜索树\" class=\"headerlink\" title=\"判断一棵树是不是BST(二叉搜索树)\"></a>判断一棵树是不是BST(二叉搜索树)</h3><ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/98%20-%20Validate%20Binary%20Search%20Tree/98%20-%20Validate%20Binary%20Search%20Tree.cpp\" target=\"_blank\" rel=\"noopener\">Validate Binary Search Tree</a><ul>\n<li>DP思路,从下向上带缓存携带需要的信息。时间复杂度O(n)，空间复杂度O(2*n)；</li>\n<li>或者传递上下界，分治思想(从上到下的DP)，时间复杂度O(n)，空间复杂度O(logn)。</li>\n</ul>\n</li>\n</ol>\n","categories":["数据结构与算法"],"tags":["Algorithm"]},{"title":"数独解析器","url":"https://applefishsky009.github.io/2016/08/03/数独解析器/","content":"<h2 id=\"数独解析器\"><a href=\"#数独解析器\" class=\"headerlink\" title=\"数独解析器\"></a>数独解析器</h2><p>数独是个好玩的游戏，前一段时间还在手机上痴迷于数独解谜- -(简直愧对职业)，后来<a href=\"https://leetcode.com/problems/sudoku-solver/\" target=\"_blank\" rel=\"noopener\">LeetCode</a>上碰到这个问题，解答见<a href=\"https://github.com/applefishsky009/LeetCode/blob/master/37%20-%20Sudoku%20Solver/37%20-%20Sudoku%20Solver.cpp\" target=\"_blank\" rel=\"noopener\">GitHub - Sudoku Solver</a>，想着制作一个简单的数独解析器，源码和可执行程序(.exe)在<a href=\"https://github.com/applefishsky009/Math/tree/master/2%20-%20SudokuSolver\" target=\"_blank\" rel=\"noopener\">GitHub-SudokuSolver</a>上。</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>比较简单，标准的DFS。</p>\n<h3 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h3><ol>\n<li>判断输入数独是否合理；</li>\n<li>如果合理，给出一个可行解；</li>\n<li>如果不合理，提示“输入数独不合法”；</li>\n</ol>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><p>输入数独合理性判断和数独解析模块应该分离，因为二者的严重性不同，数独合理性判断失败时解析失败，数独解析时可以回溯。否则，第一，逻辑上不通；第二，空位当前解析失败回溯一步，非空判断正确往前走一步，造成死循环。</p>\n<ol>\n<li>模块分离，先判断合理性再解析数独(本程序采用)；</li>\n<li>对输入数独合理性判断用<code>try catch</code>块抛出异常(第一时间没想到)。</li>\n</ol>\n<h3 id=\"数独输入的合理性\"><a href=\"#数独输入的合理性\" class=\"headerlink\" title=\"数独输入的合理性\"></a>数独输入的合理性</h3><p>之前在<a href=\"https://github.com/applefishsky009/LeetCode/blob/master/37%20-%20Sudoku%20Solver/37%20-%20Sudoku%20Solver.cpp\" target=\"_blank\" rel=\"noopener\">GitHub - Sudoku Solver</a>中写过判断输入数独是否合理的接口，时间复杂度时O(n^4)，之后碰到<a href=\"https://leetcode.com/problems/valid-sudoku/\" target=\"_blank\" rel=\"noopener\">LeetCode - Valid Sudoku</a>这个问题发现，有时间复杂度为O(n^2)的解答，见<a href=\"https://github.com/applefishsky009/LeetCode/blob/master/36%20-%20Valid%20Sudoku/36%20-%20Valid%20Sudoku.cpp\" target=\"_blank\" rel=\"noopener\">GitHub - Valid Sudoku</a>。</p>\n","categories":["Math"],"tags":["Math"]},{"title":"约瑟夫斯问题","url":"https://applefishsky009.github.io/2016/08/02/约瑟夫斯问题/","content":"<h2 id=\"约瑟夫斯问题\"><a href=\"#约瑟夫斯问题\" class=\"headerlink\" title=\"约瑟夫斯问题\"></a>约瑟夫斯问题</h2><p>1-n共n个数字排列成一个圆圈，从第1个开始数，数到第k个，删除这个数字，以下一个为1继续数，最后一个数字是多少?<br>相关问题：</p>\n<ol>\n<li><a href=\"https://www.zhihu.com/question/21874955\" target=\"_blank\" rel=\"noopener\">知乎提问</a> - 苏莉安的回答很精彩；</li>\n<li><a href=\"http://www.nowcoder.com/questionTerminal/3213d528946a4056ab48c4bd1a0d7fa6?orderByHotValue=2&done=0&pos=3&onlyReference=false\" target=\"_blank\" rel=\"noopener\">微软面试</a></li>\n</ol>\n<h3 id=\"k-2的约瑟夫斯问题\"><a href=\"#k-2的约瑟夫斯问题\" class=\"headerlink\" title=\"k=2的约瑟夫斯问题\"></a>k=2的约瑟夫斯问题</h3><p>证明过程：<a href=\"https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98\" target=\"_blank\" rel=\"noopener\">维基百科</a><br>更详细的介绍：<a href=\"https://en.wikipedia.org/wiki/Josephus_problem\" target=\"_blank\" rel=\"noopener\">英文维基百科</a><br>模拟解答：<a href=\"http://www.funnyjs.com/josephusproblem/\" target=\"_blank\" rel=\"noopener\">苏莉安的个人博客</a><br>一般解(log表示以2为底)：<br>$$ f(n)\\ =\\ 2(n - 2^{|\\log^n|})+1 $$<br>也可以这么解答，更方便理解：<br>$$if\\qquad n=2^m+l \\qquad and \\qquad 0 \\le l \\lt 2^m \\qquad，so \\qquad f(n)=2l+1 \\qquad$$<br>值列表：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">1</th>\n<th align=\"center\">2</th>\n<th align=\"center\">3</th>\n<th align=\"center\">4</th>\n<th align=\"center\">5</th>\n<th align=\"center\">6</th>\n<th align=\"center\">7</th>\n<th align=\"center\">8</th>\n<th align=\"center\">9</th>\n<th align=\"center\">10</th>\n<th align=\"center\">11</th>\n<th align=\"center\">12</th>\n<th align=\"center\">13</th>\n<th align=\"center\">14</th>\n<th align=\"center\">15</th>\n<th align=\"center\">16</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">1</td>\n<td align=\"center\">3</td>\n<td align=\"center\">1</td>\n<td align=\"center\">3</td>\n<td align=\"center\">5</td>\n<td align=\"center\">7</td>\n<td align=\"center\">1</td>\n<td align=\"center\">3</td>\n<td align=\"center\">5</td>\n<td align=\"center\">7</td>\n<td align=\"center\">9</td>\n<td align=\"center\">11</td>\n<td align=\"center\">13</td>\n<td align=\"center\">15</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">可以看到\\( f(n) \\)的奇数排列规律。</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h3 id=\"k-gt-2的约瑟夫问题\"><a href=\"#k-gt-2的约瑟夫问题\" class=\"headerlink\" title=\"k&gt;2的约瑟夫问题\"></a>k&gt;2的约瑟夫问题</h3><p>没有通用的简单公式，只能逐个递推，递归公式见维基百科。这样编程时不用模拟链表环，有递推公式就是DP的思路。对于\\( k&gt;=n \\)的约瑟夫斯问题，有<code>O(k*logn)</code>的递推公式，对\\( k&lt;n \\)的约瑟夫斯问题，有<code>O(n)</code>的递推公式：<br><img src=\"http://i.imgur.com/yDFRuYk.png\" alt=\"约瑟夫斯递推公式\"></p>\n<p>相关题目：</p>\n<ol>\n<li><a href=\"https://github.com/applefishsky009/FunnyIssues/blob/master/2%20-%201%E5%88%B0N%E6%8A%A5%E6%95%B0%EF%BC%8C%E4%B8%89%E5%88%A0%E5%8E%BB/2.cpp\" target=\"_blank\" rel=\"noopener\">1到N报数，3删去，最后一个数字是？</a></li>\n</ol>\n","categories":["Math"],"tags":["Math"]},{"title":"辗转相除法求最大公约数","url":"https://applefishsky009.github.io/2016/08/01/辗转相除法求最大公约数/","content":"<h2 id=\"辗转相除法\"><a href=\"#辗转相除法\" class=\"headerlink\" title=\"辗转相除法\"></a>辗转相除法</h2><p>问题：求两个数的最大公约数<br>维基：<a href=\"https://zh.wikipedia.org/wiki/%E8%BC%BE%E8%BD%89%E7%9B%B8%E9%99%A4%E6%B3%95\" target=\"_blank\" rel=\"noopener\">辗转相除法</a></p>\n<p><a href>网易2016研发工程师笔试题目-GitHub待上传</a><br><a href=\"http://www.nowcoder.com/questionTerminal/fe6c73cb899c4fe1bdd773f8d3b42c3d\" target=\"_blank\" rel=\"noopener\">OJ</a></p>\n<p>直观想象，假设求\\( a,b(a&gt;b) \\)的最大公约数\\( c \\)，\\( a=mc,b=nc \\)，即一定有\\( m&gt;n \\)，设\\( t=a%b=kc \\)，显然\\( m&gt;n&gt;k \\)，另\\( m=n,n=k \\)重复以上操作，算法收敛( \\( m,n \\)向\\( 0 \\)收敛,直到其中小的数是大的数的公约数)，\\( a%b=0 \\)时\\( b \\)即为最大公约数。<br>核心：\\( a,b \\)的余数一定是最大公约数的整数倍。</p>\n<p>以下图像演示动画来自维基：<br><img src=\"http://i.imgur.com/Yoxwyvi.gif\" alt=\"辗转相除法\"><br>简单解释，一个长方形草坪，尽可能多的填充以宽为边的正方形地板，然后对新的长方形重复上述操作。<br>$$$$</p>\n","categories":["Math"],"tags":["Math"]},{"title":"VSCode配置Gcc环境","url":"https://applefishsky009.github.io/2016/07/30/VSCode配置Gcc环境/","content":"<p>之前编程需要用Vs2015(c++11/14)零散的解读过STL源码，后来受到启发，想要系统的剖析STL源码，深入了解泛型编程，于是以侯捷的《STL源码剖析》为指引，开始我的STL源码剖析之旅。</p>\n<hr>\n<h2 id=\"STL版本\"><a href=\"#STL版本\" class=\"headerlink\" title=\"STL版本\"></a>STL版本</h2><p>STL目前一共有五个版本：</p>\n<ol>\n<li>HP STL，所有STL实现版本的始祖；</li>\n<li>PJ STL, Visual C++ 采用，可读性极低(命名极不讲究)；</li>\n<li>RW STL, C++Builder 采用，可读性不错，源码中夹杂特殊常量；</li>\n<li>STLport, 以SGI STL 为蓝本的高度可移植性版本，可以将STLport移植到Visual C++ 和 C++Builder；</li>\n<li>SGI STL，GCC 采用，可读性很高，建议剖析这个版本。</li>\n</ol>\n<hr>\n<h2 id=\"在windows下使用SGI-STL\"><a href=\"#在windows下使用SGI-STL\" class=\"headerlink\" title=\"在windows下使用SGI STL\"></a>在windows下使用SGI STL</h2><p>首先gdb调试(工程目录和gdb安装目录都是)不支持中文目录，包括空格，需要调试尤其注意这一点。总之，Vscode+gcc比codeblock好用太多了。。。</p>\n<h3 id=\"CodeBlock\"><a href=\"#CodeBlock\" class=\"headerlink\" title=\"CodeBlock\"></a>CodeBlock</h3><ol>\n<li><a href=\"http://www.codeblocks.org/downloads/26\" target=\"_blank\" rel=\"noopener\">codeblocks</a>,下载最新版mingw版本;</li>\n<li><a href=\"http://www.cnblogs.com/abcdea/archive/2013/09/13/Sublime.html\" target=\"_blank\" rel=\"noopener\">Have g++ follow the C++11 ISO C++ language standard [-std=c++11]</a>；</li>\n<li>界面不太友好，调试器极度不友好!!!，但是他源码追踪是很正确稳定的。</li>\n</ol>\n<h3 id=\"VsCode-GCC\"><a href=\"#VsCode-GCC\" class=\"headerlink\" title=\"VsCode+GCC\"></a>VsCode+GCC</h3><ol>\n<li>先参照这个<a href=\"http://blog.csdn.net/c_duoduo/article/details/51615381\" target=\"_blank\" rel=\"noopener\">Windows下VSCode编译调试c/c++</a>,这是<a href=\"https://code.visualstudio.com/docs/languages/cpp\" target=\"_blank\" rel=\"noopener\">官方指南</a>，安装cpptools,SGITools;<ul>\n<li>安装参考<a href=\"http://www.programarts.com/cfree_ch/doc/help/UsingCF/CompilerSupport/Cygwin/Cygwin1.htm\" target=\"_blank\" rel=\"noopener\">下载安装cgywin</a>，即从中国镜像地址<code>http://www.cygwin.cn</code>下载；</li>\n<li>建议安装<code>make</code>包，在编译大项目是需要自己写<code>makefile</code>。</li>\n</ul>\n</li>\n<li>安装编译、调试环境时有些问题，一般在项目的<code>.vscode</code>中放入三个文件(即上述过程中的配置文件,我的配置在后边给出，参数依然需要follow the C++11 ISO C++ language standard)，参考来源：<a href=\"http://stackoverflow.com/questions/10363646/compiling-c11-with-g\" target=\"_blank\" rel=\"noopener\">Compiling C++11 with g++</a>， <a href=\"http://stackoverflow.com/questions/16886591/how-do-i-enable-c11-in-gcc\" target=\"_blank\" rel=\"noopener\">How do I enable C++11 in gcc?</a>;</li>\n<li>一定要注意安装gcc时，用VsCode调试项目时，<font color=\"red\">路径中不能有空格</font>，否则gdb调试器不能定位这个路径；</li>\n<li>界面很友好，但是，源码追踪比较坑，建议直接在文件夹中自己找源码。</li>\n</ol>\n<p>需要注意的是，使用不同的编译器要包含正确的头文件，VS中的一些习惯很可能在GCC中失败，比如<code>#include &lt;cstdlib&gt;</code>和<code>#include &lt;cmath&gt;</code>中的<code>abs()</code>方法是不同的。</p>\n<p>launch.json</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">\t<span class=\"attr\">\"version\"</span>: <span class=\"string\">\"0.2.0\"</span>, </span><br><span class=\"line\">\t<span class=\"attr\">\"configurations\"</span>: [ </span><br><span class=\"line\">\t\t&#123; </span><br><span class=\"line\">\t\t\t<span class=\"attr\">\"name\"</span>: <span class=\"string\">\"C++ Launch (GDB)\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">\"type\"</span>: <span class=\"string\">\"cppdbg\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">\"request\"</span>: <span class=\"string\">\"launch\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">\"targetArchitecture\"</span>: <span class=\"string\">\"x86\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">\"program\"</span>: <span class=\"string\">\"$&#123;file&#125;.exe\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">\"miDebuggerPath\"</span>:<span class=\"string\">\"D:\\\\Cygwin64\\\\bin\\\\gdb.exe\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">\"args\"</span>: [<span class=\"string\">\"blackkitty\"</span>, <span class=\"string\">\"1221\"</span>, <span class=\"string\">\"# #\"</span>], </span><br><span class=\"line\">\t\t\t<span class=\"attr\">\"stopAtEntry\"</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">\"cwd\"</span>: <span class=\"string\">\"$&#123;workspaceRoot&#125;\"</span>,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">\"externalConsole\"</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">\"preLaunchTask\"</span>: <span class=\"string\">\"g++\"</span></span><br><span class=\"line\">\t\t&#125; </span><br><span class=\"line\">\t] </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>tasks.json</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"attr\">\"version\"</span>: <span class=\"string\">\"0.1.0\"</span>, </span><br><span class=\"line\">\t<span class=\"attr\">\"command\"</span>: <span class=\"string\">\"g++\"</span>, </span><br><span class=\"line\">\t<span class=\"attr\">\"args\"</span>: [<span class=\"string\">\"-g\"</span>,<span class=\"string\">\"-std=c++11\"</span>,<span class=\"string\">\"$&#123;file&#125;\"</span>,<span class=\"string\">\"-o\"</span>,<span class=\"string\">\"$&#123;file&#125;.exe\"</span>],</span><br><span class=\"line\">\t<span class=\"attr\">\"problemMatcher\"</span>: &#123; </span><br><span class=\"line\">\t\t<span class=\"attr\">\"owner\"</span>: <span class=\"string\">\"cpp\"</span>, </span><br><span class=\"line\">\t\t<span class=\"attr\">\"fileLocation\"</span>: [<span class=\"string\">\"relative\"</span>, <span class=\"string\">\"$&#123;workspaceRoot&#125;\"</span>], </span><br><span class=\"line\">\t\t<span class=\"attr\">\"pattern\"</span>: &#123; </span><br><span class=\"line\">\t\t\t<span class=\"attr\">\"regexp\"</span>: <span class=\"string\">\"^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$\"</span>, </span><br><span class=\"line\">\t\t\t<span class=\"attr\">\"file\"</span>: <span class=\"number\">1</span>, </span><br><span class=\"line\">\t\t\t<span class=\"attr\">\"line\"</span>: <span class=\"number\">2</span>, </span><br><span class=\"line\">\t\t\t<span class=\"attr\">\"column\"</span>: <span class=\"number\">3</span>, </span><br><span class=\"line\">\t\t\t<span class=\"attr\">\"severity\"</span>: <span class=\"number\">4</span>, </span><br><span class=\"line\">\t\t\t<span class=\"attr\">\"message\"</span>: <span class=\"number\">5</span> </span><br><span class=\"line\">\t\t&#125; </span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>c_cpp_properties    -    定位STL源文件位置</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"configurations\"</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"Mac\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"includePath\"</span>: [<span class=\"string\">\"D:/Cygwin64/lib/gcc/x86_64-w64-mingw32/4.9.2/include\"</span>],</span><br><span class=\"line\">            <span class=\"attr\">\"browse\"</span> : &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"limitSymbolsToIncludedHeaders\"</span> : <span class=\"literal\">true</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"databaseFilename\"</span> : <span class=\"string\">\"\"</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"Linux\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"includePath\"</span>: [<span class=\"string\">\"D:/Cygwin64/lib/gcc/x86_64-w64-mingw32/4.9.2/include\"</span>],</span><br><span class=\"line\">            <span class=\"attr\">\"browse\"</span> : &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"limitSymbolsToIncludedHeaders\"</span> : <span class=\"literal\">true</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"databaseFilename\"</span> : <span class=\"string\">\"\"</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"Win32\"</span>,</span><br><span class=\"line\">            <span class=\"attr\">\"includePath\"</span>: [<span class=\"string\">\"D:/Cygwin64/lib/gcc/x86_64-w64-mingw32/4.9.2/include\"</span>],</span><br><span class=\"line\">            <span class=\"attr\">\"browse\"</span> : &#123;</span><br><span class=\"line\">                <span class=\"attr\">\"limitSymbolsToIncludedHeaders\"</span> : <span class=\"literal\">true</span>,</span><br><span class=\"line\">                <span class=\"attr\">\"databaseFilename\"</span> : <span class=\"string\">\"\"</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"attr\">\"clang_format\"</span> : &#123;</span><br><span class=\"line\">        <span class=\"attr\">\"style\"</span> : <span class=\"string\">\"file\"</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"fallback-style\"</span> : <span class=\"string\">\"LLVM\"</span>,</span><br><span class=\"line\">        <span class=\"attr\">\"sort-includes\"</span> : <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上述文件修改你的gcc include目录，各项的含义第一条中的超链接有。</p>\n","categories":["VSCode"],"tags":["VSCode"]},{"title":"玲珑枝枝，斗妆金栗","url":"https://applefishsky009.github.io/2016/07/29/玲珑枝枝，斗妆金栗/","content":"<p>上次提到有想记录心血来潮时想法的篇，主要是方便回顾一路走来当时的所思所想，这是严格意义上的新开category第一篇，姑且叫做ryl的碎碎念吧，一时之间想不到什么契合的诗词。</p>\n<p>写点什么呢，从<code>Insert</code>开始吧，我之前一直很讨厌这个键，觉得不仅没什么用，不小心按到了之后敲的一大串字符又要重新输入。今天coding的时候才发现，他在某些时候可以极大提高效率，比如说复制框架，只是修改某些变量，这个键的作用就体现出来了，不用你不停的退格。。。</p>\n<p>其实发现在生活中很多时候都是这样，一些细节上表现的很蠢，自己丝毫不觉。。。不过这也给自己一个启示，</p>\n<ul>\n<li>首先要谦虚，学习的过程总是需要不断输入反馈调节的(推荐采铜《精进：如何成为一个很厉害的人》)，而不是一蹴而就的。你自认为正确的东西也许下一秒就会发现更正确的东西。</li>\n<li>其次要思考，多想想为什么，找原因，这一点也是我一直在做的，爱钻牛角尖，凡事喜欢找一个说服自己的理由，即使我知道很可能是错的。但这不重要，也许当时局限性太大，只能意识到这么多，如果以后有可能(相关输入)，不就可以反馈调节了？这是不是就更接近正确？所以说学无止境。</li>\n</ul>\n<hr>\n<blockquote>\n<p>玲珑枝枝，斗妆金栗。<br>宋，无名氏， 只有一句</p>\n</blockquote>\n","categories":["ryl"],"tags":["ryl"]},{"title":"其他非STL库","url":"https://applefishsky009.github.io/2016/07/29/其他非STL库/","content":"<hr>\n<h2 id=\"valarray和array\"><a href=\"#valarray和array\" class=\"headerlink\" title=\"valarray和array\"></a>valarray和array</h2><ol>\n<li><code>vector</code>模板是容器类和算法系统的一部分，他支持面向容器的操作；</li>\n<li><code>valarray</code>模板是面向数值计算的，之前简单介绍过，比如重载基本运算符，定义数学方法等；</li>\n<li><code>array</code>为代替内置数组设计，他通过更好更安全的接口，让数组更紧凑，<font color=\"red\">效率更高</font>。</li>\n</ol>\n<p>注意：</p>\n<ol>\n<li><code>valarray</code>的接口更简单，但是性能并不更高，而且他没有<code>begin()</code>,<code>end()</code>方法，凡是他有<code>begin(val)</code>,<code>end(val)</code>函数，他还有二值化值域，扩展的下标访问等功能。<ul>\n<li><code>valarray&lt;bool&gt; vbool = numbers &gt; 9</code>;</li>\n<li><code>a[slice(1,4,3)]</code>没有计算功能，需要转化为<code>valarray</code>:<code>valarray&lt;int&gt; b(a[slice(1,4,3)])</code>;</li>\n</ul>\n</li>\n<li><code>array</code>提供了多个STL方法，但是他固定长度(因此改变长度的方法他都没有)；</li>\n</ol>\n<hr>\n<h2 id=\"initializer-list\"><a href=\"#initializer-list\" class=\"headerlink\" title=\"initializer_list\"></a>initializer_list</h2><p>C++11新增，使得STL容器能够使用初始化列表语法，容器类会包含一个<code>initializer_list&lt;T&gt;</code>作为参数的构造函数。</p>\n<ol>\n<li>如果类有接受<code>initializer_list</code>作为参数的构造函数，则使用<code>{}</code>语法将调用该构造函数；</li>\n<li>初始化列表构造函数不能进行隐式的缩窄转化；</li>\n<li>包含头文件<code>&lt;initializer_list&gt;</code>构造<code>initializer_list</code>对象，这个模板类包括<code>begin()</code>,<code>end()</code>,<code>size()</code>等成员函数，还重载了赋值运算符<code>=</code>；</li>\n<li><code>initializer_list</code>迭代器类型为<code>const</code>。</li>\n</ol>\n","categories":["STL"],"tags":["C++"]},{"title":"晓来寒露滴疏桐","url":"https://applefishsky009.github.io/2016/07/28/晓来寒露滴疏桐/","content":"<p>写在最前，GitPage更新博客70+了，逐渐认识到一些好的，值得坚持的，有待改进的地方，</p>\n<ol>\n<li>比如学习C++,Primer一定比plus好(也有人说《The C++ Programming Language》和primer是一个等级的，未看过，不予评论)，大众的智慧还是值得相信的；</li>\n<li>再比如技术书籍一定要学习至少两遍才行，第一遍至少明白书的组织架构，第二遍争取弄明白每一步作者想表达的意思；</li>\n<li>再比如，在刷算法，学习各种语言，更博客的时候，偶尔间心血来潮总会有一点点想法一吐为快，就像各种写在最前的话，趁着这些东西不多，想再开一个category作为心路历程；</li>\n<li>再比如，在知识构架的组织中，深刻意识到以前的学习方式和组织方式是很浅薄的，随着意识的提升，这方面总会做的越来越好。但是之前的东西没精力去为了框架动一次大手术，只能在以后的组织学习中做得更好。</li>\n<li>博客锻炼总结能力(知识架构)，反思自己所学所想(知识反馈调整能力)，作为知识索引(快速查阅知识点)，最重要的是能帮助自己更好的认识自己。</li>\n</ol>\n<hr>\n<blockquote>\n<p>晓来寒露滴疏桐<br>宋，无名氏, 只有一句</p>\n</blockquote>\n","categories":["ryl"],"tags":["ryl"]},{"title":"STL算法库","url":"https://applefishsky009.github.io/2016/07/28/STL算法库/","content":"<p>这里主要是指<code>&lt;algorithm&gt;</code>和<code>&lt;numeric&gt;</code>头文件。<br>STL算法库包含一些处理容器的非成员函数，查阅<a href=\"http://www.cplusplus.com/reference/algorithm/\" target=\"_blank\" rel=\"noopener\">参考文档</a>得到详细信息。这些算法函数设计，思路主要是两个通用部分：</p>\n<ol>\n<li>使用模板来提供泛型；</li>\n<li>使用迭代器来提供访问容器中的数据的通用表示。</li>\n</ol>\n<p>这些容器设计使不同类型的容器之间有明显的联系，比如：</p>\n<ol>\n<li>不同容器之间的<code>copy()</code>;</li>\n<li>不同容器之间的<code>==</code>。</li>\n</ol>\n<p>使用STL时应尽可能减少要编写的代码，STL算法是经过仔细选择的，并且是内联的。</p>\n<hr>\n<h2 id=\"算法组分类\"><a href=\"#算法组分类\" class=\"headerlink\" title=\"算法组分类\"></a>算法组分类</h2><ol>\n<li>非修改式序列操作(Non-modifying sequence operations);</li>\n<li>修改式序列操作(Modifying sequence operations);</li>\n<li>排序和相关操作(Sorting,Partitions,Merge等);</li>\n<li>通用数字计算(<numeric>)</numeric></li>\n</ol>\n<hr>\n<h2 id=\"就地算法和复制算法\"><a href=\"#就地算法和复制算法\" class=\"headerlink\" title=\"就地算法和复制算法\"></a>就地算法和复制算法</h2><p>就地算法(in-place algorithm)就地完成工作(如<code>sort()</code>)，复制算法(copy algirithm)创建拷贝(如<code>copy()</code>)。有的可以以两种方式工作(如<code>transform()</code>，他的输出迭代器可以指向输入区间)</p>\n<p>STL约定：</p>\n<ol>\n<li>复制版本的名称以<code>_copy</code>结尾，他仅仅是只读只写，因此输入输出迭代器足够了(如<code>replace_copy()</code>)；</li>\n<li>就地版本，同时需要读写数据，因此至少需要正向迭代器(如<code>replace()</code>)；</li>\n<li><code>_if</code>变体：根据 将函数应用于容器元素得到的结果 来执行操作(如<code>replace_if()</code>)。</li>\n</ol>\n<hr>\n<h2 id=\"STL与string类兼容\"><a href=\"#STL与string类兼容\" class=\"headerlink\" title=\"STL与string类兼容\"></a>STL与string类兼容</h2><p><code>string</code>类不是STL组件，但是他设计时考虑了STL，包含<code>begin()</code>,<code>end()</code>,<code>rbegin()</code>,<code>rend()</code>等成员，因此可以使用STL接口；<br>得到字符串的所有组合(两个方法都体现兼容性)：</p>\n<ol>\n<li><code>next_permutation()</code>得到下一种排列方式；</li>\n<li><code>sort()</code>得到最初的排列方式，二者组合即能得到所有组合。</li>\n</ol>\n<hr>\n<h2 id=\"函数和容器方法\"><a href=\"#函数和容器方法\" class=\"headerlink\" title=\"函数和容器方法\"></a>函数和容器方法</h2><p>STL方法和STL函数对比而言，方法是更好的选择，因为方法是针对特定容器设计的，一般使用可能的最低需求。<br><code>remove()</code>方法和函数：</p>\n<ol>\n<li><code>remove()</code>方法删除容器中指定值的元素；</li>\n<li><code>renmove()</code>函数调整 指定值所在结点值 为 下一个非指定值的值 ，并返回新的超尾；因此重要的一点是容器大小不变，之后<code>erase()</code>新超尾和原超尾区间才能达到<code>remove()</code>方法的效果。</li>\n</ol>\n","categories":["STL"],"tags":["Algorithm"]},{"title":"函数对象","url":"https://applefishsky009.github.io/2016/07/27/函数对象/","content":"<p>C++11有函数指针和函数符的替代品-lambda。</p>\n<hr>\n<h2 id=\"函数对象\"><a href=\"#函数对象\" class=\"headerlink\" title=\"函数对象\"></a>函数对象</h2><p>函数对象也叫函数符(functor)，包括函数名，指向函数的指针和重载了()运算符的类对象，以<code>for_each()</code>为例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for_each(nums.<span class=\"built_in\">begin</span>(),nums.<span class=\"built_in\">end</span>(),show);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputIterator</span>, <span class=\"title\">class</span> <span class=\"title\">Function</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">Function</span> <span class=\"title\">for_each</span>(<span class=\"title\">InputIterator</span> <span class=\"title\">first</span>, <span class=\"title\">InputIterator</span> <span class=\"title\">lase</span>, <span class=\"title\">Function</span> <span class=\"title\">f</span>);</span></span><br></pre></td></tr></table></figure>\n\n<p>不能将<code>for_each()</code>的第三个参数声明为函数指针，因为函数指针需要指定参数类型，显然<code>for_each()</code>是泛型的。因此使用了模板。<br><code>Function</code>参数可以表示函数指针或具有重载的<code>()</code>运算符的类类型。最终，<code>for_each()</code>代码将具有调用<code>f()</code>的表达式，对函数指针而言，他调用该函数；对类对象而言，他调用了重载的<code>()</code>方法。<br>在<a href=\"http://www.cplusplus.com/reference/algorithm/for_each/?kw=for_each\" target=\"_blank\" rel=\"noopener\">参考文档</a>中提到，第三个参数可以是函数指针或移动构造的函数对象。</p>\n<h3 id=\"函数符概念\"><a href=\"#函数符概念\" class=\"headerlink\" title=\"函数符概念\"></a>函数符概念</h3><ol>\n<li>生成器(generator) - 不用参数就可以调用；</li>\n<li>一元函数(unary function) - 用一个参数可以调用 - 比如<code>for_each()</code>方法的第三个参数；</li>\n<li>二元函数(binary function) - 用两个参数可以调用。</li>\n</ol>\n<p>一元函数和二元函数改进：</p>\n<ol>\n<li>谓词(predicate) - 返回<code>bool</code>值的一元函数 - <code>list</code>模板的<code>remove_if()</code>方法；</li>\n<li>二元谓词(binary predicate) - 返回<code>bool</code>值的二元函数。</li>\n</ol>\n<h4 id=\"类函数符的必要性\"><a href=\"#类函数符的必要性\" class=\"headerlink\" title=\"类函数符的必要性\"></a>类函数符的必要性</h4><p>由于函数符对其参数个数有限制，不能传递定制的参数，因此可以设计一个类，使用类成员来传递额外的信息，采用类模板，传递额外信息的构造函数可以轻松解决这个问题。简单例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">tooBig</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>&#123;<span class=\"keyword\">return</span> n &gt; <span class=\"number\">100</span>&#125;;\t\t<span class=\"comment\">//函数指针不能定制100,只能内部设置</span></span><br><span class=\"line\"><span class=\"built_in\">list</span>&lt;<span class=\"keyword\">int</span>&gt; score;</span><br><span class=\"line\">...</span><br><span class=\"line\">score.remove_if(tooBig);</span><br><span class=\"line\"></span><br><span class=\"line\">tamplate&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">TooBig</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tT cutoff;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tTooBig(<span class=\"keyword\">const</span> T &amp; t):cutoff(t)&#123;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">tooBig</span><span class=\"params\">(<span class=\"keyword\">const</span> T &amp;v)</span></span>&#123;<span class=\"keyword\">return</span> v&gt;cutoff;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//score.remove_if(Too_Big&lt;int&gt;(200));</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"预定义的函数符\"><a href=\"#预定义的函数符\" class=\"headerlink\" title=\"预定义的函数符\"></a>预定义的函数符</h3><p>查看<code>transform()</code>函数的两个版本：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//unary operation(1)\t</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputIterator</span>, <span class=\"title\">class</span> <span class=\"title\">OutputIterator</span>, <span class=\"title\">class</span> <span class=\"title\">UnaryOperation</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"title\">OutputIterator</span> <span class=\"title\">transform</span> (<span class=\"title\">InputIterator</span> <span class=\"title\">first1</span>, <span class=\"title\">InputIterator</span> <span class=\"title\">last1</span>,</span></span><br><span class=\"line\"><span class=\"class\">                            <span class=\"title\">OutputIterator</span> <span class=\"title\">result</span>, <span class=\"title\">UnaryOperation</span> <span class=\"title\">op</span>);</span></span><br><span class=\"line\"><span class=\"comment\">//binary operation(2)\t</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputIterator1</span>, <span class=\"title\">class</span> <span class=\"title\">InputIterator2</span>,</span></span><br><span class=\"line\"><span class=\"class\">          <span class=\"title\">class</span> <span class=\"title\">OutputIterator</span>, <span class=\"title\">class</span> <span class=\"title\">BinaryOperation</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"title\">OutputIterator</span> <span class=\"title\">transform</span> (<span class=\"title\">InputIterator1</span> <span class=\"title\">first1</span>, <span class=\"title\">InputIterator1</span> <span class=\"title\">last1</span>,</span></span><br><span class=\"line\"><span class=\"class\">                            <span class=\"title\">InputIterator2</span> <span class=\"title\">first2</span>, <span class=\"title\">OutputIterator</span> <span class=\"title\">result</span>,</span></span><br><span class=\"line\"><span class=\"class\">                            <span class=\"title\">BinaryOperation</span> <span class=\"title\">binary_op</span>);</span></span><br></pre></td></tr></table></figure>\n\n<p>STL提供算术运算符，逻辑运算符，关系运算符等价的函数符，可用来处理C++内置类型或任何用户定义的类型(需要重载相应的运算符)<br><a href=\"http://www.cplusplus.com/reference/functional/\" target=\"_blank\" rel=\"noopener\">STL函数符列表</a></p>\n<h3 id=\"自适应函数符和函数适配器\"><a href=\"#自适应函数符和函数适配器\" class=\"headerlink\" title=\"自适应函数符和函数适配器\"></a>自适应函数符和函数适配器</h3><h4 id=\"自适应函数符\"><a href=\"#自适应函数符\" class=\"headerlink\" title=\"自适应函数符\"></a>自适应函数符</h4><p>STL自带的函数符都是自适应(adaptable)的，他标识参数类型和返回类型。它携带了三个成员：</p>\n<ol>\n<li><code>result_type</code>;</li>\n<li><code>first_argument_type</code>;</li>\n<li><code>second_argument_type</code>;</li>\n</ol>\n<p>他们将函数符参数自适应(<code>typedef</code>)为内置类型或自定义类型，比如<code>plus&lt;int&gt;::result_type</code>就被自适应为<code>int</code>，其实就是别名适应。</p>\n<p>他们的作用在于，三个成员是泛型需要，而自适应则是编译器需要(不然编译器无法理解这是什么类型)。</p>\n<p>他的意义是，函数适配器对象可以使用函数对象(通过<code>typedef</code>自适应解析一次类型，用于二元函数符)</p>\n<h4 id=\"函数适配器\"><a href=\"#函数适配器\" class=\"headerlink\" title=\"函数适配器\"></a>函数适配器</h4><p>将接受两个参数的函数符转化为接受一个参数的函数符，STL使用<code>binder1st()</code>，<code>binder2st()</code>类(他们被称为适配器类)来完成这一过程：</p>\n<ol>\n<li><code>binder1st(f2,val) f1</code>-&gt; f1(x) = f2(val,x);</li>\n<li><code>binder2st(f2,val) f1</code>-&gt; f1(x) = f2(x,val);</li>\n</ol>\n<p>以下为个人猜测：<br>以1为例，假设x为<code>double</code>，调用f1(x)，相当于调用f2(val,x)，返回类型为<code>multiplies&lt;double&gt;::result_type</code>,由于f2是自适应的,将他自适应为<code>double</code>。因此使用适配器类，注意函数符参数应该是自适应的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">transform(num.<span class=\"built_in\">begin</span>(), num.<span class=\"built_in\">end</span>(), num2.<span class=\"built_in\">begin</span>(), binder1st(multiplies&lt;<span class=\"keyword\">double</span>&gt;(), <span class=\"number\">2.5</span>))</span><br></pre></td></tr></table></figure>\n\n<p>上式中函数符返回类型为<code>multiplies&lt;double&gt;::result_type</code>，由于<code>multiplies</code>函数符自适应将其解析为<code>double</code>，然后复制到<code>num2.begin()</code>，否则编译器可不知道<code>multiplies&lt;double&gt;::result_type</code>是什么类型以及如何赋值。</p>\n","categories":["C++基础"],"tags":["C++"]},{"title":"有趣的switch","url":"https://applefishsky009.github.io/2016/07/26/有趣的switch/","content":"<p>遇到一个有趣的题目，以下代码会输出什么？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> n = <span class=\"string\">'c'</span>;</span><br><span class=\"line\"><span class=\"keyword\">switch</span> (n++) &#123;</span><br><span class=\"line\"><span class=\"keyword\">default</span>:<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"error\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">'a'</span>:<span class=\"keyword\">case</span> <span class=\"string\">'A'</span>:<span class=\"keyword\">case</span> <span class=\"string\">'B'</span>:<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"good\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">'c'</span>:<span class=\"keyword\">case</span> <span class=\"string\">'C'</span>:<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"pass\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">'d'</span>:<span class=\"keyword\">case</span> <span class=\"string\">'D'</span>:<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"warn\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"keyword\">break</span>;</span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">'k'</span>:<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"hello\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>答案是</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pass</span><br><span class=\"line\">warn</span><br></pre></td></tr></table></figure>\n\n<p>下面说明switch是如何工作以帮助使用，并合理猜测其底层原理。</p>\n<hr>\n<h2 id=\"switch\"><a href=\"#switch\" class=\"headerlink\" title=\"switch\"></a>switch</h2><p>将<code>switch</code>简单视为<code>if...else...</code>的替代品是错误的，他忽略了<code>break</code>语句在<code>switch</code>中的作用。简单来说，编译时<code>switch</code>的<code>case</code>会有一个比较表(这个表的顺序不重要)，重要的是每一个比较值都有一个跳转地址(所以这个表也叫跳转表，是一个<code>case</code>值与地址的映射)，这个跳转地址是按语句顺序来的，比如在上边的程序中：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"string\">\"aAB\"</span>\t \t\t跳转到 <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"good\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;地址并向下执行；</span><br><span class=\"line\">\t<span class=\"string\">\"cC\"</span>  \t\t\t跳转到 <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"pass\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;地址并向下执行；</span><br><span class=\"line\">\t<span class=\"string\">\"dD\"</span>  \t\t\t跳转到 <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"warn\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;地址并向下执行；</span><br><span class=\"line\">\t<span class=\"string\">\"k\"</span>\t\t\t\t跳转到 <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"hello\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;地址并向下执行；</span><br><span class=\"line\"><span class=\"keyword\">default</span>，即不在表中\t跳转到 <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"error\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;地址并向下执行；</span><br><span class=\"line\">遇到<span class=\"keyword\">break</span>;\t\t\t跳转到 <span class=\"keyword\">switch</span>&#123;&#125;代码块的下一句并向下执行，上述代码中是n++；</span><br></pre></td></tr></table></figure>\n\n<p>因此尤为注意的是：</p>\n<ol>\n<li>每一个<code>switch</code>只在跳转表中查找一次(可能有n次比较)，然后提供一个程序入口，之后与<code>switch...case...</code>无关；</li>\n<li>有n个<code>case</code>语句最坏情况下需要n次比较；</li>\n<li>上述代码中的<code>n++</code>实际上执行在<code>switch(){}</code>代码块之后。</li>\n</ol>\n","categories":["C++基础"],"tags":["C++"]},{"title":"泛型编程","url":"https://applefishsky009.github.io/2016/07/25/泛型编程/","content":"<p>面向对象编程关注编程数据，泛型编程关注算法。共同点是抽象和创建代码可重用性。<br>模板使得算法独立于存储的数据类型，而迭代器使算法独立于使用的容器类型。</p>\n<hr>\n<h2 id=\"迭代器简介\"><a href=\"#迭代器简介\" class=\"headerlink\" title=\"迭代器简介\"></a>迭代器简介</h2><p>泛型编程旨在使用同一个函数来处理数组、链表或任何其他容器类型。</p>\n<ol>\n<li>迭代器应可以解除引用(<code>*p</code>);</li>\n<li>迭代器应可以赋值(<code>p=q</code>);</li>\n<li>迭代器应可以比较(<code>p==q</code>,<code>p!=q</code>);</li>\n<li>迭代器应可以遍历容器(<code>p++</code>,<code>q++</code>)。</li>\n</ol>\n<p>参考<a href=\"http://rylcode.cn/2016/05/06/i++%E4%B8%8E++i%E7%9A%84%E5%8C%BA%E5%88%AB/\" target=\"_blank\" rel=\"noopener\">i++与++i的区别</a>，为了区分前缀版本和后缀版本，C++将<code>operator++</code>作为前缀版本，将<code>operator++(int)</code>作为后缀版本，其中的参数永远不会用到，因此不必指定其名称，列出<code>iterator</code>中<code>p++</code>和<code>++p</code>的实现：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iterator&amp; <span class=\"keyword\">operator</span>++()&#123;\t<span class=\"comment\">//++p</span></span><br><span class=\"line\">\tpt = pt-&gt;next;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">iterator&amp; <span class=\"keyword\">operator</span>++(<span class=\"keyword\">int</span>)&#123;\t<span class=\"comment\">//p++</span></span><br><span class=\"line\">\titerator tmp = *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">\tpt = pt-&gt;next;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> tmp; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>对容器类要求都有超尾；</li>\n<li>使用自动类型推断<code>auto</code>来进一步简化代码；</li>\n<li>形成避免直接使用迭代器的编程风格，尽可能使用STL函数。</li>\n</ol>\n<hr>\n<h2 id=\"迭代器概念与层次结构\"><a href=\"#迭代器概念与层次结构\" class=\"headerlink\" title=\"迭代器概念与层次结构\"></a>迭代器概念与层次结构</h2><p><a href=\"http://www.cplusplus.com/reference/iterator/\" target=\"_blank\" rel=\"noopener\">5种迭代器类型</a>：</p>\n<ol>\n<li>输入迭代器 - 单向，只读 - 不保证第二次遍历时顺序不变；</li>\n<li>输出迭代器 - 单向，只写 - 不保证第二次遍历时顺序不变；</li>\n<li>正向迭代器 - 单向，读写或只读 - 输入迭代器+输出迭代器+保证相同顺序遍历；</li>\n<li>双向迭代器 - 双向，读写或只读 - 正向迭代器+两种递减运算符；</li>\n<li>随机访问迭代器 - 双向迭代器+随机访问功能(比如<code>a+n</code>，<code>a&lt;b</code>)等)；</li>\n</ol>\n<p>在编写算法时，尽可能使用要求最低的迭代器，并让他适用于容器的最大区别。举例：</p>\n<ol>\n<li><code>vector&lt;int&gt;</code>使用随机访问迭代器；</li>\n<li><code>list&lt;int&gt;</code>使用双向迭代器。</li>\n</ol>\n<p>注意这是一系列概念而不是类型。，概念可以具有类型继承的关系，概念的具体实现被称为模型。例如指向<code>int</code>的常规指针是一个随机访问迭代器模型。</p>\n<hr>\n<h2 id=\"迭代器方法\"><a href=\"#迭代器方法\" class=\"headerlink\" title=\"迭代器方法\"></a>迭代器方法</h2><p><code>next()</code>,<code>prev()</code>,<code>advance()</code>,<code>distance()</code>详见<a href=\"http://www.cplusplus.com/reference/iterator/\" target=\"_blank\" rel=\"noopener\">参考文档</a>,提供这些方法简化程序。他们是用<code>+</code>(随机访问迭代器)或者<code>++</code>(双向迭代器)来实现的，因此，n越界时程序会异常终止。</p>\n<hr>\n<h2 id=\"高级迭代器\"><a href=\"#高级迭代器\" class=\"headerlink\" title=\"高级迭代器\"></a>高级迭代器</h2><p><code>copy()</code>方法在迭代器的使用中非常重要。</p>\n<h3 id=\"常规指针迭代器模型\"><a href=\"#常规指针迭代器模型\" class=\"headerlink\" title=\"常规指针迭代器模型\"></a>常规指针迭代器模型</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> SIZE = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">double</span> r[SIZE];</span><br><span class=\"line\">sort(r, r + SIZE);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"输出流迭代器\"><a href=\"#输出流迭代器\" class=\"headerlink\" title=\"输出流迭代器\"></a>输出流迭代器</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iterator&gt;</span></span></span><br><span class=\"line\">ostream_iterator&lt;int, char&gt; out_iter(cout,\" \");\t//用cout类将int输出为char</span><br><span class=\"line\">copy(r.<span class=\"built_in\">begin</span>(), r.<span class=\"built_in\">end</span>(), out_iter);</span><br><span class=\"line\"></span><br><span class=\"line\">copy(r.<span class=\"built_in\">begin</span>(), r.<span class=\"built_in\">end</span>(), ostream_iterator&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">char</span>&gt;(<span class=\"built_in\">cout</span>,<span class=\"string\">\" \"</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"输入流迭代器\"><a href=\"#输入流迭代器\" class=\"headerlink\" title=\"输入流迭代器\"></a>输入流迭代器</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">copy(istream_iterator&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">char</span>&gt;(<span class=\"built_in\">cin</span>), istream_iterator&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">char</span>&gt;(), r.<span class=\"built_in\">begin</span>());\t<span class=\"comment\">//使用cin类将char存为int</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"反向迭代器\"><a href=\"#反向迭代器\" class=\"headerlink\" title=\"反向迭代器\"></a>反向迭代器</h3><p>容器中的<code>rbegin()</code>,<code>rend()</code>都是反向迭代器，执行递增操作将导致他被递减，由于容器头部没有超尾，因此反向迭代器通过先递减，再解除引用解决问题。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iterator&gt;</span></span></span><br><span class=\"line\">ostream_iterator&lt;int, char&gt; out_iter(cout,\" \");\t//用cout类将int输出为char</span><br><span class=\"line\">copy(r.rbegin(), r.rend(), out_iter);\t<span class=\"comment\">//反向打印容器</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"插入迭代器\"><a href=\"#插入迭代器\" class=\"headerlink\" title=\"插入迭代器\"></a>插入迭代器</h3><ol>\n<li><code>insert_iterator</code> - 插入到容器参数指定位置前面;</li>\n<li><code>back_insert_iterator</code> - 常数时间后插;</li>\n<li><code>front_insert_iterator</code> - 常数时间前插。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iterator&gt;</span></span></span><br><span class=\"line\">copy(s1.<span class=\"built_in\">begin</span>(), s1,<span class=\"built_in\">end</span>(), back_insert_iterator&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt;(s2));\t<span class=\"comment\">//不要用这个迭代器对容器自我复制，可以用for_each()传递函数体，即s1和s2不要是同一个东西！</span></span><br><span class=\"line\"><span class=\"comment\">//这是因为push_back()操作无效化了迭代器，从而只能复制一个元素。因此要合理使用reverse()</span></span><br><span class=\"line\">copy(s1.<span class=\"built_in\">begin</span>(), s1.<span class=\"built_in\">end</span>(), insert_iterator&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &gt;(s2, s2.<span class=\"built_in\">begin</span>()));</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"容器种类\"><a href=\"#容器种类\" class=\"headerlink\" title=\"容器种类\"></a>容器种类</h2><h3 id=\"容器概念\"><a href=\"#容器概念\" class=\"headerlink\" title=\"容器概念\"></a>容器概念</h3><p>存储同质对象，可复制构造，可赋值。复杂度要求是STL特征，可以隐藏细节，但必须公开规格。C++11中的移动构造，移动赋值和复制构造，复制赋值的区别是：</p>\n<ol>\n<li>复制操作保留源对象，移动操作可以修改源对象，还可能转让所有权而不做任何复制；</li>\n<li>如果源对象是临时的，移动操作的效率高。</li>\n</ol>\n<h3 id=\"序列容器\"><a href=\"#序列容器\" class=\"headerlink\" title=\"序列容器\"></a>序列容器</h3><ol>\n<li><code>vector</code> - 随机访问，尾部插入删除O(1);</li>\n<li><code>deque</code> - 随机访问，头部尾部插入删除O(1)， - 双端队列;</li>\n<li><code>list</code> - 以无法随机访问为代价，任一位置插入删除O(1) - 双向链表;<ul>\n<li><code>insert()</code>是插入(副本)，<code>splice()</code>是移动(原数据)；</li>\n<li><code>unique()方法</code>将相邻的相同值压缩为单个值，如果有必要，可以先执行<code>sort()</code>;</li>\n<li>由于非成员<code>sort()</code>方法(<code>algorithm</code>中)是使用随机访问迭代器实现的(快排)，因此不能用于<code>list</code>，所以<code>list</code>包含了一个使用双向迭代器的<code>sort()</code>方法。</li>\n</ul>\n</li>\n<li><code>forward_list</code> - 不可反转 - 单链表;</li>\n<li><code>queue</code> - 不能随机访问，不能遍历 - 队列;</li>\n<li><code>priority_queue</code> - 最大元素移到对首+<code>queue</code> - 优先级队列;<ul>\n<li>可以接受预定义函数对象；</li>\n<li>用二叉堆实现，数组存储，按二叉树的BFS存放，N的左右孩子为2N和2N+1，删除插入均为O(logn)。</li>\n</ul>\n</li>\n<li><code>stack</code> - 不能随机访问，不能遍历 - 栈。</li>\n<li><code>array</code>(C++11) - 非STL容器，不能动态调整容器大小，但可以使用很多STL标准算法。</li>\n</ol>\n<h3 id=\"关联容器\"><a href=\"#关联容器\" class=\"headerlink\" title=\"关联容器\"></a>关联容器</h3><p>特点：对元素的快速访问，通常是使用某种树来实现，有序的，因此都可以接受预定义函数对象。</p>\n<ol>\n<li><code>set</code> - 键值相同，键唯一，可反转，可排序;</li>\n<li><code>multiset</code> - 值(键)可以不唯一+<code>set</code>;</li>\n<li><code>map</code> - 键值不同，键唯一，可反转，可排序;</li>\n<li><code>multimap</code> - 值可以不唯一+<code>map</code>。</li>\n</ol>\n<h3 id=\"无序关联容器\"><a href=\"#无序关联容器\" class=\"headerlink\" title=\"无序关联容器\"></a>无序关联容器</h3><p>特点：也是将值与键关联，并用键来查找值，但无需关联容器是基于哈斯表的。主要是提高添加和删除元素的速度以及提高查找算法的效率。</p>\n<ol>\n<li><code>unordered_set</code>;</li>\n<li><code>unordered_multiset</code>;</li>\n<li><code>unordered_map</code>;</li>\n<li><code>unordered_multimap</code>。</li>\n</ol>\n","categories":["STL"],"tags":["C++"]},{"title":"STL简介","url":"https://applefishsky009.github.io/2016/07/24/STL简介/","content":"<p>STL提供一组表示容器、迭代器、函数对象和算法的模板。</p>\n<ol>\n<li>容器存储若干个同质的值；</li>\n<li>算法完成特定任务；</li>\n<li>迭代器是广义指针，用来遍历容器对象；</li>\n<li>函数对象是类似于函数的对象，可以是类对象或函数指针。</li>\n</ol>\n<p>注意STL不是面向对象的编程，而是泛型编程。</p>\n<hr>\n<h2 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h2><p>之前介绍，使用都比较多了，简单列举一些：</p>\n<ol>\n<li>重载<code>[]</code>，使用数组表示方来访问元素。</li>\n<li><code>vector</code>模板开头如下，省略模板第二个参数的值时容器模板默认使用<code>allocator&lt;T&gt;</code>类，这个类使用<code>new</code>和<code>delete</code>。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>,<span class=\"title\">class</span> <span class=\"title\">Allocator</span> = <span class=\"title\">allocator</span>&lt;T&gt;&gt;</span></span><br><span class=\"line\"><span class=\"class\">\t<span class=\"title\">class</span> <span class=\"title\">vector</span>&#123;</span>...&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"矢量操作\"><a href=\"#矢量操作\" class=\"headerlink\" title=\"矢量操作\"></a>矢量操作</h2><p>STL容器的基本方法：</p>\n<ol>\n<li><code>size()</code>，返回元素数目；</li>\n<li><code>swap()</code>，交换两个容器内容(可以看作交换名字，<code>a.swap(b)</code>)，与<code>iterator</code>的<code>swap()</code>方法是不同的；</li>\n<li><code>begin()</code>，得到指向容器第一个元素的迭代器；</li>\n<li><code>end()</code>，得到指向容器超尾的迭代器。</li>\n</ol>\n<p>迭代器，是一个广义指针，即一个指针或一个可对其执行类似指针操作的对象(包括解除引用<code>operator*()</code>和递增<code>operator++()</code>等)</p>\n<ol>\n<li><code>for_each(nums.begin(),nums.end(),XXXX)</code>可以避免显式使用迭代器变量,<code>XXX</code>代表对每个元素操作的函数；</li>\n<li><code>random_shuffle(nums.begin(),nums.end())</code>，随机排列区间元素；</li>\n<li><code>sort(nums.begin(),nums.end(),XXX)</code>，排序，<code>XXX</code>是指向要使用的函数的指针(函数对象)，可定制排序方式。<ul>\n<li>全排序中<code>a&lt;b</code>，<code>a&gt;b</code>都不成立，必然是<code>a=b</code>；</li>\n<li>完整弱排序只是说明二者等价(只在比较/排序的项上相同)，不一定相同。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"基于范围的for循环\"><a href=\"#基于范围的for循环\" class=\"headerlink\" title=\"基于范围的for循环\"></a>基于范围的for循环</h2><p>需要注意传值还是传引用。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">double</span> x : prices)\t<span class=\"comment\">//缺点：对数组没有下标索引</span></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; x &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">for_each(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>(), show)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show</span> <span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">double</span> &amp;x)</span></span>&#123;\t<span class=\"comment\">//广义指针操作，依然没有下标索引，值不可变，但是例外，可查看参考文档</span></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; x &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;x : nums) change(x);\t<span class=\"comment\">//值可变，依然没有索引</span></span><br></pre></td></tr></table></figure>\n\n","categories":["STL"],"tags":["C++"]},{"title":"智能指针模板类","url":"https://applefishsky009.github.io/2016/07/22/智能指针模板类/","content":"<p>智能指针模板添加了指针的析构函数，用delete释放动态内存，方式内存泄漏，有三种：</p>\n<ol>\n<li>auto_ptr        (C++98)</li>\n<li>unique_ptr    (C++11)</li>\n<li>shared_ptr    (C++11)</li>\n</ol>\n<hr>\n<h2 id=\"智能指针简介\"><a href=\"#智能指针简介\" class=\"headerlink\" title=\"智能指针简介\"></a>智能指针简介</h2><p>智能指针语法需要头文件<code>&lt;memory&gt;</code>，将初始化指针语法改为构造智能指针语法，删除<code>delete</code>，他可以将<code>new</code>返回的地址赋给智能指针对象，在智能指针过期时，智能指针对象调用析构函数释放指针和动态内存而不用手动释放。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> *p = <span class=\"keyword\">new</span> <span class=\"keyword\">double</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">auto_ptr</span>&lt;<span class=\"keyword\">double</span>&gt; <span class=\"title\">p</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">double</span>)</span></span>;\t<span class=\"comment\">//可以看到这是模板语法，模板位于名称空间std中</span></span><br></pre></td></tr></table></figure>\n\n<p>三种指针详解：</p>\n<ol>\n<li>智能指针类不接受从普通指针的隐式转化(赋值运算符转化)，只能显示转化(将普通指针作为参数传递给构造函数)</li>\n<li><code>auto_ptr</code>和<code>unique_ptr</code>都采用<font color=\"red\">所有权策略</font>，即赋值操作表示转让所有权对象,但其中<code>auto_ptr</code>会有野指针的问题，而<code>unique_ptr</code>不允许留下悬挂的空指针，因此其更为安全。</li>\n<li><code>shared_ptr</code>采用<font color=\"red\">引用计数策略</font>，他会跟踪引用特定对象的智能指针数，仅当最后一个指针过期时才会释放内存。</li>\n</ol>\n<p>注意事项：</p>\n<ol>\n<li><code>unique_ptr</code>不允许留下危险的悬挂指针(赋值操作转让所有权)，仅限于左值，对临时右值，因其无法引用，因此允许赋值。</li>\n<li><code>unique_ptr</code>可用于数组的变体(调用<code>delete</code>或<code>delete[]</code>,对应构造方式),<code>auto_ptr</code>不能(只能调用<code>delete</code>)</li>\n</ol>\n<hr>\n<h2 id=\"使用智能指针\"><a href=\"#使用智能指针\" class=\"headerlink\" title=\"使用智能指针\"></a>使用智能指针</h2><ol>\n<li>如果使用多个指向同一对象的指针，应选择<code>shared_ptr</code>；</li>\n<li>如果不需要多个指向同一个对象的指针，使用<code>unique_ptr</code>；</li>\n<li>考虑到<code>unique_ptr</code>的特性，谨慎使用STL中的算法，因为STL中算法很可能将指针复制或赋给另一个方法或算法(左值),自定义的函数体中一定要按引用传递指针。</li>\n<li><code>shared_ptr</code>有一个显式构造函数可以将<strong>右值</strong><code>unique_ptr</code>转换为<code>shared_ptr</code>,<code>unique_ptr</code>所指对象不可同时出现两个左值智能指针的特性依然满足。</li>\n</ol>\n","categories":["C++的类"],"tags":["C++"]},{"title":"青青河边草，绵绵思远道","url":"https://applefishsky009.github.io/2016/07/21/青青河边草，绵绵思远道/","content":"<p>写在最前</p>\n<p>半个多月没有更新，近来诸事不顺，一周多时间来开题，被导师坑，出差电脑坏了还差点被人骗，导致Github连续60天绿的记录断了4天，知米135天连续也断了，好久没健身，姐姐在荷兰过得不顺心我很担心她，另外非常想念女友。</p>\n<p>讲个好玩的，当天在无锡出差发现电脑坏了，连BIOS都进不去，等不及回北京修，冒着35度大太阳出门修电脑，然后第一家告诉我他只会装系统。。。第二家糊弄了两下告诉我只能换硬盘。。。最后还是自己解决的= =。。。</p>\n<p>对了，我的电脑维修方案是，放两天。。。<br>然后可以进BIOS，一切问题就好解决了，简单来说先备份数据，然后花式格式化和重装系统(4次才搞定)。。。总感觉硬盘？内存？不稳定，随时要崩。</p>\n<hr>\n<blockquote>\n<p>青青河边草。<br>绵绵思远道。<br>远道不可思。<br>宿昔梦见之。<br>梦见在我傍。<br>忽觉在他乡。<br>他乡各异县。<br>展转不可见。<br>枯桑知天风。<br>海水知天寒。<br>入门各自媚。<br>谁肯相为言。<br>客从远方来。<br>遗我双鲤鱼。<br>呼儿烹鲤鱼。<br>中有尺素书。<br>长跪读素书。<br>书中竟何如。<br>上有加餐食。<br>下有长相忆。<br>汉 蔡邕 《饮马长城窟行》</p>\n</blockquote>\n","categories":["ryl"],"tags":["ryl"]},{"title":"Two Pointers","url":"https://applefishsky009.github.io/2016/07/21/Two-Pointers/","content":"<h2 id=\"关于Two-Pointers\"><a href=\"#关于Two-Pointers\" class=\"headerlink\" title=\"关于Two Pointers\"></a>关于Two Pointers</h2><p>一直以来致力于总结算法，方法。正如某些算法书作者所说，这个工作确实不好做，按数据结构显得大而空(精细的方法优化必然是很有针对性的)，而按照方法显得好很多，但是感觉必然总有一些问题徘徊于体系之外(或者说自成体系)，LeetCode上的Tags其实做的很好,一般来说是，数据结构+方法(技巧)。除去基本的数据结构，这些方法/技巧很具有启发意义。</p>\n<p>遇到很多巧妙地利用<code>Two Pointers</code>的题目，感觉无法按照经典分类，这里使其自成体系，这绝对不过分，题目以后会慢慢填充，一般来说其具有以下几个特点：</p>\n<ol>\n<li>针对数组或链表</li>\n<li>针对数组一般是夹逼，begin指针，back指针。</li>\n<li>针对链表一般是记录位置，需要回溯。</li>\n</ol>\n<p>举几个必要的例子，找单链表倒数第k个节点，水的最大容积，有序数组移除重复元素，三色排序，合并有序数组等。</p>\n<hr>\n<h2 id=\"Two-Pointer的实例\"><a href=\"#Two-Pointer的实例\" class=\"headerlink\" title=\"Two Pointer的实例\"></a>Two Pointer的实例</h2><ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/15%20-%203Sum/15%20-%203Sum.cpp\" target=\"_blank\" rel=\"noopener\">3Sum</a><ul>\n<li>先排序，注意跳过重复值，且遍历后再跳以便于第三个指针可以跳到前两个指针的重复值(如果有的话)；</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/19%20-%20Remove%20Nth%20Node%20From%20End%20of%20List/19%20-%20Remove%20Nth%20Node%20From%20End%20of%20List.cpp\" target=\"_blank\" rel=\"noopener\">Remove Nth Node From End of List</a><ul>\n<li>使用头结点不必对第一个逻辑结点单独处理。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/16%20-%203Sum%20Closest/16%20-%203Sum%20Closest.cpp\" target=\"_blank\" rel=\"noopener\">3Sum Closest</a><ul>\n<li>夹逼的精髓是两侧逼近，如水的容积，正数组和为k的最长长度；</li>\n<li>注意迭代器方法的使用可以简化编程。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/18%20-%204Sum/18%20-%204Sum.cpp\" target=\"_blank\" rel=\"noopener\">4Sum</a><ul>\n<li>固定两个位置，两个指针夹逼；</li>\n<li>注意提前减枝，去掉相同解。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/27%20-%20Remove%20Element/27%20-%20Remove%20Element.cpp\" target=\"_blank\" rel=\"noopener\">Remove Element</a><ul>\n<li>模拟<code>remove()</code>函数。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/141%20-%20Linked%20List%20Cycle/141%20-%20Linked%20List%20Cycle.cpp\" target=\"_blank\" rel=\"noopener\">Linked List Cycle</a><ul>\n<li>快慢指针相遇，说明链表有环。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/142%20-%20Linked%20List%20Cycle%20II/142%20-%20Linked%20List%20Cycle%20II.cpp\" target=\"_blank\" rel=\"noopener\">Linked List Cycle II</a><ul>\n<li>设快慢指针相遇时慢指针走了\\( s \\)步，环长为\\( r \\)，那么对快指针：\\( 2s = s+nr \\)；即有关系\\( s = nr \\)；(注意相遇时慢指针一定没有走完链表一次);</li>\n<li>设链表长度为\\( L \\),链表头到环结点的距离为\\( x \\),环结点到快慢指针相遇结点的距离为\\( a \\),那么\\( s(x+a) = nr((n-1)*r+L-x) \\);</li>\n<li>即有关系：\\( x = (n-1)r+(L-x-a) \\),\\( L-x-a \\)在链表上代表相遇结点到环结点的距离！</li>\n<li>记住结论：快慢指针相遇时，两个慢指针，一个从链表头出发，一个从相遇点出发，他们相遇在环入口。</li>\n</ul>\n</li>\n</ol>\n<p>$$$$</p>\n","categories":["数据结构与算法"],"tags":["Algorithm"]},{"title":"深入了解string类","url":"https://applefishsky009.github.io/2016/07/01/深入了解string类/","content":"<p>之前由于编程过程中经常使用，在<a href=\"http://rylcode.cn/2016/04/21/string%E4%B8%8Ecctype/\" target=\"_blank\" rel=\"noopener\">string类与cctype</a>等博客中简单介绍过一些<code>string</code>相关的方法，迭代器，算法的用法。这篇主要是以一个类的角度深入系统地管理<code>string</code>类知识。可在<a href=\"http://www.cplusplus.com/reference/string/\" target=\"_blank\" rel=\"noopener\">cplus上的string</a>查阅各种方法用法。</p>\n<hr>\n<h2 id=\"模板具体化\"><a href=\"#模板具体化\" class=\"headerlink\" title=\"模板具体化\"></a>模板具体化</h2><p><code>string</code>是模板<code>basic_string&lt;char&gt;</code>的一个typedef，<code>basic_string</code>有四个具体化，都有<code>typedef</code>名称：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">charT</span>, <span class=\"title\">class</span> <span class=\"title\">traits</span> = <span class=\"title\">char_traits</span>&lt;charT&gt;, <span class=\"title\">class</span> <span class=\"title\">Allocator</span> = <span class=\"title\">allocator</span>&lt;charT&gt; &gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">basic_string</span>&#123;</span>...&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> basic_string&lt;<span class=\"keyword\">char</span>&gt; <span class=\"built_in\">string</span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> basic_string&lt;<span class=\"keyword\">wchar_t</span>&gt; <span class=\"built_in\">wstring</span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> basic_string&lt;<span class=\"keyword\">char16_t</span>&gt; u16string;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> basic_string&lt;<span class=\"keyword\">char32_t</span>&gt; u32string;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><code>charT</code>表示选定字符类型；</li>\n<li><code>traits</code>描述选定字符类型的特定情况(如值比较)；</li>\n<li><code>Allocator</code>类管理内村分配，每种字符类类型，都有预定义(默认)的<code>allocator</code>模板具体化，使用<code>new</code>和<code>delete</code>。</li>\n</ol>\n<hr>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">default</span> (<span class=\"number\">1</span>)\t<span class=\"built_in\">string</span>();</span><br><span class=\"line\">copy (<span class=\"number\">2</span>)\t<span class=\"built_in\">string</span> (<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; str);</span><br><span class=\"line\">substring (<span class=\"number\">3</span>)\t<span class=\"built_in\">string</span> (<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; str, <span class=\"keyword\">size_t</span> pos, <span class=\"keyword\">size_t</span> len = npos);</span><br><span class=\"line\">from c-<span class=\"built_in\">string</span> (<span class=\"number\">4</span>)\t<span class=\"built_in\">string</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s);</span><br><span class=\"line\"><span class=\"function\">from <span class=\"title\">buffer</span> <span class=\"params\">(<span class=\"number\">5</span>)</span>\t<span class=\"title\">string</span> <span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s, <span class=\"keyword\">size_t</span> n)</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">fill</span> (<span class=\"number\">6</span>)\t<span class=\"built_in\">string</span> (<span class=\"keyword\">size_t</span> n, <span class=\"keyword\">char</span> c);</span><br><span class=\"line\">range (<span class=\"number\">7</span>)\t<span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputIterator</span>&gt;\t//指针模板</span></span><br><span class=\"line\"><span class=\"class\">  \t\t\t<span class=\"title\">string</span>  (<span class=\"title\">InputIterator</span> <span class=\"title\">first</span>, <span class=\"title\">InputIterator</span> <span class=\"title\">last</span>);</span></span><br><span class=\"line\"><span class=\"function\">initializer <span class=\"title\">list</span> <span class=\"params\">(<span class=\"number\">8</span>)</span>\t<span class=\"title\">string</span> <span class=\"params\">(<span class=\"built_in\">initializer_list</span>&lt;<span class=\"keyword\">char</span>&gt; il)</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">move</span> (<span class=\"number\">9</span>)\t<span class=\"built_in\">string</span> (<span class=\"built_in\">string</span>&amp;&amp; str) <span class=\"keyword\">noexcept</span>;</span><br></pre></td></tr></table></figure>\n\n<p>大部分很容易理解，特别说明的几个：</p>\n<ol>\n<li>(5)中从s指针开始位置开始构造n个字符，即使超过了NBTS(以空字符结束的字符串)；</li>\n<li>(8)是为了普遍化列表初始化语法，其使用意义并不大；</li>\n<li>(9)-移动构造函数与(2)的区别是不将<code>string</code>视为<code>const</code>，主要用来在一些情况下优化性能。</li>\n</ol>\n<hr>\n<h2 id=\"输入\"><a href=\"#输入\" class=\"headerlink\" title=\"输入\"></a>输入</h2><p><code>string</code>对象有两种输入方式(<code>cin.getline()</code>和<code>cin.get()</code>是C风格的输入方式)：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> s;</span><br><span class=\"line\"><span class=\"built_in\">cin</span>&gt;&gt;s;\t<span class=\"comment\">//read a word</span></span><br><span class=\"line\">getline(<span class=\"built_in\">cin</span>,s);\t<span class=\"comment\">//read a line, discard \\n, 接受第三个参数作为分界符，默认\\n</span></span><br></pre></td></tr></table></figure>\n\n<p><code>getline()</code>的<code>string</code>版本是一个独立的函数而不是<code>istream</code>类的方法，他可以自动调整目标对象大小使之刚好存储，他受到两个条件限制：</p>\n<ol>\n<li><code>string</code>对象最大允许长度(<code>string::npos</code>)，通常是<code>unsigned int</code>最大值；</li>\n<li>内存量大小。</li>\n</ol>\n<p>他在以下情况下停止读取：</p>\n<ol>\n<li>到达文件尾(EOF)，输入流<code>ios_base::iostate</code>设置为<code>ios::eof</code>(只有<code>ios::good</code>才能读取，<code>cin.clear()</code>可纠正)；</li>\n<li>分界字符(默认为<code>\\n</code>)；</li>\n<li>读取字符数最大允许值<code>string::npos</code>(注意他的类型为<code>size_t</code>)，输入流<code>ios_base::iostate</code>设置为<code>ios::fail</code>.</li>\n</ol>\n<h3 id=\"一般的简单连续输入\"><a href=\"#一般的简单连续输入\" class=\"headerlink\" title=\"一般的简单连续输入\"></a>一般的简单连续输入</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> s;</span><br><span class=\"line\"><span class=\"keyword\">int</span> i;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"built_in\">cin</span> &gt;&gt; s &gt;&gt;i) &#123;\t<span class=\"comment\">//读入binding 123这种输入</span></span><br><span class=\"line\"> ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> s;</span><br><span class=\"line\"><span class=\"keyword\">int</span> i;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"built_in\">cin</span> &gt;&gt; s) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (s == <span class=\"string\">\"end\"</span>) <span class=\"keyword\">break</span>;\t<span class=\"comment\">//end开头表示没有数字</span></span><br><span class=\"line\">\t<span class=\"built_in\">cin</span> &gt;&gt; i;\t\t<span class=\"comment\">//从缓存区读入</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"使用字符串\"><a href=\"#使用字符串\" class=\"headerlink\" title=\"使用字符串\"></a>使用字符串</h2><h3 id=\"比较\"><a href=\"#比较\" class=\"headerlink\" title=\"比较\"></a>比较</h3><p>主要是重载了关系运算符。</p>\n<h3 id=\"搜索\"><a href=\"#搜索\" class=\"headerlink\" title=\"搜索\"></a>搜索</h3><p>以<code>find()</code>方法为例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> (<span class=\"number\">1</span>)\t<span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">find</span> <span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; str, <span class=\"keyword\">size_t</span> pos = <span class=\"number\">0</span>)</span> <span class=\"keyword\">const</span> <span class=\"keyword\">noexcept</span></span>;</span><br><span class=\"line\">c-<span class=\"built_in\">string</span> (<span class=\"number\">2</span>)\t<span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">find</span> <span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s, <span class=\"keyword\">size_t</span> pos = <span class=\"number\">0</span>)</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">buffer</span> (<span class=\"number\">3</span>)\t<span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">find</span> <span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s, <span class=\"keyword\">size_t</span> pos, size_type n)</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">character (<span class=\"number\">4</span>)\t<span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">find</span> <span class=\"params\">(<span class=\"keyword\">char</span> c, <span class=\"keyword\">size_t</span> pos = <span class=\"number\">0</span>)</span> <span class=\"keyword\">const</span> <span class=\"keyword\">noexcept</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>注意(3)中n表示限制了子串的长度。下列其他的方法原型类似：</p>\n<ol>\n<li><code>rfind()</code>找最后一次出现的位置；</li>\n<li><code>find_first_of()</code>找参数中<strong>任何</strong>字符第一次出现的位置；</li>\n<li><code>find_last_of</code>找参数中<strong>任何</strong>字符最后一次出现的位置’</li>\n<li><code>find_first_not_of</code>找字符串中第一个不在参数串中的字符位置；</li>\n<li><code>find_last_not_of</code>找字符串中最后一个不在参数串中的字符位置。</li>\n</ol>\n<p>注意以上不管是什么寻找方法(<code>first</code>类寻找或者<code>last</code>类寻找)，找不到都会返回<code>string::npos</code>;</p>\n<hr>\n<h2 id=\"其他功能\"><a href=\"#其他功能\" class=\"headerlink\" title=\"其他功能\"></a>其他功能</h2><p>列出功能提纲，如有需要可以扩充上一目录中：</p>\n<ol>\n<li>删除(erase)；</li>\n<li>替换(replace)；</li>\n<li>插入(insert)；</li>\n<li>提取(substring)；</li>\n<li>复制(copy)；</li>\n<li>交换(swap)；</li>\n</ol>\n<hr>\n<h2 id=\"重载的运算符\"><a href=\"#重载的运算符\" class=\"headerlink\" title=\"重载的运算符\"></a>重载的运算符</h2><ol>\n<li><code>+</code>；</li>\n<li><code>=</code>；</li>\n<li><code>+=</code>;</li>\n<li><code>[]</code>;</li>\n<li><code>&gt;&gt;</code>;</li>\n<li><code>&gt;&gt;</code>;</li>\n<li>关系运算符。</li>\n</ol>\n<h3 id=\"重载\"><a href=\"#重载\" class=\"headerlink\" title=\"[]重载\"></a>[]重载</h3><p>三观尽毁，先来一个概念<a href=\"https://en.wikipedia.org/wiki/Null-terminated_string\" target=\"_blank\" rel=\"noopener\">Null-terminated string</a>,再来参考文档<a href=\"http://www.cplusplus.com/reference/string/string/operator[]/\" target=\"_blank\" rel=\"noopener\">operator[]</a>。解释一下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> s;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> flag = s[s.<span class=\"built_in\">size</span>()] == <span class=\"string\">'\\0'</span>；</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><code>s[s.size()]</code>不会抛出异常，调试时监视器提示越界(坑，越界是没错，但其有值!)</li>\n<li><code>flag</code>等于<code>true</code>，也就是说<code>s[s.size()]</code>的值为<code>&#39;\\0&#39;</code>。</li>\n</ol>\n","categories":["STL"],"tags":["C++"]},{"title":"RTTI","url":"https://applefishsky009.github.io/2016/06/29/RTTI/","content":"<h2 id=\"RTTI\"><a href=\"#RTTI\" class=\"headerlink\" title=\"RTTI\"></a>RTTI</h2><p>RTTI(Runtime Type Identification)，是运行阶段类型识别。<br>在以下三种情况下需要在运行阶段知道类型(指针指向的对象)：</p>\n<ol>\n<li>调用类方法的正确版本(通过虚方法已经解决)；</li>\n<li><strong>调用派生类对象独有的方法</strong>(这需要将基类指针转化为派生类指针)；</li>\n<li>调试需要跟踪对象类型。</li>\n</ol>\n<p>以下三种方法支持RTTI:</p>\n<ol>\n<li><code>dynamic_cast</code>运算符将使用一个指向基类(expr)的指针来生成指向派生类的指针(target type)(<font color=\"red\">这个指针指向的对象继承层次必须低于要转化的层次</font>)，否则返回<code>nullptr</code>；</li>\n<li><code>typeid</code>返回指出对象类型的值；</li>\n<li><code>typed_info</code>结构存储特定类型信息；</li>\n</ol>\n<h3 id=\"dynamic-cast运算符\"><a href=\"#dynamic-cast运算符\" class=\"headerlink\" title=\"dynamic_cast运算符\"></a>dynamic_cast运算符</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">dynamic_cast</span>&lt;target-type&gt; (expr)</span><br></pre></td></tr></table></figure>\n\n<p>他解决这样一个问题：expr(对象指针或引用)是否可以转化为target-type的指针或引用。如果可以，返回目标指针/引用，否则返回<code>nullptr</code>。<a href=\"http://www.cplusplus.com/forum/general/33626/\" target=\"_blank\" rel=\"noopener\">cplusplus-Forum</a>明确指出<strong>被铸造的指针/引用应该是expr类类型或其派生类类型</strong>。</p>\n<p>应尽可能使用虚函数，只在必要时使用RTTI。以下是指针和引用的使用例子：<br>指针用法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object *p = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\">DerivedObject *q = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (q = <span class=\"keyword\">dynamic_cast</span>&lt;DerivedObject *&gt;(p))&#123;</span><br><span class=\"line\">\tq-&gt;uniqueFunc();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>引用用法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;\t<span class=\"comment\">//因为没有与空指针对应的引用类型</span></span><br><span class=\"line\">\t<span class=\"function\">Object <span class=\"title\">test</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\tObject &amp;p = test;</span><br><span class=\"line\">\tDerivedObject &amp;q = <span class=\"keyword\">dynamic_cast</span>&lt;DerivedObject &amp;&gt;(p)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span> (bad_cast &amp;)&#123;\t<span class=\"comment\">//&lt;typeinfo&gt;中定义</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"typeid运算符和type-info类\"><a href=\"#typeid运算符和type-info类\" class=\"headerlink\" title=\"typeid运算符和type_info类\"></a>typeid运算符和type_info类</h3><p><code>typeid</code>运算符接受类名或结果为对象的表达式，返回一个<code>type_info</code>对象的引用,重载<code>==</code>,<code>!=</code>，可用来判断两个类型是否一致。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Object <span class=\"title\">test</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">Object *p = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeid</span>(test) == <span class=\"keyword\">typeid</span>(*p))&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>值得注意的是如果在<code>if_else</code>语句中使用了<code>tpyeid</code>，则考虑使用<code>dynamic_cast</code>。</p>\n<hr>\n<h2 id=\"类型转换运算符\"><a href=\"#类型转换运算符\" class=\"headerlink\" title=\"类型转换运算符\"></a>类型转换运算符</h2><p>向上类型转换：派生类向基类转化。<br>向下类型转换：基类向派生类转化。<br>根据目的提供四个运算符：</p>\n<ol>\n<li>dynamic_cast;</li>\n<li>const_cast;</li>\n<li>static_cast;</li>\n<li>reinterpret_cast。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xxxxx_cast&lt;target-type&gt; (expr)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"dynamic-cast\"><a href=\"#dynamic-cast\" class=\"headerlink\" title=\"dynamic_cast\"></a>dynamic_cast</h3><p>对指向对象的指针来说，他支持向上转化(也就是说他在运行阶段会检查转换是否安全)，如果不安全(不是向上转化)返回<code>nullptr</code>，如果不是多态，编译出错。</p>\n<h3 id=\"const-cast\"><a href=\"#const-cast\" class=\"headerlink\" title=\"const_cast\"></a>const_cast</h3><p>改变值为<code>const</code>或者<code>vilatile</code>，例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *b = &amp;a;</span><br><span class=\"line\"><span class=\"comment\">//*b = 6;\t//invalid because const</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *c = <span class=\"keyword\">const_cast</span>&lt;<span class=\"keyword\">int</span> *&gt;(b);</span><br><span class=\"line\">*c = <span class=\"number\">9</span>;</span><br></pre></td></tr></table></figure>\n\n<p>注意他修改一个指向值的指针，但修改<code>const</code>值得结果是不确定的。仅当指向的值不是<code>const</code>时才可行。</p>\n<h3 id=\"static-cast\"><a href=\"#static-cast\" class=\"headerlink\" title=\"static_cast\"></a>static_cast</h3><p><a href=\"http://www.cplusplus.com/forum/general/79249/\" target=\"_blank\" rel=\"noopener\">using static_cast to downcast</a>,他在运行阶段不会检查转化是否合理(假设是合理的)，因此可以向下转化(这一般情况下是不允许的，因为不安全)，因此<code>static_cast</code>更快一些，相比<code>dynamic_cast</code>来说(需要多态)，更像显式的强制类型转化，因此数值指针转化都用他。<br>使用心得：</p>\n<ol>\n<li>因为不安全，因此一定在100%确认转化是合理的才能使用<code>static_cast</code>；</li>\n<li>在不确认转换是否合理时，使用<code>dynamic_cast</code>。</li>\n</ol>\n<h3 id=\"reinterpret\"><a href=\"#reinterpret\" class=\"headerlink\" title=\"reinterpret\"></a>reinterpret</h3><p><a href=\"http://www.cplusplus.com/forum/general/47849/\" target=\"_blank\" rel=\"noopener\">When to use reinterpret_cast</a>他执行一些危险的类型转化，如“改变编译器解释数据的方式”</p>\n<ol>\n<li>他不允许删除<code>const</code>；</li>\n<li>可以将指针类型转换为足以存储指针表示的整型，但不能将指针转换为更小的整型或浮点型；</li>\n<li>转换为一种类型到<strong>完全不同的类型</strong>而不改变位；</li>\n<li>不能将函数指针转化为数据指针。</li>\n</ol>\n<p><a href=\"http://baike.baidu.com/item/reinterpret_cast\" target=\"_blank\" rel=\"noopener\">static_cast和reinterpret_cast的区别</a>,要谨慎使用<code>reinterpret_cast</code>(按字节<strong>重新解释</strong>)</p>\n","categories":["C++基础"],"tags":["C++"]},{"title":"异常","url":"https://applefishsky009.github.io/2016/06/27/异常/","content":"<h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><p>预防运行阶段错误。</p>\n<h3 id=\"异常终止-abort\"><a href=\"#异常终止-abort\" class=\"headerlink\" title=\"异常终止(abort())\"></a>异常终止(abort())</h3><p>程序员可以调用abort()函数来终止程序。其位于&lt; cstdlib &gt;中，向标准错误流发送消息abnormal program termination(程序异常终止)(这个消息随编译器而异)，并终止程序。</p>\n<h3 id=\"数值检查防止异常终止\"><a href=\"#数值检查防止异常终止\" class=\"headerlink\" title=\"数值检查防止异常终止\"></a>数值检查防止异常终止</h3><p>依靠程序来避免错误导致的程序终止(可靠性)，但是不需要经常这么做，因为程序过于冗长(一般以短小精悍实现目的为主)。</p>\n<ol>\n<li>对于有返回值的函数，可以讲返回值作为<strong>指针</strong>或引用传递(可以明显区分哪个参数用于答案)，将返回值设置为<code>bool</code>标识是否有错误，以便在调用中检查异常。</li>\n</ol>\n<h3 id=\"使用异常机制\"><a href=\"#使用异常机制\" class=\"headerlink\" title=\"使用异常机制\"></a>使用异常机制</h3><p>使用三个关键字将控制权从程序的一个部分传递到另一部分的途径。</p>\n<ol>\n<li>使用<code>throw</code>引发异常；</li>\n<li>使用<code>catch</code>捕获特定异常(一个<code>try</code>块可以跟多个<code>catch</code>块)；</li>\n<li>使用<code>try</code>标志可能激活特定异常的代码块。</li>\n</ol>\n<p>注意不一定抛出<code>exception</code>类，只要<code>throw</code>和<code>catch</code>的类型一致，异常就能捕获。例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"string\">\"Now I throw a string\"</span></span><br><span class=\"line\"><span class=\"keyword\">catch</span>(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *s)&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><code>throw</code>会执行返回语句，终止函数执行；</li>\n<li>返回后在<code>catch</code>中进行异常匹配，如果没有匹配，将会调用<code>abort()</code>(这个行为可以修改)。</li>\n</ol>\n<h3 id=\"将对象作为异常类型\"><a href=\"#将对象作为异常类型\" class=\"headerlink\" title=\"将对象作为异常类型\"></a>将对象作为异常类型</h3><p>异常类型指的是抛出的类型(字符串或对象)，使用对象有两个好处：</p>\n<ol>\n<li>不同的异常类型(抛出对象)区分不同的函数引发的异常；</li>\n<li>这个返回的异常可以携带信息，便于确定引发异常的原因。</li>\n</ol>\n<h3 id=\"C-11唯一支持的异常规范\"><a href=\"#C-11唯一支持的异常规范\" class=\"headerlink\" title=\"C++11唯一支持的异常规范\"></a>C++11唯一支持的异常规范</h3><p>C++98新增异常规范功能,他主要告诉用户函数可能引发异常，因此建议对这个函数使用异常机制</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">double</span> a)</span> <span class=\"title\">throw</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *s)</span></span>;\t<span class=\"comment\">//这项工作显然在注释中可以完成</span></span><br></pre></td></tr></table></figure>\n\n<p>C++11唯一支持的异常规范,指出这个函数不会引发异常</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">double</span>)</span> noexpect</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"栈解退\"><a href=\"#栈解退\" class=\"headerlink\" title=\"栈解退\"></a>栈解退</h3><p>不同于函数调用和返回的过程(释放栈到第一个返回地址停止)，如果引发异常，程序一直释放栈直到第一个位于<code>try</code>块中的返回地址(块中函数的返回地址<code>;</code>)，然后程序转移到<code>catch</code>块而不是调用函数的下一条语句.</p>\n<ol>\n<li>引发异常时栈解退到能引发异常的地方；</li>\n<li>和函数返回一样，栈中的自动类对象，类的析构函数将被调用；</li>\n<li>如果返回到最近的<code>try</code>块但是没有异常匹配，那么会继续栈解退，直到最后的<code>try</code>块，不匹配再调用<code>abort()</code>； </li>\n<li><code>catch</code>块使用<code>exit(EXIT_FAILURE)</code>立即终止程序，异常机制依然负责释放自动变量。</li>\n</ol>\n<h3 id=\"异常特性\"><a href=\"#异常特性\" class=\"headerlink\" title=\"异常特性\"></a>异常特性</h3><ol>\n<li>如果返回到最近的<code>try</code>块但是没有异常匹配，那么会继续栈解退，直到最后的<code>try</code>块，不匹配再调用<code>abort()</code>；</li>\n<li>引发异常时，编译器总会创建一个临时拷贝，即使异常规范和<code>catch</code>块中指定的是引用(这是作用域的问题)。</li>\n<li><font color=\"red\">有2的特性为什么还要使用引用？</font>这是因为基类引用可以引用派生类对象。因此在异常类继承层次结构中，更具体的异常类应该放在前边匹配(<code>catch</code>)，而在<code>throw</code>中，恰好相反(is-a关系，基类不是派生类，而派生类是基类)。</li>\n</ol>\n<p>捕获一切异常(与<code>switch</code>中的<code>default</code>相似)：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">catch</span> (...)&#123;</span><br><span class=\"line\">\t...\t<span class=\"comment\">//statement</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"exception类\"><a href=\"#exception类\" class=\"headerlink\" title=\"exception类\"></a>exception类</h3><p><a href=\"http://www.cplusplus.com/reference/exception/exception/?kw=exception\" target=\"_blank\" rel=\"noopener\">&lt; exception &gt;</a>头文件定义的<code>exception</code>类提供异常的语言支持(可以作为其他异常的基类)。</p>\n<ol>\n<li>公有虚成员函数<code>const char * what(){return &quot;Your own description&quot;}</code>，继承并隐藏后可以代替用字符串作为异常类型。</li>\n</ol>\n<p><a href=\"http://www.cplusplus.com/reference/stdexcept/?kw=stdexcept\" target=\"_blank\" rel=\"noopener\">&lt; stdexcept &gt;</a>头文件从&lt; exception &gt;公有派生，定义了<code>logic_error</code>和<code>runtime_error</code>类。</p>\n<ol>\n<li>共7种异常类型(定义域错误，参数错误，空间不足，索引错误，范围溢出，上溢，下溢)，每个类有一个构造函数，提供方法<code>what()</code>返回的字符串。</li>\n</ol>\n<p><a href=\"http://www.cplusplus.com/reference/new/bad_alloc/\" target=\"_blank\" rel=\"noopener\">&lt; new &gt;</a>头文件包含<code>bad_alloc</code>类的声明，从&lt; exception &gt;类公有派生而来，用来标识无法分配请求的内存量(new引发)。</p>\n<ol>\n<li>可以设计使<code>new</code>失败时返回空指针(这很合理)，C++提供了一种用法，指出不会抛出异常(用空指针代替)：<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *p = <span class=\"keyword\">new</span> (<span class=\"built_in\">std</span>::nothrow) <span class=\"keyword\">int</span>;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"异常，类和继承\"><a href=\"#异常，类和继承\" class=\"headerlink\" title=\"异常，类和继承\"></a>异常，类和继承</h3><p>因为异常类也是类，所以可以继承，可以嵌套。</p>\n<ol>\n<li>从一个异常类中派生出另一个类；</li>\n<li>在类定义中嵌套异常类声明来组合异常，被嵌套类的方法定义式需要使用多个作用域解析符；</li>\n<li>嵌套的类(一般在类公有部分声明)本身可以被继承，可用作基类。</li>\n</ol>\n<h3 id=\"迷失方向的异常\"><a href=\"#迷失方向的异常\" class=\"headerlink\" title=\"迷失方向的异常\"></a>迷失方向的异常</h3><p>即对未捕获异常或者意外异常的反应。<br>引发异常后两种情况会导致问题：</p>\n<ol>\n<li>异常规范没有异常匹配导致程序异常终止；</li>\n<li>异常不在函数中引发(或者函数没有异常规范)，必须捕获，否则也会异常终止。</li>\n</ol>\n<h4 id=\"未捕获异常\"><a href=\"#未捕获异常\" class=\"headerlink\" title=\"未捕获异常\"></a>未捕获异常</h4><p>程序意外终止时，不直接调用<code>abort()</code>函数，他通过<code>terminate()</code>函数调用<code>abort()</code>(默认)，因此可以修改<code>terminate()</code>调用的函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myAbort</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t...;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">set_terminate(myAbort);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"意外异常\"><a href=\"#意外异常\" class=\"headerlink\" title=\"意外异常\"></a>意外异常</h4><p>函数引发了异常规范中没有的异常。将调用<code>unexpected()</code>函数，这个函数调用<code>terminate()</code>(默认)，<code>terminate()</code>调用<code>abort()</code>,同理可修改这个默认值：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;exception&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">myUnexpected</span><span class=\"params\">()</span></span>&#123;\t<span class=\"comment\">//将意外异常转化为bad_exception</span></span><br><span class=\"line\">\t<span class=\"keyword\">throw</span> bad_exception;\t<span class=\"comment\">//如果不指定抛出的异常，会重新引发原来的异常</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">set_unexpected(myunexpected);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><p>可能内存泄漏，栈解退对动态管理的内存是ok的,但是程序员管理的内存，解退时可能释放指针造成内存泄漏，有两个解决方案：</p>\n<ol>\n<li>在调用的函数中也使用异常机制，抓取所有异常来管理内存并抛出原本想抛出的异常(这是在原本的异常层次中强行植入一层来执行想要的操作，原本程序的代码顺序没有任何变化)；<ul>\n<li>简单理解不同的地方，逻辑为，函数中有异常要先释放内存再抛出异常(那么不使用异常机制，在抛出异常前释放也ok?)。</li>\n</ul>\n</li>\n<li>使用智能指针模板。</li>\n</ol>\n","categories":["C++基础"],"tags":["C++"]},{"title":"常见排序算法","url":"https://applefishsky009.github.io/2016/06/25/常见排序算法/","content":"<p>虽然接触各种排序，但恐才疏学浅一直以来未开始总结。今日先列出一个提纲，慢慢填充。<br><a href=\"https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95\" target=\"_blank\" rel=\"noopener\">wikipedia - 排序算法</a><br>什么是排序算法的稳定性？</p>\n<ol>\n<li>不稳定的排序算法可能在相等的键值中改变记录的相对次序，但是稳定排序算法从不会如此。</li>\n<li>不稳定排序算法可以扩充第二键值的比较，实现为稳定的排序算法。</li>\n</ol>\n<hr>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><p>从无序区通过交换找出最大元素放到有序区前端；<br>代码都比较简单，略过不谈；</p>\n<ol>\n<li>数据对象：数组(并不是说链表不能用冒泡，确实是毫无优势)；</li>\n<li>相邻交换并不会改变相同值元素的相对位置，因此冒泡排序时<font color=\"red\">稳定</font>的；</li>\n<li>时间复杂度：平均O(n^2),最坏O(n^2)；</li>\n<li>额外空间复杂度：O(1)。</li>\n</ol>\n<hr>\n<h2 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h2><p>从无序区找出一个最小的元素跟在有序区的后面。<br>代码比较简单，依然略过不谈。<br><a href=\"https://www.zhihu.com/question/20926405\" target=\"_blank\" rel=\"noopener\">知乎 - 选择排序究竟属于稳定排序还是不稳定排序？</a></p>\n<ol>\n<li>数据对象：数组，链表。</li>\n<li>对数组就地排序：<font color=\"red\">不稳定</font>，因为他包含交换操作，破坏了相对顺序，比如<code>5^1，5^2，2</code>-&gt;<code>2,5^2,5^1</code>；<br>对链表和新数组的排序：本质上时插入排序，因此他是<font color=\"red\">稳定</font>的；</li>\n<li>时间复杂度：平均O(n^2),最坏O(n^2)；</li>\n<li>额外空间复杂度：O(1)。</li>\n</ol>\n<hr>\n<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><p>把无序区的第一个元素插入到有序区合适的位置。<br>代码比较简单，依然略过不谈。</p>\n<ol>\n<li>数据对象：数组，链表。</li>\n<li>他是<font color=\"red\">稳定</font>的排序方式，通常采用就地实现，即用O(1)的额外空间取出无序区的元素，后移有序区小于/大于他的元素。</li>\n<li>时间复杂度：平均O(n^2),最坏O(n^2)；</li>\n<li>额外空间复杂度：O(1)。</li>\n</ol>\n<hr>\n<h2 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h2><p>从堆顶把根卸出来放在有序区之前，再恢复堆。<br><a href=\"https://github.com/applefishsky009/DataStructuresAndAlgorithms/blob/master/3%20-%20HeapSort/HeapSort.cpp\" target=\"_blank\" rel=\"noopener\">堆排序 - C++</a></p>\n<ol>\n<li>数据对象：数组；</li>\n<li>堆排序是<font color=\"red\">不稳定</font>的，因为建立堆的过程有交换操作，会破坏相对顺序，比如<code>5^1,5^2,9</code>-&gt;<code>9,5^2,5^1</code>；</li>\n<li>时间复杂度：O(n*logn);</li>\n<li>额外空间复杂度：O(1)。</li>\n</ol>\n<hr>\n<h2 id><a href=\"#\" class=\"headerlink\" title></a></h2><hr>\n<h2 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h2><p>桶排序是常见排序算法中最快的排序，时间复杂度为O(n)，他的核心思想是将每一个元素放在他”应该”在的位置，数据结构是指针数组，每个指针是一个链表。<br>举两个实际中的例子：</p>\n<ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode\" target=\"_blank\" rel=\"noopener\">github</a>组织文件夹的方式就是桶排序；</li>\n<li>用程序(已测试过C++,MATLAB)读取一个文件夹的所有文件时，不管文件夹中文件如何排序，程序的遍历方式是(按文件名)桶排序的。</li>\n</ol>\n<p>算法实例：</p>\n<ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/41%20-%20First%20Missing%20Positive/41%20-%20First%20Missing%20Positive.cpp\" target=\"_blank\" rel=\"noopener\">First Missing Positive</a><ul>\n<li>O(n)时间复杂度，首先想到Hash Table，但是必然会有O(n)的空间复杂度，也不能用两个指针来简化；</li>\n<li>考虑到桶排序，将所有的元素放在他应该在的位置，再遍历一次就得到异常元素；</li>\n<li>注意避免无限交换(比如[1,1]序列)。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/75%20-%20Sort%20Colors/75%20-%20Sort%20Colors.cpp\" target=\"_blank\" rel=\"noopener\">Sort Colors</a><ul>\n<li>两个指针排序，我也不知道该分类为什么排序算法 = =</li>\n</ul>\n</li>\n</ol>\n","categories":["数据结构与算法"],"tags":["Algorithm"]},{"title":"友元类和嵌套类","url":"https://applefishsky009.github.io/2016/06/23/友元类和嵌套类/","content":"<p>主要介绍友元类，友元成员函数，嵌套类。友元类在本类中声明，友元成员函数是另一个类的成员函数，在本类中声明为友元，嵌套类是在本类中声明并定义的类。友元的声明都要使用<code>friend</code>关键字。</p>\n<hr>\n<h2 id=\"友元类\"><a href=\"#友元类\" class=\"headerlink\" title=\"友元类\"></a>友元类</h2><ol>\n<li>友元类的所有方法都可以访问原始类的私有成员和保护成员；</li>\n<li>友元成员函数是比友元类更明确的用法，因此这另一个类和本类的关系必须是可以被声明为友元类(改变本类中的数据成员，但不是is-a关系)；</li>\n<li>哪些函数，成员函数，或者类是本类的友元必须由本类定义，而不能从外部声明为友元(这样本类是不可见的，也不能给予他访问权限)。</li>\n</ol>\n<h3 id=\"友元类-1\"><a href=\"#友元类-1\" class=\"headerlink\" title=\"友元类\"></a>友元类</h3><ol>\n<li>友元类不是本类的一部分(非is-a关系)，但是可以改变本类的状态(如遥控器和电视机)；</li>\n<li>友元声明可以位于公有，私有或者保护部分，其所在的位置无关紧要；</li>\n<li>友元类的私有数据可以用来描述友元类的特性；</li>\n<li>除构造函数外，所有的友元类函数都将一个本类对象作为参数，这表明友元类针对特定的本类对象。</li>\n</ol>\n<p>友元描述一种关系，如果不用友元，必须将本类状态数据设置为公有(不安全)或者用一个大型类来同时包含本类和友元类对象(过于笨拙而且一个友元类对象不能用于多个本类对象)，而使用友元，一个友元类对象可以传入任意本类对象。</p>\n<h3 id=\"友元成员函数\"><a href=\"#友元成员函数\" class=\"headerlink\" title=\"友元成员函数\"></a>友元成员函数</h3><p>仅仅让直接访问本类私有成员的友元类成员成员本类的成员函数，而不必使整个类成为本类的成员类。</p>\n<ol>\n<li>对本类使用前向声明(forward declaration)而不是友元类，如果对友元类前向声明，本类可以看到友元类的声明，但是看不到友元成员函数的声明；</li>\n<li>友元类中只包含方法声明，将实际定义放在本类之后，这是由于内联的友元类中调用的本类方法暂时是不可见的(还未声明，前向声明只是针对类)，放在本类定义之后，将内联函数用<code>inline</code>定义；</li>\n<li>注意函数链接性默认为外部的(外部链接性在其他文件中使用时也要先声明)，内联函数的链接性是内部的；</li>\n<li>使用友元类并不需要前向声明，因为友元语句本身指出友元类是一个类。 </li>\n</ol>\n<h3 id=\"交互式友元类\"><a href=\"#交互式友元类\" class=\"headerlink\" title=\"交互式友元类\"></a>交互式友元类</h3><p>两个类互为友元。</p>\n<ol>\n<li>声明和定义时，保证一个原则：在调用友元类的函数时他是被声明过的。</li>\n</ol>\n<h3 id=\"共同的友元类\"><a href=\"#共同的友元类\" class=\"headerlink\" title=\"共同的友元类\"></a>共同的友元类</h3><p>一个友元成员函数/友元类同时是两个类的友元。</p>\n<ol>\n<li>原则同上，在使用(传参)其中一个类时，保证他是声明过的，因此这里也需要前向声明。</li>\n</ol>\n<hr>\n<h2 id=\"嵌套类\"><a href=\"#嵌套类\" class=\"headerlink\" title=\"嵌套类\"></a>嵌套类</h2><p>在类中声明的类成为嵌套类。</p>\n<h3 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h3><ol>\n<li>主要作用是提供新的类型以及限制其作用域；</li>\n<li>同数据成员相同，只有声明为公有的才能在类外使用，而且必须使用作用域解析符(只有类或结构体才支持这么使用)；</li>\n<li>结构是一种其成员在默认情况下是公有的类。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> x;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> y;</span><br><span class=\"line\">\tStudent(<span class=\"keyword\">int</span> s, <span class=\"keyword\">int</span> t) :x(s), y(t) &#123;&#125;;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Student1</span> &#123;</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> x;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> y;</span><br><span class=\"line\">\t\tStudent1(<span class=\"keyword\">int</span> s, <span class=\"keyword\">int</span> t) :x(s), y(t) &#123;&#125;;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">Student::Student1 <span class=\"title\">k</span><span class=\"params\">(<span class=\"number\">1</span>,<span class=\"number\">2</span>)</span></span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; k.x &lt;&lt; k.y &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h3><ol>\n<li>类声明的位置(外层类的访问规则)决定类的作用域/可见性，类可见后，访问控制规则(内层类的访问规则)决定程序对嵌套类成员的访问权限；</li>\n<li>一般使用共有枚举来提供供客户程序员使用的类常数；</li>\n</ol>\n","categories":["C++的类"],"tags":["C++"]},{"title":"类模板","url":"https://applefishsky009.github.io/2016/06/21/类模板/","content":"<p>泛型编程的一种，即将具体类型作为参数传递给类。</p>\n<hr>\n<h2 id=\"模板类\"><a href=\"#模板类\" class=\"headerlink\" title=\"模板类\"></a>模板类</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>模板类应该这样开头：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> Type&gt;</span><br></pre></td></tr></table></figure>\n\n<p>模板成员函数的每个函数头(函数定义之前)将以相同的模板声明打头：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;typeName Type&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实例化\"><a href=\"#实例化\" class=\"headerlink\" title=\"实例化\"></a>实例化</h3><p>泛型标识符要求必须对类型变量实例化才能使用，通过<code>&lt;Type&gt;</code>来实例化类型。</p>\n<h3 id=\"指针变量\"><a href=\"#指针变量\" class=\"headerlink\" title=\"指针变量\"></a>指针变量</h3><p>若将指针作为类型变量，需要注意：</p>\n<ol>\n<li>指针作为参数类型，必须让调用程序提供<strong>指针数组</strong>，因其满足这四个条件：空间，左值，可赋值，不同的指向；</li>\n<li>创建不同指针是调用程序的职责，而不是泛型模板类的职责；</li>\n<li>以指针为参数的模板类涉及到动态内存，因此必须包含析构函数，复制构造函数和赋值运算符。</li>\n<li>制定返回类型或作用域解析符时，必须使用完整的实例化类型<code>classA&lt;Type&gt;</code>;</li>\n<li>构造函数使用<code>new</code>创建一个用于保存指针的数组，析构函数删除该数组，而不是数组元素指向的内容。</li>\n</ol>\n<h3 id=\"非类型参数\"><a href=\"#非类型参数\" class=\"headerlink\" title=\"非类型参数\"></a>非类型参数</h3><p>举例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>,<span class=\"title\">int</span> <span class=\"title\">n</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>相比在构造函数和析构函数中<code>new</code>和<code>delete</code>，非类型参数使用自动变量维护的内存栈，速度更快；</li>\n<li>但每个不同的非类型参数都会生成自己的模板类;</li>\n<li>构造函数更通用(参数优于硬编码)，便于赋值和创建大小可变的类。</li>\n</ol>\n<h3 id=\"递归，多参，默认参数\"><a href=\"#递归，多参，默认参数\" class=\"headerlink\" title=\"递归，多参，默认参数\"></a>递归，多参，默认参数</h3><ol>\n<li>递归使用模板：<code>array&lt;array&lt;int,5&gt;,10&gt; a</code>；</li>\n<li>多个类型参数：<code>template&lt;typename T1,typename T2&gt;</code>；</li>\n<li>默认类型模板参数：<code>template&lt;typename T1,typename T2 = int&gt;</code>。</li>\n</ol>\n<h3 id=\"具体化\"><a href=\"#具体化\" class=\"headerlink\" title=\"具体化\"></a>具体化</h3><p>模板以泛型的方式描述类，具体化是使用具体的类型生成类声明。具体化(具体的行为)包括，隐式实例化(最常用)，显式实例化，显式具体化。</p>\n<ol>\n<li><strong>隐式实例化</strong>：在创建对象时，编译器根据参数类型生成类定义，再根据类定义生成对象；</li>\n<li><strong>显式实例化</strong>：使用关键字<code>template</code>指出所需类型来声明类，编译器生成类声明的显式实例化；</li>\n<li><strong>显示具体化</strong>：特定类型的定义，特殊类型实例化时，对模板修改使其行为不同，这要求<strong>必须有自己的函数定义</strong>，使用前缀<code>template&lt;&gt;</code>(<code>&lt;&gt;</code>内声明的是没有被具体化的参数，因此这表示全部被具体化了),<font color=\"red\">这是一种多态？</font>。</li>\n<li>显示具体化的匹配优先级高于通用模板。</li>\n<li><strong>部分具体化</strong>：使部分特定类型的行为不同，<code>template&lt;typename T1&gt;</code>表示T1的行为不显式具体化，而余下的T2被显示具体化： <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T1&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span>&lt;T1,int&gt;&#123;</span>&#125;;\t<span class=\"comment\">//T2部分具体化为int</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"成员模板\"><a href=\"#成员模板\" class=\"headerlink\" title=\"成员模板\"></a>成员模板</h3><p>模板可以作为结构，类或模板类的成员。</p>\n<ol>\n<li><p>在模板中声明模板类和模板方法(模板函数)，在模板外面定义他们；</p>\n</li>\n<li><p>因为模板是嵌套的，外部定义必须使用下面语法：</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">\t<span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> V&gt;</span><br><span class=\"line\">\t\tfatherClass::method/childClass&#123;</span><br><span class=\"line\">\t\t\t...</span><br><span class=\"line\">\t\t&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用作用域解析符指明他们是哪一类的成员。</p>\n</li>\n</ol>\n<h3 id=\"模板参数\"><a href=\"#模板参数\" class=\"headerlink\" title=\"模板参数\"></a>模板参数</h3><p>模板可以包含类型参数和非类型参数，也可以接受模板作为参数。递归使用模板就是参数是自身这一模板的特殊情况。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Example</span>&gt;;</span></span><br><span class=\"line\">Example&lt;<span class=\"keyword\">int</span>&gt;;\t<span class=\"comment\">//1作为类数据成员</span></span><br><span class=\"line\">Example&lt;<span class=\"keyword\">double</span>&gt;;\t<span class=\"comment\">//2作为类数据成员</span></span><br><span class=\"line\">Father&lt;Stack&gt; result;\t<span class=\"comment\">//将1实例化为Stack&lt;int&gt;,将2实例化为Stack&lt;double&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>模板参数和常规参数可以混合使用.</li>\n</ol>\n<h3 id=\"模板类和友元\"><a href=\"#模板类和友元\" class=\"headerlink\" title=\"模板类和友元\"></a>模板类和友元</h3><p>模板的友元有三类：</p>\n<ol>\n<li>非模板友元(普通友元函数，只不过模板具体化使他成为很多具体化之后的类的友元)；</li>\n<li>约束模板友元()；</li>\n<li>非约束模板友元(模板友元函数，)。</li>\n</ol>\n<p>约束是指友元函数是某一具体化的友元还是所有实例化的友元；模板是指友元函数本身是不是模板。</p>\n<h4 id=\"非模板友元\"><a href=\"#非模板友元\" class=\"headerlink\" title=\"非模板友元\"></a>非模板友元</h4><ol>\n<li><p>使函数成为模板所有实例化的友元，他的用处：</p>\n<ul>\n<li>访问全局对象；</li>\n<li>使用全局指针访问非全局对象；</li>\n<li>创建自己的对象；</li>\n<li>访问独立于对象的模板类的静态数据成员。<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"keyword\">void</span> <span class=\"title\">counts</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>为友元函数提供模板类参数，必须为友元定义显式具体化：</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">clasee A&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"keyword\">void</span> <span class=\"title\">report</span> <span class=\"params\">(A&lt;T&gt; &amp;a)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h4 id=\"约束模板友元\"><a href=\"#约束模板友元\" class=\"headerlink\" title=\"约束模板友元\"></a>约束模板友元</h4><p>将友元函数本身成为模板(类外部声明)，即对友元函数的类型加以约束，使每个类型都有自己的友元函数，这是<strong>类具体化获得函数具体化来约束了友元类型</strong>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"keyword\">void</span> <span class=\"title\">counts</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"keyword\">void</span> <span class=\"title\">report</span><span class=\"params\">(T &amp;t)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> TT&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">friend</span> <span class=\"keyword\">void</span> counts&lt;TT&gt;();</span><br><span class=\"line\">\t<span class=\"keyword\">friend</span> <span class=\"keyword\">void</span> report&lt;&gt;(A&lt;TT&gt; &amp;a);\t<span class=\"comment\">//省略了&lt;&gt;中的A&lt;TT&gt;,因为可以从参数推断</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>和模板类参数的非模板友元区别，有无<code>&lt;&gt;</code>来约束类型，总的来说包含以下三步；</li>\n<li>在类定义前面声明每个模板函数；</li>\n<li>在类中将具体化的模板函数声明为友元；</li>\n<li>为友元提供模板定义。</li>\n</ol>\n<h4 id=\"非约束模板友元\"><a href=\"#非约束模板友元\" class=\"headerlink\" title=\"非约束模板友元\"></a>非约束模板友元</h4><p>通过在类内部声明模板，创建非约束模板友元，<strong>每个函数具体化是每个类具体化的友元</strong>，友元模板参数类型与模板类类型参数是不同的，也就是说类具体化不能约束友元函数类型，因此每个函数具体化都是所有类具体化的友元。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>&#123;</span></span><br><span class=\"line\">\ttemplate&lt;typename C,typename D&gt; friend void show2(C &amp;c,D &amp;d);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"模板别名\"><a href=\"#模板别名\" class=\"headerlink\" title=\"模板别名\"></a>模板别名</h3><p>使用typedef为模板具体化指定别名：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">array</span>&lt;<span class=\"keyword\">double</span>,12&gt; arrd;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">array</span>&lt;<span class=\"keyword\">int</span> 12&gt; arri;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">array</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>,12&gt; arrst;</span><br></pre></td></tr></table></figure>\n\n<p>使用模板提供一系列别名(<code>using</code>关键字)：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">using</span> arrtype = <span class=\"built_in\">std</span>::<span class=\"built_in\">array</span>&lt;T,<span class=\"number\">12</span>&gt;;</span><br><span class=\"line\"><span class=\"built_in\">array</span>&lt;<span class=\"keyword\">double</span>&gt; arrd;</span><br><span class=\"line\"><span class=\"built_in\">array</span>&lt;<span class=\"keyword\">int</span>&gt; arri;</span><br><span class=\"line\"><span class=\"built_in\">array</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt; arrst;</span><br></pre></td></tr></table></figure>","categories":["C++的类"],"tags":["C++"]},{"title":"多重继承","url":"https://applefishsky009.github.io/2016/06/20/多重继承/","content":"<p>多重继承(Multiple Inherit)/MI是指一个类别可以同时从多于一个父类继承行为和特征。这增加了编程的复杂度，主要是派生类通过多条途径继承同一基类引起的。有一点注意和两个问题：</p>\n<ol>\n<li>使用<code>public</code>关键字限定<strong>每一个</strong>基类，否则默认为私有派生；</li>\n<li>如何从两个基类继承同名方法？(作用域解析符或者隐藏)</li>\n<li>从两个基类或更多相关基类继承同一个类的多个实例造成不期望的多个组成部分，引入虚基类来解决问题。</li>\n</ol>\n<hr>\n<h2 id=\"虚基类-或者叫做虚拟继承更好\"><a href=\"#虚基类-或者叫做虚拟继承更好\" class=\"headerlink\" title=\"虚基类/或者叫做虚拟继承更好\"></a>虚基类/或者叫做虚拟继承更好</h2><p>引入虚基类来解决重复的基类组成问题。</p>\n<ol>\n<li>将可能重复的基类在派生时使用<code>virtual</code>关键字，其和<code>public</code>的关键字的顺序不关紧要(区分虚函数，纯虚函数)；</li>\n<li>虚函数和虚基类之间没有明显联系，<code>virtual</code>关键字重载；</li>\n<li>将基类声明为虚要求额外的计算，因此不能使虚行为成为默认的MI准则；</li>\n<li>虚基类通过禁止信息通过中间类自动传递给基类来解决上述问题，因此采用一种<font color=\"red\">特殊的构造函数</font>，但是注意这种形式只适用于虚基类，对于非虚基类是非法的。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// not this(class Work is not virtual,SingerWaiter has an unexpected objects)</span></span><br><span class=\"line\">SingerWaiter(<span class=\"keyword\">const</span> Worker &amp;wk,<span class=\"keyword\">int</span> p = <span class=\"number\">0</span>,<span class=\"keyword\">int</span> v = Singer::other):Waiter(wk,p),Singer(wk,v)&#123;&#125;\t<span class=\"comment\">//other是class Singer中的枚举量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//but this</span></span><br><span class=\"line\">SingerWaiter(<span class=\"keyword\">const</span> Worker &amp;wk,<span class=\"keyword\">int</span> p = <span class=\"number\">0</span>,<span class=\"keyword\">int</span> v = Singer::other):Worker(wk),Waiter(wk,p),Singer(wk,v)&#123;&#125;\t<span class=\"comment\">//必须在构造派生对象之前构造基类，否则将采用默认的构造函数</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"选择方法\"><a href=\"#选择方法\" class=\"headerlink\" title=\"选择方法\"></a>选择方法</h2><p>使用作用域解析符或多态的方法定义一个新的函数指明调用的方法。另外使用模块化的方法(这将要求一些方法声明为保护而不是私有以便于派生类的模块化)防止重复访问。</p>\n<ol>\n<li>私有方法一般是外部接口(公有方法)的辅助方法，为了模块化，可以将这些辅助方法(私有方法)声明为保护的，在派生类中和派生类的辅助方法(只访问派生类的数据模块)构成完整的模块；</li>\n<li>祖先相同时，使用MI必须引入虚基类，并修改构造函数列表初始化规则。</li>\n</ol>\n<hr>\n<h2 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h2><h3 id=\"混合使用基类和非虚基类\"><a href=\"#混合使用基类和非虚基类\" class=\"headerlink\" title=\"混合使用基类和非虚基类\"></a>混合使用基类和非虚基类</h3><ol>\n<li>当类通过多条非虚途径继承某个特定的基类时，该类将包含一个表示所有的虚途径的基类子对象和分别表示各条非虚途径的多个基类子对象。</li>\n</ol>\n<h3 id=\"虚基类和支配\"><a href=\"#虚基类和支配\" class=\"headerlink\" title=\"虚基类和支配\"></a>虚基类和支配</h3><ol>\n<li>使用非虚基类，类从不同类继承了同名成员(数据或方法)，将导致二义性；</li>\n<li>使用虚基类，派生类中的名称优先于这个派生类直接或间接祖先中的名称(也就是说这两个方法所在的类必须有继承关系才不会导致二义性)；</li>\n<li>虚二义性和访问规则无关，例如，基类中<code>public</code>方法，他的派生类中<code>private</code>方法，当前类从派生类继承而来，在不用作用域解析符时默认调用派生类的<code>private</code>方法(这对实例对象来说是不可访问的)。</li>\n</ol>\n","categories":["C++的类"],"tags":["C++"]},{"title":"中继器、集线器、网桥、交换机、路由器和网关","url":"https://applefishsky009.github.io/2016/06/17/中继器、集线器、网桥、交换机、路由器和网关/","content":"<p>首先这些设备运行在不同层上：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">OSI模型</th>\n<th align=\"center\">设备</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">应用层</td>\n<td align=\"center\">应用网关</td>\n</tr>\n<tr>\n<td align=\"center\">传输层</td>\n<td align=\"center\">传输网关</td>\n</tr>\n<tr>\n<td align=\"center\">网络层</td>\n<td align=\"center\">路由器</td>\n</tr>\n<tr>\n<td align=\"center\">数据链路层</td>\n<td align=\"center\">网桥、交换机</td>\n</tr>\n<tr>\n<td align=\"center\">物理层</td>\n<td align=\"center\">中继器、集线器</td>\n</tr>\n</tbody></table>\n<p>另外需要<strong>特别说明</strong>的是，无线路由器是AP(Access Point)，路由功能和交换机的集合体。</p>\n<ol>\n<li>他是AP,有ip地址，可以访问；</li>\n<li>他是路由，可以访问网络；</li>\n<li>他是交换机，可以建立无线局域网。</li>\n</ol>\n<hr>\n<h2 id=\"中继器-又称转发器，放大器\"><a href=\"#中继器-又称转发器，放大器\" class=\"headerlink\" title=\"中继器(又称转发器，放大器)\"></a>中继器(又称转发器，放大器)</h2><p>信号放大。</p>\n<ol>\n<li>他是模拟设备(处理连续变化的序列而不是脉冲)，用于连接两个电缆线；</li>\n<li>在一段上出现的信号被放大后放到另一段，他只理解电压值，不理解帧、分组、头的概念；</li>\n<li>经典以太网中电缆长度从500m扩展到2500米，以太网允许4个中继器。</li>\n</ol>\n<hr>\n<h2 id=\"集线器\"><a href=\"#集线器\" class=\"headerlink\" title=\"集线器\"></a>集线器</h2><p>连接输入线路，CSMA/CD。</p>\n<ol>\n<li>使用集线器的局域网是一个总线网，各站共享逻辑上的<strong>总线</strong>(各站的适配器执行CSMA/CD协议)；</li>\n<li>很像一个<strong>多接口</strong>的中继器，但通常不会放大信号，一般会再生整形并重新定时；</li>\n<li>他简单的转发比特，不进行碰撞检测(冲突域)，如果信号碰撞，所有接口都将收不到正确的帧，因此所有线路必须运行在同样的速度上。</li>\n<li>采用自适应串音回波抵消防止接口转发的较强信号干扰接口接收到的较弱信号；</li>\n<li>现在堆叠式集线器由4-8个集线器堆叠起来使用；</li>\n<li>有少量的容错能力(断开故障适配器连线)和网络管理能力(指示灯显示网络故障)。</li>\n</ol>\n<hr>\n<h2 id=\"网桥\"><a href=\"#网桥\" class=\"headerlink\" title=\"网桥\"></a>网桥</h2><p>连接两个或多个LAN，基于帧地址路由。</p>\n<ol>\n<li>内部软件从帧头提取目标地址，在一张表中查询地址以确定该把这一帧发送到哪里去；</li>\n<li>一个网桥可以有多个线卡处理不同网络类型和不用速度的网络(比如分别处理以太网和令牌环)；</li>\n<li>与集线器不同的是，往桥上的每条线路都有自己的冲突域。</li>\n</ol>\n<hr>\n<h2 id=\"交换机\"><a href=\"#交换机\" class=\"headerlink\" title=\"交换机\"></a>交换机</h2><p>(一般)连接独立计算机，基于帧地址路由。</p>\n<ol>\n<li>假如A和B在同一LAN,网桥拿到A发送B的帧要丢弃，但是交换机需要转发；</li>\n<li>显然交换机永远不会因为冲突而丢失帧；</li>\n<li>需要比网桥更多的线卡，每块线卡的缓冲区空间将在他端口上到达的帧缓存起来。</li>\n<li>为了防止线卡缓冲区溢出，采用直通型交换机而不是“存储-转发”交换方式(目标头域进来就转发)。</li>\n</ol>\n<hr>\n<h2 id=\"路由器\"><a href=\"#路由器\" class=\"headerlink\" title=\"路由器\"></a>路由器</h2><p>通过互联网把信息从源地址传输到目的地址。</p>\n<ol>\n<li>一个分组到达路由器的时候，帧头帧尾被剥掉，净荷域中的分组被传递给路由软件，其利用分组头信息选择一条输出线路；</li>\n<li>路由软件不会看到该分组源地址的任何信息。</li>\n</ol>\n<hr>\n<h2 id=\"传输网关\"><a href=\"#传输网关\" class=\"headerlink\" title=\"传输网关\"></a>传输网关</h2><p>将两台使用不同的面向连接的传输协议连接起来。</p>\n<ol>\n<li>将分组从一个连接复制到另一个连接中，根据需要重新格式化；</li>\n<li>面向连接的TCP/IP协议与面向连接的ATM传输协议通话。</li>\n</ol>\n<hr>\n<h2 id=\"应用网关\"><a href=\"#应用网关\" class=\"headerlink\" title=\"应用网关\"></a>应用网关</h2><p>消息格式转化。</p>\n<ol>\n<li>理解数据内容，将消息从一种格式转译为另一种格式。</li>\n<li>电子邮件网关将Internet消息转以为移动电话的SMS消息。</li>\n</ol>\n","categories":["计算机网络"],"tags":["计算机网络"]},{"title":"心脏线","url":"https://applefishsky009.github.io/2016/06/15/心脏线/","content":"<h2 id=\"两个硬币\"><a href=\"#两个硬币\" class=\"headerlink\" title=\"两个硬币\"></a>两个硬币</h2><p>设有两个大小相同的硬币，考虑一下两个问题：</p>\n<h3 id=\"内侧不动，外圆绕内圆滚动一周\"><a href=\"#内侧不动，外圆绕内圆滚动一周\" class=\"headerlink\" title=\"内侧不动，外圆绕内圆滚动一周\"></a>内侧不动，外圆绕内圆滚动一周</h3><p>以下是不同解释:</p>\n<h4 id=\"瞬心\"><a href=\"#瞬心\" class=\"headerlink\" title=\"瞬心\"></a>瞬心</h4><p>在下一个问题中极限情况下，R=r.差两周。</p>\n<h4 id=\"物理\"><a href=\"#物理\" class=\"headerlink\" title=\"物理\"></a>物理</h4><p>在下一个问题可知与R大小没有关系(R&gt;=r)，只不过极限情况下R=r时内圆是不动的。<br>另有一解<a href=\"https://www.zhihu.com/question/37855226\" target=\"_blank\" rel=\"noopener\">hunsen的回答</a>，在纯滚动的情况下，<font color=\"red\">圆上一点走过的距离和圆心走过的距离是一样的</font>，因此只要考虑两个圆心走过的距离相差多少，两硬币半径相等显然差两周。</p>\n<h4 id=\"多边形\"><a href=\"#多边形\" class=\"headerlink\" title=\"多边形\"></a>多边形</h4><p><a href=\"http://www.matrix67.com/blog/archives/5040\" target=\"_blank\" rel=\"noopener\">每转过一个顶点，转过两个外角大小</a></p>\n<h4 id=\"自转与公转\"><a href=\"#自转与公转\" class=\"headerlink\" title=\"自转与公转\"></a>自转与公转</h4><ol>\n<li>无滚动的平滑移动转过一周(公转)；</li>\n<li>绕瞬心转过一周(自传)。</li>\n</ol>\n<h3 id=\"在同一大圆周上滚动一周\"><a href=\"#在同一大圆周上滚动一周\" class=\"headerlink\" title=\"在同一大圆周上滚动一周\"></a>在同一大圆周上滚动一周</h3><h4 id=\"瞬心-1\"><a href=\"#瞬心-1\" class=\"headerlink\" title=\"瞬心\"></a>瞬心</h4><p>参照<a href=\"https://www.zhihu.com/question/37855226\" target=\"_blank\" rel=\"noopener\">苏暖暖的回答</a></p>\n<ol>\n<li>R展平，两边一样多；</li>\n<li>对无滚动的平移滑动，R是圆，是转一周的，那么圆心(接触线也是)转过顺时针一周，即相对直线情况各叠加顺时针一周，<font color=\"red\">因为硬币实际上是绕着接触点这个瞬心转的</font>。</li>\n<li>但内圈是逆时针，外圈是顺时针，所以差两圈。</li>\n</ol>\n<h4 id=\"物理-1\"><a href=\"#物理-1\" class=\"headerlink\" title=\"物理\"></a>物理</h4><p>参照<a href=\"https://www.zhihu.com/question/37855226\" target=\"_blank\" rel=\"noopener\">yjzding的回答</a></p>\n<ol>\n<li>外圆心走过的距离\\( s1=2\\pi(R+r) \\)\\( \\therefore n1=s1/(2\\pi r)=(R+r)/r \\);</li>\n<li>内圆心走过的距离\\( s2=2\\pi(R-r) \\)\\( \\therefore n2=s2/(2\\pi R)=(R-r)/R \\);</li>\n<li>圈数相差\\( n1-n2=2 \\)。<ul>\n<li>注：为什么圈数可以这样计算?还是因为转动时瞬心在大圆周上。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"心脏线\"><a href=\"#心脏线\" class=\"headerlink\" title=\"心脏线\"></a>心脏线</h2><p>在上述内圆不动，外圆绕内圆一周的问题中，外圆圆周上任意一点的曲线轨迹就是心脏线。</p>\n<ol>\n<li>极坐标方程<br>水平方向：$$ r\\ =\\ a(1-cos\\theta) \\mid r\\ =\\ a(1+cos\\theta)\\ (a&gt;0) $$<br>垂直方向：$$ r\\ =\\ a(1-sin\\theta) \\mid r\\ =\\ a(1+sin\\theta)\\ (a&gt;0) $$</li>\n<li>直角坐标方程<br>$$ x^2+y^2+ax\\ =\\ a\\sqrt{x^2+y^2} $$<br>$$ x^2+y^2-ax\\ =\\ a\\sqrt{x^2+y^2} $$</li>\n<li>参数方程<br>$$ x\\ =\\ a(2cos(t)-cos(2t)) $$<br>$$ y\\ =\\ a(2sin(t)-sin(2t)) $$</li>\n</ol>\n<h3 id=\"二维心脏线\"><a href=\"#二维心脏线\" class=\"headerlink\" title=\"二维心脏线\"></a>二维心脏线</h3><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">%a=10的心形线</span></span><br><span class=\"line\">a = <span class=\"number\">10</span>;</span><br><span class=\"line\">theta = <span class=\"number\">0</span>:<span class=\"built_in\">pi</span>/<span class=\"number\">50</span>:<span class=\"number\">2</span>*<span class=\"built_in\">pi</span>;</span><br><span class=\"line\">r = a.*(<span class=\"number\">1</span>+<span class=\"built_in\">cos</span>(theta));\t<span class=\"comment\">% r = a.*(1+cos(theta+pi/2));转过90度</span></span><br><span class=\"line\">polar(theta,r,<span class=\"string\">'-r'</span>);</span><br><span class=\"line\">title(<span class=\"string\">'心脏线（a = 10）'</span>);</span><br><span class=\"line\"><span class=\"comment\">%绘制a逐渐增大的心形线</span></span><br><span class=\"line\"><span class=\"built_in\">i</span> = <span class=\"number\">0</span>;<span class=\"built_in\">figure</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> a = <span class=\"number\">1</span>:<span class=\"number\">3</span>:<span class=\"number\">12</span></span><br><span class=\"line\">    <span class=\"built_in\">i</span> = <span class=\"built_in\">i</span>+<span class=\"number\">1</span>;</span><br><span class=\"line\">    r = a.*(<span class=\"number\">1</span>+<span class=\"built_in\">cos</span>(theta));\t<span class=\"comment\">% r = a.*(1+cos(theta+pi/2));转过90度</span></span><br><span class=\"line\">    subplot(<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"built_in\">i</span>);</span><br><span class=\"line\">    polar(theta,r,<span class=\"string\">'-r'</span>);</span><br><span class=\"line\">    title(<span class=\"string\">'心脏线，a逐渐增大'</span>);</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"http://i.imgur.com/hycT5xb.jpg\" alt=\"心脏线1\"><br><img src=\"http://i.imgur.com/whWvWzv.jpg\" alt=\"心脏线2\"></p>\n<h3 id=\"三维心脏线\"><a href=\"#三维心脏线\" class=\"headerlink\" title=\"三维心脏线\"></a>三维心脏线</h3><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[x,y,z] = <span class=\"built_in\">meshgrid</span>(<span class=\"built_in\">linspace</span>(<span class=\"number\">-1.5</span>,<span class=\"number\">1.5</span>));</span><br><span class=\"line\">val = (x.^<span class=\"number\">2</span>+(<span class=\"number\">9</span>/<span class=\"number\">4</span>)*y.^<span class=\"number\">2</span>+z.^<span class=\"number\">2</span><span class=\"number\">-1</span>).^<span class=\"number\">3</span>-x.^<span class=\"number\">2.</span>*z.^<span class=\"number\">3</span>-(<span class=\"number\">9</span>/<span class=\"number\">80</span>)*y.^<span class=\"number\">2.</span>*z.^<span class=\"number\">3</span>;</span><br><span class=\"line\">[f,v] = isosurface(x,y,z,val,<span class=\"number\">0</span>);</span><br><span class=\"line\">p = patch(<span class=\"string\">'Faces'</span>,f,<span class=\"string\">'Vertices'</span>,v,<span class=\"string\">'CData'</span>,v(:,<span class=\"number\">3</span>),<span class=\"string\">'FaceColor'</span>,<span class=\"string\">'w'</span>,<span class=\"string\">'EdgeColor'</span>,<span class=\"string\">'flat'</span>);</span><br><span class=\"line\">isonormals(x,y,z,val,p);</span><br><span class=\"line\">view(<span class=\"number\">30</span>,<span class=\"number\">30</span>);</span><br><span class=\"line\">grid on,axis equal;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"http://i.imgur.com/NTsCbWb.jpg\" alt=\"心脏线3\"></p>\n<h2 id=\"外摆线\"><a href=\"#外摆线\" class=\"headerlink\" title=\"外摆线\"></a>外摆线</h2><p>其实心脏线是外摆线的一种，<a href=\"https://zh.wikipedia.org/wiki/%E5%A4%96%E6%91%86%E7%BA%BF\" target=\"_blank\" rel=\"noopener\">wikipedia</a>上的两个动图诠释了其产生的过程与外摆线方程，太有趣了。</p>\n","categories":["Math"],"tags":["Math"]},{"title":"私有和保护继承","url":"https://applefishsky009.github.io/2016/06/13/私有和保护继承/","content":"<p>has-a关系，即新的类将包含另一个类的对象。有两种方式实现：</p>\n<ol>\n<li>包含；</li>\n<li>私有或保护继承。</li>\n</ol>\n<p>多数情况下都使用包含：</p>\n<ol>\n<li>他易于理解；</li>\n<li>继承会引发很多问题(尤其是多基类)；</li>\n</ol>\n<p>但继承也有优势：</p>\n<ol>\n<li>派生类可以访问保护成员；</li>\n<li>派生类可以重新定义虚函数。</li>\n</ol>\n<hr>\n<h2 id=\"包含\"><a href=\"#包含\" class=\"headerlink\" title=\"包含\"></a>包含</h2><ol>\n<li>公有继承可以继承接口和实现，但包含可以获得实现，不能获得接口；<ul>\n<li>公有继承获得接口的意思是可以在派生类通过函数原型来隐藏或重写(覆盖)原接口；</li>\n<li>包含获得实现的意思是可以通过具体对象调用实现的方法。</li>\n</ul>\n</li>\n<li>必须在构建对象的其他部分之前，先构建对象的所有成员对象。初始化被包含的对象通过初始化列表。</li>\n</ol>\n<hr>\n<h2 id=\"私有或保护继承\"><a href=\"#私有或保护继承\" class=\"headerlink\" title=\"私有或保护继承\"></a>私有或保护继承</h2><h3 id=\"私有继承-默认\"><a href=\"#私有继承-默认\" class=\"headerlink\" title=\"私有继承(默认)\"></a>私有继承(默认)</h3><p>基类的<strong>一切</strong>成员都将成为派生类的私有成员。</p>\n<ol>\n<li>包含版本提供显示命名的对象，而私有继承提供了两个无名称的子对象成员；</li>\n<li>构造函数使用成员初始化列表时，使用类名而不是成员名来标识构造函数(必要时使用作用于解析符)；</li>\n<li>只能在派生类的<strong>方法</strong>中使用基类方法(通过<strong>类名和作用域解析符</strong>)，包含使用<strong>对象</strong>来调用；</li>\n<li>使用强制类型转化<code>*this</code>(派生类本身)得到基类继承而来的无名对象；</li>\n<li>不能用作用域解析符使用友元函数(友元函数不属于类)，可以显式将派生类转化为基类引用来调用友元函数；<ul>\n<li>不能自动转化：<strong>不显式转化</strong>，派生类的引用/指针不能赋值给基类的引用/指针(反过来可以)；</li>\n<li>不显式转化，可能会递归调用；</li>\n<li>MI时，无法确定转换哪个基类。 </li>\n</ul>\n</li>\n</ol>\n<h3 id=\"保护继承\"><a href=\"#保护继承\" class=\"headerlink\" title=\"保护继承\"></a>保护继承</h3><p>基类的公有成员和保护成员将成为派生类的保护成员。</p>\n<ol>\n<li>私有继承<strong>第三代类</strong>不能使用基类方法，而保护继承可以；</li>\n<li>私有与保护继承中，方法对类外不可见，若类外想使用，有两种方法：<ul>\n<li>定义一个使用基类方法的公有派生类方法；</li>\n<li>使用<code>using</code>声明指出派生类可以使用的基类成员(即使是私有派生)，这相当于重定义了访问权限；</li>\n</ul>\n</li>\n</ol>\n","categories":["C++的类"],"tags":["C++"]},{"title":"继承杂谈","url":"https://applefishsky009.github.io/2016/06/12/继承杂谈/","content":"<p>在上一篇提到过，不能被继承的一些情况：</p>\n<ol>\n<li>构造函数(派生类调用基类)；</li>\n<li>析构函数(派生类调用基类)；</li>\n<li>赋值运算符(成员赋值)；</li>\n<li>友元函数(非成员函数，通过指针强制类型转化改变作用域访问)。</li>\n</ol>\n<p>这篇详细说明这些。</p>\n<hr>\n<h2 id=\"友元函数\"><a href=\"#友元函数\" class=\"headerlink\" title=\"友元函数\"></a>友元函数</h2><p>继承只针对成员函数，但友元不是成员函数，因此不能被继承。如果希望派生类可以使用基类的友元函数，可以使用指针强制转化将基类指针指向派生类指针，通过基类指针调用友元函数。</p>\n<hr>\n<h2 id=\"继承中动态内存分配\"><a href=\"#继承中动态内存分配\" class=\"headerlink\" title=\"继承中动态内存分配\"></a>继承中动态内存分配</h2><p>派生类构造函数使用列表初始化调用基类的构造函数。余下的复制构造函数，析构函数，赋值运算符重载，都是与动态内存分配相关(这三种成员函数总是需要特别注意分配的动态内存)，放在一起来分析。</p>\n<h3 id=\"派生类不使用new\"><a href=\"#派生类不使用new\" class=\"headerlink\" title=\"派生类不使用new\"></a>派生类不使用new</h3><ol>\n<li>默认析构函数是合适的(销毁自身构造的对象部分后调用基类的析构函数)；</li>\n<li>复制构造函数是合适的(成员复制，基类对象部分调用基类对象的复制构造函数)；</li>\n<li>同上，赋值运算符也是合适的(赋值运算符一般需要用复制构造函数)。</li>\n</ol>\n<h3 id=\"派生类使用new\"><a href=\"#派生类使用new\" class=\"headerlink\" title=\"派生类使用new\"></a>派生类使用new</h3><p>必须为派生类定义显式析构函数，复制构造函数和赋值运算符。</p>\n<ol>\n<li>析构函数需要对派生类构造执行工作进行清理(delete new出来的空间)；</li>\n<li>派生类复制构造函数，初始化列表中将派生类对象直接传递给基类对象用来复制派生类中的基类部分(因为基类引用可以引用派生类对象，这调用基类复制构造函数)，在代码块中执行剩下的工作。</li>\n<li>派生类赋值运算符使用作用域解析符显式调用基类的复制构造函数。例如：<code>base::operator=(a)</code>，其作用相当于<code>*this=a</code>(但这个语法是错的)，只不过将后者的赋值运算符显式声明为基类赋值运算符。</li>\n</ol>\n","categories":["C++的类"],"tags":["C++"]},{"title":"valarray容器(数值处理)","url":"https://applefishsky009.github.io/2016/06/10/valarray容器(数值处理)/","content":"<p><code>#include&lt;valarray&gt;</code>，头文件valarray支持了用于数值处理的valarray类,可以在<a href=\"http://www.cplusplus.com/reference/valarray/\" target=\"_blank\" rel=\"noopener\">cplusplus</a>上查看其特性。在此做一个简单介绍即可。<strong>最后尽量用它来代替vector</strong></p>\n<hr>\n<h2 id=\"valarray简介\"><a href=\"#valarray简介\" class=\"headerlink\" title=\"valarray简介\"></a>valarray简介</h2><h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>常用的两个构造函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">explicit valarray (size_t n);</span><br><span class=\"line\">valarray (const T&amp; val, size_t n);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"运算符重载\"><a href=\"#运算符重载\" class=\"headerlink\" title=\"运算符重载\"></a>运算符重载</h3><p>他实现了很多运算符的重载，除了最基本的<code>+</code>,<code>-</code>,<code>*</code>,<code>/</code>重载，基本所有算术运算符都重载了。</p>\n<h3 id=\"类方法\"><a href=\"#类方法\" class=\"headerlink\" title=\"类方法\"></a>类方法</h3><p>一些简单的<code>sum()</code>,<code>min()</code>,<code>max()</code>,<code>size()</code>,<code>swap()</code>等。</p>\n<h3 id=\"其他方法\"><a href=\"#其他方法\" class=\"headerlink\" title=\"其他方法\"></a>其他方法</h3><p>他可以调用一些数学方法，<code>abs()</code>,<code>cos()</code>,<code>sin()</code>,<code>exp()</code>，<code>log()</code>等。</p>\n","categories":["STL"],"tags":["C++"]},{"title":"公有继承，多态继承和抽象基类","url":"https://applefishsky009.github.io/2016/06/08/公有继承、多态继承和抽象基类/","content":"<p>通过本篇的学习，可以看到如何通过类继承来实现<code>代码复用</code>(可重用性)，不得让人感慨设计的精妙。<br>简单来讲，类继承可以完成以下工作：</p>\n<ol>\n<li>已有类的基础上添加功能；</li>\n<li>给类添加数据；</li>\n<li>修改类方法的行为。</li>\n</ol>\n<p>但以下是不能被继承的：</p>\n<ol>\n<li>构造函数(派生类调用基类)；</li>\n<li>析构函数(派生类调用基类)；</li>\n<li>赋值运算符(成员赋值)；</li>\n<li>友元函数(非成员函数，通过指针强制类型转化改变作用域访问)。</li>\n</ol>\n<hr>\n<h2 id=\"公有继承\"><a href=\"#公有继承\" class=\"headerlink\" title=\"公有继承\"></a>公有继承</h2><p>简单继承有三种：公有继承，保护继承，私有继承。最常用简单公有继承是is-a关系，也就是<strong>包含</strong>关系，这种关系通常是不可逆的(除非相互包含)。注意这里的包含和has-a中的包含是不一样的，这里是抽象上的逻辑上包含，has-a强调有一个。</p>\n<h3 id=\"C风格字符串参数\"><a href=\"#C风格字符串参数\" class=\"headerlink\" title=\"C风格字符串参数\"></a>C风格字符串参数</h3><p>简单来说，C风格字符串作为函数参数时，函数原型必须是<code>const string</code>才行(否则参数类型不匹配)，如下:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">A <span class=\"title\">a</span><span class=\"params\">(<span class=\"string\">\"test\"</span>,x,y)</span></span>;\t<span class=\"comment\">//A的实例1</span></span><br><span class=\"line\"><span class=\"function\">A <span class=\"title\">b</span><span class=\"params\">(str2,x,y)</span></span>;\t<span class=\"comment\">//A的实例2</span></span><br><span class=\"line\">A::A (<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;first,<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y);\t<span class=\"comment\">//A的构造函数原型</span></span><br></pre></td></tr></table></figure>\n\n<p>对“test”可以引用，但显然他是常量，因此引用之后不能改变。那么这个引用必须声明为<code>const</code>，否则构造函数只于实例2匹配。置于传入的是<code>const char*</code>还是<code>string</code>并不重要，因为string类有<code>const char*</code>的构造函数(其实就是告诉编译器，可以将<code>const char*</code>解释为<code>string</code>。</p>\n<ol>\n<li>注意这里的const和A类构造函数中的const不是一个概念；</li>\n<li>即使在赋值过程中构造了string，其是一个中间计算过程，也不能作为左值出现。</li>\n</ol>\n<h3 id=\"公有派生的特性\"><a href=\"#公有派生的特性\" class=\"headerlink\" title=\"公有派生的特性\"></a>公有派生的特性</h3><p>公有派生必须使用<code>public</code>关键字，如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>:</span><span class=\"keyword\">public</span> A &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>派生类对象存储了积累的数据成员(继承了基类的实现)；</li>\n<li>派生类可以使用基类的方法(派生类继承了基类的接口)；</li>\n<li>派生类需要自己的<strong>构造函数</strong>；</li>\n<li>派生类可以添加额外的数据成员和成员函数。</li>\n</ol>\n<h3 id=\"公有继承的构造函数\"><a href=\"#公有继承的构造函数\" class=\"headerlink\" title=\"公有继承的构造函数\"></a>公有继承的构造函数</h3><p>构造函数必须给新成员和继承的成员提供数据，由于派生类只能通过基类的公有方法来访问基类的私有数据，因此<strong>派生类构造函数必须使用基类的构造函数</strong>来初始化(基类部分的)数据。有以下几个要点：</p>\n<ol>\n<li>创建基类对象；</li>\n<li>派生类通过<strong>成员初始化列表</strong>(非构造函数不能使用成员初始化列表语法)来指明要使用的基类构造函数，否则将会调用默认构造函数；</li>\n<li>派生类初始化其新增的数据成员。</li>\n</ol>\n<h3 id=\"基类指针-引用-指向-引用派生类对象\"><a href=\"#基类指针-引用-指向-引用派生类对象\" class=\"headerlink\" title=\"基类指针/引用 指向/引用派生类对象\"></a>基类指针/引用 指向/引用派生类对象</h3><p>将公有派生类和基类之间的特殊关系总结(从概念上将，公有派生是包含关系，2,3点也就好理解了)如下：</p>\n<ol>\n<li>公有派生的派生类可以使用基类的非私有(公有或保护)方法；</li>\n<li>基类指针在不进行显示类型转化的情况下指向派生类对象；</li>\n<li>基类引用在不进行显示类型转化的情况下可以引用派生类对象。</li>\n</ol>\n<p>2,3(这是<font color=\"red\">公有派生(is-a关系)的核心</font>)有几个常用的场景，</p>\n<ol>\n<li>对象数组中，可以是基类对象和派生类对象(-.-因为派生类对象是一种特殊的基类对象)；</li>\n<li>指向基类对象的指针数组，可以指向基类对象会派生类对象；</li>\n<li>形参为基类引用，实参可以是基类或派生类对象；</li>\n<li>形参是指向基类的指针，实参可以传入基类或派生类对象的地址；</li>\n<li>基类对象可以初始化为派生类对象(调用复制构造函数)；</li>\n<li>派生类对象可以赋给基类对象(调用重载的赋值运算符)。</li>\n</ol>\n<p>这一特性在使用隐藏的多态中会出现问题，虚函数的出现解决了这个问题。</p>\n<h3 id=\"不能被继承的赋值运算符\"><a href=\"#不能被继承的赋值运算符\" class=\"headerlink\" title=\"不能被继承的赋值运算符\"></a>不能被继承的赋值运算符</h3><p>派生类继承的方法特征标与基类完全相同，但赋值运算符的特征标只与类本身有关。因此其不能被继承。</p>\n<ol>\n<li>默认的赋值运算符采用成员赋值的方式。如果是派生类对象，对其中属于基类对象的部分调用基类的赋值运算符(默认或显式)；</li>\n<li>派生类中使用<code>new</code>，必须提供显式的赋值运算符重载；</li>\n<li>派生类对象赋给基类对象，将调用基类的赋值运算符重载，只涉及基类的成员；</li>\n<li>在满足下列两个条件之一时，基类可以赋值给派生类：<ul>\n<li>从基类到派生类的转换构造函数；</li>\n<li>定义一个用于将基类赋给派生类的赋值运算符。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"多态继承\"><a href=\"#多态继承\" class=\"headerlink\" title=\"多态继承\"></a>多态继承</h2><p>考虑继承的多态行为，就是说同一个函数在派生类中和基类中行为不同(函数名相同，具体代码有区别)，有两种方式：</p>\n<ol>\n<li>隐藏，即在派生类中重新定义基类方法(派生类隐藏基类同名方法)；</li>\n<li>虚方法(vtbl)。</li>\n</ol>\n<h3 id=\"隐藏的规则：\"><a href=\"#隐藏的规则：\" class=\"headerlink\" title=\"隐藏的规则：\"></a>隐藏的规则：</h3><p><strong>隐藏</strong>是指<strong>在派生类的函数中屏蔽了与其同名的基类函数</strong>。<br>(1)如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无 <code>virtual</code>关键字，基类的函数将被隐藏。<br>(2)如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏。</p>\n<h3 id=\"隐藏的缺陷\"><a href=\"#隐藏的缺陷\" class=\"headerlink\" title=\"隐藏的缺陷\"></a>隐藏的缺陷</h3><p>在隐藏的时候，程序根据指针或者引用类型选择方法。但是公有继承中基类的指针/引用可以指向/引用派生类对象，这样会导致多态行为不稳定。而虚方法会解决这一问题。他会根据指针指向或引用的对象类型来调用方法而不是指针/引用类型。</p>\n<h3 id=\"使用虚方法\"><a href=\"#使用虚方法\" class=\"headerlink\" title=\"使用虚方法\"></a>使用虚方法</h3><p>在基类中将派生类会<strong>重写(覆盖)</strong>的方法声明为虚方法(在函数声明最前端使用<code>virtual</code>关键字)。</p>\n<ol>\n<li>要将析构函数声明为虚的(保证调用正确的析构函数)；<ul>\n<li>如果析构函数不是虚的，只会调用指针/引用类型的析构函数，而不是对象类型，这会有隐患；</li>\n<li>在重写(覆盖)的虚析构函数里，应该调用基类的析构函数并释放派生类动态申请的空间。</li>\n</ul>\n</li>\n<li>在派生类中定义虚函数时，如果要调用基类同名方法，需要使用作用域解析符，否则编译器会视为递归调用。</li>\n</ol>\n<h3 id=\"虚函数对静态联编的困扰\"><a href=\"#虚函数对静态联编的困扰\" class=\"headerlink\" title=\"虚函数对静态联编的困扰\"></a>虚函数对静态联编的困扰</h3><p>静态联编(C++默认选择)的必要性：</p>\n<ol>\n<li>静态联编效率高；</li>\n<li>指出不要重新定义该函数(因为是静态的)。<br>考虑派生类引用或指针转换为基类引用或指针，被称为向上强制转换。这种关系是不可逆的(因为是包含关系)。这种情况下肯定需要动态联编来调用正确重写的函数。</li>\n</ol>\n<h3 id=\"虚函数实现机制vtbl\"><a href=\"#虚函数实现机制vtbl\" class=\"headerlink\" title=\"虚函数实现机制vtbl\"></a>虚函数实现机制vtbl</h3><p>C++规定了虚函数的行为，编译器执行他的实现。实现方式为为每个对象添加<strong>一个</strong>隐藏成员，他是一个指向函数地址数组的指针，这个数组称为<strong>虚函数表(vtbl)</strong>。虚函数多少决定了这个地址数组大小。实现机制：</p>\n<ol>\n<li>如果重写虚方法，vtbl保存新函数地址；</li>\n<li>如果没有重写虚方法，vtbl指向基类原始方法地址；</li>\n<li>如果定义新的虚方法，vtbl加入新成员。<br>虚函数具有了动态联编的能力，同时使用虚函数的成本：</li>\n<li>每个对象都将增大(指针成员和存储地址的空间)；</li>\n<li>编译器为每一个类创建一个虚函数地址表(数组)(对象是类的实例)；</li>\n<li>每个虚函数调用，都需要到表中查找地址。</li>\n</ol>\n<h3 id=\"虚函数注意事项\"><a href=\"#虚函数注意事项\" class=\"headerlink\" title=\"虚函数注意事项\"></a>虚函数注意事项</h3><p>之前关于虚函数大体上说有三个要点：</p>\n<ol>\n<li>需要重写就声明虚函数；</li>\n<li>使用<code>virtual</code>关键字；</li>\n<li>(由于向上强制转化)使用动态联编。</li>\n</ol>\n<p>还有一些注意事项：</p>\n<ol>\n<li>构造函数不能是虚函数，而应该在派生类中调用基类的构造函数；</li>\n<li>不管是否用作基类，析构函数应该是虚的(只是不用做基类时效率略低)；</li>\n<li>友元不能是虚函数，因为友元不是成员函数。只有成员函数才能被申明为虚；<ul>\n<li><strong>友元函数</strong>不是成员函数，不能被继承；</li>\n<li>如果想派生类使用基类的友元函数，可以通过强制类型转换，将派生类引用或指针转换为基类引用或指针，使用转换后的引用或指针来调用基类的友元函数。</li>\n</ul>\n</li>\n<li>基类中声明为虚，但派生类中没有重写，依然会调用基类方法<ul>\n<li>因为vtbl初始状态是基类方法地址，重写一个虚方法才更新；</li>\n<li>由<font color=\"red\">C++的隐藏规则</font>可推断，应该是先删掉所有的同名函数地址，然后加入新的虚方法地址。</li>\n</ul>\n</li>\n<li>由4中所说，重写才将隐藏方法。</li>\n</ol>\n<p>2条经验规则：</p>\n<ol>\n<li>重写的继承方法确保与原来的原型完全相同，但<font color=\"red\">返回类型协变</font>例外。返回类型协变：如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针。只适用于返回类型不适用于参数；</li>\n<li>如果基类声明被重载了，派生类中应重写所有的基类版本(先重写的版本<strong>隐藏</strong>所有的同名函数)。<ul>\n<li>如果只重写一个版本，另外两版本会被隐藏，派生类将无法使用；</li>\n<li>如果想使用基类方法但是又不要修改方法，在重写的派生类方法中调用基类方法即可。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"protected访问控制\"><a href=\"#protected访问控制\" class=\"headerlink\" title=\"protected访问控制\"></a>protected访问控制</h3><p><code>protected</code>关键字使类成员在类外是<code>public</code>权限，在派生类内是<code>public</code>权限。但是其类成员的选择值得注意：</p>\n<ol>\n<li>数据成员最好采用私有访问控制。因为数据成员一般被封装，只能通过成员函数访问，如果被声明为<code>protected</code>，在派生类中其成为公有数据，与数据隐藏的概念相矛盾，可以调用基类方法来修改私有数据成员；</li>\n<li>对<strong>成员函数</strong>来讲，保护访问控制很有用。对基类，一些方法的实现细节被封装(外部不可见)；对派生类，我们依然可以调用这些成员函数来完成更多的工作(可作为派生类方法的实现细节)。</li>\n</ol>\n<hr>\n<h2 id=\"抽象基类-ABC\"><a href=\"#抽象基类-ABC\" class=\"headerlink\" title=\"抽象基类(ABC)\"></a>抽象基类(ABC)</h2><p>一些情况下的公有派生是很笨拙的，例如圆是一种椭圆。可以通过抽象基类(ABC)来抽象出他们的共性，ABC使用纯虚函数(<code>virtual</code>与原型<code>=0</code>)来提供未实现的函数接口(由于实现接口的一些数据不是共性，在派生类中才能添加)。注意，<font color=\"red\">至少含一个纯虚函数的类才是ABC</font>。一个例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">double</span> <span class=\"title\">Area</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>= <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ABC特征\"><a href=\"#ABC特征\" class=\"headerlink\" title=\"ABC特征\"></a>ABC特征</h3><ol>\n<li>在ABC派生的具体类中实现纯虚方法的定义；</li>\n<li>使用ABC指针数组管理所有具体类；</li>\n<li>ABC是一种必须实现的接口。</li>\n</ol>\n","categories":["C++的类"],"tags":["C++"]},{"title":"Git简明指南","url":"https://applefishsky009.github.io/2016/06/07/Git简明指南/","content":"<h2 id=\"Git本地版本库\"><a href=\"#Git本地版本库\" class=\"headerlink\" title=\"Git本地版本库\"></a>Git本地版本库</h2><p>本地版本库推送到远程版本库需要经过这样的过程：<br>本地文件-&gt;缓存池-&gt;HEAD-&gt;remote</p>\n<h3 id=\"git-help\"><a href=\"#git-help\" class=\"headerlink\" title=\"git help \"></a>git help <command></h3><p>查看某一个指令的<code>Manuel Page</code>，在网页打开。</p>\n<h3 id=\"git-init\"><a href=\"#git-init\" class=\"headerlink\" title=\"git init\"></a>git init</h3><p>将本地文件夹初始化为版本库，使用下列指令创建并进入文件夹(简单的window操作。。。)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir folder</span><br><span class=\"line\">cd folder</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-add-file-lt-gt-git-rm-file\"><a href=\"#git-add-file-lt-gt-git-rm-file\" class=\"headerlink\" title=\"git add file &lt;-&gt; git rm file\"></a>git add file &lt;-&gt; git rm file</h3><p>将本地文件加入到缓存池中&lt;-&gt;从缓存池删除。<strong>不论文件是新建的还是旧的，只要你想commit，就需要add进缓存池</strong></p>\n<ol>\n<li><code>git rm file</code>,将缓存池中有，本地文件夹没有，的文件从缓存池删除。</li>\n<li><code>git rm -f file</code>,<strong>缓存池</strong>中有，本地文件夹也有，这个指令可以一并删除。</li>\n<li>注意如果还没有add到缓存池,直接<code>rm file</code>就行。</li>\n</ol>\n<h3 id=\"git-commit-m-“summary”\"><a href=\"#git-commit-m-“summary”\" class=\"headerlink\" title=\"git commit -m “summary”\"></a>git commit -m “summary”</h3><p>将缓存池的改动提交到HEAD中,push到远程分支之后,summay就是文件名和时间中间现实的东西，一般新建的仓库中的read.md的summary都是Initial commit。</p>\n<h3 id=\"git-reset-–soft-ID\"><a href=\"#git-reset-–soft-ID\" class=\"headerlink\" title=\"git reset –soft ID\"></a>git reset –soft ID</h3><p>不改变索引(一切都正确暂存了)，但是想调整提交消息，配合<code>git commit --amend</code>来使用。</p>\n<h3 id=\"git-reset-–hard-ID\"><a href=\"#git-reset-–hard-ID\" class=\"headerlink\" title=\"git reset –hard ID\"></a>git reset –hard ID</h3><p>把分支拉回到之前的状态，同时也会修改工作目录。</p>\n<h3 id=\"git-commit-–ammend\"><a href=\"#git-commit-–ammend\" class=\"headerlink\" title=\"git commit –ammend\"></a>git commit –ammend</h3><p>修改最近一次commit的summary。</p>\n<h3 id=\"git-rebase-i-ID\"><a href=\"#git-rebase-i-ID\" class=\"headerlink\" title=\"git rebase -i ID\"></a>git rebase -i ID</h3><p>变基(将基置于ID)提交，可用于重写提交历史，或者合并提交。输入后会弹出文本文档。</p>\n<ol>\n<li>更改文本文档中提交历史的顺序，可以重写提交历史。使用这一条指令和<code>git commit --ammend</code>可以修改某一次commit的summary。</li>\n<li>pick改为squash会将这次提交合并到前一次提交。</li>\n<li>修改完成之后<code>git rebase --continue</code></li>\n</ol>\n<h3 id=\"git-status\"><a href=\"#git-status\" class=\"headerlink\" title=\"git status\"></a>git status</h3><p>显示你的本地文件夹，缓存池，HEAD中不一致的地方。</p>\n<h3 id=\"git-log-file\"><a href=\"#git-log-file\" class=\"headerlink\" title=\"git log /file\"></a>git log /file</h3><p>查看版本库的提交历史，按q退出。</p>\n<ol>\n<li><code>git log -n</code>显示版本库提交的历史，默认参数n=all。</li>\n<li><code>git log --stat -n</code>显示版本库历史的文件变更统计。</li>\n<li><code>git log file</code>是一个很重要的指令，查看某一个文件的变更历史。配合<code>--pretty=oneline</code>和<code>-stat</code>参数可以追踪详细精简的文件变更记录。而<code>cmd</code>中出现的<code>^M</code>是指一行插入完了(换行的显式标识)。</li>\n<li><code>git log -p /file</code>显示每次提交引进的补丁或变更，如果指定文件查看更方便。<code>p=patch</code>。</li>\n<li>注意这个指令中无论添加什么参数<code>/file</code>参数是可选的，相当于一个过滤器。</li>\n</ol>\n<h3 id=\"git-reflog\"><a href=\"#git-reflog\" class=\"headerlink\" title=\"git reflog\"></a>git reflog</h3><p>记录所有的Head历史，即使误删也不怕啦！<a href=\"http://blog.sina.com.cn/s/blog_4bc7d49f01014r2s.html\" target=\"_blank\" rel=\"noopener\">恢复 git reset -hard 的误操作</a></p>\n<h3 id=\"cat-file\"><a href=\"#cat-file\" class=\"headerlink\" title=\"cat file\"></a>cat file</h3><p>文件列表中的文件或标准输入转标准输出，简单来讲，在屏幕上打印文件内容。</p>\n<ol>\n<li>常用<code>cat .git/config</code>查看配置文件</li>\n</ol>\n<h3 id=\"git-diff\"><a href=\"#git-diff\" class=\"headerlink\" title=\"git diff\"></a>git diff</h3><ol>\n<li><code>git diff</code>显示本地版本库修改前后的变化。</li>\n<li><code>gir diff --cached</code>显示缓存池add前后的变化。</li>\n<li><code>git diff ID1 ID2</code>显示两次commit的变化(ID2-ID1)，如果需要查看最新一次提交的变更，ID2是最新一次的ID，ID1是之前的ID。</li>\n</ol>\n<h3 id=\"git-show\"><a href=\"#git-show\" class=\"headerlink\" title=\"git show\"></a>git show</h3><ol>\n<li><code>git show ID</code>显示某次commit的详细信息。</li>\n<li><code>git show-branch --more=10</code>显示当前开发分支的开发summary。</li>\n</ol>\n<h3 id=\"git-branch\"><a href=\"#git-branch\" class=\"headerlink\" title=\"git branch\"></a>git branch</h3><ol>\n<li><code>git branch</code>列出本地分支;</li>\n<li><code>git branch -r</code>列出远程分支;</li>\n<li><code>git branch -a</code>列出本地分支和远程分支;</li>\n<li><code>git branch name1</code>创建名字为<code>name1</code>的本地分支(不进行分支切换);</li>\n<li><code>git branch -d name1</code>删除分支，详情自行查询。</li>\n<li><code>git checkout name1</code>切换分支，详情自行查询。</li>\n</ol>\n<h3 id=\"git-mv-file1-file2\"><a href=\"#git-mv-file1-file2\" class=\"headerlink\" title=\"git mv file1 file2\"></a>git mv file1 file2</h3><p>重命名一个文件夹(更改到缓存池)，这是下列指令的组合：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv file1 file2</span><br><span class=\"line\">git rm file1</span><br><span class=\"line\">git add file2</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-clone\"><a href=\"#git-clone\" class=\"headerlink\" title=\"git clone\"></a>git clone</h3><p>clone一个版本库</p>\n<ol>\n<li><code>clone folder1 folder2</code>，将folder1版本库clone并重命名为folder2；</li>\n<li><code>clone url</code>clone在url上的远程版本库到本地。</li>\n</ol>\n<h3 id=\"git-config\"><a href=\"#git-config\" class=\"headerlink\" title=\"git config\"></a>git config</h3><ol>\n<li><code>git config paramname val</code>修改本仓库的配置</li>\n<li><code>git config --global paraname val</code>修改全局配置(我的.config文件在C：/users/username/.gitconfig)</li>\n</ol>\n<h3 id=\"touch-gitignore\"><a href=\"#touch-gitignore\" class=\"headerlink\" title=\"touch .gitignore\"></a>touch .gitignore</h3><ol>\n<li>这个指令可以在git Bash中创建<code>.gitignore</code>文件；</li>\n<li>当然可以在git for windows或者github创建仓库的时候添加这个文件。</li>\n</ol>\n<hr>\n<h2 id=\"Git远程版本库\"><a href=\"#Git远程版本库\" class=\"headerlink\" title=\"Git远程版本库\"></a>Git远程版本库</h2><h3 id=\"git-remote-add-origin-url\"><a href=\"#git-remote-add-origin-url\" class=\"headerlink\" title=\"git remote add origin url\"></a>git remote add origin url</h3><p>这为你的git本地仓库创建远程连接。</p>\n<ol>\n<li>origin是约定的远端库的名字(当然可以用其他的);url在github上创建的仓库可以clone到。</li>\n<li>可以使用cat .git/config来查看。</li>\n</ol>\n<h3 id=\"git-push\"><a href=\"#git-push\" class=\"headerlink\" title=\"git push\"></a>git push</h3><ol>\n<li><code>git push origin master</code>，将HEAD提交到远端库origin的master分支；</li>\n<li><code>git push -u origin master</code>，指定默认远端库和分支。执行之后，以后的提交都可以简写为<code>git push</code>。</li>\n<li><code>git push -f</code>将本地内容强行提交(force)到远端(本地有冲突),比如说修改commit的summary。</li>\n</ol>\n<h3 id=\"git-pull\"><a href=\"#git-pull\" class=\"headerlink\" title=\"git pull\"></a>git pull</h3><p>git pull = git fetch + git merge</p>\n<ol>\n<li><code>git fetch</code>将远端库的HEAD,fetch到本地；</li>\n<li><code>git merge</code>将本地与HEAD合并，有冲突时需要先解决冲突，注意如果本地有远端库没有的文件，需要手动删除。</li>\n</ol>\n<h3 id=\"git-reset-–hard-HEAD-3-ID\"><a href=\"#git-reset-–hard-HEAD-3-ID\" class=\"headerlink\" title=\"git reset –hard HEAD~3/ID\"></a>git reset –hard HEAD~3/ID</h3><p>这一指令可以快速的版本切换(用git log查询ID，变更HEAD的头指针)</p>\n<ol>\n<li>变更之后使用<code>git log -g</code>查看，可以来回切换。</li>\n</ol>\n","categories":["Git"],"tags":["Git"]},{"title":"局域网通信","url":"https://applefishsky009.github.io/2016/06/05/局域网通信/","content":"<p>这是对第一篇博客<a href=\"http://rylcode.cn/2016/06/04/%E8%AE%BF%E9%97%AE%E7%BD%91%E7%AB%99%E6%97%B6%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/\" target=\"_blank\" rel=\"noopener\">访问网站时到底发生了什么？</a>中，局域网通信的扩展。</p>\n<hr>\n<h2 id=\"以太网和互联网的区别\"><a href=\"#以太网和互联网的区别\" class=\"headerlink\" title=\"以太网和互联网的区别\"></a>以太网和互联网的区别</h2><p>通常来说，局域网是工作在网络接口层的小型网络；互联网是将小型网络连接起来的大型网络。</p>\n<ol>\n<li>以太网是为了实现局域网通信而设计的一种(目前应用最普遍的)技术(局域网组网方式)，没有中继覆盖200m。其他局域网标准如令牌环，FDDI，ARCNET；</li>\n<li>互联网(internet)是网络的网络；</li>\n<li>因特网(Internet)特指当前全球最大的，开放的，有众多网络互相连接而成的特定计算机网络，采用TCP/IP协议族作为通信规则；</li>\n<li>以太网&lt;局域网&lt;互联网!=因特网。</li>\n</ol>\n<hr>\n<h2 id=\"IP地址与MAC地址\"><a href=\"#IP地址与MAC地址\" class=\"headerlink\" title=\"IP地址与MAC地址\"></a>IP地址与MAC地址</h2><p>由于全世界网络各式各样，使用的硬件地址也不同，如果用硬件地址通信，需要非常复杂的硬件地址转换工作。因此使用统一的IP地址通信。</p>\n<ol>\n<li>MAC地址是数据链路层和物理层使用的地址，是物理地址，IP地址是网络层和以上各层使用的地址，是逻辑地址。</li>\n<li>IP数据报是MAC帧的数据，链路层只能看见MAC帧，IP层抽象的互联网上只能看到IP数据报，屏蔽下层细节；</li>\n<li>路由器只根据目的站的IP地址网络号进行路由选择。</li>\n<li>报文发送过程中IP地址是不会变化的。</li>\n</ol>\n<hr>\n<h2 id=\"ARP协议\"><a href=\"#ARP协议\" class=\"headerlink\" title=\"ARP协议\"></a>ARP协议</h2><h3 id=\"什么是ARP？\"><a href=\"#什么是ARP？\" class=\"headerlink\" title=\"什么是ARP？\"></a>什么是ARP？</h3><p>解决<strong>同一个局域网</strong>上的主机或路由器的IP地址和硬件地址的映射问题。是局域网内通信。<br>由于数据发送在数据链路层和物理层上，也就是说必须是硬件到硬件的数据发送，因此如果不是一个局域网，地址解析也是没有意义的。</p>\n<h3 id=\"什么时候用ARP？\"><a href=\"#什么时候用ARP？\" class=\"headerlink\" title=\"什么时候用ARP？\"></a>什么时候用ARP？</h3><p>主机准备封装MAC帧的时候发现他不知道(同一个局域网内)另一台主机的MAC地址或第一跳(局域网路由器)的MAC地址。具体是哪一种情况，主机<strong>根据目的IP识别</strong>。</p>\n<h3 id=\"主机为什么会不知道MAC地址？\"><a href=\"#主机为什么会不知道MAC地址？\" class=\"headerlink\" title=\"主机为什么会不知道MAC地址？\"></a>主机为什么会不知道MAC地址？</h3><p>主机有一个ARP高速缓存记录IP-MAC对(高速缓存可以极大减少网络信息量)，每一个映射地址项目都有生存时间(10-20min)，如果目的主机换了网络适配器，主机找不到目的主机，生存时间之后，ARP高速缓存就删除了原先的目的主机硬件地址。</p>\n<h3 id=\"ARP到底是在网络层还是在数据链路层？\"><a href=\"#ARP到底是在网络层还是在数据链路层？\" class=\"headerlink\" title=\"ARP到底是在网络层还是在数据链路层？\"></a>ARP到底是在网络层还是在数据链路层？</h3><p>IP协议使用了ARP协议解析其物理地址，所以通常来讲将他放在网络层。但是解析出来的MAC地址实在数据链路层使用。因此也有将其划分在数据链路层，只要明白原理，其在哪一层不重要。</p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>每经过一个硬件设备，MAC帧首部的地址就会变化，但IP数据报首部的地址不会变化。</p>\n<h3 id=\"ARP协议怎么使用\"><a href=\"#ARP协议怎么使用\" class=\"headerlink\" title=\"ARP协议怎么使用\"></a>ARP协议怎么使用</h3><ol>\n<li>主机A想局域网上的主机B(主机或者路由器，取决于A的IP数据报首部的目的IP)发送数据报时，在ARP高速缓存中查看IP-MAC映射；</li>\n<li>若没有，ARP进程在本局域网发送ARP广播请求(WLAN协议(CSMA/CA)或广播信道CSMA/CD协议)，本局域网上所有主机运行的ARP进程都会收到这个请求；</li>\n<li>主机B的IP地址与请求的IP一致，则接受请求，并向A单播发送ARP请求响应(在其中写入自己的MAC地址)</li>\n<li>主机A收到ARP请求响应，将IP-MAC写入ARP高速缓存，并填入MAC帧，发送数据报。</li>\n</ol>\n","categories":["计算机网络"],"tags":["计算机网络"]},{"title":"访问网站时到底发生了什么？","url":"https://applefishsky009.github.io/2016/06/04/访问网站时到底发生了什么？/","content":"<p>之前有学习过计算机网络，但并没有理解他到底是什么，直到现在，决定重温计算机网络。首先推荐一本书，谢希仁编著的《计算机网络》，还有一个<a href=\"https://mp.weixin.qq.com/s?__biz=MzA5ODUxOTA5Mg==&mid=2652549492&idx=1&sn=1ee3f3ac7e3939c2d043475ee94fc84a&scene=0&key=f5c31ae61525f82ee719b6a9891804cfdb17bfef968860d6549e72f709c44f8858691a090c5bb18f36988dc88354c172&ascene=7&uin=MTI5MjI0NzEyMQ%3D%3D&devicetype=android-23&version=26031031&nettype=WIFI&pass_ticket=Y%2F%2FFA4XRBgzEZc7TWnpUSOgilSIZ%2BwlAC7IVjUZZxQ8%2BeVY%2BsyubOhQ6ThMU3jn%2F\" target=\"_blank\" rel=\"noopener\">计算机网络总结</a>。直到看了这本书，我才认识到，国内教材还是有可取之处的。。。</p>\n<p>第一篇计算机网络的博客，回答这样一个问题，我们<strong>访问一个网站的时候经历了怎样的过程</strong>？以后的内容基本都是基于这一解释的扩展。</p>\n<hr>\n<h2 id=\"获得网站的IP\"><a href=\"#获得网站的IP\" class=\"headerlink\" title=\"获得网站的IP\"></a>获得网站的IP</h2><p>我知道他的名字，但是不知道他的联系方式，怎么玩耍呢？<br>只有获得网站的IP(联系方式)才能建立TCP连接(通话约好玩耍)，因此第一步就是获得网站的IP。</p>\n<ol>\n<li>查看浏览器DNS缓存有没有URL对应的IP，(还要查看系统缓存)，若没有，浏览器需要向DNS服务器发出DNS请求；<ul>\n<li>简单将DNS服务器理解为：URL转IP(域名解析)；</li>\n</ul>\n</li>\n<li>浏览器向本地DNS模块发出DNS请求，DNS模块生成相关的DNS报文；</li>\n<li>会话层/应用层的DNS模块将生成的DNS报文传递给传输层的UDP协议单元；</li>\n<li>UDP协议单元将数据封装成UDP数据报，传递给网络层的IP协议单元；</li>\n<li>IP单元将数据封装成IP数据包，其中目的IP是电脑设置的默认DNS地址(DNS服务器地址，路由器根据这个IP进行路由选择)，将封装好的数据包传递给数据链路层的协议单元；</li>\n<li>封装好的IP数据包传递给数据链路层，数据链路层需要封装到达目的IP的MAC地址(下一跳地址)，这时候IP协议需要使用ARP协议获得下一跳的MAC地址(路由的MAC)，如ARP缓存没有相关数据，发送ARP广播(WLAN协议(CSMA/CA)或广播信道CSMA/CD协议)请求，等待ARP回应；<ul>\n<li>ARP协议解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题。</li>\n</ul>\n</li>\n<li>收到ARP单播回应，将对应信息写入ARP缓存，这时候数据链路层就可以封装IP数据包和下一跳MAC地址(路由器或目的主机)并发送(单播，指定IP)；<ul>\n<li>组播和单播都会侦听信道，<strong>组播表示所有主机都会接收消息，但不一定响应，单播是只有特定IP才会接受消息</strong>。举个例子，广播ARP请求，所有主机接收到信道上的消息，发现是广播(IP)，于是接受消息，再一分析，发现是ARP请求，于是选择响应或者不响应。如果是单播，直接查看IP选择接受或者不接受。</li>\n<li>注意，广播ARP请求所有主机都会收到消息，但是非目标主机不会响应。</li>\n</ul>\n</li>\n<li>多次经过路由器解封/封装MAC帧，DNS请求到达DNS服务器(DNS服务器由IPS提供，通信使用PPP-&gt;IPCP协议(包含NCP协议))的数据链路层(协议单元)-&gt;IP-&gt;UDP-&gt;DNS(-&gt;表示经过协议单元并解析报文)，解析DNS域名，如果DNS服务器有相关数据，则产生DNS回应报文。<ul>\n<li>主机向本地域名服务器采用<strong>递归查询</strong>，就是说，如果这里没有相关数据，由本地域名服务器向其他根域名服务器继续发出DNS请求(每次DNS请求从1开始)；</li>\n<li>本地域名服务器向跟域名服务器采用<strong>迭代查询</strong>，就是说，被查询的根域名服务器产生DNS回应报文，其中要么给出目的IP，要么说：“我不知道，你去问我下边的那个顶级域名服务器吧！”，同理顶级域名服务器如果还是不知道，就会说：“我不知道，你去问我下边的这个权限域名服务器吧”，然后就得到了所需要的DNS回应报文。</li>\n</ul>\n</li>\n<li>DNS回应报文在本地域名服务器上，DNS回应报文-&gt;UDP-&gt;IP-&gt;数据链路层(MAC)。</li>\n<li>本机得到DNS回应报文，数据链路层-&gt;IP-&gt;UDP-&gt;DNS,解析得到URL对应的IP-&gt;浏览器写入DNS缓存表。</li>\n</ol>\n<hr>\n<h2 id=\"TCP链接的三次握手\"><a href=\"#TCP链接的三次握手\" class=\"headerlink\" title=\"TCP链接的三次握手\"></a>TCP链接的三次握手</h2><p>我知道了他的联系方式，现在我需要和他联系约好一起愉快的玩耍。<br>现在浏览器直到了目标URL的IP地址，下一步和这个IP建立TCP连接。</p>\n<ol>\n<li>浏览器向目的IP发送TCP连接请求报文，TCP(SYN=1，ACK=0)-&gt;IP-&gt;ARP(MAC)-&gt;网关-&gt;目的主机；    <font color=\"red\">本机状态：SYN_SEND</font></li>\n<li>目的主机得到TCP请求报文，数据链路层-&gt;IP-&gt;TCP；</li>\n<li>发送请求应答报文，TCP(SYN=1,ACK=1)-&gt;IP-&gt;数据链路层；    <font color=\"red\">主机状态：SYN_RCVD</font></li>\n<li>本机得到请求应答报文，数据链路层-&gt;IP-&gt;TCP；</li>\n<li>本机回应请求确认报文，TCP-&gt;IP-&gt;数据链路层；    <font color=\"red\">本机状态：ESTABLISHED</font></li>\n<li>目的主机得到请求应答报文，数据链路层-&gt;IP-&gt;TCP,连接建立完成。    <font color=\"red\">主机状态：ESTABLISHED</font></li>\n</ol>\n<h3 id=\"为什么需要三次握手\"><a href=\"#为什么需要三次握手\" class=\"headerlink\" title=\"为什么需要三次握手\"></a>为什么需要三次握手</h3><p>如果不是三次握手：</p>\n<ol>\n<li>本机请求报文阻塞时，本机超时后会再次发送连接请求，服务器建立多个响应等待。</li>\n<li>若2次握手，再考虑目的主机回应报文阻塞了(这时候服务器已经响应了)。主机会再次发送连接请求，造成服务器再次响应，依然有服务器资源浪费。</li>\n<li>采用三次握手，如果服务器没有收到确认报文的确认，他会有一个重传次数和半连接存活时间，超过重传次数或半连接存活时间，就知道本机并没有想要建立连接，因此不会响应。</li>\n<li><font color=\"red\">TCP的漏洞</font>,如上所说，有一个重传次数和半连接存活时间,如果有一个主机不停地伪装不存在的IP，对服务器发出连接请求，无法响应确认报文，服务器需要不停重发确认报文直到超时，这些伪造的SYN包长时间占用未连接队列，正常的SYN请求被丢弃，服务器系统会运行缓慢，严重时引起网络堵塞升值系统瘫痪。</li>\n</ol>\n<hr>\n<h2 id=\"浏览器访问过程\"><a href=\"#浏览器访问过程\" class=\"headerlink\" title=\"浏览器访问过程\"></a>浏览器访问过程</h2><p>怎么愉快的玩耍呢？<br>通过HTTP协议的方法来交互，比如：</p>\n<ol>\n<li>HTTP.GET方法报文-&gt;TCP-&gt;IP-&gt;MAC(ARP)-&gt;网关-&gt;主机；</li>\n<li>主机数据链路层-&gt;IP-&gt;TCP-&gt;HTTP,HTTP协议产生封装好的HTML超文本形式数据；</li>\n<li>HTTP-HTML-&gt;TCP-&gt;IP-&gt;MAC(ARP)-&gt;网关-&gt;本机；</li>\n<li>本机收到数据帧，数据链路层-&gt;IP-&gt;TCP-&gt;HTTP,浏览器显示HTML超文本。</li>\n</ol>\n<hr>\n<h2 id=\"TCP断开连接的四次握手\"><a href=\"#TCP断开连接的四次握手\" class=\"headerlink\" title=\"TCP断开连接的四次握手\"></a>TCP断开连接的四次握手</h2><p>愉快地玩耍了，各回各家吧！<br>断开连接是也是一个平等的过程，本机需要主机同意，主机也需要本机同意。</p>\n<ol>\n<li>浏览器发送结束请求报文，TCP(FIN=1)-&gt;IP-&gt;MAC(ARP)-&gt;网关-&gt;主机，本机等待关闭1；    <font color=\"red\">本机状态：FIN-WAIT-1</font></li>\n<li>主机收到数据帧，数据链路层-&gt;IP-&gt;TCP,并回应应答报文，主机等待关闭，TCP(FIN=1,ACK=1)-&gt;IP-&gt;MAC(ARP)-&gt;网关-&gt;主机，本机等待关闭2。    <font color=\"red\">主机状态：CLOSE-WAIT</font></li>\n<li>主机发送结束请求报文，TCP(FIN=1)-&gt;IP-&gt;MAC(ARP)-&gt;网关-&gt;本机；<font color=\"red\">主机状态：CLOSE-WAIT -&gt; LAST-ACK</font></li>\n<li>本机收到数据帧，数据链路层-&gt;IP-&gt;TCP,并回应应答报文，关闭连接，TCP(FIN=1,ACK=1)-&gt;IP-&gt;MAC(ARP)-&gt;网关-&gt;主机。    <font color=\"red\">本机状态：TIME-WAIT</font></li>\n<li>主机收到ACK应答报文，关闭连接。    <font color=\"red\">主机状态：CLOSE</font></li>\n</ol>\n<h3 id=\"为什么要四次握手\"><a href=\"#为什么要四次握手\" class=\"headerlink\" title=\"为什么要四次握手\"></a>为什么要四次握手</h3><ol>\n<li>考虑本机将数据发送完了，发送结束请求报文，主机收到了，但是主机没有将需要发送的数据发完，因此会告诉本机，“你先等等，我发完数据再断开”，本机就在等待。</li>\n<li>主机告诉本机，“我发完了，可以关闭了”，本机收到后回应，“好的，那就关闭吧”</li>\n<li>主机收到最后一句话会断开连接，但是，本机发送后不能立刻关闭连接(TIME WAIT)，若回应报文丢失，主机会重新发送结束请求报文，本机还需要响应，因此需要TIME WAIT(一般是30s)。</li>\n</ol>\n<p>图解：<br><img src=\"http://i.imgur.com/nzqCAKf.jpg\" alt></p>\n<hr>\n<p>参考<a href=\"http://www.voidcn.com/blog/zbuger/article/p-5713349.html\" target=\"_blank\" rel=\"noopener\">访问一个网站的过程</a>。至此回答了<strong>访问一个网站经历了哪些过程？</strong>，作为一个入门级的计算机网络，其中每一层都值得深思。以后会慢慢补充。</p>\n","categories":["计算机网络"],"tags":["计算机网络"]},{"title":"函数重载与函数模板","url":"https://applefishsky009.github.io/2016/06/03/函数重载与函数模板/","content":"<p>简单介绍重载和模板，具体可以参考<a href=\"http://rylcode.cn/2016/05/21/%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E4%B8%8E%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0/\" target=\"_blank\" rel=\"noopener\">OPP特性分析</a><br>函数重载是一种多态，一种消息对不同对象有多个动作；<br>函数模板是一种泛型编程，简化了重载函数的函数体设计，使代码的可重用性大大提高。到之后的类模板设计中可以体会到他的优美。</p>\n<hr>\n<h2 id=\"函数重载\"><a href=\"#函数重载\" class=\"headerlink\" title=\"函数重载\"></a>函数重载</h2><p>关键：函数参数列表也就是特征标不同。</p>\n<ol>\n<li>如果没有完全匹配，C++尝试标准类型转换强制匹配；</li>\n<li>编译器检查函数特征标时，将类型引用和类型本身视为同一个特征标；</li>\n<li>非<code>const</code>参数只匹配非<code>const</code>调用，<code>const</code>参数同时匹配<code>const</code>调用和非<code>const</code>调用。(<code>const</code>参数不能传给非<code>const</code>参数，因为有改变的风险)</li>\n<li>三个原型的可能匹配(优先最佳匹配)，注意<code>r2</code>匹配范围最广<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sink</span><span class=\"params\">(<span class=\"keyword\">double</span> &amp;r1)</span></span>;\t<span class=\"comment\">//可修改的左值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sink</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">double</span> &amp;r2)</span></span>;\t<span class=\"comment\">//可修改的左值，'const'左值，右值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sink</span><span class=\"params\">(<span class=\"keyword\">double</span> &amp;&amp;r3)</span></span>;\t<span class=\"comment\">//右值</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>仅当函数基本上执行相同的任务，但是用不同形式的数据时，才应采用函数重载。</p>\n<hr>\n<h2 id=\"函数模板\"><a href=\"#函数模板\" class=\"headerlink\" title=\"函数模板\"></a>函数模板</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>假设维护一个大项目，对于两个数据相加，其数据类型可能是<code>char</code>,<code>int</code>,<code>short</code>,<code>double</code>,<code>float</code>甚至自定义的类，不可能对每种可能的类型提供重载，这就需要泛型编程。</p>\n<ol>\n<li><p>函数模板允许以任意类型的方式来定义函数,可用于将同一种算法用于不同类型的数据，如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\">T <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">const</span> T &amp;a,<span class=\"keyword\">const</span> T &amp; b，<span class=\"keyword\">int</span> n = <span class=\"number\">0</span>)</span> </span>&#123;</span><br><span class=\"line\">\tT c = a+b;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>函数模板不能缩短可执行程序。最终的代码只包含为程序生成的史记汉书，并不包含任何模板。</p>\n</li>\n<li><p>模板函数参数不一定必须是模板的参数类型；</p>\n</li>\n<li><p>模板函数中使用的运算符在具体化的模板中可能并未重载，这时候可以为具体化的模板重载运算符。</p>\n</li>\n</ol>\n<h3 id=\"具体化\"><a href=\"#具体化\" class=\"headerlink\" title=\"具体化\"></a>具体化</h3><ol>\n<li>匹配顺序：非模板函数&gt;显式具体化函数&gt;模板函数；</li>\n<li>实例化指的是模板参数(上例中的T)的指定，这样就可以生成一个定义。实例化是指对特定类型的显式定义，<strong>这些原型必须有自己的函数定义</strong>(也就是说这个类型和通用模板的行为不同时使用显示具体(具体指的是具体行为)化)，<font color=\"red\">这是一种多态？</font>。</li>\n<li>重载解析将寻找最匹配的函数。<ul>\n<li>如果只有一个，选择它；</li>\n<li>如果有多个，只有一个非模板函数，选择它；</li>\n<li>如果有多个，且都是模板函数，选择更具体的模板；</li>\n<li>如果这些模板函数都不比其他模板具体，编译器会困惑，这是错误的；</li>\n<li>没有匹配也是错误的。</li>\n</ul>\n</li>\n<li>自定义选择调用模板或者具体化的模板(即使不是最匹配，因为是先具体化再调用)<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//提供非模板函数，模板函数，具体化的模板函数</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> m,n;<span class=\"keyword\">double</span> x,y;</span><br><span class=\"line\">lesser(m,n)\t<span class=\"comment\">//调用非模板函数</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;&gt;lesser(m,n)\t<span class=\"comment\">//调用模板函数，使用int具体化</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">int</span>&gt;lesser(x,y)\t<span class=\"comment\">//地用模板函数，使用int具体化</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"类型的困惑\"><a href=\"#类型的困惑\" class=\"headerlink\" title=\"类型的困惑\"></a>类型的困惑</h3><ol>\n<li><p><code>decltype(expression)</code>关键字用于类型获取<code>decltype(x+y) xpy = x+y</code></p>\n</li>\n<li><p><code>decltype</code>关键字的核对表：</p>\n<ul>\n<li>如果是没有用括号括起来的标识符，则得到的类型与标识符相同；</li>\n<li>如果获取函数调用，得到类型与函数返回值相同；</li>\n<li>将标识符用括号括起来，可以得到标识符引用；</li>\n<li>如果都不满足，得到<code>expression</code>类型。<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> x;</span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(x);\t<span class=\"comment\">//int</span></span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(<span class=\"built_in\">sqrt</span>(x));\t<span class=\"comment\">//int</span></span><br><span class=\"line\"><span class=\"keyword\">decltype</span>((x));\t<span class=\"comment\">//int &amp;</span></span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(x+<span class=\"number\">6</span>).\t<span class=\"comment\">//int</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>后置返回类型，函数返回类型在函数声明之前，如果是需要在函数内推断的类型，如何获得?使用后置返回类型，用<code>auto</code>占位，将<code>decltype</code>置于函数声明之后。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T1,<span class=\"keyword\">typename</span> T2&gt;</span><br><span class=\"line\">auto gt(T1 x,T2 y)-&gt;decltype(x+y) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> x+y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n","categories":["C++基础"],"tags":["C++"]},{"title":"unordered_map容器简介","url":"https://applefishsky009.github.io/2016/06/01/unordered_map容器简介/","content":"<p>先上彩蛋：</p>\n<ol>\n<li><a href=\"http://www.cplusplus.com/\" target=\"_blank\" rel=\"noopener\">cplusplus</a></li>\n<li><a href=\"http://en.cppreference.com/w/\" target=\"_blank\" rel=\"noopener\">cppreference</a></li>\n<li><a href=\"http://stackoverflow.com/\" target=\"_blank\" rel=\"noopener\">stackoverflow</a><br><code>#include&lt;unordered_map&gt;</code>头文件内定义了两个无序的hash容器<code>unordered_map</code>和<code>unordered_multimap</code></li>\n</ol>\n<hr>\n<h2 id=\"unordered-map简介\"><a href=\"#unordered-map简介\" class=\"headerlink\" title=\"unordered_map简介\"></a>unordered_map简介</h2><p>容器属性：</p>\n<ol>\n<li>Associative:通过key而不是绝对位置来引用；</li>\n<li>Unordered:无序，即通过hash表来组织数据，以支持通过key的快速访问；</li>\n<li>Map:将key与mapped value映射，通过key访问mapped value；</li>\n<li>Unique keys:这是一个一一映射</li>\n<li>Allocator-aware:使用分配器<code>allocator</code>来动态存储。</li>\n</ol>\n<p>特征补充：</p>\n<ol>\n<li><code>unordered_map</code>访问个体的速度比<code>map</code>更快，但是子集元素的范围迭代效率更低。</li>\n<li><font color=\"red\"><code>value_type:pair&lt;const key_type,mapped_type&gt;</code></font></li>\n</ol>\n<p>心得：</p>\n<ol>\n<li>他底层数据结构是散列表，因此搜索操作具有常数级的平均时间复杂度,<a href=\"http://ask.todgo.com/detail/6006173bc12b.html\" target=\"_blank\" rel=\"noopener\">和map对比</a>；</li>\n<li><code>map</code>的查找效率比<code>unordered_map</code>稳定，其插入，删除，搜索的复杂度都是O(logn)，对于频繁的插入删除，优先使用<code>map</code>；</li>\n<li>如果仅需要在插入完毕后排序一次，可以考虑用<code>unordered_map</code>，最后sort那个arary。</li>\n</ol>\n<hr>\n<h2 id=\"unordered-map使用\"><a href=\"#unordered-map使用\" class=\"headerlink\" title=\"unordered_map使用\"></a>unordered_map使用</h2><ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/133%20-%20Clone%20Graph/133%20-%20Clone%20Graph(BFS).cpp\" target=\"_blank\" rel=\"noopener\">Clone Graph</a></li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/47%20-%20Permutations%20II/47%20-%20Permutations%20II.cpp\" target=\"_blank\" rel=\"noopener\">Permutations II</a><ul>\n<li>随着sums的增长，在最后一步find()方法的复杂度n!增长，耗时太久;</li>\n<li>在每一步中可以去掉相同的步，可以极大优化算法;</li>\n<li>用hash_map统计出现的次数速度更快，于是用字符次数对来代替原数组(重复字符越多速度提升越明显)。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/128%20-%20Longest%20Consecutive%20Sequence/128%20-%20Longest%20Consecutive%20Sequence.cpp\" target=\"_blank\" rel=\"noopener\">Longest Consecutive Sequence</a><ul>\n<li>O(n)的时间复杂度应该联想到Hash Table；</li>\n<li>和其他线性容器不同，他的删除操作很容易实现。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/1%20-%20Two%20Sum/1%20-%20Two%20Sum.cpp\" target=\"_blank\" rel=\"noopener\">Two Sum</a><ul>\n<li>使用<code>unordered_map</code>，常数级搜索；</li>\n<li>考虑{3,2,4，(3)},6；因此不能对半筛选，因此过滤相同下标。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/30%20-%20Substring%20with%20Concatenation%20of%20All%20Words/30%20-%20Substring%20with%20Concatenation%20of%20All%20Words.cpp\" target=\"_blank\" rel=\"noopener\">Substring with Concatenation of All Words</a><ul>\n<li>用<code>Hash Table</code>，涉及到字符串，使用<code>unordered_map</code>统计字符串个数作为“池”；</li>\n<li><code>iterator</code>的方法目前涉及太少<code>next()</code>,<code>pre()</code>,<code>advance()</code>。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"operator\"><a href=\"#operator\" class=\"headerlink\" title=\"operator[]\"></a>operator[]</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mapped_type&amp; <span class=\"keyword\">operator</span>[] ( <span class=\"keyword\">const</span> key_type&amp; k );</span><br><span class=\"line\">mapped_type&amp; <span class=\"keyword\">operator</span>[] ( key_type&amp;&amp; k );</span><br></pre></td></tr></table></figure>\n\n<p>运算符<code>[]</code>的重载，如果已有key，返回val;<strong>如果没有key,插入这个key</strong>,返回val的引用(因此可以直接赋值)。注意使用operator[]和find()具有不同意义。</p>\n<h3 id=\"insert\"><a href=\"#insert\" class=\"headerlink\" title=\"insert()\"></a>insert()</h3><p>之前提到他的<code>value_type</code>是<code>pair&lt;const key_type,mapped_type&gt;</code>，因此使用insert()方法要用<code>make_pair()</code>方法来构建对象，返回对象也是指针和bool的pair。<br><code>pair&lt;iterator,bool&gt; insert ( const value_type&amp; val );</code></p>\n<h3 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find()\"></a>find()</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">find</span> <span class=\"params\">( <span class=\"keyword\">const</span> key_type&amp; k )</span></span>;</span><br><span class=\"line\"><span class=\"function\">const_iterator <span class=\"title\">find</span> <span class=\"params\">( <span class=\"keyword\">const</span> key_type&amp; k )</span> <span class=\"keyword\">const</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>返回指向key的指针，如果没有则返回超尾unordered_map::end。他的两个主要用途可以使用<code>count()</code>方法(是否有Key)和<code>operator[]</code>(访问val)来代替。</p>\n<h3 id=\"erase\"><a href=\"#erase\" class=\"headerlink\" title=\"erase()\"></a>erase()</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">erase</span> <span class=\"params\">( const_iterator <span class=\"built_in\">position</span> )</span></span>;\t<span class=\"comment\">//by position (1)\t</span></span><br><span class=\"line\"><span class=\"function\">size_type <span class=\"title\">erase</span> <span class=\"params\">( <span class=\"keyword\">const</span> key_type&amp; k )</span></span>;\t<span class=\"comment\">//by key (2)\t</span></span><br><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">erase</span> <span class=\"params\">( const_iterator first, const_iterator last )</span></span>;\t/range (<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n\n<p>Hash Table的删除操作很容易实现(因为其数据结构不是线性的)，因此相对于线性结构赋值区分不同，删除更方便。</p>\n<hr>\n<p>以后一一补充。</p>\n","categories":["STL"],"tags":["C++"]},{"title":"Python爬虫抓取知乎图片","url":"https://applefishsky009.github.io/2016/05/30/Python爬虫抓取知乎图片/","content":"<p>初学Python，数据结构感觉很简单，语法什么也太过于枯燥无味。就从爬虫做起，使用Python3.5版本，在Pycharm中编写，用自带的IDE调试(这个真好用啊)，花了两天时间终于做好了自己的Python爬虫，先抓取某个用户一个回答的所有图片，然后抓取某一知乎用户的所有图片，代码见<a href=\"https://github.com/applefishsky009/PythonReptile\" target=\"_blank\" rel=\"noopener\">Github</a>，感觉新世界的大门在缓缓开启啊，^.^~</p>\n<p>另外，由于只学习几天就急着做爬虫玩，导致Python基本功不行，代码风格还是乱七八槽的，估计以后也懒得修改，主要关注内容原理吧。</p>\n<hr>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><p>首先介绍使用的三个模块，在实现中节省不少功夫，不知道的可以去搜，这里主要分析如何实现功能以及为什么这么使用，不会介绍模块。</p>\n<ol>\n<li>bs4，<code>from bs4 import BeautifulSoup</code>，模块文档在这里<a href=\"https://www.crummy.com/software/BeautifulSoup/bs4/doc/\" target=\"_blank\" rel=\"noopener\">doc</a>，这是一个非常好用的网页解析工具。简单来说，将抓回来的页面解析成<code>html</code>格式以便于查找定位。那么<strong>如何找想要的标签?</strong>可以在谷歌浏览器中F12查看，鼠标移到对应标签左边相应栏目就会显示为蓝色。</li>\n<li>shutil，<code>import shutil</code>导入这个模块主要是使用文件夹操作，主要是因为<code>mkdir</code>使用时如果目录中已有想创建的文件夹，会返回错误，我用shutil删除重建，保证程序的稳定性。</li>\n<li>linecache，<code>import linecache</code>导入这个模块读取本地txt文件中的信息，存储了两行，第一行是要爬取的<strong>主页</strong>,第二行是保存图片的文件夹。注意<code>linecache.getline()</code>方法会读取回车，去掉就行。</li>\n</ol>\n<h3 id=\"bs4\"><a href=\"#bs4\" class=\"headerlink\" title=\"bs4\"></a>bs4</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">url_open</span><span class=\"params\">(url)</span>:</span> <span class=\"comment\">#打开页面]</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"keyword\">with</span> urllib.request.urlopen(url,timeout=<span class=\"number\">30</span>) <span class=\"keyword\">as</span> response:</span><br><span class=\"line\">            html = response.read()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> html</span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        print(e)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> url_open(url)</span><br><span class=\"line\"></span><br><span class=\"line\">anwser_page = url_open(table_tail)</span><br><span class=\"line\">soup = BeautifulSoup(anwser_page,<span class=\"string\">'html.parser'</span>)</span><br><span class=\"line\">soup = BeautifulSoup(one_page, <span class=\"string\">'html.parser'</span>)</span><br></pre></td></tr></table></figure>\n\n<p>简单强调一点，bs4的<code>find()</code>和<code>find_all</code>方法，第一个返回一个bs4.Tag类，第二个返回的是这个类的<code>Set</code>,因此<code>find_all</code>之后一定要在循环中对<code>Set</code>的每一个成员才能使用<code>find()</code>方法。<br>大部分页面不登录就能访问，个别页面需要登录才能访问，因此需要判断<code>soup.find()</code>返回类型是不是<code>None</code>，可以登录才能爬取图片。</p>\n<h3 id=\"shutil\"><a href=\"#shutil\" class=\"headerlink\" title=\"shutil\"></a>shutil</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> os.path.isdir(folder):</span><br><span class=\"line\">\tshutil.rmtree(folder)</span><br><span class=\"line\">\tos.mkdir(folder)</span><br><span class=\"line\">\tprint(<span class=\"string\">'删除已有目录，创建新目录'</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">\tos.mkdir(folder)</span><br><span class=\"line\">\tprint(<span class=\"string\">'没有指定目录，创建新目录'</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"linecache\"><a href=\"#linecache\" class=\"headerlink\" title=\"linecache\"></a>linecache</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">person = linecache.getline(<span class=\"string\">r'E:\\Python\\pic_answer_page\\input.txt'</span>,<span class=\"number\">1</span>).split(<span class=\"string\">'\\n'</span>)[<span class=\"number\">0</span>]</span><br><span class=\"line\">folder = linecache.getline(<span class=\"string\">r'E:\\Python\\pic_answer_page\\input.txt'</span>,<span class=\"number\">2</span>).split(<span class=\"string\">'\\n'</span>)[<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n\n<p>由于<code>linecache.getline()</code>方法会读取回车，因此需要分割字符串去掉<code>\\n</code>。</p>\n<hr>\n<h2 id=\"简易\"><a href=\"#简易\" class=\"headerlink\" title=\"简易\"></a>简易</h2><p>这里只爬取了知乎一个回答页面的图片作为测试，要抓取的人和保存的文件夹都内置了，可以右键编辑<code>down_wshpic</code>函数的默认参数<code>folder</code>和这个函数下的<code>url</code>(注意一定要是某一个回答的页面)<br>这个简短程序主要的BUG有两个：</p>\n<ol>\n<li><code>url_open(url)</code>没有采取<code>try...catch</code>模块，遇见这个BUG多跑几次就行了，在进阶的程序中也做了修改，可以直接替换函数。</li>\n<li>抓取的知乎页面提示需要登录才能访问，这个问题本不该出现，下次制作爬虫再解决<br>代码在这里<a href=\"https://github.com/applefishsky009/PythonReptile/blob/master/pic_page/pic_page.py\" target=\"_blank\" rel=\"noopener\">抓取单个页面</a></li>\n</ol>\n<hr>\n<h2 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h2><p>找到一个你感兴趣的人，主页是这样的形式<code>https://www.zhihu.com/people/xxxx</code>，为了熟悉定位过程，程序会自动定位回答页面，解析回答页面数，解析所有回答的链接，爬取图片。<br>代码在这里<a href=\"https://github.com/applefishsky009/PythonReptile/blob/master/pic_people/pic_people.py\" target=\"_blank\" rel=\"noopener\">抓取某位用户的所有图片</a><br>主页信息和要保存图片的路径信息都在txt中保存，第一行是主页信息，第二行是保存文件的路径，形式见<a href=\"https://github.com/applefishsky009/PythonReptile/blob/master/pic_people/input.txt\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<hr>\n<h2 id=\"卡死的爬虫\"><a href=\"#卡死的爬虫\" class=\"headerlink\" title=\"卡死的爬虫\"></a>卡死的爬虫</h2><ol>\n<li>可以看到在进阶中和简易的爬虫中的<code>url_open(url)</code>是不一样的，这是由于网络响应不全或者服务器不响应导致的(注意如果服务器不响应，<code>except</code>后边要用<code>pass</code>)，设置一个响应超时的参数(30s)，如果还未抓取<code>urlopen()</code>会抛出一个异常，因此采用<code>try...except</code>来抓取异常，并重新请求响应(因为知乎服务器大部分情况下，我们认为是响应不全)。如果用<code>pass</code>这个页面就被跳过了。如下：<br><img src=\"http://i.imgur.com/tKh1O4Z.png\" alt=\"超时重连\"></li>\n<li>在爬取的过程中还有一个问题，大部分页面是不需要的登陆就可以访问的，偶尔有极个别的人登陆之后才能访问，这些页面，爬取不到，直接跳过，以后的制作的爬虫会发送登录信息。<br><img src=\"http://i.imgur.com/3eNTvO5.png\" alt=\"抓取错误\"></li>\n<li>还有这个错误。。。原因未知，猜测是我的网挂了一下，挂着蓝灯不太稳定导致的<br><img src=\"http://i.imgur.com/LTGQx7W.png\" alt=\"BadGate\"></li>\n</ol>\n<hr>\n<p>吐槽一下，有的人278个回答，只有250个图片，有的人142个回答，爬了1629个图片。。。这真是太可怕了。。<br>一共爬取9个人获得3231张图片。</p>\n<p>写在最后，喜欢哪个知乎上的帅哥妹子，快去收藏他/她的图库吧。。。</p>\n<p>下一步计划，</p>\n<ol>\n<li>登陆网站</li>\n<li>使用正则</li>\n<li>打印PDF</li>\n</ol>\n","categories":["Python"],"tags":["Python"]},{"title":"set容器简介","url":"https://applefishsky009.github.io/2016/05/27/set容器简介/","content":"<p>先上彩蛋：</p>\n<ol>\n<li><a href=\"http://www.cplusplus.com/\" target=\"_blank\" rel=\"noopener\">cplusplus</a></li>\n<li><a href=\"http://en.cppreference.com/w/\" target=\"_blank\" rel=\"noopener\">cppreference</a></li>\n<li><a href=\"http://stackoverflow.com/\" target=\"_blank\" rel=\"noopener\">stackoverflow</a><br><code>#include&lt;set&gt;</code>头文件内定义了两个有序的hash容器<code>set</code>和<code>multiset</code></li>\n</ol>\n<hr>\n<h2 id=\"set简介\"><a href=\"#set简介\" class=\"headerlink\" title=\"set简介\"></a>set简介</h2><p>容器属性：</p>\n<ol>\n<li>Associative:通过key而不是绝对位置来引用;</li>\n<li>Ordered:有序;</li>\n<li>Set:键值就是值本身；</li>\n<li>Unique keys:这是一个一一映射</li>\n<li>Allocator-aware:使用分配器<code>allocator</code>来动态存储。</li>\n</ol>\n<p>特征补充：</p>\n<ol>\n<li>容器中的元素都是不可修改的(都是<code>const</code>类型)，但是可以<code>insert()</code>，<code>remove()</code>；</li>\n<li>容器通过二叉搜索树实现。</li>\n</ol>\n<hr>\n<h2 id=\"set使用\"><a href=\"#set使用\" class=\"headerlink\" title=\"set使用\"></a>set使用</h2><ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/90%20-%20Subsets%20II/90%20-%20Subsets%20II(Recursion).cpp\" target=\"_blank\" rel=\"noopener\">Subsets II(Recursion)</a></li>\n</ol>\n<h3 id=\"insert\"><a href=\"#insert\" class=\"headerlink\" title=\"insert()\"></a>insert()</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pair&lt;iterator,bool&gt; insert (const value_type&amp; val);</span><br><span class=\"line\">pair&lt;iterator,bool&gt; insert (value_type&amp;&amp; val);</span><br></pre></td></tr></table></figure>\n\n<p><code>set</code>中没有则插入，返回一个<code>pair</code>对象，<code>pair.first()</code>指向插入的元素或set中已有的该元素，<code>pair.second()</code>指示该元素是已有的还是新插入的。</p>\n<h3 id=\"彩蛋\"><a href=\"#彩蛋\" class=\"headerlink\" title=\"彩蛋\"></a>彩蛋</h3><ol>\n<li><code>#include &lt;algorithm&gt;</code>中<a href=\"http://stackoverflow.com/questions/5034211/c-copy-set-to-vector\" target=\"_blank\" rel=\"noopener\">copy将set转vector</a>，当然也可以用<code>vector</code>的构造函数(iterator类型一致)。</li>\n</ol>\n<hr>\n<p>暂没有用到其他方法，待补充</p>\n","categories":["STL"],"tags":["C++"]},{"title":"类中的new和delete","url":"https://applefishsky009.github.io/2016/05/26/类中的new和delete/","content":"<p>之前提到过浅拷贝和深拷贝的问题，现在详细讲一讲类中的<code>new</code>和<code>delete</code>。</p>\n<hr>\n<h2 id=\"构造函数中的new\"><a href=\"#构造函数中的new\" class=\"headerlink\" title=\"构造函数中的new\"></a>构造函数中的<code>new</code></h2><ol>\n<li>构造函数中使用<code>new</code>来初始化，析构函数中应该用<code>delete</code>;</li>\n<li><code>new</code>和<code>delete</code>必须相互兼容，<code>new</code>对应于<code>delete</code>，<code>new[]</code>对应于<code>delete[]</code>;</li>\n<li>多个构造函数必须以相同的方式<code>new</code>，因为只有一个析构函数，所有的构造函数必须与之兼容。注意，<code>delete</code>可以用于看那个指针，因此指针可以初始化为<code>nullptr</code>;</li>\n<li>应定义复制构造函数进行深度复制;</li>\n<li>应定义赋值运算符重载，将一个对象深度复制给另一个对象。</li>\n<li>逐成员复制将使用<strong>成员类型定义</strong>的复制构造函数和赋值运算符(如<code>String</code>作为成员对象赋值时会调用自身的复制构造函数和赋值运算符)。</li>\n</ol>\n<hr>\n<h2 id=\"析构函数的调用\"><a href=\"#析构函数的调用\" class=\"headerlink\" title=\"析构函数的调用\"></a>析构函数的调用</h2><ol>\n<li>动态变量在代码块结束时调用;</li>\n<li>静态变量，程序结束时调用;</li>\n<li><code>new</code>创建的，使用<code>delete</code>删除或者程序结束时。</li>\n</ol>\n<hr>\n<h2 id=\"new与指针\"><a href=\"#new与指针\" class=\"headerlink\" title=\"new与指针\"></a><code>new</code>与指针</h2><p>考虑这一常见语句:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TreeNode *head = new TreeNode(1);</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>使用<code>new</code>来初始化指针，这将调用相应的类构造函数来创建一个对象;</li>\n<li><code>-&gt;</code>运算符用于对象指针访问类方法;</li>\n<li><code>*</code>运算符用于对象指针获得对象;</li>\n</ol>\n<hr>\n<h2 id=\"定位new运算符\"><a href=\"#定位new运算符\" class=\"headerlink\" title=\"定位new运算符\"></a>定位<code>new</code>运算符</h2><p>考虑这一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p = new(buffer+N*sizeof(B)) B();</span><br></pre></td></tr></table></figure>\n\n<p>定位<code>new</code>运算符能在分配内存时指定内存位置<code>buffer</code>(需要包含头文件<code>new</code>)，但是这里有一个问题，在<code>delete buffer</code>时编译器并不知道你对<code>buffer</code>做了什么，因此不会调用对象的析构函数，那么如何保证析构函数与构造函数的数量一致?</p>\n<ol>\n<li>之前强调过析构函数只销毁对象不释放内存，因此需要在<code>buffer</code>内存释放前销毁对象;</li>\n<li>用指向对象的指针显示地调用析构函数;</li>\n<li>应注意调用析构函数的正确顺序。对于使用定位<code>new</code>运算符创建的对象，应该和创建的顺序相反。因为，晚创建的对象可能依赖于早创建的对象。另外，仅当所有对象都被销毁后，才能释放用于存储这些对象的缓冲区。</li>\n</ol>\n","categories":["C++的类"],"tags":["C++"]},{"title":"返回对象的说明","url":"https://applefishsky009.github.io/2016/05/26/返回对象的说明/","content":"<p>有三种可选择的返回对象，返回对象的<code>const</code>引用，返回对象的非<code>const</code>引用，返回<code>const</code>对象。返回对象。简单来说就是两个问题,是对象还是引用?是<code>const</code>还是非<code>const</code>?</p>\n<hr>\n<h2 id=\"返回对象的const引用\"><a href=\"#返回对象的const引用\" class=\"headerlink\" title=\"返回对象的const引用\"></a>返回对象的<code>const</code>引用</h2><p>返回引用提高效率</p>\n<ol>\n<li>返回对象调用复制构造函数，返回引用不会，效率更高；</li>\n<li>引用指向的对象在调用函数执行时存在(否则返回时释放会出现野指针);</li>\n<li>注意返回类型可能与传入的某种类型匹配。</li>\n</ol>\n<hr>\n<h2 id=\"返回指向非const对象的引用\"><a href=\"#返回指向非const对象的引用\" class=\"headerlink\" title=\"返回指向非const对象的引用\"></a>返回指向非<code>const</code>对象的引用</h2><p>主要是返回对象能不能修改，常见两种情况，重载赋值运算符<code>=</code>，重载与<code>cout</code>一起使用的<code>&lt;&lt;</code>运算符;</p>\n<ol>\n<li>重载<code>=</code>是为了提高效率，用于连续赋值；</li>\n<li>重载<code>&lt;&lt;</code>(与<code>cout</code>一起使用)必须这样做，因为用于连续输出时对象会发生变化。</li>\n</ol>\n<hr>\n<h2 id=\"返回const对象\"><a href=\"#返回const对象\" class=\"headerlink\" title=\"返回const对象\"></a>返回<code>const</code>对象</h2><p>使用<code>const</code>对象将其声明为不可修改的左值防止被覆盖，不希望被覆盖的量如果不声明为<code>const</code>经常会引发误用和滥用。</p>\n<ol>\n<li>不可修改的左值防止被覆盖。</li>\n</ol>\n<hr>\n<h2 id=\"返回对象\"><a href=\"#返回对象\" class=\"headerlink\" title=\"返回对象\"></a>返回对象</h2><p>返回局部变量不能用引用，这是一个可修改的值或者需要赋值给一个非<code>const</code>变量，则会适用对象。</p>\n<ol>\n<li>算术运算符重载。</li>\n</ol>\n<hr>\n<p>简单回答开头所提出的问题，</p>\n<ol>\n<li>是不是<code>const</code>要看返回对象允许不允许赋值,对象有没有改变的必要性,能用<code>const</code>绝对不要不用,<strong>有趣的是</strong>,上述分析中，运算符重载都是非<code>const</code>。</li>\n<li>是不是引用取决于能不能返回引用(可不可以复制)，能返回引用一定要返回引用来提高效率(返回对象有拷贝过程),返回局部变量才不能用引用，否则会出现野指针。</li>\n</ol>\n<hr>\n<h2 id=\"函数原型中的const\"><a href=\"#函数原型中的const\" class=\"headerlink\" title=\"函数原型中的const\"></a>函数原型中的const</h2><ol>\n<li>函数参数中的<code>const</code>表示表示函数不会修改调用的参数值；</li>\n<li>函数头的<code>const</code>表示其返回对象是否可修改；</li>\n<li>参数列表后花括号前的<code>const</code>表示函数不会修改其访问对象的值(虽然参数声明为<code>const</code>其不能显式修改，但不能保证参数的成员函数隐式修改其值)。举例：<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">cosnt <span class=\"keyword\">int</span> <span class=\"title\">sum</span> <span class=\"params\">(<span class=\"keyword\">const</span> shape &amp;shape1)</span> <span class=\"keyword\">const</span> </span>&#123; </span><br><span class=\"line\">shape1.memberFunc1;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">1</span>；</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n","categories":["C++的类"],"tags":["C++"]},{"title":"类的自动转换与转换函数","url":"https://applefishsky009.github.io/2016/05/25/类的自动转换与转换函数/","content":"<p>先来一个彩蛋:C++ primer plus P410中写道，如果发现自己在随机漫步时，请保持自信，迈大步走。虽然在蜿蜒前进的过程中仍旧无法控制前进的方向，但至少会走得远一点。WTF?卖萌= =。<br>因为对于随机漫步问题,步数(N)，步长(s),净距离(D)有如下关系：\\( N = (D/s)^2 \\)</p>\n<hr>\n<h2 id=\"自动转换\"><a href=\"#自动转换\" class=\"headerlink\" title=\"自动转换\"></a>自动转换</h2><p>自动转换是通过类的构造函数作为自动转换的函数，但构造函数必须是<strong>一个参数的构造函数</strong>或者<strong>其他参数提供默认值</strong>。</p>\n<ol>\n<li>关键字<code>explicit</code>可以关闭自动转换的特性，只能显示强制转换。</li>\n</ol>\n<hr>\n<h2 id=\"转换函数\"><a href=\"#转换函数\" class=\"headerlink\" title=\"转换函数\"></a>转换函数</h2><p>转换函数是自动转换相反功能的转换，将类对象转化为基本数据类型。方式应该如基本数据类型的强制类型转换<code>int()</code>,<code>double()</code>。只不过作为类的方法调用，没有返回值，没有参数。函数原型：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">B::operator double();</span><br></pre></td></tr></table></figure>\n\n<p>虽然没有返回类型，但其也会返回所需要的值。</p>\n<ol>\n<li>关键字在C++11中也可以用于转换函数，关闭自动转换特性；</li>\n<li>也可以用非转换函数代替转换函数：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int B::B2int();</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<hr>\n<h2 id=\"转换函数和友元函数\"><a href=\"#转换函数和友元函数\" class=\"headerlink\" title=\"转换函数和友元函数\"></a>转换函数和友元函数</h2><p>考虑<code>b+5</code>与<code>5+b</code>应该有相同的值(返回一个B类实例)，都要使用友元函数</p>\n<ol>\n<li>通过赋值运算符重载<code>B operate+(int)</code>匹配1式，通过友元函数<code>friend B operate+(int,B);</code>匹配2式。</li>\n<li>通过<code>B(int)</code>构造函数转化基本数据类型，友元函数<code>friend B operate+(B,B);</code>来匹配1和2式。<ul>\n<li>第一种方法程序简短，但每次调用构造函数，增加时间内存开销；</li>\n<li>第二种方法运行速度快，但程序工作量大。</li>\n</ul>\n</li>\n<li>如果经常使用这种类型相加，为了时间和内存，应该重载加法;如果偶尔使用，为了简单应该依赖自动转换。</li>\n</ol>\n","categories":["C++的类"],"tags":["C++"]},{"title":"使用栈-持续更新","url":"https://applefishsky009.github.io/2016/05/23/使用栈-持续更新/","content":"<p>在自己使用栈的时候，特别是对数组，有一个容易犯的错误，就是push数值，其实除非情况特别简单(邻近匹配，即便这样也不推荐，如第一个例子),这样使用栈是不可取的，栈是具有记忆功能的数据结构，我们需要记录的是<font color=\"red\">如何回到</font>我们记忆的路径，而不是我们记忆了什么东西。</p>\n<hr>\n<h2 id=\"数组，字符串的栈\"><a href=\"#数组，字符串的栈\" class=\"headerlink\" title=\"数组，字符串的栈\"></a>数组，字符串的栈</h2><ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/20%20-%20Valid%20Parentheses/20%20-%20Valid%20Parentheses.cpp\" target=\"_blank\" rel=\"noopener\">邻近括号匹配</a></li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/32%20-%20Longest%20Valid%，20Parentheses/32%20-%20Longest%20Valid%20Parentheses.cpp\" target=\"_blank\" rel=\"noopener\">非临近括号匹配</a>，注意匹配点的更新标记了不临近的匹配。</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/84%20-%20Largest%20Rectangle%20in%20Histogram/84%20-%20Largest%20Rectangle%20in%20Histogram.cpp\" target=\"_blank\" rel=\"noopener\">直方图的计算</a>，如<a href=\"http://www.cnblogs.com/lichen782/p/leetcode_Largest_Rectangle_in_Histogram.html\" target=\"_blank\" rel=\"noopener\">这里的解释</a>，稍微有点错误，正确如下：<ul>\n<li>栈为空，之前所有元素大于当前元素，宽度为i</li>\n<li>栈不空，宽度 = i-temp的位置(因为弹出了，所以temp = s.top()+1)</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/150%20-%20Evaluate%20Reverse%20Polish%20Notation/150%20-%20Evaluate%20Reverse%20Polish%20Notation.cpp\" target=\"_blank\" rel=\"noopener\">Evaluate Reverse Polish Notation</a><ul>\n<li>遇到值入栈，操作符出栈；</li>\n<li><code>stringtoint:stoi()</code>;</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/107%20-%20Binary%20Tree%20Level%20Order%20Traversal%20II/107%20-%20Binary%20Tree%20Level%20Order%20Traversal%20II.cpp\" target=\"_blank\" rel=\"noopener\">Binary Tree Level Order Traversal II</a><ul>\n<li>头插用insert()，尾插用push_back();</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"指针-主要是树-的栈\"><a href=\"#指针-主要是树-的栈\" class=\"headerlink\" title=\"指针(主要是树)的栈\"></a>指针(主要是树)的栈</h2><ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/144%20-%20Binary%20Tree%20Preorder%20Traversal/144%20-%20Binary%20Tree%20Preorder%20Traversal.cpp\" target=\"_blank\" rel=\"noopener\">前序遍历</a></li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/94%20-%20Binary%20Tree%20Inorder%20Traversal/94%20-%20Binary%20Tree%20Inorder%20Traversal.cpp\" target=\"_blank\" rel=\"noopener\">中序遍历</a></li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/145%20-%20Binary%20Tree%20Postorder%20Traversal/145%20-%20Binary%20Tree%20Postorder%20Traversal.cpp\" target=\"_blank\" rel=\"noopener\">后序遍历</a></li>\n</ol>\n<p>基本来讲，树的栈遍历都是用一个while以及嵌套在内的一个while与一个if实现的(只有后序可以例外，一个while,以及嵌套的if-else实现)。</p>\n","categories":["数据结构与算法"],"tags":["C++"]},{"title":"数字输入与atoi函数","url":"https://applefishsky009.github.io/2016/05/22/数字输入与atoi函数/","content":"<p>这篇博客来源于编程中的数字输入检查，最终选择<code>cingetline()</code>加<code>atoi()</code>函数进行输入检查转换。</p>\n<hr>\n<h2 id=\"输入\"><a href=\"#输入\" class=\"headerlink\" title=\"输入\"></a>输入</h2><h3 id=\"cin的学问\"><a href=\"#cin的学问\" class=\"headerlink\" title=\"cin的学问\"></a>cin的学问</h3><p>首先分析<code>cin</code>,<code>cin.get()</code>,<code>cin.getline()</code>:</p>\n<ol>\n<li><code>cin&gt;&gt;</code>会忽略<strong>有效字符前的</strong>空格，换行符，制表符(开始有效输入之后非法就退出了)；</li>\n<li><code>cin.get()</code>读取每一个字符；</li>\n<li><code>cin.getline()</code>读取一行到字符串中，并把<code>\\n</code>替换为<code>\\0</code>存储。</li>\n</ol>\n<p>测试中发现更多的问题：</p>\n<ol>\n<li>cin.getline(字符指针(char*),字符个数N(int),结束符(char));其只读取N-1个字符，因为最后一个字符要补<code>\\0</code>,如果<font color=\"red\">输入超过N-1</font>,会将状态位设置：<code>ios_base::failbit</code>(表示轻微错误，可以挽回。查看<code>cin.getline()</code>源码很明显)，注意剩下的字符依然在输入队列中。</li>\n<li><code>cin.getline()</code>超过N-1输入状态位设置：<code>ios_base::failbit</code>(可修复的)，这时候不能使<code>cin&lt;&lt;</code>和<code>cin.get()</code>和<code>cin.getline()</code>，此时输入队列有值。应该用<code>cin.clear()</code>设置状态位<code>ios_base::goodbit</code>才能继续读取。</li>\n<li><a href=\"https://www.zhihu.com/question/40160488\" target=\"_blank\" rel=\"noopener\">cin.sync()</a>亲自测试<code>cin.sync()</code>并不是如网上所说的清空缓冲区(相信英语是对的…),<code>cin.ignore()</code>才是。</li>\n</ol>\n<p>在编写主界面时，经常会碰到如下语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int index = 0;</span><br><span class=\"line\">switch(index)&#123;</span><br><span class=\"line\">\tcase 1:</span><br><span class=\"line\">\tcase 2:</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\tdefault：</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述语句没有对<code>index</code>变量进行输入检查，显然不安全，那么如何进行输入检查？</p>\n<h3 id=\"一般的错误处理机制\"><a href=\"#一般的错误处理机制\" class=\"headerlink\" title=\"一般的错误处理机制\"></a>一般的错误处理机制</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int index;</span><br><span class=\"line\">while (!cin&lt;&lt;idex) &#123;</span><br><span class=\"line\">\tcin.clear();</span><br><span class=\"line\">\twhile(cin.get()!=&apos;\\n&apos;)</span><br><span class=\"line\">\t\tcontinue;</span><br><span class=\"line\">\tcout&lt;&lt;&quot;请再次输入&quot;&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里会解决错误输入的问题,但是有一个新的问题，如输入<code>5a</code>，<code>cin&lt;&lt;</code>只会让<code>index=5</code>，<code>a</code>留在输入队列中，会影响下一次的输入。</p>\n<h3 id=\"atoi-引发的思考\"><a href=\"#atoi-引发的思考\" class=\"headerlink\" title=\"atoi()引发的思考\"></a>atoi()引发的思考</h3><p>原型：<code>int atoi(const char *nptr);</code>;<br>头文件：<code>#include &lt;cstdlib&gt;</code>;<br>[LeetCode][1]<br>[1]:<a href=\"https://github.com/applefishsky009/LeetCode/blob/master/8%20-%20String%20to%20Integer%20(atoi)/8%20-%20String%20to%20Integer%20(atoi).cpp\" target=\"_blank\" rel=\"noopener\">https://github.com/applefishsky009/LeetCode/blob/master/8%20-%20String%20to%20Integer%20(atoi)/8%20-%20String%20to%20Integer%20(atoi).cpp</a><br>这里有一个非常重要的概念，不管是数字输入还是字符串转数字，都是<strong>遇到有效输入开始读取，直到碰到无效输入退出</strong><br>也就是说其实<code>cin&lt;&lt;</code>就是对输入缓存进行了一个atoi()。区别就是在<code>cin&lt;&lt;</code>退出之后同行中的非法输入(如果有)还是留在输入队列中，影响后续读入。<br>因此可以使用<code>cingetline()</code>加<code>atoi()</code>函数进行输入检查转换是安全的。代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> s1[<span class=\"number\">20</span>];\t<span class=\"comment\">//注意分配空间和,很久没用char[]，</span></span><br><span class=\"line\"><span class=\"built_in\">cin</span>.getline(s1,<span class=\"number\">20</span>);</span><br><span class=\"line\">k = atoi(s1);</span><br></pre></td></tr></table></figure>\n\n<p>之后大于19的部分可以正常用<code>getchar()</code>读取，<code>clear()</code>之后可以用cin方法读取，但是之前的输入依然在队列中，如果不想要之前的部分，要使用<code>ignore()</code>方法。</p>\n","categories":["C++基础"],"tags":["C++"]},{"title":"二元运算符重载与友元函数","url":"https://applefishsky009.github.io/2016/05/21/二元运算符重载与友元函数/","content":"<p>一般来说，在基础知识的介绍中不会提供代码，无论哪一本语法书中都会有大篇幅的代码和例子，而博客只是用作总结提纲复习之用，没有必要提供代码(STL等代码分析除外)，如果需要细致的分析，建议查看《C++ primer plus》和《C++ Primer》</p>\n<hr>\n<h2 id=\"OOP特性的分析\"><a href=\"#OOP特性的分析\" class=\"headerlink\" title=\"OOP特性的分析\"></a>OOP特性的分析</h2><p>首先分析OOP特性：</p>\n<ol>\n<li>抽象：指抽象接口的类设计；</li>\n<li>封装和数据隐藏：通过访问控制实现封装，数据隐藏是封装的一种<ul>\n<li>数据隐藏(数据放在类的私有部分)</li>\n<li>私有成员函数(实现细节私有化)</li>\n<li>类函数定义和声明放在不同的文件中(类定义封装)</li>\n</ul>\n</li>\n<li>多态(一种消息对不同对象有多个动作)：通过重载(静态多态)和vtbl(虚函数表，动态多态)实现<ul>\n<li>vtbl</li>\n<li>运算符重载(成员函数和友元函数)</li>\n<li>函数重载</li>\n</ul>\n</li>\n<li>继承(用于代码复用)：is-a关系，公有继承(常用，派生类可以使用基类方法)，保护继承，私有继承。</li>\n<li>代码可重用性：库，类库，类继承。</li>\n</ol>\n<hr>\n<h2 id=\"运算符重载\"><a href=\"#运算符重载\" class=\"headerlink\" title=\"运算符重载\"></a>运算符重载</h2><h3 id=\"规则\"><a href=\"#规则\" class=\"headerlink\" title=\"规则\"></a>规则</h3><p>先上接口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">operator+();</span><br><span class=\"line\">operator*();</span><br><span class=\"line\">operator[]();</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>注意在函数之前有返回类型和类的作用域声明。运算符重载有一定的限制：</p>\n<ol>\n<li>重载后的运算符必须至少有一个操作数是用户定义的类型(不然会引发已知类型的运算符冲突)；</li>\n<li>使用运算符不能违反运算符原来的句法规则(操作数数量和优先级不能改变，编译器无法解释)</li>\n<li>不能创建新的运算符，还有一些运算符不能重载(查看可重载运算符列表)</li>\n<li><code>=,(),[],-&gt;</code>只能通过成员函数重载。</li>\n</ol>\n<p><strong>一般而言(下面的问题2的解决方案中就有例外)，单目运算符最好重载为类的成员函数，双目运算符最好重载为类的友元函数。</strong></p>\n<h3 id=\"疑问\"><a href=\"#疑问\" class=\"headerlink\" title=\"疑问\"></a>疑问</h3><p>在运算符传递的过程中，运算符左侧的对象是调用对象，右侧的对象是传递的对象。于是就会产生两个问题：</p>\n<ol>\n<li>基本四则运算(<code>+，-，*，/</code>)的交换律怎么满足?(如<code>a = b*2</code>可以匹配，但<code>a = 2*b</code>无法匹配)</li>\n<li>如何对自定义的类使用<code>ostream</code>对象(<code>&lt;&lt;</code>如何重载)?(<code>a&lt;&lt;cout</code>太过奇怪)</li>\n</ol>\n<hr>\n<h2 id=\"友元函数\"><a href=\"#友元函数\" class=\"headerlink\" title=\"友元函数\"></a>友元函数</h2><p>先回答上面的问题,引入友元函数来解决,简单解释：</p>\n<h3 id=\"什么是友元\"><a href=\"#什么是友元\" class=\"headerlink\" title=\"什么是友元\"></a>什么是友元</h3><p>特性：访问权限与成员函数相同的非成员函数;<br>创建：</p>\n<ol>\n<li>在类声明中使用<code>friend</code>关键字；</li>\n<li>在类定义中不要使用<code>friend</code>和类限定符(因为不是成员函数);</li>\n</ol>\n<h3 id=\"如何解决问题\"><a href=\"#如何解决问题\" class=\"headerlink\" title=\"如何解决问题\"></a>如何解决问题</h3><p>问题的答案：</p>\n<ol>\n<li>问题1中的不同类型运算使用 成员函数重载+友元函数(不同类型)重载 做到分别匹配；或者使用自动转换(特定类型的构造函数)+友元函数(相同类型，都是自定义的)来实现。前者运行速度快但程序长，后者程序简短但时间内存开销大。</li>\n<li>非成员函数重载<code>&lt;&lt;</code>，并返回<code>ostream&amp;</code>来保证连续输出(必须返回引用，因为<code>ostream</code>没有共有的复制构造函数)。<code>ostream&amp; operator&lt;&lt;(ostream &amp;os,const A &amp;a)</code>。</li>\n</ol>\n<p>使用友元函数要注意规避二义性错误。自动转换和转换函数会在下一篇中分析。</p>\n","categories":["C++的类"],"tags":["C++"]},{"title":"链表的精髓-持续更新","url":"https://applefishsky009.github.io/2016/05/21/链表的精髓/","content":"<p>术有穷而道无穷。一些简单的方法在实践过程中往往知易行难。在这里我会持续记录一些链表操作中值得注意的事情以及一些小小的有趣的事情。希望大家可以会心一笑。在链表操作中，发现最重要的一个概念就是<font color=\"red\">前驱</font>(后继同样重要，但是链表的后继太容易得到)。对于链表的调整，包括插入，删除，转置等操作，都涉及到链表结构的重组，在重组中前驱就是串联各个节点的线。</p>\n<hr>\n<h2 id=\"前驱和后继\"><a href=\"#前驱和后继\" class=\"headerlink\" title=\"前驱和后继\"></a>前驱和后继</h2><p>链表自带后继<code>-&gt;next</code>,最后一个节点的后继通常为<code>nullptr</code>，可以看作超尾。而编程过程中往往喜欢创建一个头节点，这是由于链表头是最特殊的一个节点，他没有前驱，不能写入循环中，往往会有<code>if else</code>之类的语句单独处理头节点(深受其害)。于是产生了这种方法，给链表建立一个虚拟的头节点，一切问题引刃而解。</p>\n<h3 id=\"逆置部分链表\"><a href=\"#逆置部分链表\" class=\"headerlink\" title=\"逆置部分链表\"></a>逆置部分链表</h3><ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/92%20-%20Reverse%20Linked%20List%20II/92%20-%20Reverse%20Linked%20List%20II.cpp\" target=\"_blank\" rel=\"noopener\">Reverse Linked List II</a><ul>\n<li>头指针L永远是前驱,q是当前要处理的节点，p是pre指针，指向最前的节点(<code>q = p;p = p-&gt;next;</code>)。而转置的核心代码只有两行(<code>q-&gt;next = l;l = q;</code>)。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/25%20-%20Reverse%20Nodes%20in%20k-Group/25%20-%20Reverse%20Nodes%20in%20k-Group.cpp\" target=\"_blank\" rel=\"noopener\">Reverse Nodes in k-Group</a></li>\n</ol>\n<h3 id=\"删除当前节点\"><a href=\"#删除当前节点\" class=\"headerlink\" title=\"删除当前节点\"></a>删除当前节点</h3><ol>\n<li><a href=\"https://github.com/applefishsky009/BeautyOfProgramming/blob/master/3.4%20-%20%E4%BB%8E%E6%97%A0%E5%A4%B4%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9/3.4.cpp\" target=\"_blank\" rel=\"noopener\">从无头单链表中删除节点</a><ul>\n<li>这个没见过很难想到，见过绝对就会了……</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"分割链表\"><a href=\"#分割链表\" class=\"headerlink\" title=\"分割链表\"></a>分割链表</h3><ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/86%20-%20Partition%20List/86%20-%20Partition%20List.cpp\" target=\"_blank\" rel=\"noopener\">Partition List</a><ul>\n<li>只要明白前驱的重要性，很容易实现，对与一个子链表，基本操作需要一个<code>const</code>指针来保留头指针，另外需要一个非<code>const</code>指针用于循环。</li>\n<li>注意链表中处理尾指针，否则很容易形成循环链表。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"链表的插入排序\"><a href=\"#链表的插入排序\" class=\"headerlink\" title=\"链表的插入排序\"></a>链表的插入排序</h3><ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/147%20-%20Insertion%20Sort%20List/147%20-%20Insertion%20Sort%20List.cpp\" target=\"_blank\" rel=\"noopener\">Insertion Sort List</a><ul>\n<li>对链表排序，头节点需要头指针。</li>\n<li>找到插入位置要使用头指针插入，不然无法交换链表指向。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"链表删除重复元素\"><a href=\"#链表删除重复元素\" class=\"headerlink\" title=\"链表删除重复元素\"></a>链表删除重复元素</h3><ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/83%20-%20Remove%20Duplicates%20from%20Sorted%20List/83%20-%20Remove%20Duplicates%20from%20Sorted%20List.cpp\" target=\"_blank\" rel=\"noopener\">Remove Duplicates from Sorted List</a><ul>\n<li>这不需要初始化头指针，因为无论如何该操作也用不到第一个节点上。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/82%20-%20Remove%20Duplicates%20from%20Sorted%20List%20II/82%20-%20Remove%20Duplicates%20from%20Sorted%20List%20II.cpp\" target=\"_blank\" rel=\"noopener\">Remove Duplicates from Sorted List II</a><ul>\n<li>第一个节点可能被操作，因为需要头节点；</li>\n<li>谨慎使用flag，仔细考虑每一步下的状态转化。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"链表的归并排序\"><a href=\"#链表的归并排序\" class=\"headerlink\" title=\"链表的归并排序\"></a>链表的归并排序</h3><ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/148%20-%20Sort%20List/148%20-%20Sort%20List.cpp\" target=\"_blank\" rel=\"noopener\">Sort List</a></li>\n</ol>\n<h3 id=\"找链表倒数第k个元素\"><a href=\"#找链表倒数第k个元素\" class=\"headerlink\" title=\"找链表倒数第k个元素\"></a>找链表倒数第k个元素</h3><ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/61%20-%20Rotate%20List/61%20-%20Rotate%20List.cpp\" target=\"_blank\" rel=\"noopener\">Rotate List</a><ul>\n<li>将单链表作为循环链表，从头指针走len-k步；</li>\n<li>用两个指针计数，分别从头指针出发(第一个指针走k步第二个指针出发，当第一个指针走到超尾，第二个指针即为所求指针)。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"交换链表相邻元素\"><a href=\"#交换链表相邻元素\" class=\"headerlink\" title=\"交换链表相邻元素\"></a>交换链表相邻元素</h3><ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/24%20-%20Swap%20Nodes%20in%20Pairs/24%20-%20Swap%20Nodes%20in%20Pairs.cpp\" target=\"_blank\" rel=\"noopener\">Swap Nodes in Pairs</a></li>\n</ol>\n<h3 id=\"复制带随机指针的链表\"><a href=\"#复制带随机指针的链表\" class=\"headerlink\" title=\"复制带随机指针的链表\"></a>复制带随机指针的链表</h3><ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/138%20-%20Copy%20List%20with%20Random%20Pointer/138%20-%20Copy%20List%20with%20Random%20Pointer.cpp\" target=\"_blank\" rel=\"noopener\">Copy List with Random Pointer</a></li>\n</ol>\n<h3 id=\"第k个序列\"><a href=\"#第k个序列\" class=\"headerlink\" title=\"第k个序列\"></a>第k个序列</h3><ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/60%20-%20Permutation%20Sequence/60%20-%20Permutation%20Sequence.cpp\" target=\"_blank\" rel=\"noopener\">Permutation Sequence</a><ul>\n<li>找第k个<code>Permutation</code>，时间复杂度O(n)，额外空间复杂度O(1)；</li>\n<li>使用单向链表模拟哈希表存储未使用的值，数组模拟哈希表缓存阶乘。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"折叠插入链表\"><a href=\"#折叠插入链表\" class=\"headerlink\" title=\"折叠插入链表\"></a>折叠插入链表</h3><ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/143%20-%20Reorder%20List/143%20-%20Reorder%20List.cpp\" target=\"_blank\" rel=\"noopener\">Reorder List</a><ul>\n<li>就地算法三步：分拆；逆序；合并；</li>\n<li>非就地算法两步：栈存指针；插入；</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"STL中的list\"><a href=\"#STL中的list\" class=\"headerlink\" title=\"STL中的list\"></a>STL中的list</h2><h3 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h3><p><code>list</code>标准模板库表示双向链表，每个结点的前驱易得，插入删除比较方便。</p>\n<h4 id=\"splice-方法\"><a href=\"#splice-方法\" class=\"headerlink\" title=\"splice()方法\"></a>splice()方法</h4><p>这是一个不同于其他容器的方法，用于链表的拼接,接口以及用法见<a href=\"http://www.cplusplus.com/reference/list/list/splice/\" target=\"_blank\" rel=\"noopener\">std<code>::</code>list<code>::</code>splice</a></p>\n<ol>\n<li><a href=\"https://leetcode.com/problems/lru-cache/\" target=\"_blank\" rel=\"noopener\">LeetCode - 146. LRU Cache</a> - 解答：<a href>GitHub - 待上传</a>;<ul>\n<li>经典LRU实现；</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"forward-list\"><a href=\"#forward-list\" class=\"headerlink\" title=\"forward_list\"></a>forward_list</h3><p>C++11新增的<code>forward_list</code>标准模板库表示单向链表，</p>\n<h3 id=\"迭代器有效性\"><a href=\"#迭代器有效性\" class=\"headerlink\" title=\"迭代器有效性\"></a>迭代器有效性</h3><p><a href=\"http://www.cplusplus.com/reference/list/list/splice/\" target=\"_blank\" rel=\"noopener\">list-splice</a>，简单来说，链表在插入或者删除元素时，迭代器所指向的元素不变，这是因为在链表中插入或者删除元素不会移动已有的元素，而只是修改链接信息。</p>\n","categories":["数据结构与算法"],"tags":["Algorithm"]},{"title":"Binary Search的陷阱","url":"https://applefishsky009.github.io/2016/05/20/Binary-Search的陷阱/","content":"<p>先上<a href=\"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95\" target=\"_blank\" rel=\"noopener\">二分搜索算法wiki</a>，再上<a href=\"http://www.cppblog.com/converse/archive/2009/09/21/96893.aspx\" target=\"_blank\" rel=\"noopener\">二分查找写正确的方法</a>。简单说说二分搜索：</p>\n<p>主要用于<font color=\"red\">有序数组</font>的遍历，时间复杂度O(log(n))，比之顺序遍历的时间复杂度O(n)更优，空间复杂度为O(1)。如用在插入排序中。</p>\n<hr>\n<h2 id=\"三点原则\"><a href=\"#三点原则\" class=\"headerlink\" title=\"三点原则\"></a>三点原则</h2><ol>\n<li>为了防止溢出折半时应该这么写<code>mid = start + (end - start) / 2;</code>；</li>\n<li>因为大部分情况不是大于就是小于，因此一般在最后检测相等(如下例，检测条件过于复杂，因此放在开始检测相等少写一个检测条件，写全条件容易出错，一般用于debug)。</li>\n<li>传入的一定是左闭右闭区间，因此递归入口为<code>low &lt;= high</code>，由原则2可知递归出口判断写在入口之后。</li>\n<li><font color=\"red\">2016.09.13修改</font>：受到STL启发，传入头和超尾，即左闭右开区间更合适。</li>\n</ol>\n<hr>\n<h2 id=\"陷阱\"><a href=\"#陷阱\" class=\"headerlink\" title=\"陷阱\"></a>陷阱</h2><p>二分法，顾名思义，就是将区间一分为二传入递归函数，但是注意区间有开闭之分，因此在过程中一定要注意，</p>\n<ol>\n<li>不建议传入左开右开区间，增加判断次数，但是这样写极为简单，不得已可以使用，如例子中的<code>Solution</code>;</li>\n<li>传入左闭右闭区间，递归入口一定是<code>low &lt;= high</code>,不能少等号;</li>\n<li>如例子中的<code>Solution1</code>所警示，在另外有区间判断的条件时注意<code>int</code>向下取整的特性，可能会有<code>low == mid;</code>需要特殊分析。</li>\n</ol>\n<hr>\n<h2 id=\"递归二分\"><a href=\"#递归二分\" class=\"headerlink\" title=\"递归二分\"></a>递归二分</h2><ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/33%20-%20Search%20in%20Rotated%20Sorted%20Array/33%20-%20Search%20in%20Rotated%20Sorted%20Array.cpp\" target=\"_blank\" rel=\"noopener\">Search in Rotated Sorted Array</a>,<a href=\"https://github.com/applefishsky009/LeetCode/blob/master/33%20-%20Search%20in%20Rotated%20Sorted%20Array/33%20-%20Search%20in%20Rotated%20Sorted%20Array(2).cpp\" target=\"_blank\" rel=\"noopener\">Search in Rotated Sorted Array(2)</a></li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/81%20-%20Search%20in%20Rotated%20Sorted%20Array%20II/81%20-%20Search%20in%20Rotated%20Sorted%20Array%20II.cpp\" target=\"_blank\" rel=\"noopener\">Search in Rotated Sorted Array II</a></li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/34%20-%20Search%20for%20a%20Range/34%20-%20Search%20for%20a%20Range.cpp\" target=\"_blank\" rel=\"noopener\">Search for a Range</a></li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/35%20-%20Search%20Insert%20Position/Search%20Insert%20Position.cpp\" target=\"_blank\" rel=\"noopener\">Search Insert Position</a></li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/50%20-%20Pow(x%2C%20n)/50%20-%20Pow(x%2C%20n)%20.cpp\" target=\"_blank\" rel=\"noopener\">Pow(x, n)</a></li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/69%20-%20Sqrt(x)/69%20-%20Sqrt(float%20x).cpp\" target=\"_blank\" rel=\"noopener\">Sqrt(float x)</a></li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/69%20-%20Sqrt(x)/69%20-%20Sqrt(int%20x).cpp\" target=\"_blank\" rel=\"noopener\">Sqrt(int x)</a></li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/74%20-%20Search%20a%202D%20Matrix/74%20-%20Search%20a%202D%20Matrix.cpp\" target=\"_blank\" rel=\"noopener\">Search a 2D Matrix</a></li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/4%20-%20Median%20of%20Two%20Sorted%20Arrays/4%20-%20Median%20of%20Two%20Sorted%20Arrays.cpp\" target=\"_blank\" rel=\"noopener\">Median of Two Sorted Arrays</a><ul>\n<li>大小数组个数和大于k，保证两数组左侧个数和是k;</li>\n<li>保证二分搜索时小数组不越界，这样小数组删完了可以直接取大数组;</li>\n<li>每次递归删掉二分的一般继续找，直到找到为止。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/29%20-%20Divide%20Two%20Integers/29%20-%20Divide%20Two%20Integers.cpp\" target=\"_blank\" rel=\"noopener\">Divide Two Integers</a><ul>\n<li>倍数逐差法来优化普通的逐差，不知道编译器是否是这么完成的除法和余操作?</li>\n<li>注意特殊边界的处理，特别是数据不对称性导致的非法值。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"使用while的二分查找\"><a href=\"#使用while的二分查找\" class=\"headerlink\" title=\"使用while的二分查找\"></a>使用while的二分查找</h2><p>不使用递归，使用while，传入左闭右闭(有人会写传入左闭右开)</p>\n<ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/74%20-%20Search%20a%202D%20Matrix/74%20-%20Search%20a%202D%20Matrix.cpp\" target=\"_blank\" rel=\"noopener\">Search a 2D Matrix</a></li>\n</ol>\n","categories":["数据结构与算法"],"tags":["Algorithm"]},{"title":"模九同余与各位数字之和","url":"https://applefishsky009.github.io/2016/05/18/模九同余与各位数字之和/","content":"<p>$$ a\\equiv b\\quad(mod\\ n) $$<br>此式即\\( a \\)与\\( b \\)同余于\\( n \\)；简称\\( a \\)与\\( b \\)模\\( n \\)同余。<br>同余运算见<a href=\"https://en.wikipedia.org/wiki/Modular_arithmetic\" target=\"_blank\" rel=\"noopener\">维基百科</a></p>\n<hr>\n<h2 id=\"模九同余\"><a href=\"#模九同余\" class=\"headerlink\" title=\"模九同余\"></a>模九同余</h2><p>结论：任何一个整数模9同余于它的各数位上数字之和。<br>题目：设自然数\\( N=a[n]a[n-1]\\ldots a[0] \\)，其中\\( a[0],a[1],\\ldots,a[n] \\)分别是个位、十位、…上的数字，再设\\( M=a[0]+a[1]+\\ldots+a[n] \\)<br>求证：\\( N\\equiv M\\quad(mod\\ 9) \\)<br>证明：</p>\n<p>$$ \\because N=a[n]a[n-1]…a[0]=a[n]\\times10^n+a[n-1]\\times10^{n-1}+\\cdots+a[1]\\times10+a[0] $$<br>又<br>$$ \\because 1\\equiv 1\\quad(mod\\ 9) $$<br>$$ 10\\equiv 1\\quad(mod\\ 9) $$<br>$$ 10^2\\equiv 1\\quad(mod\\ 9) $$<br>$$ \\cdots $$<br>$$ 10^n\\equiv 1\\quad(mod\\ 9) $$</p>\n<p>上面这些同余式两边分别同乘以\\( a[0],a[1],a[2],\\ldots,a[n] \\)<br>再相加得：</p>\n<p>$$ a[n]\\times10^n+a[n-1]\\times10^{n-1}+\\cdots+a[1]\\times10+a[0]\\equiv (a[0]+a[1]+…+a[n])\\quad(mod\\ 9) $$<br>即<br>$$ N\\equiv M\\quad(mod\\ 9) $$<br>得证。</p>\n<p>参考：<a href=\"http://www.cnblogs.com/Rinyo/archive/2012/12/20/2826755.html\" target=\"_blank\" rel=\"noopener\">找规律</a></p>\n<hr>\n<h2 id=\"LeetCode\"><a href=\"#LeetCode\" class=\"headerlink\" title=\"LeetCode\"></a><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/258%20-%20Add%20Digits/258%20-%20Add%20Digits.cpp\" target=\"_blank\" rel=\"noopener\">LeetCode</a></h2><hr>\n<h2 id=\"2012-2012\"><a href=\"#2012-2012\" class=\"headerlink\" title=\"\\( 2012^{2012} \\)\"></a>\\( 2012^{2012} \\)</h2><p>题目：记\\( 2012^{2012} \\)的各位数字之和为\\( A \\),\\( A \\)的各位数字之和是\\( B \\)，\\( B \\)的各位数字之和是\\( C \\)，求\\( C \\)的值。</p>\n<h3 id=\"2012-2012-的余数\"><a href=\"#2012-2012-的余数\" class=\"headerlink\" title=\"\\( 2012^{2012} \\)的余数\"></a>\\( 2012^{2012} \\)的余数</h3><p>$$ \\because 2012 \\equiv 5\\quad(mod\\ 9) $$<br>\\begin{equation}<br>\\begin{split}<br>\\therefore 2012^{2012} &amp; \\equiv 5^{2012}\\quad(mod\\ 9) \\\\<br>&amp; \\equiv 25^{1006}\\quad(mod\\ 9) \\\\<br>&amp; \\equiv (-2)^{1006}\\quad(mod\\ 9) \\\\<br>&amp; \\equiv 2^{1006}\\quad(mod\\ 9) \\\\<br>&amp; \\equiv 2\\times8^{335}\\quad(mod\\ 9) \\\\<br>&amp; \\equiv 2\\times(-1)^{335}\\quad(mod\\ 9) \\\\<br>&amp; \\equiv -2\\quad(mod\\ 9) \\\\<br>&amp; \\equiv 7<br>\\end{split}<br>\\end{equation}</p>\n<h3 id=\"C的最大值\"><a href=\"#C的最大值\" class=\"headerlink\" title=\"C的最大值\"></a>C的最大值</h3><p>$$ \\because 2012^{2012}&lt;10000^{2012}-1 $$<br>$$ \\Rightarrow A&lt;2012\\times4\\times9=72504 $$<br>$$ \\Rightarrow B&lt;6+4\\times9=42 $$<br>$$ \\Rightarrow C&lt;3+9=12 $$<br>$$ \\therefore C=7 $$</p>\n<p>思路：<strong>算出最大位数</strong>，每一位给9算出\\( A,B,C \\)的最大值。</p>\n","categories":["Math"],"tags":["Math"]},{"title":"伯努利级数","url":"https://applefishsky009.github.io/2016/05/18/伯努利级数/","content":"<p>先来彩蛋，在<a href=\"http://www.wolframalpha.com/\" target=\"_blank\" rel=\"noopener\">wolframalpha</a>使用Latex格式输入数学公式，可以快速得到结果。</p>\n<p>考虑以下四种无穷级数：<br>$$ \\sum_n\\frac{1}{n^2\\pm\\omega^2}\\qquad(1) $$</p>\n<p>$$ \\prod_n(1\\pm\\frac{\\omega^2}{n^2})\\qquad(2) $$</p>\n<p>在式\\( (1) \\)中当\\( \\omega=0 \\)时，公式变为伯努利级数：<br>$$ \\sum_n\\frac{1}{n^2}\\qquad(3) $$</p>\n<p>式\\( (3) \\)中是一个非常有意思的题目，下面考虑来解决他，式\\( (1) \\)和式\\( (2) \\)并不会经常用到，具体解答见<a href=\"http://mp.weixin.qq.com/s?__biz=MzA5ODUxOTA5Mg==&mid=404226908&idx=1&sn=93aa43ffa9157af03ad82543493cfe51&scene=23&srcid=042515FZI3kzNY54U1YJaKv8#rd\" target=\"_blank\" rel=\"noopener\">算法与数学之美</a>的这篇文章。<a href=\"https://zh.wikipedia.org/wiki/%E5%B7%B4%E5%A1%9E%E5%B0%94%E9%97%AE%E9%A2%98\" target=\"_blank\" rel=\"noopener\">维基百科上的解答</a></p>\n<p>与式\\( (3) \\)相似的一个题目:<br>$$ \\sum_nn^2 = \\frac{1}{6}n(n+1)(2n+1)\\qquad(4)$$<br>这个题目可以用数学归纳法简单求得。</p>\n<hr>\n<h2 id=\"伯努利级数\"><a href=\"#伯努利级数\" class=\"headerlink\" title=\"伯努利级数\"></a>伯努利级数</h2><p>$$ \\sum_n\\frac{1}{n^2}=1+\\frac{1}{4}+\\frac{1}{9}+\\frac{1}{16}+\\cdots\\qquad(5) $$</p>\n<h3 id=\"泰勒展开\"><a href=\"#泰勒展开\" class=\"headerlink\" title=\"泰勒展开\"></a>泰勒展开</h3><p>首先，我们考虑式\\( \\frac{sin\\sqrt{x}}{\\sqrt{x}}=0 \\)的根为\\( n^2\\pi^2,n=1,2,3,\\ldots \\)<br>左侧泰勒展开式为<br>$$ \\frac{sin\\sqrt{x}}{\\sqrt{x}}=1-\\frac{x}{6}+\\frac{x^2}{120}-\\frac{x^3}{5040}+\\cdots\\qquad(6) $$</p>\n<h3 id=\"韦达定理\"><a href=\"#韦达定理\" class=\"headerlink\" title=\"韦达定理\"></a>韦达定理</h3><p>其次，考虑一元n次方程的韦达定理：<br>$$ 1+a_1x+a_2x^2+\\cdots+a_nx^n=0\\qquad(7) $$</p>\n<p>假设他有\\( n \\)个非零根\\( x_1,x_2,\\ldots,x_n \\),将它转化为关于\\( \\frac{1}{x} \\)的方程：<br>$$ (\\frac{1}{x})^n+a_1(\\frac{1}{x})^{n-1}+\\cdots+a_n=0\\qquad(8) $$<br>对应根变成\\( 1/x_1,1/x_2,\\ldots,1/x_n \\)，由韦达定理得到：<br>$$ \\frac{1}{x_1}+\\frac{1}{x_2}+\\cdots+\\frac{1}{x_n}=-a_1\\qquad(9) $$</p>\n<h3 id=\"欧拉的大胆推广\"><a href=\"#欧拉的大胆推广\" class=\"headerlink\" title=\"欧拉的大胆推广\"></a>欧拉的大胆推广</h3><p>将式\\( (9) \\)推广在式\\( (6) \\)为0的根中：</p>\n<p>$$ \\frac{1}{\\pi^2}+\\frac{1}{2^2\\pi^2}+\\frac{1}{3^2\\pi^2}+\\cdots=-a_1=\\frac{1}{6}\\qquad(10) $$<br>那么：<br>$$ 1+\\frac{1}{2^2}+\\frac{1}{3^2}+\\cdots=\\frac{\\pi^2}{6}\\qquad(11) $$</p>\n<p>如算法与数学之美中所说，其启发性创造性远远掩盖其不严格性。</p>\n<h3 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h3><p>如果直接在式\\( (7) \\)中使用韦达定理，得到<br>$$ -\\frac{a_{n-1}}{a_n}=\\pi^2\\sum_nn^2=\\frac{\\pi^2}{6}n(n+1)(2n+1)\\qquad(12) $$<br>但是这个只有在\\( n\\rightarrow\\infty \\)才是有意义的，例如不能取\\( n=3 \\)(一个特定数值)来使等式成立。就如式\\( (11) \\)中取级数前\\( n=3 \\)部分使之成立。因此对无穷级数的未知项用韦达定理是没有意义的。</p>\n","categories":["Math"],"tags":["Math"]},{"title":"牛顿迭代法","url":"https://applefishsky009.github.io/2016/05/17/牛顿迭代法/","content":"<p>牛顿迭代法是一种巧妙地(切线)逼近方法，它是一种在实数域和复数域上近似求解方程的方法。<a href=\"https://zh.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E6%B3%95\" target=\"_blank\" rel=\"noopener\">维基百科的介绍</a></p>\n<p>下面的图(来源于wiki)巧妙的解释了牛顿迭代法的过程：<br><img src=\"http://i.imgur.com/2y9UyHF.gif\" alt=\"牛顿迭代法\"></p>\n<p>公式如下：<br>$$ x_{n+1} = x_n-\\frac{f(x_n)}{f’(x_n)} $$</p>\n<p>Markdownpad2不支持Latex有点烦，使用atom编辑器和markdowm pas plus插件可以解决这个问题，在HEXO博客上部署数学公式需要给HEXO安装<a href=\"http://catx.me/2014/03/09/hexo-mathjax-plugin/\" target=\"_blank\" rel=\"noopener\">hexo-mathjax插件</a>,注意在本机中使用时不需要修改_config.yml配置文件，否则会生成错误。<br>参考：<a href=\"http://www.jeyzhang.com/how-to-insert-equations-in-markdown.html\" target=\"_blank\" rel=\"noopener\">MarkdownPad 2的MathJax插件</a></p>\n<hr>\n<h2 id=\"牛顿迭代法在开方中的应用\"><a href=\"#牛顿迭代法在开方中的应用\" class=\"headerlink\" title=\"牛顿迭代法在开方中的应用\"></a>牛顿迭代法在开方中的应用</h2><p>开方的迭代式：<br>$$ x_{k+1} = \\frac{1}{2}(x_k+\\frac{n}{x_k}) $$</p>\n<ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/69%20-%20Sqrt(x)/69%20-%20Sqrt(int%20x).cpp\" target=\"_blank\" rel=\"noopener\"><code>int</code>开方</a></li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/69%20-%20Sqrt(x)/69%20-%20Sqrt(int%20x).cpp\" target=\"_blank\" rel=\"noopener\"><code>float</code>开方</a></li>\n<li>Magic Number(只针对<code>float</code>，链接同2)</li>\n</ol>\n<ul>\n<li>在开方的计算中，二分查找和牛顿迭代法时间复杂度都是O(logn)，但是牛顿迭代法优于二分查找。</li>\n<li>基于牛顿迭代法的<code>float</code>开方中使用Magic Number，可以看到使用3次牛顿迭代法就可以得到较高的精确度(相同的迭代次数，要开放的数字越大，精度越低)，其原理与浮点数的存储相关，因此只用于浮点数。</li>\n<li>直观来看，开方(凹型曲线)时牛顿迭代法只从右侧逼近，二分查找从右侧左侧同时逼近,因此显然牛顿迭代法优于二分查找法，尤其对高阶的f(x),牛顿迭代法的逼近速度更快。</li>\n</ul>\n","categories":["Math"],"tags":["Math"]},{"title":"map容器简介","url":"https://applefishsky009.github.io/2016/05/16/map容器简介/","content":"<p>先上彩蛋：</p>\n<ol>\n<li><a href=\"http://www.cplusplus.com/\" target=\"_blank\" rel=\"noopener\">cplusplus</a></li>\n<li><a href=\"http://en.cppreference.com/w/\" target=\"_blank\" rel=\"noopener\">cppreference</a></li>\n<li><a href=\"http://stackoverflow.com/\" target=\"_blank\" rel=\"noopener\">stackoverflow</a><br><code>#include &lt;map&gt;</code>中定义了两个hash容器，<code>map</code>和<code>multimap</code>，他将键对象和值对象进行关联，值对象可以是新的<code>map</code>，因此可以形成多级映射。</li>\n</ol>\n<hr>\n<h2 id=\"multimap简介\"><a href=\"#multimap简介\" class=\"headerlink\" title=\"multimap简介\"></a>multimap简介</h2><p>容器属性：</p>\n<ol>\n<li>Associative:通过key而不是绝对位置来引用；</li>\n<li>Ordered:有序；</li>\n<li>Map:将key与mapped value映射，通过key访问mapped value；</li>\n<li>Multiple equivalent keys:这是一个一对多映射</li>\n<li>Allocator-aware:使用分配器<code>allocator</code>来动态存储。</li>\n</ol>\n<p>特征补充：</p>\n<ol>\n<li><font color=\"red\"><code>value_type:pair&lt;const key_type,mapped_type&gt;</code></font></li>\n<li>multimap多重映照容器:容器的数据结构采用红黑树进行管理；</li>\n<li>multimap特性以及用法与map完全相同，唯一的差别在于: 允许重复键值的元素插入容器(每一个都是用一个<strong>链表</strong>来链接的);</li>\n</ol>\n<hr>\n<h2 id=\"multimap使用\"><a href=\"#multimap使用\" class=\"headerlink\" title=\"multimap使用\"></a>multimap使用</h2><ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/126%20-%20Word%20Ladder%20II/126%20-%20Word%20Ladder%20II.cpp\" target=\"_blank\" rel=\"noopener\">Word Ladder II</a>；</li>\n</ol>\n<h3 id=\"insert\"><a href=\"#insert\" class=\"headerlink\" title=\"insert()\"></a>insert()</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">single <span class=\"title\">element</span> <span class=\"params\">(<span class=\"number\">1</span>)</span>\titerator <span class=\"title\">insert</span> <span class=\"params\">(<span class=\"keyword\">const</span> value_type&amp; val)</span></span>;</span><br><span class=\"line\"><span class=\"function\">with <span class=\"title\">hint</span> <span class=\"params\">(<span class=\"number\">2</span>)</span>\titerator <span class=\"title\">insert</span> <span class=\"params\">(const_iterator <span class=\"built_in\">position</span>, <span class=\"keyword\">const</span> value_type&amp; val)</span></span>;</span><br><span class=\"line\">range (<span class=\"number\">3</span>)\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span> <span class=\"params\">(InputIterator first, InputIterator last)</span></span>;</span><br><span class=\"line\"><span class=\"function\">initializer <span class=\"title\">list</span> <span class=\"params\">(<span class=\"number\">4</span>)</span>\t<span class=\"keyword\">void</span> <span class=\"title\">insert</span> <span class=\"params\">(<span class=\"built_in\">initializer_list</span>&lt;value_type&gt; il)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>有序插入</p>\n<h3 id=\"equal-range\"><a href=\"#equal-range\" class=\"headerlink\" title=\"equal_range()\"></a>equal_range()</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pair&lt;const_iterator,const_iterator&gt; equal_range (const key_type&amp; k) const;</span><br><span class=\"line\">pair&lt;iterator,iterator&gt;             equal_range (const key_type&amp; k);</span><br></pre></td></tr></table></figure>\n\n<p>寻找某个键值的所有对象，返回pair对象(两个指针,左闭右开,将右开的指针称为超尾)。如果没有找到，这两个指针都会指向超尾。</p>\n","categories":["STL"],"tags":["C++"]},{"title":"i++与++i的区别","url":"https://applefishsky009.github.io/2016/05/06/i++与++i的区别/","content":"<p>一直以来对<code>++i</code>与<code>i++</code>，知道前者效率更高，但是不知道为什么。有人说与寄存器有关，实际上寄存器都执行了一次加法，是一样的。看了<a href=\"http://falldog7.blogspot.jp/2007/10/programmer-i-i.html\" target=\"_blank\" rel=\"noopener\">这里的博客</a>才恍然大悟，原来是其实现的机制不同。</p>\n<p><code>++i</code>先加再用，其对i类型(假设为INT)的++运算符重载如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//++i</span><br><span class=\"line\">INT operator ++()&#123;</span><br><span class=\"line\">\tthis-&gt;_value++;</span><br><span class=\"line\">\treturn *this;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>i++</code>先用再加，创建临时变量保存原有值用来返回，后调用++i语句，重载如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//i++</span><br><span class=\"line\">INT operator ++(int t)&#123;</span><br><span class=\"line\">\tINT temp(_value);//!!! 必須create出一個temp的變數!!!</span><br><span class=\"line\">\tthis-&gt;_value++;</span><br><span class=\"line\">\treturn temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个函数中参数n是没有任何意义的，它的存在只是为了区分是前置形式还是后置形式。</p>\n<p>可以看到<code>i++</code>所必须付出的代价，就是多create出一个temp的变量，以及temp变量的的constructor()。</p>\n","categories":["C++基础"],"tags":["C++"]},{"title":"二叉树的递归遍历与栈遍历","url":"https://applefishsky009.github.io/2016/05/06/二叉树的递归遍历与栈遍历/","content":"<p>二叉树的遍历算法有三种，最简单的递归遍历，还有两种非递归遍历，分别是使用栈的遍历和Morris遍历。每一种遍历根据访问根节点的时机又分为前序，中序，后序三种。<br>二叉树节点的定义如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TreeNode</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> val;</span><br><span class=\"line\">\tTreeNode *left;</span><br><span class=\"line\">\tTreeNode *right;</span><br><span class=\"line\">\tTreeNode(<span class=\"keyword\">int</span> x) : val(x), left(<span class=\"literal\">nullptr</span>), right(<span class=\"literal\">nullptr</span>) &#123;&#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"二叉树的递归遍历\"><a href=\"#二叉树的递归遍历\" class=\"headerlink\" title=\"二叉树的递归遍历\"></a>二叉树的递归遍历</h2><p>没什么技巧，方式如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Traversal</span><span class=\"params\">(TreeNode* root,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;result)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!root)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">//result.push(root-&gt;val);\t//preorderTraversal</span></span><br><span class=\"line\">\t\tTraversal(root-&gt;left,result);</span><br><span class=\"line\">\t\t<span class=\"comment\">//result.push(root-&gt;val);\t//inorderTraversal</span></span><br><span class=\"line\">\t\tTraversal(root-&gt;right,result);</span><br><span class=\"line\">\t\t<span class=\"comment\">//result.push(root-&gt;val);\t//postorderTraversal</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"二叉树的栈遍历\"><a href=\"#二叉树的栈遍历\" class=\"headerlink\" title=\"二叉树的栈遍历\"></a>二叉树的栈遍历</h2><p>前序和中序可以用同一段代码来实现(用栈记忆所有左子树(while)，回溯一位(if)访问右子树)：<br><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/144%20-%20Binary%20Tree%20Preorder%20Traversal/144%20-%20Binary%20Tree%20Preorder%20Traversal.cpp\" target=\"_blank\" rel=\"noopener\">前序遍历</a><br><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/94%20-%20Binary%20Tree%20Inorder%20Traversal/94%20-%20Binary%20Tree%20Inorder%20Traversal.cpp\" target=\"_blank\" rel=\"noopener\">中序遍历</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; result;</span><br><span class=\"line\">\t\t<span class=\"built_in\">stack</span>&lt;TreeNode*&gt; sS1;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (root||!sS1.empty())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (root)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//result.push_back(root-&gt;val);\t//先序遍历的位置</span></span><br><span class=\"line\">\t\t\t\tsS1.push(root);</span><br><span class=\"line\">\t\t\t\troot = root-&gt;left;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!sS1.empty())</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\troot = sS1.top();</span><br><span class=\"line\">\t\t\t\tsS1.pop();</span><br><span class=\"line\">\t\t\t\tresult.push_back(root-&gt;val);\t<span class=\"comment\">//中序遍历的位置</span></span><br><span class=\"line\">\t\t\t\troot = root-&gt;right;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>后序遍历稍微复杂一点，有两种思路：</p>\n<ol>\n<li>左子树-&gt;右子树-&gt;节点(后序)    转化为    节点-&gt;右子树-&gt;左子树(前序) 的翻转(栈)</li>\n<li>对于任一结点P，先将其入栈。如果P不存在左孩子和右孩子，则可以直接访问它。或者P存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。若非上述两种情况，则将P的右孩子和左孩子依次入栈。这样就保证了每次取栈顶元素的时候，左孩子和右孩子都在根结点前面被访问。</li>\n</ol>\n<p><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/145%20-%20Binary%20Tree%20Postorder%20Traversal/145%20-%20Binary%20Tree%20Postorder%20Traversal.cpp\" target=\"_blank\" rel=\"noopener\">后序遍历</a><br>第一种(变异的前序)：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution1</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">postorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; outTreeNode;</span><br><span class=\"line\">\t\t<span class=\"built_in\">stack</span>&lt;TreeNode*&gt; sTreeNode;</span><br><span class=\"line\">\t\t<span class=\"built_in\">stack</span>&lt;<span class=\"keyword\">int</span>&gt; sInt;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (root||!sTreeNode.empty())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (root)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tsInt.push(root-&gt;val);</span><br><span class=\"line\">\t\t\t\tsTreeNode.push(root);</span><br><span class=\"line\">\t\t\t\troot=root-&gt;right;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!sTreeNode.empty())</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\troot=sTreeNode.top();</span><br><span class=\"line\">\t\t\t\tsTreeNode.pop();</span><br><span class=\"line\">\t\t\t\troot=root-&gt;left;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (!sInt.empty())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\toutTreeNode.push_back(sInt.top());</span><br><span class=\"line\">\t\t\tsInt.pop();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> outTreeNode;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>第二种(利用pre指针的后序)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class=\"line\">\t\tvector&lt;int&gt; outTreeNode;</span><br><span class=\"line\">\t\tstack&lt;TreeNode*&gt; sTreeNode;</span><br><span class=\"line\">\t\tTreeNode* pre=nullptr;\t//指向之前访问的节点</span><br><span class=\"line\">\t\tif (root)</span><br><span class=\"line\">\t\t\tsTreeNode.push(root);</span><br><span class=\"line\">\t\twhile (!sTreeNode.empty())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\troot=sTreeNode.top();</span><br><span class=\"line\">\t\t\tif ((root-&gt;left==nullptr&amp;&amp;root-&gt;right==nullptr)||(pre!=nullptr&amp;&amp;(pre==root-&gt;left||pre==root-&gt;right)))</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\toutTreeNode.push_back(root-&gt;val);</span><br><span class=\"line\">\t\t\t\tpre=root;</span><br><span class=\"line\">\t\t\t\tsTreeNode.pop();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\telse</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tif (root-&gt;right)</span><br><span class=\"line\">\t\t\t\t\tsTreeNode.push(root-&gt;right);//右孩子先入栈，后访问</span><br><span class=\"line\">\t\t\t\tif (root-&gt;left)</span><br><span class=\"line\">\t\t\t\t\tsTreeNode.push(root-&gt;left);//左孩子后入栈，先访问</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn outTreeNode;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"二叉树的Morris遍历\"><a href=\"#二叉树的Morris遍历\" class=\"headerlink\" title=\"二叉树的Morris遍历\"></a>二叉树的Morris遍历</h2><p>Moriis遍历法的优点：O(1)空间复杂度。Morris遍历的<strong>核心</strong>是使当前结点左孩子的最终右孩子的右指针指向当前结点，其分为三个阶段，制作指针阶段，回溯阶段，恢复指针阶段。</p>\n<ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/99%20-%20Recover%20Binary%20Search%20Tree/99%20-%20Recover%20Binary%20Search%20Tree.cpp\" target=\"_blank\" rel=\"noopener\">Recover Binary Search Tree</a><ul>\n<li>在回溯阶段(因为是中序，往右走之前遍历当前结点)访问右孩子的右结点，在恢复指针阶段访问当前结点；</li>\n<li>注意检测原理，如果两个元素逻辑上相邻，遍历只会出现一次异常，因此第一次异常就要及时更新second，如果两个元素逻辑上不相邻，遍历会出现两次异常，在第二次异常要更新second。</li>\n</ul>\n</li>\n</ol>\n","categories":["数据结构与算法"],"tags":["Algorithm"]},{"title":"BP、KMP、改进的KMP","url":"https://applefishsky009.github.io/2016/05/03/BP、KMP、改进的KMP/","content":"<p>在主串S中，自low位置开始，查找与模式串T相等的子串。如果这样的子串存在，返回其第一次出现的位置。本文详细介绍三种字符串匹配算法:</p>\n<ol>\n<li>BF(Brute-Force)算法(暴力破解);</li>\n<li>KMP算法;</li>\n<li>改进的KMP算法。</li>\n</ol>\n<p>这三种算法的代码<a href=\"https://github.com/applefishsky009/Interface/blob/master/BF%E5%92%8CKMP/BF%E5%92%8CKMP.cpp\" target=\"_blank\" rel=\"noopener\">在这里</a>。</p>\n<hr>\n<h2 id=\"BF算法\"><a href=\"#BF算法\" class=\"headerlink\" title=\"BF算法\"></a>BF算法</h2><p>设主串从i位开始与子串(从0开始)判断是否匹配;到子串的j位置，对应主串的i+j位置失配;将主串左移一位(<code>i++</code>),j回到0位继续匹配。</p>\n<hr>\n<h2 id=\"KMP算法\"><a href=\"#KMP算法\" class=\"headerlink\" title=\"KMP算法\"></a>KMP算法</h2><h3 id=\"为什么是next-j\"><a href=\"#为什么是next-j\" class=\"headerlink\" title=\"为什么是next[j]\"></a>为什么是next[j]</h3><p>每次失配将i右移一位显然是低效的。<strong>主观上来考虑，如果在失配之前子串有相等的真后缀，那么就可以右移更多的位。</strong>考虑在i+j位失配时将主串左移k位(子串右移k位)，而不是一位。容易得到，这个k只与子串的性质有关。<br>我们使用next[j]来标识当j位失配时子串应向右移j-next[j]位。示例:</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><code>abcdefg</code></th>\n<th align=\"center\">0 1 2 3 4 5 6</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>next[j]</code></td>\n<td align=\"center\">-1 0 0 0 0 0 0</td>\n</tr>\n<tr>\n<td align=\"center\">offset</td>\n<td align=\"center\">1 1 2 3 4 5 6</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><code>abcabcabc</code></th>\n<th align=\"center\">0 1 2 3 4 5 6 7 8</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>next[j]</code></td>\n<td align=\"center\">-1 0 0 0 1 2 3 4 5</td>\n</tr>\n<tr>\n<td align=\"center\">offset</td>\n<td align=\"center\">1 1 2 3 3 3 3 3 3</td>\n</tr>\n</tbody></table>\n<h3 id=\"如何求得next-j\"><a href=\"#如何求得next-j\" class=\"headerlink\" title=\"如何求得next[j]\"></a>如何求得next[j]</h3><p>在计算公式中next[j]指的是:j位<strong>以前</strong>字串中真前后缀的最大<strong>公共</strong>元素长度。真前缀、真后缀指的不包含串本身的子串。那么我们可以这样来计算j:<br>tempNext[j]表示j位及以前子串真前缀最大公共元素长度。将tempNext[j]右移一位，初值赋为-1,得到next[j]</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><code>xyxyyxxyx</code></th>\n<th align=\"center\">0 1 2 3 4 5 6 7 8</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>tempNext[j]</code></td>\n<td align=\"center\">0 0 1 2 0 1 1 2 3</td>\n</tr>\n<tr>\n<td align=\"center\"><code>next[j]</code></td>\n<td align=\"center\">-1 0 0 1 2 0 1 1 2</td>\n</tr>\n<tr>\n<td align=\"center\">offset</td>\n<td align=\"center\">1 1 2 2 2 5 5 6 6</td>\n</tr>\n</tbody></table>\n<p>tempNext[j]的计算:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//计算j位及之前真前缀以及真后缀的最大公共元素长度</span><br><span class=\"line\">void calTempNext(vector&lt;int&gt;&amp;next)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif (s2.size() == 1)</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\tnext[0] = 0;</span><br><span class=\"line\">\tint k = 0;//前缀指针,j就是后缀指针</span><br><span class=\"line\">\tfor (int j = 1;j &lt; s2.size();j++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\twhile(k &gt; 0 &amp;&amp; s2[j] != s2[k])//k位失配，</span><br><span class=\"line\">\t\t\tk = next[k-1];//k-1是可靠匹配，next[k-1]记录了上一个真后缀出现的地方</span><br><span class=\"line\">\t\tif (s2[j] == s2[k])//匹配，k++,j++，next[j]赋值</span><br><span class=\"line\">\t\t\tk++;</span><br><span class=\"line\">\t\tnext[j] = k;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"如何在编程中求得next-j\"><a href=\"#如何在编程中求得next-j\" class=\"headerlink\" title=\"如何在编程中求得next[j]\"></a>如何在编程中求得next[j]</h3><p>如果使用上述计算过程，先计算tempNext[j]再计算next[j]，需要两次遍历。将tempNext[j]右移初值赋-1的过程可以直接融入程序中，使用一次遍历就可以得到next[j]，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//直接计算next(时间复杂度O(n))</span><br><span class=\"line\">void cal2Next(vector&lt;int&gt;&amp;next)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint j = -1;\t\t//j,偏移指针</span><br><span class=\"line\">\tint i = 0;\t\t//i,next下标（实际上是要计算的next下标-1,因为是先加后赋值）</span><br><span class=\"line\">\tnext[0] = -1;</span><br><span class=\"line\">\twhile (i &lt; s2.size()-1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif (j == -1 || s2[i]==s2[j])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ti++;</span><br><span class=\"line\">\t\t\tj++;</span><br><span class=\"line\">\t\t\tnext[i] = j;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\tj = next[j];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"改进的KMP算法\"><a href=\"#改进的KMP算法\" class=\"headerlink\" title=\"改进的KMP算法\"></a>改进的KMP算法</h2><p>next[j]值越小，模式匹配所需比较次数越少。next[j]的计算中先判断匹配，i,j自加再赋值。</p>\n<ol>\n<li>若自加之后失配，这时候i失配并不代表j失配，因此留给下次循环回溯后来判断。</li>\n<li>若自加之后匹配，说明i与j位置完全等效，i失配，j一定失配。，而朴素的KMP算法在失配之后要一次一次回溯。因此可以<font color=\"red\">一次回溯到底</font>节约比较次数。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><code>abcaabbabcaac</code></th>\n<th align=\"center\">0 1 2  3 4 5 6  7 8 9 10 11 12</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>next[j]</code></td>\n<td align=\"center\">-1 0 0  0 1 1 2  0 1 2  3  4  5</td>\n</tr>\n<tr>\n<td align=\"center\">offset1</td>\n<td align=\"center\">1 1 2  3 3 4 4  7 7 7  7  7  7</td>\n</tr>\n<tr>\n<td align=\"center\"><code>nextVal[j]</code></td>\n<td align=\"center\">-1 0 0 -1 1 0 2 -1 0 0 -1  1  5</td>\n</tr>\n<tr>\n<td align=\"center\">offset2</td>\n<td align=\"center\">1 1 2  4 3 5 4  8 8 9 11 10  7</td>\n</tr>\n</tbody></table>\n<p>[LeetCode代码][中括号很烦]<br>[中括号很烦]:<a href=\"https://github.com/applefishsky009/LeetCode/blob/master/28-Implement_strStr()/28-Implement_strStr().cpp\" target=\"_blank\" rel=\"noopener\">https://github.com/applefishsky009/LeetCode/blob/master/28-Implement_strStr()/28-Implement_strStr().cpp</a></p>\n","categories":["数据结构与算法"],"tags":["Algorithm"]},{"title":"野指针与内存泄漏","url":"https://applefishsky009.github.io/2016/04/25/野指针与内存泄漏/","content":"<p>野指针和内存泄漏是两个相联系的概念，一般来讲指针&lt;-&gt;内存相互对应，如果有一个指针但没有指向任何内存，就是野指针；如果有一块未释放的内存，但没有指针指向他，就是内存泄露。</p>\n<hr>\n<h2 id=\"野指针\"><a href=\"#野指针\" class=\"headerlink\" title=\"野指针\"></a>野指针</h2><p>野指针指向一个已删除对象或未申请访问受限内存区域的指针，一般来说野指针有三个成因：</p>\n<ol>\n<li>指针变量未初始化；</li>\n<li>指针释放后未置空；</li>\n<li>指针操作超越变量作用域。</li>\n</ol>\n<p>值得注意的是，如果有多个指针指向同一块内存，释放其中一个指针后，应将包含这个指针在内的指向这一块内存的所有指针都置空，否则都会成为野指针。</p>\n<h2 id=\"内存泄漏\"><a href=\"#内存泄漏\" class=\"headerlink\" title=\"内存泄漏\"></a>内存泄漏</h2><p>在某一块内存的生命周期内，指向它的指针全部指向别处时，用户无法访问，也无法申请到这一块内存。这就是内存泄露。</p>\n","categories":["C++基础"],"tags":["C++"]},{"title":"Git命令","url":"https://applefishsky009.github.io/2016/04/23/Git命令/","content":"<p>初学git，记录当时的一些解决方法。</p>\n<ol>\n<li><a href=\"https://www.zhihu.com/question/22132675\" target=\"_blank\" rel=\"noopener\">删除不想要的git历史</a><code>git rebase -i SHA</code>如果之后有版本，会有conflict，根据提示<code>git rebase --abort</code>会放弃修改，<code>git rebase --skip</code>会跳过这个(放弃冲突的提交,也就是说之后的提交都没了)<code>git rebase --continue</code>应该会保留之后的提交,暂时没有进行测试。</li>\n<li><a href=\"https://segmentfault.com/q/1010000000115900\" target=\"_blank\" rel=\"noopener\">删除版本库中的提交</a>注意，他将HEAD指向某一个commit，之后的commit和文件都被擦除了，删除前做好备份……</li>\n<li>博客中常用的命令：hexo clean(删除一些没有用的缓存，比如删掉的tag等);hexo generate(生成一个commit?);hexo deploy(提交到远程)；合并hexo generate和hexo deploy：hexo d -g；<ul>\n<li>hexo s -p 5000；可以改变server运行的端口号。</li>\n</ul>\n</li>\n<li>使用过程中碰到<a href=\"http://stackoverflow.com/questions/9299651/git-says-warning-permanently-added-to-the-list-of-known-hosts\" target=\"_blank\" rel=\"noopener\">Warning: Permanently added ‘github.com,192.30.252.120’ (RSA) to the list of known hosts</a>.这个问题在linux下很好解决,但我用windows for github，困扰好久，方法如下：在C:/user/###(你的用户名)/.ssh/新建config文件(无后缀),添加UserKnownHostsFile ~/.ssh/known_hosts,下一次访问你还会看到，但是之后(可能要多几次，我的三次才可以，因为在这个文件夹下添加了三个ip)就没有了。</li>\n<li>windows下换行符<a href=\"http://www.luckyonecn.com/blog/git-auto-crlf-problem/\" target=\"_blank\" rel=\"noopener\">warning: LF will be replaced by CRLF</a>，不知道为什么我的<code>git config --global autocrlf false</code>没有用，因此直接在仓库中将config文件，core中修改autocrlf = false,没有则添加。</li>\n<li>从零配置网上教程到处都是，不必多说，主要解释换电脑或者重装系统的配置：<ul>\n<li>安装Nodejs(这是一个框架)</li>\n<li>安装hexo -&gt; npm install hexo-cli -g(这是hexo指令)</li>\n<li>将保存的hexo目录(博客文件夹)拷贝过来，并使用git for windows add仓库(否则使用命令行配置key)</li>\n<li>然后进入Hexo目录重新配置hexo模块 npm install(局部hexo指令)</li>\n<li>最后建议在GUI同步一下(否则本地和remote的commit记录不同步)</li>\n<li><a href=\"http://stackoverflow.com/questions/9023672/nodejs-how-to-resolve-cannot-find-module-error\" target=\"_blank\" rel=\"noopener\">参考资料</a></li>\n<li>为hexo安装math指令：npm install hexo-math –save,(也有可能并不需要,npm以及全部安装了)</li>\n<li>注意如果使用行内数学公式，该文章必须至少使用一行行间公式，不然行内公式会失效(如果不需要，请在文章最后添加<code>$$$$</code>)。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"命令行新建repository的步骤\"><a href=\"#命令行新建repository的步骤\" class=\"headerlink\" title=\"命令行新建repository的步骤\"></a>命令行新建repository的步骤</h2><ol>\n<li><code>mkdir repositoryName</code> -&gt; <code>cd repositoryName</code>;</li>\n<li><code>git init</code>，同时在远程新建仓库得到链接;</li>\n<li><code>touch .gitignore</code> -&gt; <code>vim .gitignore</code>并设置ignore文件<ul>\n<li><a href=\"http://blog.csdn.net/jackalfly/article/details/7546878\" target=\"_blank\" rel=\"noopener\">vim简易使用指南</a></li>\n<li>将 .gitignore 文件和 .gitattributes文件 另存，每次新建仓库拷贝即可。</li>\n<li><a href=\"http://blog.csdn.net/benkaoya/article/details/7932370\" target=\"_blank\" rel=\"noopener\">Git之忽略文件(ignore file)</a></li>\n</ul>\n</li>\n<li>标准commit：<code>git add .gitignore</code> -&gt; <code>git commit -m &quot;.gitignore&quot;</code>;<br> <code>-m</code>即message，界面中的summary。</li>\n<li>远程链接<code>git remote add origin &lt;URL&gt;</code>;<ul>\n<li><code>origin</code>指定你<code>push</code>到哪个remote,如果远程没有，参考<a href=\"http://blog.csdn.net/abo8888882006/article/details/12375091\" target=\"_blank\" rel=\"noopener\">Git 的origin和master分析 </a></li>\n</ul>\n</li>\n<li>设置默认上传流<code>git push -u origin master</code>;<ul>\n<li>默认推送到远程<code>master</code>分支，如果没有则新建；</li>\n</ul>\n</li>\n<li>设置完毕，以后的文件上传使用三个指令就可以完成：<ul>\n<li><code>git add fileName</code>；</li>\n<li><code>git commit -m &quot;summary&quot;</code>;</li>\n<li><code>git push</code>；</li>\n<li>结合 .gitignore 文件设置上传规则。</li>\n<li>可以<code>cd folder</code>单独上传文件设置不同的message，但是github上文件的message是最近commit的message。</li>\n</ul>\n</li>\n</ol>\n","categories":["Git"],"tags":["Git"]},{"title":"动态规划","url":"https://applefishsky009.github.io/2016/04/22/动态规划/","content":"<p>持续更新，记录在编程过程中关于动态规划(DP)的心得体会。算法分析以算法导论为主。主要是用于求解最优化问题，不同于递归用于解决<font color=\"red\">互不相交的子问题</font>，动态规划应用于<font color=\"red\">子问题重叠</font>的情况。简单来说，动态规划就是当前状态由前一状态所决定(也许有更前相关)。在实际应用中发现他有两个关键点：</p>\n<ol>\n<li>子问题的<strong>状态转移方程</strong>(递推关系式)；</li>\n<li>保存子问题的解用于递归(自顶向下);</li>\n</ol>\n<p>它有两种等价的实现方式：</p>\n<ol>\n<li>带备忘的自顶向下；</li>\n<li>自底向上。</li>\n</ol>\n<p>在使用过程中，根据之前状态的相关性将<font color=\"red\">DP问题分为三种</font>，这样在解题过程中可以帮助更快的定位问题：</p>\n<ol>\n<li>当前状态仅与前一状态有关(Edit Distance等)；</li>\n<li>当前状态与前一状态和更前一状态有关(Fibonacci等)；</li>\n<li>当前状态与前n个状态相关(Edit Distance II等)</li>\n</ol>\n<p>一般来说自底向上更容易实现。实际中哪一种更容易编程取决于具体问题。</p>\n<h2 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/120%20-%20Triangle/120%20-%20Triangle.cpp\" target=\"_blank\" rel=\"noopener\">triangle</a></li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/tree/master/62%20-%20Unique%20Paths\" target=\"_blank\" rel=\"noopener\">Unique Paths</a></li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/53%20-%20Maximum%20Subarray/53%20-%20Maximum%20Subarray.cpp\" target=\"_blank\" rel=\"noopener\">LeetCode:Maximum Subarray</a>和<a href=\"https://github.com/applefishsky009/BeautyOfProgramming/blob/master/2.14%20-%20%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/2.14.cpp\" target=\"_blank\" rel=\"noopener\">BeautyOfProgramming:一维数组的最大子数组</a><ul>\n<li>注意递推关系式(未改进版)(主要是理清逻辑，需要一个\\( nStart[i] \\)的递推):</li>\n<li>\\( nStart[i] = max(nStart[i-1]+A[i],nAll[i-1]) \\);</li>\n<li>\\( nAll[i] = max(nStart[i],nAll[i-1]) \\) </li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/121%20-%20Best%20Time%20to%20Buy%20and%20Sell%20Stock/121%20-%20Best%20Time%20to%20Buy%20and%20Sell%20Stock.cpp\" target=\"_blank\" rel=\"noopener\">Best Time to Buy and Sell Stock</a><ul>\n<li>每新一步，记录这一步与前面最小值最大差价，也就是利润</li>\n<li>更新最小值用于下一步</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/132%20-%20Palindrome%20Partitioning%20II/132%20-%20Palindrome%20Partitioning%20II.cpp\" target=\"_blank\" rel=\"noopener\">Palindrome Partitioning II</a><ul>\n<li>每次从i向右扫描(i的遍历)，每找到一个回文(j的遍历)就算一次DP，可以转换成f(i)=min{f(j+1)+1} ,i&lt;=j&lt;n</li>\n<li>定义状态 \\( P[i][j] = true\\ if [i,j] \\)是回文，那么\\( P[i][j] = str[i]==str[j]&amp;&amp;P[i+1][j-1] \\)</li>\n<li>注意上边转移函数\\(P[i][j]\\)依赖于\\(P[i+1][j-1]\\)，因此i递减，j递增，否则要做备忘录</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/123%20-%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20III/123%20-%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20III.cpp\" target=\"_blank\" rel=\"noopener\">Best Time to Buy and Sell Stock III</a><ul>\n<li>每个节点有四种可能:</li>\n<li>二次卖出，所得利润最高；</li>\n<li>二次持有，买入价格最低；</li>\n<li>首次卖出，所得利润最高；</li>\n<li>首次持有，买入价格最低。</li>\n<li>第二种思路：设状态f(i)表示区间[0,i],状态g(i)表示状态[i+1,n-1]的最大利润，则最终答案为max(f(i)+g(i))。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/188%20-%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20IV/188%20-%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20IV.cpp\" target=\"_blank\" rel=\"noopener\">Best Time to Buy and Sell Stock IV</a><ul>\n<li>这道题找到(v,p)之后的DP有四种转移状态：</li>\n<li>待转换：考虑(1,5)-&gt;(2,4),利润不仅由下一次决定(此状态p可能转移从而跳入状态2)，还可能与下下次相关，-&gt;(3,6)就需要两次利润转换，因此加入转换队列；若-&gt;(0,6)就在待转化栈中计算了两次利润；</li>\n<li>需要转换:考虑(1,5)-&gt;(2,6),利润转换5+3=4+4,小利润3，大利润5对应(1,6)还要看下一步；</li>\n<li>利润:考虑(1,5)-&gt;(0,3),利润是4,(0,3)由下次决定；</li>\n<li>利润:考虑(1,5)-&gt;(0,6),利润是4,(0,6)由下次决定。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/85%20-%20Maximal%20Rectangle/85%20-%20Maximal%20Rectangle.cpp\" target=\"_blank\" rel=\"noopener\">Maximal Rectangle</a><ul>\n<li>直方图面积的计算;</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/97%20-%20Interleaving%20String/97%20-%20Interleaving%20String.cpp\" target=\"_blank\" rel=\"noopener\">Interleaving String</a><ul>\n<li>初始化，第零行或者第零列意味着s3和另一字符串做匹配，实际匹配时的路径只与左或下的取值(还有字符是否匹配)相关；</li>\n<li>这是二维数组是否通路的问题，就像走<font color=\"red\">迷宫</font>一样，DFS会走完所有的路径，但DP会记录某一结点是否可抵达。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/10%20-%20Regular%20Expression%20Matching/10%20-%20Regular%20Expression%20Matching.cpp\" target=\"_blank\" rel=\"noopener\">Regular Expression Matching</a><ul>\n<li><code>*</code>匹配0个或者多个前个字符 - 重点；</li>\n<li>注意当前匹配条件<code>*p == *s || (*p == &#39;.&#39; &amp;&amp; *s != &#39;\\0&#39;)</code>，’.’唯一不能匹配’\\0’。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/87%20-%20Scramble%20String/87%20-%20Scramble%20String.cpp\" target=\"_blank\" rel=\"noopener\">Scramble String</a><ul>\n<li>两个<code>string</code>DP需要一个平面，长度DP需要一维，三维DP问题；</li>\n<li>参考第9个题目，二维DP像走迷宫，三维DP更像n层神经网络；</li>\n<li>三维DP有点像n层神经网络，就是这个题目中映射函数略难理解，两个条件映射才为true：</li>\n<li>第一个条件：z轴slice某一点为true且互补平面，偏移原平面高度的点为true;</li>\n<li>第二个条件：z轴slice，y偏移互补平面高度点为true且互补平面x偏移原平面高度点为true;</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/44%20-%20Wildcard%20Matching/44%20-%20Wildcard%20Matching.cpp\" target=\"_blank\" rel=\"noopener\">Wildcard Matching</a><ul>\n<li>利用字符串和字符串指针来回溯；</li>\n<li>正则匹配的思路。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/64%20-%20Minimum%20Path%20Sum/64%20-%20Minimum%20Path%20Sum.cpp\" target=\"_blank\" rel=\"noopener\">Minimum Path Sum</a><ul>\n<li>经典二维DP(二维路径问题)的写法，比较简单。</li>\n<li>初始化-&gt;遍历二维数组得到目标数-&gt;目标地址。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/72%20-%20Edit%20Distance/72%20-%20Edit%20Distance.cpp\" target=\"_blank\" rel=\"noopener\">Edit Distance</a><ul>\n<li>两个字符串的经典二维DP，设状态为f[i][j],表示A[0,i]和B[0,j]之间的最小编辑距离，设A[0,i]形式是str1c;B[0,j]形式是str2d;</li>\n<li>如果c == d，则f[i][j] = f[i-1][j-1];</li>\n<li>如果c != d：<ul>\n<li>替换：f[i][j] = f[i-1][j-1]+1;    //c替换为d，str1与str2的距离加1</li>\n<li>添加：f[i][j] = f[i][j-1]+1;    //表示c后添加一个d，str1c与str2之间的距离加1</li>\n<li>删除：f[i][j] = f[i-1][j]+1;    //表示删除c，str1与str2d之间的距离加1</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/91%20-%20Decode%20Ways/91%20-%20Decode%20Ways.cpp\" target=\"_blank\" rel=\"noopener\">Decode Ways</a><ul>\n<li>带条件的斐波那契,当前状态由前两个状态决定(甚至与当前值无关)。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/115%20-%20Distinct%20Subsequences/115%20-%20Distinct%20Subsequences.cpp\" target=\"_blank\" rel=\"noopener\">Distinct Subsequences</a><ul>\n<li>两个字符串问题，经典二维DP;</li>\n<li>设状态为f[i][j]表示T[0,j]在S[0,i]出现的次数，那么就有如下状态转移方程：<ul>\n<li>若s[i] == T[j] f[i][j] = f[i - 1][j] + f[i - 1][j-1];</li>\n<li>若s[i] != T[j] f[i][j] = f[i - 1][j];</li>\n<li>初始条件，认为s[i][0]永远为1,即s之前永远有一个T[0,0]。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/117%20-%20Populating%20Next%20Right%20Pointers%20in%20Each%20Node%20II/117%20-%20Populating%20Next%20Right%20Pointers%20in%20Each%20Node%20II.cpp\" target=\"_blank\" rel=\"noopener\">Populating Next Right Pointers in Each Node II</a><ul>\n<li>常数空间，类似于滚动数组的 DP 思路。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/116%20-%20Populating%20Next%20Right%20Pointers%20in%20Each%20Node/116%20-%20Populating%20Next%20Right%20Pointers%20in%20Each%20Node.cpp\" target=\"_blank\" rel=\"noopener\">Populating Next Right Pointers in Each Node</a><ul>\n<li>思路同17，不同的是这一题可以采用递归解决。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/140%20-%20Word%20Break%20II/140%20-%20Word%20Break%20II.cpp\" target=\"_blank\" rel=\"noopener\">Word Break II</a><ul>\n<li>使用二维DP来记录路径，DFS+Backtracking来组合路径。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/96%20-%20Unique%20Binary%20Search%20Trees/96%20-%20Unique%20Binary%20Search%20Trees.cpp\" target=\"_blank\" rel=\"noopener\">Unique Binary Search Trees</a><ul>\n<li>当前状态与前n个状态相关的DP问题。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/95%20-%20Unique%20Binary%20Search%20Trees%20II/95%20-%20Unique%20Binary%20Search%20Trees%20II.cpp\" target=\"_blank\" rel=\"noopener\">Unique Binary Search Trees II</a><ul>\n<li>二叉树的DP问题，带缓存的由上向下DP。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/279%20-%20Perfect%20Squares/279%20-%20Perfect%20Squares.cpp\" target=\"_blank\" rel=\"noopener\">Perfect Squares</a><ul>\n<li>最少平方数的和，自顶向下带缓存的DP。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/198%20-%20House%20Robber/198%20-%20House%20Robber.cpp\" target=\"_blank\" rel=\"noopener\">House Robber</a><ul>\n<li>链状抢劫房屋，是环状抢劫的基础。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/213%20-%20House%20Robber%20II/213%20-%20House%20Robber%20II.cpp\" target=\"_blank\" rel=\"noopener\">House Robber II</a><ul>\n<li>环状抢劫房屋，关键是如何将链转化为环，第一个抢或者不抢可以转化。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/337%20-%20House%20Robber%20III/337%20-%20House%20Robber%20III.cpp\" target=\"_blank\" rel=\"noopener\">House Robber III</a><ul>\n<li>二叉树式抢劫房屋，带缓存的自顶向下的递归，即DP。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/FunnyIssues/blob/master/9%20-%20Edit%20Distance%20II/9%20-%20Edit%20Distance%20II.cpp\" target=\"_blank\" rel=\"noopener\">Edit Distance II</a><ul>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/72%20-%20Edit%20Distance/72%20-%20Edit%20Distance.cpp\" target=\"_blank\" rel=\"noopener\">Edit Distance</a>的变形，进阶DP问题，删除任意长度的字符代价是2，增加n长度字符串的代价是n + 2;</li>\n<li>对DP问题,首先分析的是<strong>当前状态与之前的那些状态有关</strong>，简单编辑距离只与前一状态有关，这个DP中的某一分支是与前n个状态相关的。</li>\n</ul>\n</li>\n</ol>\n","categories":["数据结构与算法"],"tags":["Algorithm"]},{"title":"贪心算法","url":"https://applefishsky009.github.io/2016/04/22/贪心算法/","content":"<p>持续更新，记录在编程过程中关于贪心算法的心得体会。算法分析以算法导论为主。求解最优化问题比动态规划更为简洁高效。其思想核心是<font color=\"red\">选择当前最优解</font>，虽然不一定是全局最优解。贪心算法主要应用有</p>\n<ol>\n<li>活动选择问题</li>\n<li>霍夫曼编码</li>\n<li>最小生成树</li>\n<li>单元最短路径的Dijkstra算法</li>\n<li>集合覆盖问题的贪心启发式算法</li>\n</ol>\n<p>贪心算法的形式一般有<strong>递归贪心算法</strong>，<strong>迭代贪心算法</strong>。</p>\n<hr>\n<h2 id=\"活动选择问题\"><a href=\"#活动选择问题\" class=\"headerlink\" title=\"活动选择问题\"></a>活动选择问题</h2><ol>\n<li>调度竞争共享资源的多个活动问题，选出最大的互相兼容的活动集合；<ul>\n<li>选择一个活动，选出他后剩下的资源能尽量多的被其他任务所用(算法导论16.1)；</li>\n</ul>\n</li>\n<li>Jump Game；<ul>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/55%20-%20Jump%20Game/55%20-%20Jump%20Game%20%20.cpp\" target=\"_blank\" rel=\"noopener\">Jump Game</a>,每个节点选择更新当前最优解。</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/45%20-%20Jump%20Game%20II/45%20-%20Jump%20Game%20II.cpp\" target=\"_blank\" rel=\"noopener\">Jump GameⅡ</a>, 每一步选择当前最优解(层数，是一层一一层映射的关系，怎么感觉是在广搜？!)。</li>\n<li>Jump GameⅡ比Jump Game多出统计步数，在这个映射范围内选择最优解。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/121%20-%20Best%20Time%20to%20Buy%20and%20Sell%20Stock/121%20-%20Best%20Time%20to%20Buy%20and%20Sell%20Stock.cpp\" target=\"_blank\" rel=\"noopener\">Best Time to Buy and Sell Stock</a><ul>\n<li>找到价格最低最高的一天，低出高进。如何选择是DP思路。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/122%20-%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20II/122%20-%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20II.cpp\" target=\"_blank\" rel=\"noopener\">Best Time to Buy and Sell Stock II</a><ul>\n<li>累计正的相邻的diff差，思路类似于最大m子段和</li>\n<li>局部利润一定是整体利润的唯一部分(因为只能持有一份股票)，因此分割为最小利润单元</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/11%20-%20Container%20With%20Most%20Water/11%20-%20Container%20With%20Most%20Water.cpp\" target=\"_blank\" rel=\"noopener\">Container With Most Water</a><ul>\n<li>贪心不一定是DP式的单向遍历，可以使用Two Pointers缩窄遍历；</li>\n<li>注意是水的容积，即计算矩形的面积，而不是梯形面积，矩形面积取决于最短的木板，因此每次更新最短木板。</li>\n<li>为什么更新短木板：这是因为短木板已经“物尽其用”，之后不可能再用到，而长木板极可能在后边用到(短木板更新必然产生新面积)。</li>\n<li>为什么说“物尽其用”：如果更新长木板：<ul>\n<li>新长木板比短木板长：宽度变窄，面积不更新；</li>\n<li>新长木板比短木板段：宽度变窄，高度变低，面积不更新。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n","categories":["数据结构与算法"],"tags":["Algorithm"]},{"title":"函数参数的传递","url":"https://applefishsky009.github.io/2016/04/22/函数参数的传递/","content":"<p>函数参数的传递有三种，按值传递，按址传递，按引用传递(C++新增)。</p>\n<hr>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><p>引用是<font color=\"red\"><strong>已定义的变量</strong></font>的别名，数据类型是<font color=\"red\"><strong>指针常量</strong></font>。</p>\n<h3 id=\"引用的本质\"><a href=\"#引用的本质\" class=\"headerlink\" title=\"引用的本质\"></a>引用的本质</h3><p>C++将<code>&amp;</code>符号赋予了另一个含义，用来声明引用。引用是已定义变量的别名(同一块内存)。引用的主要作用是用作函数形参。<br>引用的本质是<font color=\"red\">指针常量</font>，例如<code>int &amp;pr = rats;</code>是<code>int* const pr = &amp;rats;</code>的伪装。它的含义是他是一个指针，指向一个常量地址。因此他有以下特性也就很好理解了：</p>\n<ol>\n<li>必须在声明引用是将其初始化；(因为指向常量地址)</li>\n<li>初始化时，省略了取地址符的操作<code>&amp;</code>,给我们感觉是别名；</li>\n<li>声明引用时，隐藏了对指针常量的自动间接引用，让我们看不到指针。</li>\n<li>使用引用时，隐藏了解除引用<code>*</code>,让我们觉得是在直接修改(别名)变量。<br>如下：<img src=\"http://i.imgur.com/idRXQZy.png\" alt=\"这里\"></li>\n</ol>\n<h3 id=\"返回引用\"><a href=\"#返回引用\" class=\"headerlink\" title=\"返回引用\"></a>返回引用</h3><ol>\n<li>返回引用比传统返回机制少了拷贝复制，效率更高。</li>\n<li>返回引用本质是返回“别名”,因此要注意保证返回后这个内存依然存在。(变量持续性)</li>\n<li>返回类型<strong>一般</strong>用<font color=\"red\"><code>const</code>标识</font>，将其设置为不可修改的左值，避免数据损失。<ul>\n<li>赋值语句，左边必须是可修改的左值；</li>\n<li>常规返回类型是右值(因为其位于临时内存单元)-&gt;不能通过地址访问。(可以出现在表达式右边，但不能出现在左边，如字面值<code>10.0</code>,表达式<code>x+y</code>) </li>\n</ul>\n</li>\n</ol>\n<p>如果返回局部变量(运算符重载中)，不能返回引用。</p>\n<h3 id=\"C-C-中的左值和右值\"><a href=\"#C-C-中的左值和右值\" class=\"headerlink\" title=\"C/C++中的左值和右值\"></a>C/C++中的左值和右值</h3><ol>\n<li>左值是一个引用到对象的表达式，因此可以取址(可以赋值)；</li>\n<li>右值强调的不是表达式本身，而是该表达式运算后的结果。这个结果往往并不引用到某一对象，可以看成计算的中间结果(临时内存单元)；（当然它也可能引用到某一对象，但是通过该右值表达式我们不能直接修改该对象—）。</li>\n</ol>\n<hr>\n<h2 id=\"按值传递\"><a href=\"#按值传递\" class=\"headerlink\" title=\"按值传递\"></a>按值传递</h2><p>C++将数值参数传递给函数，函数将其赋给一个新的变量，新变量与旧变量在赋值之后没有任何关系。</p>\n<hr>\n<h2 id=\"按址传递\"><a href=\"#按址传递\" class=\"headerlink\" title=\"按址传递\"></a>按址传递</h2><p>C++将参数地址传递给函数，函数原型用指针(一般用<code>const</code>修饰表示指针不会乱指)指向这个地址</p>\n<hr>\n<h2 id=\"数组传递\"><a href=\"#数组传递\" class=\"headerlink\" title=\"数组传递\"></a>数组传递</h2><p>数组在传递时，编译器将数组名解释为第一个元素的地址，因此传递实参为数组时，形参应该是一个指针指向这个地址。<br>在用多维数组名作为形参时，可以指定所有维数的大小，也可以省略第一位的大小(高维大小必须指定)，这与编译器寻址有关，比如<code>int p[m][n]</code>如果要取<code>p[i][j]</code>的值，编译器会计算地址为<code>p+i*n+j;</code>，因此编译器可以不知道m的值，但必须知道n的值。</p>\n<hr>\n<h2 id=\"volatile关键字简介\"><a href=\"#volatile关键字简介\" class=\"headerlink\" title=\"volatile关键字简介\"></a>volatile关键字简介</h2><p>相对于<code>const</code>关键字，简单介绍<code>volatile</code>限定符：</p>\n<ol>\n<li>当对象的值可能在程序的控制或检测之外改变时，应该将对象声明为<code>volatile</code>，例如包含一个由系统时钟定时更新的变量，他告诉编译器不应对这样的编译器进行优化。</li>\n<li><code>const</code>关键字和<code>volatile</code>关键字相互没有什么影响，</li>\n<li>就像类可以定义<code>const</code>成员函数一样，可以定义<code>volatile</code>成员函数，但对于一个<code>volatile</code>类对象，只有<code>volatile</code>成员函数、构造函数、析构函数可以被调用。</li>\n</ol>\n","categories":["C++基础"],"tags":["C++"]},{"title":"BFS和DFS","url":"https://applefishsky009.github.io/2016/04/21/BFS和DFS/","content":"<p>持续更新,该贴记录一些BFS和DFS在使用过程中的心得体会，以加深对BFS与DFS的理解。</p>\n<hr>\n<h2 id=\"BFS-广度优先搜索\"><a href=\"#BFS-广度优先搜索\" class=\"headerlink\" title=\"BFS(广度优先搜索)\"></a>BFS(广度优先搜索)</h2><p>BFS需要借助一个<strong>队列</strong>来记录遍历的”层数”；对每个节点的邻接节点咬判断是否入队(入队就是该节点的下一层)，如果需要记录步长，要将<code>pair</code>模板压入队列；队列为空，结束搜寻。</p>\n<ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/127%20-%20World%20Ladder/127%20-%20World%20Ladder.cpp\" target=\"_blank\" rel=\"noopener\">Word Ladder</a></li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/126%20-%20Word%20Ladder%20II/126%20-%20Word%20Ladder%20II.cpp\" target=\"_blank\" rel=\"noopener\">Word Ladder II</a></li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/130%20-%20Surrounded%20Regions/130%20-%20Surrounded%20Regions.cpp\" target=\"_blank\" rel=\"noopener\">Surrounded Regions</a></li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/107%20-%20Binary%20Tree%20Level%20Order%20Traversal%20II/107%20-%20Binary%20Tree%20Level%20Order%20Traversal%20II.cpp\" target=\"_blank\" rel=\"noopener\">Binary Tree Level Order Traversal II</a></li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/103%20-%20Binary%20Tree%20Zigzag%20Level%20Order%20Traversal/103%20-%20Binary%20Tree%20Zigzag%20Level%20Order%20Traversal.cpp\" target=\"_blank\" rel=\"noopener\">Binary Tree Zigzag Level Order Traversal</a><ul>\n<li><code>vector</code>当<code>stack</code>来使用。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"DFS-深度优先搜索\"><a href=\"#DFS-深度优先搜索\" class=\"headerlink\" title=\"DFS(深度优先搜索)\"></a>DFS(深度优先搜索)</h2><p>DFS需要用递归或者借助栈来<strong>记录</strong>走过的路径；每遍历完这条分支(所有可能性)，便要<strong>回溯</strong>到上一层(撤销操作)；在递归之前可以记录深度。<br>有四点需要特别说明：<strong>递归出口(DFS深度控制)</strong>，<strong>递归入口(在DFS中何时调用DFS)</strong>，<strong>撤销操作(同一层继续找递归入口)</strong>，<strong>递归出口深度控制需要传递深度参数</strong>。</p>\n<ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/131%20-%20Palindrome%20Partitioning/131%20-%20Palindrome%20Partitioning.cpp\" target=\"_blank\" rel=\"noopener\">Palindrome Partitioning</a><ul>\n<li>使用递归的DFS</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/126%20-%20Word%20Ladder%20II/126%20-%20Word%20Ladder%20II.cpp\" target=\"_blank\" rel=\"noopener\">Word Ladder II</a><ul>\n<li>使用栈的DFS；</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/62%20-%20Unique%20Paths/62%20-%20Unique%20Paths.cpp\" target=\"_blank\" rel=\"noopener\">Unique Paths</a><ul>\n<li>二分DFS与DP；</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/63%20-%20Unique%20Paths%20II/63%20-%20Unique%20Paths%20II.cpp\" target=\"_blank\" rel=\"noopener\">Unique Paths II</a><ul>\n<li>带判断的二分递归与DP；</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/51%20-%20N-Queens/51%20-%20N-Queens.cpp\" target=\"_blank\" rel=\"noopener\">N-Queens</a><ul>\n<li>使用递归的DFS，递归出口(DFS深度控制)，递归入口(在DFS中何时调用DFS)，以及回溯时撤销操作(同一层继续找递归入口)；</li>\n<li>判断是否在对角线上：行列差相等。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/46%20-%20Permutations/46%20-%20Permutations.cpp\" target=\"_blank\" rel=\"noopener\">Permutations</a><ul>\n<li>按位置遍历，注意出口，入口，往前走一步(覆盖所有可能性)，回溯。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/47%20-%20Permutations%20II/47%20-%20Permutations%20II.cpp\" target=\"_blank\" rel=\"noopener\">Permutations II</a><ul>\n<li>随着sums的增长，在最后一步find()方法的复杂度n!增长，耗时太久;</li>\n<li>在每一步中可以去掉相同的步，可以极大优化算法;</li>\n<li>用hash_map统计出现的次数速度更快，于是用字符次数对来代替原数组(重复字符越多速度提升越明显)。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/52%20-%20N-Queens%20II/52%20-%20N-Queens%20II.cpp\" target=\"_blank\" rel=\"noopener\">N-Queens II</a><ul>\n<li>使用<code>vector&lt;int&gt; C</code>来记录每一层/行(i)的Q在哪一列(j)。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/tree/master/97%20-%20Interleaving%20String\" target=\"_blank\" rel=\"noopener\">Interleaving String</a><ul>\n<li>DFS传递步数，使用两个指针判断，但是会超时(在release版本下复杂样本测试时间超过30s)。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/77%20-%20Combinations/77%20-%20Combinations.cpp\" target=\"_blank\" rel=\"noopener\">Combinations</a><ul>\n<li>start-标识当前步, cur-path中的元素数量(可以用path.size()代替);</li>\n<li>这题自己写的时候走了不少弯路，想用<code>unordered_set&lt;int&gt;</code>标识当前可走的步数，用<code>set&lt;int&gt;</code>对path排序，用<code>unodered_set&lt;vector&lt;int&gt;&gt;</code>来防止重复，但<code>unodered_set&lt;vector&lt;int&gt;&gt;</code>需要重写hasher，比较复杂，因此用了对<code>vector&lt;vector&lt;int&gt;&gt;</code>用了find方法，这在大样本下难免会超时；</li>\n<li>从上可以看出其<strong>深度参数</strong>的重要性，参数左边是已经走过的步，参数右边就是所有可能走的步数；</li>\n<li>另外注意Backtracking是在当前步走完，递归，就要立即回溯。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/93%20-%20Restore%20IP%20Addresses/93%20-%20Restore%20IP%20Addresses.cpp\" target=\"_blank\" rel=\"noopener\">Restore IP Addresses</a><ul>\n<li>每一层的选择不一定这么简单，就像这个问题，尤其注意剪枝；</li>\n<li>每一层的遍历尽量用<code>for</code>，不符合条件的剪掉就行。当前层剪不掉的可以在下一层入口剪掉，例如例子中余下字符数过多过少的问题。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/100%20-%20Same%20Tree/100%20-%20Same%20Tree.cpp\" target=\"_blank\" rel=\"noopener\">Same Tree</a><ul>\n<li>及其简单的一个DFS。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/17%20-%20Letter%20Combinations%20of%20a%20Phone%20Number/17%20-%20Letter%20Combinations%20of%20a%20Phone%20Number.cpp\" target=\"_blank\" rel=\"noopener\">Letter Combinations of a Phone Number</a><ul>\n<li>递归版本比较简单，掌握四要素：1.递归出口；2.传递当前步数；3.当前步数可能值循环；4.回溯(因为是按值传递path)</li>\n<li>非递归版本比较复杂，按内存复制。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/39%20-%20Combination%20Sum/39%20-%20Combination%20Sum.cpp\" target=\"_blank\" rel=\"noopener\">Combination Sum</a><ul>\n<li>保证输入排序；</li>\n<li>提前减枝提升性能。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/101%20-%20Symmetric%20Tree/101%20-%20Symmetric%20Tree.cpp\" target=\"_blank\" rel=\"noopener\">Symmetric Tree</a><ul>\n<li>利用重载来改变接口为自己想要的；</li>\n<li>不能用中序遍历判断vector是否对称来做，以1233N2N(层次顺序)为例。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/40%20-%20Combination%20Sum%20II/40%20-%20Combination%20Sum%20II.cpp\" target=\"_blank\" rel=\"noopener\">Combination Sum II</a><ul>\n<li>严格按照层dfs，每层使用一次dfs，不要调用第二次；</li>\n<li>对数组来说，未决定的所有剩余数字都可作为本层输入。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/22%20-%20Generate%20Parentheses/22%20-%20Generate%20Parentheses.cpp\" target=\"_blank\" rel=\"noopener\">Generate Parentheses</a></li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/79%20-%20Word%20Search/79%20-%20Word%20Search.cpp\" target=\"_blank\" rel=\"noopener\">Word Search</a><ul>\n<li>DFS解答，注意模拟<code>Hash Table</code>记录已经遍历的路径防止重复使用元素。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/105%20-%20Construct%20Binary%20Tree%20from%20Preorder%20and%20Inorder%20Traversal/105%20-%20Construct%20Binary%20Tree%20from%20Preorder%20and%20Inorder%20Traversal.cpp\" target=\"_blank\" rel=\"noopener\">Construct Binary Tree from Preorder and Inorder Traversal</a><ul>\n<li>正确传递下标就没有问题。建议传递超尾，易于迁移到迭代器。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/106%20-%20Construct%20Binary%20Tree%20from%20Inorder%20and%20Postorder%20Traversal/106%20-%20Construct%20Binary%20Tree%20from%20Inorder%20and%20Postorder%20Traversal.cpp\" target=\"_blank\" rel=\"noopener\">Construct Binary Tree from Inorder and Postorder Traversal</a><ul>\n<li>传数组<code>Index</code>，仿照迭代器传递头和超尾；</li>\n<li>找根节点的同时计数，方便计算下一次的<code>Index</code>。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/108%20-%20Convert%20Sorted%20Array%20to%20Binary%20Search%20Tree/108%20-%20Convert%20Sorted%20Array%20to%20Binary%20Search%20Tree.cpp\" target=\"_blank\" rel=\"noopener\">Convert Sorted Array to Binary Search Tree</a><ul>\n<li>二分查找,传递超尾。</li>\n</ul>\n</li>\n</ol>\n","categories":["数据结构与算法"],"tags":["Algorithm"]},{"title":"共用体、枚举和浮点数存储","url":"https://applefishsky009.github.io/2016/04/21/共用体、枚举和浮点数存储/","content":"<h2 id=\"共用体\"><a href=\"#共用体\" class=\"headerlink\" title=\"共用体\"></a>共用体</h2><p>是一种数据格式，简单来说，在同一块内存地址，可以同时起不同数据类型的名字，用这些名字来取值时，名字所对应的数据类型告诉编译器怎么去解释内存中的数据。他的特点：</p>\n<ol>\n<li>它的长度是最大数据类型长度，可以节省空间；</li>\n<li>数据不共存；</li>\n<li>关键字<code>union</code>，声明方式与结构体相同；</li>\n</ol>\n<hr>\n<h2 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h2><p>创建符号常量的方式，简单来说就是将一个“标签”与枚举量对应起来。特点：</p>\n<ol>\n<li>可以提升(常到<code>int</code>)，但<code>int</code>不能缩窄到它；</li>\n<li>可以显式设置枚举量，枚举范围内即使没有枚举量，也合法；</li>\n<li>关键词<code>enum</code>，声明方式与结构体相似；</li>\n<li>他没有算术运算，一般常用于<code>swith</code>语句中的标签。</li>\n</ol>\n<hr>\n<h2 id=\"浮点数存储方式\"><a href=\"#浮点数存储方式\" class=\"headerlink\" title=\"浮点数存储方式\"></a>浮点数存储方式</h2><h3 id=\"浮点数表示\"><a href=\"#浮点数表示\" class=\"headerlink\" title=\"浮点数表示\"></a>浮点数表示</h3><p>不管是什么数据类型，在内存中的表示方式都是一样的(0或者1)，数据类型的作用只是告诉编译器如何去解释内存中的数据，那么编译器是如何解释浮点型的？<br>首先，二进制科学法表示中，一个浮点型S = M*2^N，内存会存储三部分：符号位+阶码(N)+尾数(M)；</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">数据</th>\n<th align=\"center\">符号位</th>\n<th align=\"center\">阶码</th>\n<th align=\"center\">尾数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>float</code></td>\n<td align=\"center\">1位</td>\n<td align=\"center\">8位</td>\n<td align=\"center\">23位</td>\n</tr>\n<tr>\n<td align=\"center\">内存位</td>\n<td align=\"center\">31</td>\n<td align=\"center\">30-23</td>\n<td align=\"center\">22-0</td>\n</tr>\n<tr>\n<td align=\"center\"><code>double</code></td>\n<td align=\"center\">1位</td>\n<td align=\"center\">11位</td>\n<td align=\"center\">52位</td>\n</tr>\n<tr>\n<td align=\"center\">内存位</td>\n<td align=\"center\">63</td>\n<td align=\"center\">62-52</td>\n<td align=\"center\">51-0</td>\n</tr>\n<tr>\n<td align=\"center\">其次，阶码使用中间偏置(固定量为2^N-1)的移码表示的,M的整数部分为1,不存储，只存储尾数即可。</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">例如，</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">1. 125.5f = <code>1111101.1</code> = 1.1111011*2^6 =&gt;移码127+6 = 133 = <code>10000101</code> =&gt;正数符号位是0，尾数补0到够23位,那么计算机中：<code>01000010 11111101 00000000 0000000</code>。</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">2. 253.5f = <code>11111101.1</code> = 1.11111011*2^7 =&gt;移码127+7 = 134 = <code>10000110</code> =&gt;正数符号位是0，尾数补0到够23位,那么计算机中：<code>01000011 01111110 10000000 0000000</code>。</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h3 id=\"浮点整型转化\"><a href=\"#浮点整型转化\" class=\"headerlink\" title=\"浮点整型转化\"></a>浮点整型转化</h3><p>讨论<code>float</code>型与<code>int</code>的相互转化(字节数相等)，值转化使用强制类型转换<code>float(int x)</code>和<code>int(float x)</code>可以完成，这个操作中内存中的位发生了变化，那么，现在不想让位变化，转变编译器解释数据的方式该如何操作?<br>之前提到过，对一个指定的编译器，任何指针的大小都是一定的。因此可以对指针(指针类型可以告诉编译器解释内存的方式)强制类型转化(缩窄转换取低位)来完成。如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float f = 253.5;</span><br><span class=\"line\">unsigned short s = *(unsigned short*)&amp;f;</span><br><span class=\"line\">short s1 = *(short*)&amp;f;</span><br></pre></td></tr></table></figure>\n\n<p>s = 2**15 = 32768;<br>s1 = <code>10000000 00000000</code> = -32768;</p>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><ol>\n<li>整型常量默认情况下是int型,浮点常量在默认情况下是<code>double</code>型,如果需要<code>float</code>型，需要这样表示：<code>3.25f</code>；</li>\n</ol>\n","categories":["C++基础"],"tags":["C++"]},{"title":"string类与cctype","url":"https://applefishsky009.github.io/2016/04/21/string类与cctype/","content":"<h2 id=\"string类\"><a href=\"#string类\" class=\"headerlink\" title=\"string类\"></a>string类</h2><ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/67%20-%20Add%20Binary/67%20-%20Add%20Binary.cpp\" target=\"_blank\" rel=\"noopener\">Add Binary</a><ul>\n<li>不同长度链表或字符串运算，注意<code>?</code>,<code>:</code>用得非常巧妙；</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/150%20-%20Evaluate%20Reverse%20Polish%20Notation/150%20-%20Evaluate%20Reverse%20Polish%20Notation.cpp\" target=\"_blank\" rel=\"noopener\">Evaluate Reverse Polish Notation</a><ul>\n<li><code>string::sizetype</code>是无符号，<code>string::npos</code>是-1的强制类型转换，不同类型值不同；</li>\n<li><code>stringtoint:string::stoi()</code>。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/3%20-%20Longest%20Substring%20Without%20Repeating%20Characters/3%20-%20Longest%20Substring%20Without%20Repeating%20Characters.cpp\" target=\"_blank\" rel=\"noopener\">Longest Substring Without Repeating Characters</a><ul>\n<li>从上一个重复字符的下一个字符计数。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/10%20-%20Regular%20Expression%20Matching/10%20-%20Regular%20Expression%20Matching.cpp\" target=\"_blank\" rel=\"noopener\">Regular Expression Matching</a><ul>\n<li><code>*</code>匹配0个或者多个前个字符 - 重点；</li>\n<li>注意当前匹配条件<code>*p == *s || (*p == &#39;.&#39; &amp;&amp; *s != &#39;\\0&#39;)</code>，’.’唯一不能匹配’\\0’。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/43%20-%20Multiply%20Strings/43%20-%20Multiply%20Strings.cpp\" target=\"_blank\" rel=\"noopener\">Multiply Strings</a><ul>\n<li>任意大小非负数字乘积计算(<code>string</code>类)，按结果逐位计算；</li>\n<li>注意避免头插和<code>find_first_not_of(&quot;0&quot;)</code>可以去掉头部的’0’；</li>\n<li>保证num1，num2访问不越界。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/44%20-%20Wildcard%20Matching/44%20-%20Wildcard%20Matching.cpp\" target=\"_blank\" rel=\"noopener\">Wildcard Matching</a><ul>\n<li>利用字符串和字符串指针来回溯；</li>\n<li>正则匹配的思路。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/14%20-%20Longest%20Common%20Prefix/14%20-%20Longest%20Common%20Prefix.cpp\" target=\"_blank\" rel=\"noopener\">Longest Common Prefix</a><ul>\n<li>参考<a href=\"https://en.wikipedia.org/wiki/Null-terminated_string\" target=\"_blank\" rel=\"noopener\">Null-terminated string</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/65%20-%20Valid%20Number/65%20-%20Valid%20Number.cpp\" target=\"_blank\" rel=\"noopener\">Valid Number</a><ul>\n<li>这种题看似简单，但是坑巨多无比;</li>\n<li>完成’ ‘的strip功能;</li>\n<li>‘.’小数点的判断；</li>\n<li>‘e’指数，底数可以是小数，但是指数只能是整数；</li>\n<li>‘+’，’-‘的有效性；</li>\n<li>最后，神一般的有限状态机解法，不知道说什么好了。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/13%20-%20Roman%20to%20Integer/13%20-%20Roman%20to%20Integer.cpp\" target=\"_blank\" rel=\"noopener\">Roman to Integer</a><ul>\n<li>除数留余，避免<code>substr()</code>方法，使用<code>Hash Table</code>让提升效率。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/38%20-%20Count%20and%20Say/38%20-%20Count%20and%20Say.cpp\" target=\"_blank\" rel=\"noopener\">CountandSay</a><ul>\n<li>dp思路，一层一层找。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/6%20-%20ZigZag%20Conversion/6%20-%20ZigZag%20Conversion.cpp\" target=\"_blank\" rel=\"noopener\">ZigZag Conversion</a><ul>\n<li>分类，注意找对称元素。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/49%20-%20Group%20Anagrams/49%20-%20Group%20Anagrams.cpp\" target=\"_blank\" rel=\"noopener\">Group Anagrams</a><ul>\n<li>这个题与ip消息队列，LRU cache有相似的地方，键值映射一个队列/链表。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/71%20-%20Simplify%20Path/71%20-%20Simplify%20Path.cpp\" target=\"_blank\" rel=\"noopener\">Simplify Path</a><ul>\n<li>这个题和处理<code>,</code>分割的数字输入类似，使用<code>find</code>分类讨论。</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/68%20-%20Text%20Justification/68%20-%20Text%20Justification.cpp\" target=\"_blank\" rel=\"noopener\">Text Justification</a><ul>\n<li>除了最后一行，字符串按位数均匀分布(两个字符串之间至少有一个空格)，注意如果只有一个单词要补充足够的空格；</li>\n<li>最后一行单词左排列就行(依然至少一个空格)，要补充足够的空格。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"string运算符\"><a href=\"#string运算符\" class=\"headerlink\" title=\"string运算符\"></a>string运算符</h3><p><code>string</code>类的运算符重载在头文件<code>string</code>里,如<code>+</code>,<code>&lt;&lt;</code>。注意<code>&quot;a&quot;+&quot;b&quot; = &quot;ab&quot;</code>,<code>&#39;a&#39;+&#39;b&#39; = 195</code>,前者是字符串拼接，后者是字符常量相加。但是<code>cout&lt;&lt;&quot;a&quot;+&quot;b&quot;;</code>这个语句是错误的，必须至少声明两个<code>string</code>类型。</p>\n<h3 id=\"string-find\"><a href=\"#string-find\" class=\"headerlink\" title=\"string.find()\"></a>string.find()</h3><p><code>string</code>类的<code>find()</code>方法，可以用于找子串，返回子串在原串出现的下标。<a href=\"http://www.cnblogs.com/web100/archive/2012/12/02/cpp-string-find-npos.html\" target=\"_blank\" rel=\"noopener\">这里</a>和<a href=\"http://www.cplusplus.com/reference/string/string/find/\" target=\"_blank\" rel=\"noopener\">这里</a>有详细解释，使用时注意以下三点：</p>\n<ul>\n<li>接受三个参数，第一个是子串，第二个是开始寻找的下标，第三个参数是匹配字串的字符数。可以用于找全部的匹配子串；</li>\n<li>如果没有找到，返回值是<code>string::npos</code>，他是一个很大的正数(-1强制转化为无符号整型)；</li>\n<li>返回值是<code>size_type</code>，一般用<code>auto</code>来代替，这是一个无符号数据，因为对于不同的数据类型,<code>string::npos</code>是不同；如果不是<code>string::npos</code>，返回值和<code>int</code>是没有区别的。</li>\n</ul>\n<p>以下代码可以输出全部的匹配位置：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> s1 = <span class=\"string\">\"abcdbcgbcdbjjkklbcdbcdbcdghjbcd\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">string</span> s2 = <span class=\"string\">\"bcd\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> k  = s1.<span class=\"built_in\">find</span>(s2);</span><br><span class=\"line\"><span class=\"keyword\">while</span> (k != <span class=\"built_in\">string</span>::npos)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;k&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\tk = s1.<span class=\"built_in\">find</span>(s2,k+<span class=\"number\">1</span>);\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"string-substr\"><a href=\"#string-substr\" class=\"headerlink\" title=\"string.substr()\"></a>string.substr()</h3><p>函数声明如下：<code>_Myt substr(size_type _Off = 0, size_type _Count = npos) const</code>，返回从指定位置(_Off)开始的长度为(_Count)的子字符串，注意缺省值取尽可能多的字符。</p>\n<h3 id=\"string-stoi\"><a href=\"#string-stoi\" class=\"headerlink\" title=\"string::stoi()\"></a>string::stoi()</h3><p>字符串转整型stringtoint:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">stoi</span> <span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp;  str, <span class=\"keyword\">size_t</span>* idx = <span class=\"number\">0</span>, <span class=\"keyword\">int</span> base = <span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">stoi</span> <span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">wstring</span>&amp; str, <span class=\"keyword\">size_t</span>* idx = <span class=\"number\">0</span>, <span class=\"keyword\">int</span> base = <span class=\"number\">10</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>对比而言<code>atoi()</code>功能类似，但其是C-stringtoint。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">atoi</span> <span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * str)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"完整的strcpy函数\"><a href=\"#完整的strcpy函数\" class=\"headerlink\" title=\"完整的strcpy函数\"></a>完整的strcpy函数</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> * <span class=\"title\">strcpy</span><span class=\"params\">( <span class=\"keyword\">char</span> *strDest, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *strSrc )</span> </span>&#123;</span><br><span class=\"line\">\tassert( (strDest != <span class=\"literal\">NULL</span>) &amp;&amp; (strSrc != <span class=\"literal\">NULL</span>) );</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> *address = strDest; </span><br><span class=\"line\">\t<span class=\"keyword\">while</span>( (*strDest++ = * strSrc++) != ‘\\<span class=\"number\">0</span>’ ); </span><br><span class=\"line\"> \t<span class=\"keyword\">return</span> address;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"cctype\"><a href=\"#cctype\" class=\"headerlink\" title=\"cctype\"></a>cctype</h2><p>主要是<code>cctype</code>头文件中的字符函数在编程过程中可以带来很多便利，常用的总结如下：</p>\n<ol>\n<li><code>isalpha()</code>,<code>isdigit()</code>,<code>isalnum()</code>可以用于判断是字符、数字、字母或数字。返回<code>true</code>或<code>false</code>。</li>\n<li><code>islower()</code>,<code>isupper()</code>,<code>isprint()</code>可以用于判断是小写字母、大写字符、可显示字符。返回<code>true</code>或<code>false</code>。<a href=\"https://zh.wikipedia.org/wiki/ASCII#.E5.8F.AF.E6.98.BE.E7.A4.BA.E5.AD.97.E7.AC.A6\" target=\"_blank\" rel=\"noopener\">可显示字符</a>从32到126一共95个。</li>\n<li><code>tolower()</code>,<code>toupper()</code>用于大小写字母的转换，如果不需要转换，字符不变。</li>\n<li>另外一些不常用的字符函数,<code>isgraph()</code>(除空格之外的打印字符),<code>ispunct()</code>(标点符号),<code>isspace()</code>(标准空白字符),<code>iscntrl()</code>(控制字符),<code>isxdigit()</code>(16进制,即1-9,a-f,A-F)。</li>\n<li>尤为注意的是除了这些判断函数，<code>&lt;cctype&gt;</code>中还包括两个转化函数(^.^主要是可以作为函数对象，很方便)</li>\n</ol>\n<hr>\n","categories":["STL"],"tags":["C++"]},{"title":"进制数转化与结构体","url":"https://applefishsky009.github.io/2016/04/21/进制数转化与结构体/","content":"<h2 id=\"进制转化\"><a href=\"#进制转化\" class=\"headerlink\" title=\"进制转化\"></a>进制转化</h2><ol>\n<li>控制符dec，hex，oct用于设置整数显式的进制数，分别对应十进制，16进制，八进制，语法：<code>cout&lt;&lt;dec;</code>,<code>cout&lt;&lt;hex;</code>,<code>cout&lt;&lt;oct</code>。</li>\n<li>头文件<code>cstdlib</code>中的<code>char *_itoa_s(int value,char string,int radix)</code>可以设置任一进制的输出。<ul>\n<li>参数一：要转换的数据；</li>\n<li>参数二：存放结果的字符串地址；</li>\n<li>参数三：进制数；</li>\n<li>返回值：指向结果字符串的指针。</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> s[<span class=\"number\">5</span>];</span><br><span class=\"line\">_itoa_s(num, s,<span class=\"number\">5</span>,<span class=\"number\">10</span>);\t<span class=\"comment\">//这里num最多是4位数，不能使用char *</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">sNum</span><span class=\"params\">(s)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h2><ol>\n<li>基本项，可以列表化，提倡外部结构声明，可以使用赋值运算符,列表初始化不允许缩窄转换。</li>\n<li>结构体对准：<ul>\n<li>结构体首地址能被其最宽基本类型成员的大小所整除；</li>\n<li>结构体每个成员相对于结构体首地址的偏移量(offset)都是成员大小整数倍；</li>\n<li>结构体的总大小是结构体最宽基本类型成员大小的整数倍。</li>\n</ul>\n</li>\n<li>与此相关还有栈对准，某些编译器(x64?)按大小对准，<code>char</code>位于栈底，<code>double</code>位于栈顶排列。找不到相关资料了，需要深入了解。</li>\n</ol>\n<p>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Definition for a binary tree node.</span><br><span class=\"line\">struct TreeNode &#123;</span><br><span class=\"line\">\tint val;</span><br><span class=\"line\">\tTreeNode *left;</span><br><span class=\"line\">\tTreeNode *right;</span><br><span class=\"line\">\tTreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","categories":["C++基础"],"tags":["C++"]},{"title":"类型转换","url":"https://applefishsky009.github.io/2016/04/20/类型转换/","content":"<p>C++自动执行以下类型转换：</p>\n<ul>\n<li>不同算术类型的赋值；</li>\n<li>包含不同类型的表达式；</li>\n<li>函数调用</li>\n</ul>\n<hr>\n<h2 id=\"初始化和赋值进行的转换\"><a href=\"#初始化和赋值进行的转换\" class=\"headerlink\" title=\"初始化和赋值进行的转换\"></a>初始化和赋值进行的转换</h2><p>扩展没有问题；缩窄可能会有一些问题:</p>\n<ul>\n<li>精度降低(double-&gt;float等);</li>\n<li>数字截短(float-&gt;int等);</li>\n<li>数据丢失(long-&gt;short等)。</li>\n</ul>\n<hr>\n<h2 id=\"列表初始化时的转换\"><a href=\"#列表初始化时的转换\" class=\"headerlink\" title=\"列表初始化时的转换\"></a>列表初始化时的转换</h2><p>不允许缩窄。</p>\n<hr>\n<h2 id=\"表达式的转换\"><a href=\"#表达式的转换\" class=\"headerlink\" title=\"表达式的转换\"></a>表达式的转换</h2><h3 id=\"自动转化\"><a href=\"#自动转化\" class=\"headerlink\" title=\"自动转化\"></a>自动转化</h3><p><code>int</code>型是计算机最自然的语言，运算速度最快。整型提升(integral promotion)规则如下:</p>\n<ol>\n<li>计算表达式时，C++将<code>bool</code>，<code>char</code>，<code>unsigned char</code>，<code>signed char</code>，<code>short</code>都转换为<code>int</code>；</li>\n<li>如果<code>short</code>和<code>int</code>一样长，<code>unsigned short</code>转换为<code>unsigned int</code>，如果<code>short</code>比<code>int</code>短，<code>unsigned short</code>转换为<code>int</code>。总之，以不损失数据为原则。</li>\n<li>在不损失数据的原则下，同级别有符号数比无符号数优先。</li>\n</ol>\n<h3 id=\"算术运算的转化\"><a href=\"#算术运算的转化\" class=\"headerlink\" title=\"算术运算的转化\"></a>算术运算的转化</h3><p>将较小的类型转换成较大的类型。依次判断long double?-&gt;double?-&gt;float?-&gt;integral promotion!可以看到浮点型优先于整型。具体过程可以查看C++11版本的效验表。</p>\n<hr>\n<h2 id=\"传递参数时的转换\"><a href=\"#传递参数时的转换\" class=\"headerlink\" title=\"传递参数时的转换\"></a>传递参数时的转换</h2><p>由C++函数原型控制，若取消函数原型的控制:</p>\n<ul>\n<li>将对<code>char</code>和<code>short</code>整型提升;</li>\n<li>将<code>float</code>参数提升为<code>double</code>。</li>\n</ul>\n<hr>\n<h2 id=\"强制类型转换\"><a href=\"#强制类型转换\" class=\"headerlink\" title=\"强制类型转换\"></a>强制类型转换</h2><p>C++设计新格式，让强制类型转换像函数一样调用:<code>typename (value)</code>更严格的限制允许的类型转换，以下4个类型转换符：</p>\n<ul>\n<li><code>dynamic_cast</code>;</li>\n<li><code>const_cast</code>;</li>\n<li><code>static_cast</code>;</li>\n<li><code>reinterpret_cast</code>;</li>\n</ul>\n<p>相关：因为指针大小固定(指针的本质是一个存放地址的内存，32位编译器是4字节),任意指针之间可以进行强制转化。</p>\n","categories":["C++基础"],"tags":["C++"]},{"title":"栈与字符型变量的地址","url":"https://applefishsky009.github.io/2016/04/20/栈与字符型变量的地址/","content":"<h2 id=\"栈的存储机制\"><a href=\"#栈的存储机制\" class=\"headerlink\" title=\"栈的存储机制\"></a>栈的存储机制</h2><p>在之前的内存存储区之中讲过栈，他大概有以下特点：编译器自助管理；空间大小指定；不会产生碎片；向下生长；静态(主要)或动态(不需要人工释放)分配；效率高。这里以下边的语句为例说明栈的存储：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint a[4] = &#123;1,2,3,4&#125;;</span><br><span class=\"line\">\tint b[4] = &#123;5,6,7,8&#125;;</span><br><span class=\"line\">\tint c[4] = &#123;9,10,11,12&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"http://i.imgur.com/r0E1t24.jpg\" alt=\"栈\"></p>\n<ol>\n<li>数组名称是一个指针，指向数组的第一个元素；</li>\n<li>a[-2]指的是a指针向栈的地址低位移动2个数据元素大小(例子中是int型)，即访问到b[2]，<strong>但是</strong>实际情况与编译器相关，他会做一些对准或者优化，明白访问原理即可；</li>\n<li>每一个元素在栈中的字节序是Little Endian，即低位字节排放在地址的低地址端，高位字节排放在地址的高地址端。与之对应的还有Big Endian，排放次序相反。</li>\n</ol>\n<hr>\n<h2 id=\"字符型变量的地址\"><a href=\"#字符型变量的地址\" class=\"headerlink\" title=\"字符型变量的地址\"></a>字符型变量的地址</h2><p>字符型变量<code>char c</code>的地址不能用<code>cout&lt;&lt;&amp;c；</code>来表示，因为<code>&amp;c</code>实际上是一个<code>char *</code>型的变量，它输出字符串的值，而字符串只有在内存中读到<code>\\0</code>才会终止，因此会出现乱码。所以要输出字符变量的地址，应该用以下语句告诉编译器如何解释：</p>\n<ol>\n<li><code>(int *)&amp;c</code>;</li>\n<li><code>(static_cast&lt;void *&gt;(&amp;jc)</code>。</li>\n</ol>\n<p>上述的<code>static_cast</code>用于显式类型转换。</p>\n","categories":["C++基础"],"tags":["C++"]},{"title":"unordered_set简介","url":"https://applefishsky009.github.io/2016/04/19/unordered_set容器简介/","content":"<p>先上彩蛋：</p>\n<ol>\n<li><a href=\"http://www.cplusplus.com/\" target=\"_blank\" rel=\"noopener\">cplusplus</a></li>\n<li><a href=\"http://en.cppreference.com/w/\" target=\"_blank\" rel=\"noopener\">cppreference</a></li>\n<li><a href=\"http://stackoverflow.com/\" target=\"_blank\" rel=\"noopener\">stackoverflow</a><br><code>#include &lt;unordered_set&gt;</code>头文件内定义了两个无序hash容器，<code>unordered_set</code>和<code>unordered_multiset</code>。</li>\n</ol>\n<hr>\n<h2 id=\"unordered-set简介\"><a href=\"#unordered-set简介\" class=\"headerlink\" title=\"unordered_set简介\"></a>unordered_set简介</h2><p>容器属性：</p>\n<ol>\n<li>Associative:通过key而不是绝对位置来引用;</li>\n<li>Unordered:无序，即通过hash表来组织数据，以支持通过key的快速访问；</li>\n<li>Set:键值就是值本身；</li>\n<li>Unique keys:这是一个一一映射</li>\n<li>Allocator-aware:使用分配器<code>allocator</code>来动态存储。</li>\n</ol>\n<p>特征补充：</p>\n<ol>\n<li><code>unordered_set简介</code>访问个体的速度比<code>set</code>更快，但是子集元素的范围迭代效率更低。</li>\n</ol>\n<hr>\n<h2 id=\"unordered-set简介-1\"><a href=\"#unordered-set简介-1\" class=\"headerlink\" title=\"unordered_set简介\"></a>unordered_set简介</h2><ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/126%20-%20Word%20Ladder%20II/126%20-%20Word%20Ladder%20II.cpp\" target=\"_blank\" rel=\"noopener\">Word Ladder II</a>；</li>\n</ol>\n<h3 id=\"insert\"><a href=\"#insert\" class=\"headerlink\" title=\"insert()\"></a>insert()</h3><p>因为key的唯一性，只有在没有这个key的情况下才能插入成功<code>_pair&lt;iterator,bool&gt; insert ( const value_type&amp; val );</code>;</p>\n<h3 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find()\"></a>find()</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">find</span> <span class=\"params\">( <span class=\"keyword\">const</span> key_type&amp; k )</span></span>;</span><br><span class=\"line\"><span class=\"function\">const_iterator <span class=\"title\">find</span> <span class=\"params\">( <span class=\"keyword\">const</span> key_type&amp; k )</span> <span class=\"keyword\">const</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>若找到该元素，返回的指针指向该元素，没找到返回的指针会指向超尾即<code>unordered_set::end</code>(<code>a.end()</code>)。</p>\n<h3 id=\"erase\"><a href=\"#erase\" class=\"headerlink\" title=\"erase()\"></a>erase()</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">by <span class=\"title\">position</span> <span class=\"params\">(<span class=\"number\">1</span>)</span>\titerator <span class=\"title\">erase</span> <span class=\"params\">( const_iterator <span class=\"built_in\">position</span> )</span></span>;</span><br><span class=\"line\"><span class=\"function\">by <span class=\"title\">key</span> <span class=\"params\">(<span class=\"number\">2</span>)</span>\tsize_type <span class=\"title\">erase</span> <span class=\"params\">( <span class=\"keyword\">const</span> key_type&amp; k )</span></span>;</span><br><span class=\"line\">range (<span class=\"number\">3</span>)\t<span class=\"function\">iterator <span class=\"title\">erase</span> <span class=\"params\">( const_iterator first, const_iterator last )</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>擦除指定值，容器重排。</p>\n<h3 id=\"count\"><a href=\"#count\" class=\"headerlink\" title=\"count()\"></a>count()</h3><p><code>size_type count(const Key&amp; keyval) const;</code>返回unordered_set中指定键对应的元素个数，由于其唯一性，只能返回1(存在)或0(不存在)。</p>\n","categories":["STL"],"tags":["C++"]},{"title":"默认参数与内联函数","url":"https://applefishsky009.github.io/2016/04/19/默认参数与内联函数/","content":"<h2 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h2><p>省略实参时自动使用的值，必须通过函数原型(这是因为函数调用时通过函数原型将函数参数压入栈帧)，使用方法是将值赋给原型中的值(压入栈帧并初始化)。 </p>\n<hr>\n<h2 id=\"内联函数\"><a href=\"#内联函数\" class=\"headerlink\" title=\"内联函数\"></a>内联函数</h2><p>常规函数和内联函数之间的主要区别是C++编译器如何将它们组合到程序中去。</p>\n<h3 id=\"C语言的宏\"><a href=\"#C语言的宏\" class=\"headerlink\" title=\"C语言的宏\"></a>C语言的宏</h3><p>宏是内联代码的原始实现，它的本质是<strong>文本替换</strong></p>\n<ol>\n<li>普通宏定义中，预处理器将空格解释成分段标志；</li>\n<li><code>##</code>是一种分隔连接方式，作用是先分隔后强制连接；</li>\n<li><code>#</code>表示变量替换后加双引号括起来。</li>\n<li>另外一些分隔符、操作符如<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>[</code>、<code>]</code>依然有意义。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define A1(name,type) type name_##type##_type</span><br><span class=\"line\">\tA1(a1,int) &lt;=&gt; int name_int_type</span><br><span class=\"line\">#define A1(name,type) type name##_##type##_type</span><br><span class=\"line\">\tA1(a1,int) &lt;=&gt; int a1_int_type</span><br><span class=\"line\">#define stringify(x) #x</span><br><span class=\"line\">\tstringify(linux) &lt;=&gt; &quot;linux&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"C-内联函数\"><a href=\"#C-内联函数\" class=\"headerlink\" title=\"C++内联函数\"></a>C++内联函数</h3><ol>\n<li>编译器将使用相应的函数代码替换函数调用(省略了来回跳跃并记录跳跃位置的过程)；</li>\n<li>运行速度较快，但占用更多的内存(同一个内联函数调用多少次，就有多少次副本)；</li>\n<li>一般省略原型(但原型特性仍在起作用)，将整个定义放在原本该提供原型的地方(这是首次使用前的函数定义，充当原型)，并使用<code>inline</code>关键字</li>\n<li>编译器并不一定满足程序员内联函数的请求，比如函数过大或者函数调用了自己(递归不能内联)。</li>\n</ol>\n<p>注意类成员函数中的内联函数并不一定使用<code>inline</code>关键字。定义位于类声明中自动成为内联函数；否则使用<code>inline</code>关键字作为内联函数。</p>\n","categories":["C++基础"],"tags":["C++"]},{"title":"函数原型与函数调用","url":"https://applefishsky009.github.io/2016/04/18/函数原型与函数调用/","content":"<h2 id=\"函数原型\"><a href=\"#函数原型\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h2><h3 id=\"为什么需要原型\"><a href=\"#为什么需要原型\" class=\"headerlink\" title=\"为什么需要原型\"></a>为什么需要原型</h3><p>原型是函数到编译器的接口，他将函数返回值的类型以及参数的类型和数量告诉编译器。</p>\n<ol>\n<li>原型告诉编译器函数参数类型和数量，如果不准确，它让编译器捕获这种错误</li>\n<li>函数完成计算后，将返回值放在指定的位置(<strong>CPU寄存器或者内存</strong>)以供调用函数取得。</li>\n<li>原型指出返回类型，让编译器知道应检索多少字节以及如何<em>解释</em>他们。</li>\n</ol>\n<h3 id=\"原型语法\"><a href=\"#原型语法\" class=\"headerlink\" title=\"原型语法\"></a>原型语法</h3><p>以<code>void cheers(int);</code>为例，</p>\n<ol>\n<li>函数原型是一条语句，必须以分号结尾；</li>\n<li>函数原型不要求提供变量名，有类型列表就够了(这与函数调用有关，原型中的变量名其实就是栈中的占位符)</li>\n</ol>\n<h3 id=\"原型功能\"><a href=\"#原型功能\" class=\"headerlink\" title=\"原型功能\"></a>原型功能</h3><ol>\n<li>编译器正确处理函数返回值(就是说在<strong>指定位置如何解释</strong>)；</li>\n<li>编译器检查使用的参数数目是否正确(<strong>不正确让编译器捕获错误</strong>)；</li>\n<li>编译器检查参数类型是否正确，如果不正确，可能的话转换为正确类型(编译阶段进行的原型化，静态类型检查)。如下<br><img src=\"http://i.imgur.com/5aaLwcA.png\" alt=\"函数原型进行类型转化\"></li>\n</ol>\n<hr>\n<h2 id=\"函数调用\"><a href=\"#函数调用\" class=\"headerlink\" title=\"函数调用\"></a>函数调用</h2><p>详细过程见<a href=\"http://www.zhihu.com/question/22444939#answer-4080329\" title=\"函数调用中栈的变化\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n<h3 id=\"相关寄存器\"><a href=\"#相关寄存器\" class=\"headerlink\" title=\"相关寄存器\"></a>相关寄存器</h3><ol>\n<li>栈指针寄存器：指向系统栈最上面一个帧栈栈底的指针；</li>\n<li>基址指针寄存器：指向系统栈最上面一个帧栈栈底的指针；</li>\n<li>指令寄存器：指向下一条待执行的指令地址。</li>\n</ol>\n<h3 id=\"函数调用步骤\"><a href=\"#函数调用步骤\" class=\"headerlink\" title=\"函数调用步骤\"></a>函数调用步骤</h3><ol>\n<li>参数入栈：C++将参数从右向左依次入栈；</li>\n<li>返回地址入栈：将<em>当前</em>代码区调用指令的<em>下一条</em>指令地址压入栈，函数返回时继续执行；</li>\n<li>代码区跳转：从当前代码区跳转到被调函数入口处；</li>\n<li>栈帧调整：<ul>\n<li>当前栈帧的EPB入栈；</li>\n<li>切换到新栈帧,ESP装入EBP；</li>\n<li>给新栈帧分配空间；</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h3><h4 id=\"为什么参数要入栈？\"><a href=\"#为什么参数要入栈？\" class=\"headerlink\" title=\"为什么参数要入栈？\"></a>为什么参数要入栈？</h4><p>为了保存现场，例如一个递归：<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int sum(int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif (n == 0)</span><br><span class=\"line\">\t\treturn 0;</span><br><span class=\"line\">\treturn sum(n-1)+n</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当<code>sum(n-1)</code>返回，他的栈帧被释放，还原到<code>sum(n)</code>的栈帧，那么n的值怎么获得？假如<code>sum</code>是在<code>main()</code>调用的，n在调用时压入了<code>main()</code>的栈帧，并对一个匿名对象拷贝了n的值供<code>sum()</code>计算，如果传地址或者引用就可以直接修改栈帧中的值。<br>这就可以解释为什么按值传递时不能修改上一级函数的数值，因为栈帧会还原，按值传递修改的也不是栈帧中的值。</p>\n","categories":["C++基础"],"tags":["C++"]},{"title":"类的复制构造函数和赋值运算符重载","url":"https://applefishsky009.github.io/2016/04/18/类的复制构造函数和赋值运算符重载/","content":"<p>C++会自动提供以下成员函数：</p>\n<ol>\n<li>默认构造函数；</li>\n<li>默认析构函数</li>\n<li>复制构造函数</li>\n<li>赋值运算符</li>\n<li>地址运算符</li>\n</ol>\n<p>之前讨论过构造函数与析构函数，今天讨论复制构造函数与赋值运算符。</p>\n<h2 id=\"类的复制构造函数\"><a href=\"#类的复制构造函数\" class=\"headerlink\" title=\"类的复制构造函数\"></a>类的复制构造函数</h2><p>原型：<code>A::A(const A &amp;a);</code></p>\n<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ol>\n<li>作用：复制构造函数用于将一个对象复制到新创建的对象中。也就是用于初始化过程（包括按值传递）,而不是常规的赋值过程。<strong>隐式构造函数<font color=\"red\">按值</font>逐个复制非静态成员</strong>,静态成员属于整个类，不属于某一个对象，因此不受影响。</li>\n<li>何时调用：新建一个对象并将其初始化为同类现有对象。有以下四种可能语法：<ul>\n<li><code>StringBad ditto(motto)</code>;</li>\n<li><code>StringBad *pStringBad = new StringBad(motto)</code>;</li>\n<li><code>StringBad metoo = motto</code>;</li>\n<li><code>StringBad also = StringBad(motto)</code>。</li>\n</ul>\n</li>\n</ol>\n<p>1、2两种声明没有临时匿名对象(或者说临时匿名对象有外部载体);3、4两种声明值是接创建metoo和also还是用复制构造函数构造临时对象然后对象赋值给metoo和also，取决于具体实现。<font color=\"red\">特点是有赋值运算符的非指针构造</font>，在本人的编译器上(VS2012 32)是有临时对象并析构的。</p>\n<h4 id=\"注：\"><a href=\"#注：\" class=\"headerlink\" title=\"注：\"></a>注：</h4><ol>\n<li>无论哪种编译器，按值传递和返回对象时，都将调用复制构造函数。</li>\n<li>由于1，复制构造函数必须<strong>接受类对象的常量引用</strong>作为参数，否则会无限递归调用自身导致堆栈溢出。</li>\n</ol>\n<h3 id=\"默认复制构造函数的缺陷-浅复制\"><a href=\"#默认复制构造函数的缺陷-浅复制\" class=\"headerlink\" title=\"默认复制构造函数的缺陷(浅复制)\"></a>默认复制构造函数的缺陷(浅复制)</h3><ol>\n<li>对象计数器：默认构造函数+显式构造函数+显式构造函数=析构函数。</li>\n<li>隐式复制构造函数是<strong>按值复制</strong>，对于指针指向的new出来的空间(动态分配的内存)，它会使两个指针指向同一块内容，因此在析构时，编译器尝试两次释放同一块内存，这会导致不确定的可能有害的结果。必须定义一个显式复制构造函数给指针开辟新的内存、</li>\n</ol>\n<hr>\n<h2 id=\"类的复制运算符重载-深度复制\"><a href=\"#类的复制运算符重载-深度复制\" class=\"headerlink\" title=\"类的复制运算符重载(深度复制)\"></a>类的复制运算符重载(深度复制)</h2><p>C++的类对象赋值通过自动为类重载赋值运算符实现。赋值运算符是只能由类成员函数重载的运算符之一。<br>如上所说四种新建对象方法，<em>初始化时总会调用复制构造函数，而是用<code>=</code>运算符也允许调用赋值运算符。</em>但是！赋值运算符的隐式实现也是对成员逐个赋值。那么如上也有两次析构的问题，因此应该提供赋值运算符进行深度复制。<br>其与复制构造函数的差别：</p>\n<ol>\n<li>应该首先检查自我复制，相同返回自身。否则未复制前释放了自身；</li>\n<li>释放拷贝对象之前引用的数据，否则会内存泄露(因为要深度复制会申请新的内存空间并指向他进行数据拷贝，之前的内存指针就丢失了)。</li>\n<li>返回一个指向调用对象的引用以便连续赋值。</li>\n</ol>\n<p>下面这个例子同时犯了复制构造函数和赋值运算符重载的浅复制错误：<br><img src=\"http://i.imgur.com/OwHR2qp.png\" alt=\"典型的浅复制错误\"></p>\n<hr>\n<h2 id=\"链表的陷阱\"><a href=\"#链表的陷阱\" class=\"headerlink\" title=\"链表的陷阱\"></a>链表的陷阱</h2><p>考虑类中的数据成员有链表，显然对于默认的复制构造和赋值运算符是不安全的，而<font color=\"red\">假设</font>我们不需要复制构造函数和赋值运算符重载，怎么忽略他们?</p>\n<p>将这些方法<strong>私有化</strong>。</p>\n<p>这样不会有默认的复制构造函数和赋值运算符重载，而且因为私有不能被广泛使用</p>\n<hr>\n<h2 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h2><ol>\n<li>为什么赋值运算符重载返回类型是引用？之前在<code>*this</code>指针中提过，返回类型为引用意味着返回对象本身而不是其副本。这样在一些含有赋值运算符的初始化中也可以防止递归调用。</li>\n<li>为什么参数类型为引用？对<em>复制构造函数</em>和<em>赋值运算符重载</em>，都是为了防止递归调用。</li>\n</ol>\n","categories":["C++的类"],"tags":["C++"]},{"title":"vector之resize方法和reverse方法","url":"https://applefishsky009.github.io/2016/04/15/vector之resize方法和reverse方法/","content":"<h2 id=\"a-resize-和a-reserve\"><a href=\"#a-resize-和a-reserve\" class=\"headerlink\" title=\"a.resize()和a.reserve();\"></a>a.resize()和a.reserve();</h2><ol>\n<li>首先介绍容器的两个属性<code>capacity</code>和<code>size</code>。<code>capacity</code>存储区的大小；<code>size</code>容器的大小。</li>\n<li><code>reserve()</code>是预分配存储区的大小，预分配存储区，但存储区不一定有容器对象。</li>\n<li><code>resize()</code>是改变容器大小，容器中一定有容器对象。</li>\n</ol>\n<hr>\n<h3 id=\"a-reserve\"><a href=\"#a-reserve\" class=\"headerlink\" title=\"a.reserve();\"></a>a.reserve();</h3><p>看源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void reserve(size_type _Count)</span><br><span class=\"line\">&#123;\t// determine new minimum length of allocated storage</span><br><span class=\"line\">\tif (capacity() &lt; _Count)</span><br><span class=\"line\">\t&#123;// something to do, check and reallocate</span><br><span class=\"line\">\t\tif (max_size() &lt; _Count)</span><br><span class=\"line\">\t\t\tXlen();</span><br><span class=\"line\">\t\t_Reallocate(_Count);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>没有<code>else</code>，说明若当前的<code>capacity</code>大于传入的值，<strong><code>capacity</code>是不会减小的</strong>；</li>\n<li>里层的if是错误检测机制；</li>\n<li>验证<code>vector</code>的<code>reallocate</code>原理，实际上每次新的<code>capacity</code>是之前的1.5倍。因此在<strong>循环之前一定要<code>reserve</code>保证效率</strong>。</li>\n</ol>\n<hr>\n<h3 id=\"a-resize\"><a href=\"#a-resize\" class=\"headerlink\" title=\"a.resize();\"></a>a.resize();</h3><p>模板类提供了两个函数重载：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">表达式</th>\n<th align=\"center\"><strong>返回类型</strong></th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>a.resize(n)</code></td>\n<td align=\"center\">void</td>\n<td align=\"center\">容器大小设为n</td>\n</tr>\n<tr>\n<td align=\"center\"><code>a.resize(n,t)</code></td>\n<td align=\"center\">void</td>\n<td align=\"center\">容器大小设为n，必要时用t填充</td>\n</tr>\n</tbody></table>\n<h4 id=\"a-resize-n\"><a href=\"#a-resize-n\" class=\"headerlink\" title=\"a.resize(n)\"></a>a.resize(n)</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void resize(size_type _Newsize)</span><br><span class=\"line\">&#123;\t// determine new length, padding as needed</span><br><span class=\"line\">\tif (_Newsize &lt; size())</span><br><span class=\"line\">\t\terase(begin() + _Newsize, end());</span><br><span class=\"line\">\telse if (size() &lt; _Newsize)</span><br><span class=\"line\">\t&#123;\t// pad as needed</span><br><span class=\"line\">\t\t_Alty _Alval(this-&gt;_Getal());</span><br><span class=\"line\">\t\t_Reserve(_Newsize - size());</span><br><span class=\"line\">\t\t_TRY_BEGIN</span><br><span class=\"line\">\t\t_Uninitialized_default_fill_n(this-&gt;_Mylast, _Newsize - size(),_Alval);</span><br><span class=\"line\">\t\t_CATCH_ALL</span><br><span class=\"line\">\t\t_Tidy();</span><br><span class=\"line\">\t\t_RERAISE;</span><br><span class=\"line\">\t\t_CATCH_END</span><br><span class=\"line\">\t\tthis-&gt;_Mylast += _Newsize - size();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>若容器新大小小于现在的大小，毁掉多余的对象；</li>\n<li>新大小大于现在的大小：<ul>\n<li>注意<code>_Reserve</code>和<code>.reverse</code>是两个不同的方法，一个比较<code>capacity</code>，一个比较<code>_Unused_capacity</code>；</li>\n<li>检查空间，不够则<code>reverse</code>；</li>\n<li>填充未初始化的对象</li>\n<li>修改尾指针</li>\n</ul>\n</li>\n</ol>\n<p>####a.resize(n,t)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void resize(size_type _Newsize, const value_type&amp; _Val)</span><br><span class=\"line\">&#123;\t// determine new length, padding with _Val elements as needed</span><br><span class=\"line\">\tif (_Newsize &lt; size())</span><br><span class=\"line\">\t\terase(begin() + _Newsize, end());</span><br><span class=\"line\">\telse if (size() &lt; _Newsize)</span><br><span class=\"line\">\t\t_Insert_n(end(), _Newsize - size(), _Val);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>若容器新大小小于现在的大小，毁掉多余的对象；</li>\n<li>新大小大于现在的大小，直接执行<code>insert</code>;</li>\n</ol>\n<hr>\n","categories":["STL"],"tags":["C++"]},{"title":"vector之erase方法","url":"https://applefishsky009.github.io/2016/04/14/vector之erase方法/","content":"<h2 id=\"a-erase\"><a href=\"#a-erase\" class=\"headerlink\" title=\"a.erase();\"></a>a.erase();</h2><p>模板类提供了两个函数重载：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">表达式</th>\n<th align=\"center\"><strong>返回类型</strong></th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>a.erase(p)</code></td>\n<td align=\"center\"><strong>迭代器</strong></td>\n<td align=\"center\">删除p指向的元素</td>\n</tr>\n<tr>\n<td align=\"center\"><code>a.erase(p,q)</code></td>\n<td align=\"center\"><strong>迭代器</strong></td>\n<td align=\"center\">删除区间[p,q)中的元素</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>思考</strong>:</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">1.    在之前内存之中讨论过，<code>vector</code>是保证内存连续的，那么<code>erase</code>之后他是如何保证内存连续的？答案是让该元素之后的所有元素前移补充“空位”。这一点在<code>erase()</code>方法的代码中可以看到传入的p的形参是<code>const</code>类型的，也就是说p指向的地址并不发生变化，只不过是元素前移了。测试如下：</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"><img src=\"http://i.imgur.com/TZxRRb6.png\" alt=\"STL的迭代器\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">2. 注意到<code>erase</code>返回的都是迭代器，由1中的分析可知，删除p指向的元素之后，他返回的迭代器的<strong>地址不变</strong>，值是删除之后可用的下一个元素，因此<strong>给人感觉是p指向了下一个元素</strong>。那么在这里有一个值得注意的问题，如下：</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::iterator p = b.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (;p!=b.<span class=\"built_in\">end</span>();p++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (*p == <span class=\"number\">2</span>)</span><br><span class=\"line\">\t\tb.erase(p);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>这是错误的，<code>b.erase(p)</code>没有迭代器来承接p的返回值，它的返回值被释放了。然后执行p++很显然会出现野指针。但是如果修改为<code>p = b.erase(p)</code>也是不正确的。迭代器在进行删除的这一个循环里会<code>++</code>两次（<code>erase</code>可以当做<code>++</code>一次）。但如果在<code>if</code>语句中执行一次<code>p--</code>，这是正确的。即<code>p = --b.erase(p);</code>，逻辑上是这样，但有时候这样会出现问题，因此最好用<code>else</code>来控制迭代器自增。</p>\n<ol>\n<li>不能用<code>p-- = b.erase(p);</code>，因为<code>p--</code>是表达式，不能为左值；</li>\n<li>不能用<code>p = b.erase(p--);</code>，也是因为<code>p--</code>是一个表达式，强调计算结果，不能作为左值，也不能取址。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> p = <span class=\"built_in\">bitSet</span>.<span class=\"built_in\">begin</span>(); p != <span class=\"built_in\">bitSet</span>.<span class=\"built_in\">end</span>();)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (??)</span><br><span class=\"line\">\t\tp = <span class=\"built_in\">bitSet</span>.erase(p);</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tp++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> <strong>迭代器的循环使用<code>while</code>可以降低错误率。</strong></p>\n<hr>\n<p>为简单，分析第一个表达式的源码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">iterator <span class=\"title\">erase</span><span class=\"params\">(const_iterator _Where)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;\t<span class=\"comment\">// erase element at where</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (_VICONT(_Where) != <span class=\"keyword\">this</span></span><br><span class=\"line\">\t\t|| _VIPTR(_Where) &lt; <span class=\"keyword\">this</span>-&gt;_Myfirst</span><br><span class=\"line\">\t\t|| <span class=\"keyword\">this</span>-&gt;_Mylast &lt;= _VIPTR(_Where))</span><br><span class=\"line\">\t\t_DEBUG_ERROR(<span class=\"string\">\"vector erase iterator outside range\"</span>);</span><br><span class=\"line\">\t_Move(_VIPTR(_Where) + <span class=\"number\">1</span>, <span class=\"keyword\">this</span>-&gt;_Mylast, _VIPTR(_Where));</span><br><span class=\"line\">\t_Destroy(<span class=\"keyword\">this</span>-&gt;_Mylast - <span class=\"number\">1</span>, <span class=\"keyword\">this</span>-&gt;_Mylast);</span><br><span class=\"line\">\t_Orphan_range(_VIPTR(_Where), <span class=\"keyword\">this</span>-&gt;_Mylast);</span><br><span class=\"line\">\t--<span class=\"keyword\">this</span>-&gt;_Mylast;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (_Make_iter(_Where));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">void</span> _Orphan_range(pointer _First, pointer _Last) <span class=\"keyword\">const</span></span><br><span class=\"line\">\t\t&#123;\t<span class=\"comment\">// orphan iterators within specified (inclusive) range</span></span><br><span class=\"line\">\t\t_Lockit _Lock(_LOCK_DEBUG);</span><br><span class=\"line\">\t\tconst_iterator **_Pnext = (const_iterator **)<span class=\"keyword\">this</span>-&gt;_Getpfirst();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (_Pnext != <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t&#123;\t<span class=\"comment\">// test an iterator</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (*_Pnext != <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> ((*_Pnext)-&gt;_Ptr &lt; _First || _Last &lt; (*_Pnext)-&gt;_Ptr)</span><br><span class=\"line\">\t\t\t\t\t_Pnext = (const_iterator **)(*_Pnext)-&gt;_Getpnext();</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t\t&#123;\t<span class=\"comment\">// orphan the iterator</span></span><br><span class=\"line\">\t\t\t\t\t(*_Pnext)-&gt;_Clrcont();\t<span class=\"comment\">//WTF!!!!!!!!!!!</span></span><br><span class=\"line\">\t\t\t\t\t*_Pnext = *(const_iterator **)(*_Pnext)-&gt;_Getpnext();</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到他做了哪些工作,首先元素前移，然后毁掉最后一个对象(<code>capacity</code>不变)，之后<font color=\"red\">_Orphan_range将这个位置以及之后的孤儿迭代器失效了！WTF!!!</font>(也许是基于安全考虑),接下来指向正确的尾部元素，最后<font color=\"red\">总算有点良心</font>，返回值是<code>erase()</code>元素之后的下一个元素(也认为是位置不变)，即返回指向原地址的迭代器。</p>\n<h2 id=\"迭代器的有效性\"><a href=\"#迭代器的有效性\" class=\"headerlink\" title=\"迭代器的有效性\"></a>迭代器的有效性</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::iterator t;\t<span class=\"comment\">//便于说明此处不初始化</span></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::iterator k = result.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::iterator p = result.<span class=\"built_in\">begin</span>() + <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::iterator q = result.<span class=\"built_in\">begin</span>() + <span class=\"number\">2</span>;</span><br><span class=\"line\">t = result.erase(p);</span><br></pre></td></tr></table></figure>\n\n<p>看这个句法，以此为例，在<a href=\"http://www.cplusplus.com/reference/vector/vector/erase/\" target=\"_blank\" rel=\"noopener\">Cplusplus</a>上提到这一点，：</p>\n<blockquote>\n<p>Iterators, pointers and references pointing to position (or first) and beyond are invalidated, with all iterators, pointers and references to elements before position (or first) are guaranteed to keep referring to the same elements they were referring to before the call.</p>\n</blockquote>\n<p>大意是指向p以及之后的孤儿迭代器都不可用了(p和q)，但是指向p之前的孤儿迭代器以及<code>erase()</code>方法返回的孤儿迭代器都是可用的(k和t)。</p>\n<p>因此在使用多个迭代器的时候一定要注意迭代器是否有效(特别是涉及<code>erase()</code>和<code>insert()</code>方法)，这种情况下最好使用<code>index</code>下标作为循环而不是孤儿迭代器。</p>\n<ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/56%20-%20Merge%20Intervals/56%20-%20Merge%20Intervals.cpp\" target=\"_blank\" rel=\"noopener\">Merge Intervals</a><ul>\n<li>注意Two Pointers的用法</li>\n</ul>\n</li>\n</ol>\n","categories":["STL"],"tags":["C++"]},{"title":"vector之insert方法和emplace方法","url":"https://applefishsky009.github.io/2016/04/13/vector之insert方法和emplace方法/","content":"<h2 id=\"a-insert\"><a href=\"#a-insert\" class=\"headerlink\" title=\"a.insert();\"></a>a.insert();</h2><p>模板类提供了三个函数重载,这是一种<strong>拷贝</strong>插入方法：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">表达式</th>\n<th align=\"center\">返回类型</th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>a.insert(p,t)</code></td>\n<td align=\"center\">迭代器</td>\n<td align=\"center\">指向原本指向的元素,将t插入到p前面</td>\n</tr>\n<tr>\n<td align=\"center\"><code>a.insert(p, n,t)</code></td>\n<td align=\"center\"><code>void</code></td>\n<td align=\"center\">将n个t插入到p前面</td>\n</tr>\n<tr>\n<td align=\"center\"><code>a.insert(p,i,j)</code></td>\n<td align=\"center\"><code>void</code></td>\n<td align=\"center\">将区间[i,j)插入到p的前面，注意是左闭右开区间，j可以是超尾</td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"a-emplace\"><a href=\"#a-emplace\" class=\"headerlink\" title=\"a.emplace();\"></a>a.emplace();</h2><p>新标准引入的<code>emplace_front</code>,<code>emplace</code>,<code>emplace_back</code>这些操作是构造而不是拷贝元素。当插入一个对象时，将会比<code>insert</code>少拷贝构造，析构的步骤。</p>\n<hr>\n<h3 id=\"注：\"><a href=\"#注：\" class=\"headerlink\" title=\"注：\"></a>注：</h3><ol>\n<li>调用<code>push</code>或<code>insert</code>成员函数，将元素类型对象传递进去，这些对象被拷贝到容器中；</li>\n<li><code>emplace()</code>在容器中构造元素，因此效率更高；</li>\n<li>注意<code>a.insert(p,t)</code>的源码提供了一个重载，若t是普通类型，则调用<code>a.emplace(p，t)</code>，若t是<code>const</code>类型，则调用<code>a.insert(p,t)</code>。</li>\n</ol>\n","categories":["STL"],"tags":["C++"]},{"title":"vector简介及非STL函数用法-持续更新","url":"https://applefishsky009.github.io/2016/04/12/vector简介及非STL函数用法-持续更新/","content":"<h2 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h2><p><code>vector</code>模板类是最简单的序列类型，除非其他类型的特殊有点能够满足程序的要求，否则应该默认使用这种类型。以后将记录一些在编程过程中常用的<code>vector</code>方法作为笔记以便不时复习，必要时会分析源码。</p>\n<p>常见的方法有：<br><code>.insert()</code>，<code>a.emplace()</code>，<code>.resize()</code>，<code>.reverse()</code>，<code>.begin()</code>，<code>a.end()</code>，<code>a.rbegin()</code>，<br><code>a.rend()</code>，<code>a.size()</code>，<code>a.swap(b)</code>，<code>a.empty()</code>，<code>a.front()</code>，<code>a.back()</code>，<code>a.clear()</code>，<br><code>a.push_back(t)</code>，<code>a.popback(t)</code>，<code>a[n]</code>，<code>a.at(n)</code>。</p>\n<p>有<code>vector&lt;int&gt; a</code>;<code>vector&lt;int&gt; b</code>;即a,b是<code>vector&lt;int&gt;</code>的对象。<code>vector&lt;int&gt; ::iterator p</code>;p是指向<code>vector&lt;int&gt;</code>的迭代器。i、j、q均和p一样是指向<code>vector&lt;int&gt;</code>的迭代器。</p>\n<hr>\n<h2 id=\"使用列表初始化构造匿名对象\"><a href=\"#使用列表初始化构造匿名对象\" class=\"headerlink\" title=\"使用列表初始化构造匿名对象\"></a>使用列表初始化构造匿名对象</h2><p>语法如下：<br><code>vector&lt;int&gt; () = {1,2,3,4,5,6};</code>。</p>\n<hr>\n<h2 id=\"push-back\"><a href=\"#push-back\" class=\"headerlink\" title=\"push_back()\"></a>push_back()</h2><p>平时使用<code>push_back()</code>方法觉得非常简单，但是有一些值得注意的地方：</p>\n<h3 id=\"迭代器有效性\"><a href=\"#迭代器有效性\" class=\"headerlink\" title=\"迭代器有效性\"></a>迭代器有效性</h3><p>如果在<code>push_back()</code>时候有内存分配行为(reallocation)，他所有的迭代器都会失效，这是因为容器可能不在原先的内容处而被拷贝到另一处。 因此可以在<code>push_back()</code>之前调用<code>reverse()</code>方法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_back</span><span class=\"params\">(<span class=\"keyword\">const</span> value_type&amp; _Val)</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;\t<span class=\"comment\">// insert element at end</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (_Inside(_STD addressof(_Val)))</span><br><span class=\"line\">\t\t&#123;\t<span class=\"comment\">// push back an element</span></span><br><span class=\"line\">\t\tsize_type _Idx = _STD addressof(_Val) - _Unfancy(<span class=\"keyword\">this</span>-&gt;_Myfirst());</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;_Mylast() == <span class=\"keyword\">this</span>-&gt;_Myend())</span><br><span class=\"line\">\t\t\t_Reserve(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t_Orphan_range(<span class=\"keyword\">this</span>-&gt;_Mylast(), <span class=\"keyword\">this</span>-&gt;_Mylast());</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;_Getal().construct(_Unfancy(<span class=\"keyword\">this</span>-&gt;_Mylast()),<span class=\"keyword\">this</span>-&gt;_Myfirst()[_Idx]);</span><br><span class=\"line\">\t\t++<span class=\"keyword\">this</span>-&gt;_Mylast();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;\t<span class=\"comment\">// push back a non-element</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>-&gt;_Mylast() == <span class=\"keyword\">this</span>-&gt;_Myend())</span><br><span class=\"line\">\t\t\t_Reserve(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t_Orphan_range(<span class=\"keyword\">this</span>-&gt;_Mylast(), <span class=\"keyword\">this</span>-&gt;_Mylast());</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>-&gt;_Getal().construct(_Unfancy(<span class=\"keyword\">this</span>-&gt;_Mylast()),_Val);</span><br><span class=\"line\">\t\t++<span class=\"keyword\">this</span>-&gt;_Mylast();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"sort-用于vector\"><a href=\"#sort-用于vector\" class=\"headerlink\" title=\"sort()用于vector;\"></a>sort()用于vector;</h2><p>在<code>algorithm&gt;</code>头文件中提供了<code>sort</code>的两个重载函数,查看源码可发现是用<strong>快排</strong>实现的。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">表达式</th>\n<th align=\"center\"><strong>返回类型</strong></th>\n<th align=\"center\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>sort(p,q)</code></td>\n<td align=\"center\"><code>void</code></td>\n<td align=\"center\">对[p,q)升序排序</td>\n</tr>\n<tr>\n<td align=\"center\"><code>sort(p,q,cmp)</code></td>\n<td align=\"center\"><code>void</code></td>\n<td align=\"center\">对[p,q)使用<code>cmp</code>方法排序，<code>cmp</code></td>\n</tr>\n</tbody></table>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">comp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;a,<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> &amp;b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  \t\t<span class=\"keyword\">return</span> a&gt;b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>右闭左开区间，一般来讲<code>p = a.begin()</code>;<code>q = a.end()</code>完成了对容器的排序；</li>\n<li>升序排序直接用第一个方法，系统默认<code>a&lt;b</code>返回真，因此是升序；</li>\n<li>降序排序需要自定义<code>cmp</code>方法,方法如下，只需要将默认值改为<code>a&gt;b</code>；</li>\n<li>第二种表达式的主要作用是对一些自己构造的数据结构可以自定义排序方法，可以这么写：<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sort(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>(), [](<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b) &#123;<span class=\"keyword\">return</span> a &lt; b;&#125;);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>例子：</p>\n<ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/56%20-%20Merge%20Intervals/56%20-%20Merge%20Intervals.cpp\" target=\"_blank\" rel=\"noopener\">Merge Intervals</a></li>\n</ol>\n<hr>\n<p>以上参考了<a href=\"http://www.cnblogs.com/cj695/p/3863142.html\" title=\"这里\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n","categories":["STL"],"tags":["C++"]},{"title":"类的this指针和对象数组","url":"https://applefishsky009.github.io/2016/04/12/类的this指针和对象数组/","content":"<h2 id=\"C-类的this指针\"><a href=\"#C-类的this指针\" class=\"headerlink\" title=\"C++类的this指针\"></a>C++类的this指针</h2><p>如图，假设有一个类<code>Stock</code>，他有一个<code>private：int val</code>。他还有一个方法<code>const Stock&amp; Stock::compare(const Stock &amp;classIn) const</code>;这个方法要实现这样的功能：对于两个类<code>Stock</code>的对象a和b，比较a的<code>val</code>和b的<code>val</code>，返回<code>val</code>大的对象(a或者b)，可能性的写法如下：<code>a.compare(b)</code>。由于在类的方法定义中，还没有具体对象(a)。那么有这样一个问题，在方法<code>compare</code>中，如何返回以后才初始化的对象本身(也就是a)？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">const</span> Stock &amp; <span class=\"title\">Stock::topval</span><span class=\"params\">(<span class=\"keyword\">const</span> Stock &amp;s)</span><span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (s.totla_val &gt; total_val)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> ???;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>一般来说，所有类方法都将<code>this</code>指针设置为调用它的<strong>地址</strong>。(因此返回对象使用<strong><code>*this</code></strong>)</li>\n<li><code>compare</code>方法返回类型是<em>指针意味着返回的是调用对象本身，而不是其副本</em>。</li>\n<li><code>compare</code>方法的最后一个<code>const</code>表示该方法不会修改隐式访问对象(即调用该方法的对象本身)，这在之前的博客中提到过。</li>\n<li>形参列表中的<code>const</code>表示该函数不会修改被显示访问的对象(即图中的s)。</li>\n<li>由于该函数返回了两个<code>const</code>对象之一的引用，因此<strong>返回类型也应该是<code>const</code>引用</strong>。</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">const</span> Stock &amp; <span class=\"title\">Stock::topval</span><span class=\"params\">(<span class=\"keyword\">const</span> Stock &amp;s)</span><span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (s.totla_val &gt; total_val)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"对象数组\"><a href=\"#对象数组\" class=\"headerlink\" title=\"对象数组\"></a>对象数组</h2><p>对象数组需要明白一个问题，创造对象数组的时候这个数组中的所有对象都是被初始化过的；<br>创建对象数组将使用<strong>默认构造函数</strong>初始化每个对象数组的元素，可以用列表初始化指定特定的构造函数来初始化指定的对象。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tA() &#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"init\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\">\tA(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> s) &#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"string init\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\">\t~A() &#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"des\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tA s[<span class=\"number\">3</span>];\t<span class=\"comment\">//notice: all the object are constructed;</span></span><br><span class=\"line\">\t\tA q[<span class=\"number\">3</span>] = &#123; A(),A(<span class=\"string\">\"test\"</span>) &#125;;</span><br><span class=\"line\">\t\tA *p = <span class=\"keyword\">new</span> A[<span class=\"number\">3</span>]&#123; A(),A(<span class=\"string\">\"test\"</span>) &#125;;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> []p;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["C++的类"],"tags":["C++"]},{"title":"溢出","url":"https://applefishsky009.github.io/2016/04/11/溢出/","content":"<h2 id=\"数值溢出原理\"><a href=\"#数值溢出原理\" class=\"headerlink\" title=\"数值溢出原理\"></a>数值溢出原理</h2><p><img src=\"http://i.imgur.com/W3CYdOb.png\" alt=\"数值圆图\"><br>C++Plus在P44已经说的很清楚，如下。<br>有几点需要注意的地方：</p>\n<ol>\n<li>上图下图中的圆在进行<strong>强制类型转化</strong>时也是<strong>对应</strong>的，这就是说<code>(uchar)-1 = 65535</code>。</li>\n<li>无符号数没有溢出，只有<strong>进/借位</strong>(微机原理<code>CF</code>标示)，因为C++确保无符号数类型超越限制后在另一极端取值的行为。</li>\n<li>有符号数没有进/借位，只有<strong>溢出</strong>(微机原理<code>OF</code>标示)，因为C++无法确保有符号数上溢下溢后在另一极端取值的行为。(在我测试的时候并没有发现违背这一现象，可能有特殊情况)。</li>\n</ol>\n<p>(2016.5.23更新)，明白了反码存在的意义，很显然就清楚数值转化的原理，也就是说，补码中没有任何变化(因为硬件没有有符号无符号，只能根据输出设置标识位让编译器去解释)，就只是最高位解释为数字还是符号位!!!<br><a href=\"http://blog.sina.com.cn/s/blog_6e44841b0100n2h6.html\" target=\"_blank\" rel=\"noopener\">汇编的一个标准两套指令</a></p>\n<hr>\n<h2 id=\"运算溢出\"><a href=\"#运算溢出\" class=\"headerlink\" title=\"运算溢出\"></a>运算溢出</h2><h3 id=\"判断加法溢出\"><a href=\"#判断加法溢出\" class=\"headerlink\" title=\"判断加法溢出\"></a>判断加法溢出</h3><p>可以像这里一样分情况或者根据圆图分析，会发现</p>\n<ol>\n<li>所有上溢结果都小于任何一个操作数；</li>\n<li>所有下溢结果都大于任何一个操作数。</li>\n</ol>\n<h3 id=\"判断乘法溢出\"><a href=\"#判断乘法溢出\" class=\"headerlink\" title=\"判断乘法溢出\"></a>判断乘法溢出</h3><ol>\n<li>在这里提到，可以用检测<code>a*b/b</code>是否等于a来判断是否乘法溢出；</li>\n<li>在这里提到，可以先扩展再强制类型转化到低位，在判断是否相等来判断。</li>\n</ol>\n<p>值得注意的是，在之前的帖子中提到过判断是否相等对<strong>浮点数</strong>和整型的判断方式是不一样的。</p>\n<h3 id=\"除零是不是溢出？\"><a href=\"#除零是不是溢出？\" class=\"headerlink\" title=\"除零是不是溢出？\"></a>除零是不是溢出？</h3><p>任何数除以零的计算“不是”算术溢出的一种。在数学上只能明显算是不明确的定义；它计算出来的结果只能当成是“没有”值，而不是非常大的无限数值。</p>\n<p>应付溢出最佳的方法还是防范，充分了解数据类型，选择恰当的变量类型。比如，<code>c = a*b</code>一般都会选择c的长度为a的长度与b的长度之和。</p>\n<h3 id=\"异常中的上溢和下溢\"><a href=\"#异常中的上溢和下溢\" class=\"headerlink\" title=\"异常中的上溢和下溢\"></a>异常中的上溢和下溢</h3><p><code>runtime_error</code>类含有三个用于报告的错误类型:</p>\n<ol>\n<li><code>range_error</code>，不在函数允许范围内，但没有上溢或者下溢;</li>\n<li><code>overflow_error</code>，计算结果小于浮点类型可以表示的最小类型值;</li>\n<li><code>underflow_error</code>，计算结果超出了某种类型(浮点或整型)所能表示的最大数量级;</li>\n</ol>\n<hr>\n<h2 id=\"堆栈溢出\"><a href=\"#堆栈溢出\" class=\"headerlink\" title=\"堆栈溢出\"></a><a href=\"https://zh.wikipedia.org/wiki/%E5%A0%86%E7%96%8A%E6%BA%A2%E4%BD%8D\" target=\"_blank\" rel=\"noopener\">堆栈溢出</a></h2><p>一般编译器默认的堆栈内存是1MB，若使用过多的堆栈内存时就会导致调用堆栈产生的溢出。一般产生于递归，或者静态申请过多的临时变量，比如<code>int a[1024[1024]</code>。</p>\n<ol>\n<li>若是静态内存导致的堆栈溢出，可以用动态申请使用堆内存。</li>\n<li>若是递归调用导致递归堆栈无法容纳调用的返回地址，要添加错误检查机制。注意数据类型或用循环处理来避免堆栈溢出。</li>\n</ol>\n<hr>\n<h2 id=\"缓冲区溢出\"><a href=\"#缓冲区溢出\" class=\"headerlink\" title=\"缓冲区溢出\"></a>缓冲区溢出</h2><p><a href=\"http://jingyan.baidu.com/article/e9fb46e1acc1267521f76633.html\" target=\"_blank\" rel=\"noopener\">缓冲区溢出</a>源于这样一个编程错误：复制一个内存区域的内容到另一个内存区域，而目标内存区域容量太小无法容纳。它允许传入函数的内存块以一种特定方式修改堆栈。</p>\n<p>此外的溢出还包括<a href=\"https://zh.wikipedia.org/wiki/%E7%AE%97%E6%9C%AF%E4%B8%8B%E6%BA%A2\" target=\"_blank\" rel=\"noopener\">算术下溢</a>(浮点数溢出)等。</p>\n","categories":["C++基础"],"tags":["C++"]},{"title":"数据存储与二进制运算","url":"https://applefishsky009.github.io/2016/04/09/数据存储与二进制运算/","content":"<h2 id=\"数据存储\"><a href=\"#数据存储\" class=\"headerlink\" title=\"数据存储\"></a>数据存储</h2><h3 id=\"为什么需要反码和补码-2016-5-23添加\"><a href=\"#为什么需要反码和补码-2016-5-23添加\" class=\"headerlink\" title=\"为什么需要反码和补码(2016.5.23添加)\"></a>为什么需要反码和补码(2016.5.23添加)</h3><p>之前几乎在所有的课本上看到为了方便计算，所以有了反码和补码，但是为什么?这两天在看斯坦福的公开课的时候恍然大悟，一个例子说明，<code>1+-1=0</code>在内存中怎么计算?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00000001+10000001=10000010;1+-1=-2? WTF?</span><br><span class=\"line\">\\therefore</span><br><span class=\"line\">00000001+11111110(反码)=11111111;</span><br><span class=\"line\">11111111+00000001=0;</span><br></pre></td></tr></table></figure>\n\n<p>因此很显然，反码存在就是和原码相加之后得到所有位都是1，然后加1就得到了0。<br>多么美妙的二进制运算,以前太多孤陋寡闻,居然不知道这个道理。</p>\n<h3 id=\"原、反、补码\"><a href=\"#原、反、补码\" class=\"headerlink\" title=\"原、反、补码\"></a>原、反、补码</h3><p>计算机为方便计算，内存中的数据都是以补码的形式储存、运算。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">数</th>\n<th align=\"center\">原码</th>\n<th align=\"center\">反码</th>\n<th align=\"center\">补码</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">正数</td>\n<td align=\"center\">二进制表示</td>\n<td align=\"center\">与原码相同</td>\n<td align=\"center\">与原码相同</td>\n</tr>\n<tr>\n<td align=\"center\">负数</td>\n<td align=\"center\">对应正数符号位（最高位）置1</td>\n<td align=\"center\">负数原码<strong>非符号位</strong>按位取反</td>\n<td align=\"center\">负数反码加1</td>\n</tr>\n</tbody></table>\n<p>举个例子，数据类型为<code>char</code>：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">原数字</th>\n<th align=\"center\">原码</th>\n<th align=\"center\">反码</th>\n<th align=\"center\">补码</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>+3</code></td>\n<td align=\"center\"><code>00000011</code></td>\n<td align=\"center\"><code>00000011</code></td>\n<td align=\"center\"><code>00000011</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>-3</code></td>\n<td align=\"center\"><code>10000011</code></td>\n<td align=\"center\"><code>11111100</code></td>\n<td align=\"center\"><code>11111101</code></td>\n</tr>\n<tr>\n<td align=\"center\">值得注意的是，如果这个数据为<code>unsigned char</code>，<code>11111101</code>对应的是253，这里涉及到溢出，详细讨论见下一博客。</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h3 id=\"消失的原码\"><a href=\"#消失的原码\" class=\"headerlink\" title=\"消失的原码\"></a>消失的原码</h3><p>对于<code>unsigned char</code>原反补相同，计算机存储的补码就是原码，原码二进制经典编码有256个；但是对于<code>signed char</code>，最高位是符号位，因此原码的取值范围是-127-127，只有<strong>255个编码</strong>，但是对内存来说，8bits可以编码256个，那多余的补码与消失的原码去了哪里？</p>\n<p>考虑到编码效率，补码与原码必须是一一对应的关系。很容易想到在有符号数中有<code>00000000</code>、<code>10000000</code>两个原码表示+0与-0，而这是没有意义的。我们保证<code>00000000</code>这个原码与<code>00000000</code>这个补码相对应来表示0就可以。这样找到了消失的原码：<code>10000000</code>。</p>\n<p>在这个基于256的数值域中，观察补码的<strong>重置点（溢出中非常重要的概念）</strong>127的补码<code>01111111</code>，-127的补码<code>10000001</code>，那么可以清楚的看到<code>127+1=？</code>、<code>？+1=127</code>。因此很好理解，多余的补码是<code>10000000</code>（与消失的原码相同，通过计算他的原码可以得到验证）。那么剩下的事情就是设置重置点了，有两个选择，128或者-128。考虑到符号位是1，我们人为规定-128是重置点。即<strong>-128的原码</strong>是<code>10000000</code>，<strong>补码</strong>也是<code>10000000</code>（显然它的<strong>反码</strong>是<code>01111111</code>）。</p>\n<h3 id=\"数据扩充和缩窄\"><a href=\"#数据扩充和缩窄\" class=\"headerlink\" title=\"数据扩充和缩窄\"></a>数据扩充和缩窄</h3><ol>\n<li>数据扩充在之前<a href=\"http://rylcode.cn/2016/04/08/LeetCodeC1%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%E8%AF%B4%E6%98%8E/\" target=\"_blank\" rel=\"noopener\">LeetCode编程技巧说明</a>提到过，有符号扩充符号位，无符号扩充0;</li>\n<li>数据缩窄，编译器认为你只对低位感兴趣，因此会丢掉高位(栈中从变量开始字节访问固定的字节结束)。列表初始化和枚举是不允许缩窄的。</li>\n</ol>\n<hr>\n<h2 id=\"二进制运算（移位得到CHAR-MAX和CHAR-MIN）\"><a href=\"#二进制运算（移位得到CHAR-MAX和CHAR-MIN）\" class=\"headerlink\" title=\"二进制运算（移位得到CHAR_MAX和CHAR_MIN）\"></a>二进制运算（移位得到CHAR_MAX和CHAR_MIN）</h2><p>明白上述数据存储概念之后，可以通过位运算来获得<code>char</code>的最大最小值。注意，其实在<code>climit</code>文件中有各种宏定义的最大最小值，比如<code>CHAR_MAX = 127</code>;<code>UCHAR_MAX = 0xff</code>;等。但是这里想利用位运算来实现这一目标(注意重置点)：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">CHAR_MAX</th>\n<th align=\"center\">CHAR_MIN</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>unsigned char max = 0-1</code></td>\n<td align=\"center\"><code>unsigned char min = 0</code>;</td>\n</tr>\n<tr>\n<td align=\"center\"><code>char max = (1&lt;&lt;7)-1</code></td>\n<td align=\"center\"><code>char min = 1&lt;&lt;7</code>(得到<code>10000000</code>);</td>\n</tr>\n<tr>\n<td align=\"center\">1. 上述表格中<code>unsigned char max</code>本质为<code>signed char = -1</code>的强制类型转化</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">2. <code>char max</code> 是利用重置点<code>CHAR_MIN</code>得到<code>01111111</code></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">3. <code>char min</code> 是利用-128的特殊补码(而且与原码相同)赋值的</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">4. <code>+</code>、<code>-</code>运算的优先级是高于<code>&lt;&lt;</code>、<code>&gt;&gt;</code>的，因此<code>1&lt;&lt;7</code>要加括号</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">注意右值中运算表达式中的数字默认都是<code>int</code>类型的，这与C++整型提升有关，详情见另一篇博客。</td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<p>另，由以上解读可以很容易的得出<code>abs(int_X)</code>的工作原理，正数不变，负数求得原码后符号位取反，即原码也是补码。但是有<strong>例外</strong>：<code>abs(INT_MIN) = INT_MIN</code>。他是不变的。</p>\n<p>解读下边两式的区别（使用中<code>unsigned</code>与<code>signed</code>操作注意符号位扩充）：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><code>char a = abs((char)(1&lt;&lt;7)-1)</code></th>\n<th align=\"center\"><code>char b = abs((1&lt;&lt;7)-1)</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>(char)(1&lt;&lt;7)-1 = (int)-129</code></td>\n<td align=\"center\"><code>(1&lt;&lt;7)-1 = (int)127</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>1·</code></td>\n<td align=\"center\"><code>2·</code></td>\n</tr>\n<tr>\n<td align=\"center\"><code>a = -127</code></td>\n<td align=\"center\"><code>b = 127</code></td>\n</tr>\n<tr>\n<td align=\"center\">1. <code>11111111 11111111 11111111 10000000</code>+<code>11111111 11111111 11111111 11111111</code>=<code>11111111 11111111 11111111 01111111</code>(<code>char</code> 原码<code>10000001</code>)</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">2. <code>00000000 00000000 00000000 1000000</code>-<code>00000000 00000000 00000000 0000001</code>=<code>00000000 00000000 00000000 01111111</code></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<hr>\n<h2 id=\"编译器的困惑\"><a href=\"#编译器的困惑\" class=\"headerlink\" title=\"编译器的困惑\"></a>编译器的困惑</h2><p>在编程过程中碰到了<a href=\"http://www.hankcs.com/program/cpp/error-c4146-%E4%B8%80%E5%85%83%E8%B4%9F%E8%BF%90%E7%AE%97%E7%AC%A6%E5%BA%94%E7%94%A8%E4%BA%8E%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B%EF%BC%8C%E7%BB%93%E6%9E%9C%E4%BB%8D%E4%B8%BA%E6%97%A0.html\" target=\"_blank\" rel=\"noopener\">这个疑惑</a>,后来发现，明明 int 最小值是 -2147483648，但我们就是<strong>无法</strong>用<code>int n = -2147483648</code>;表示。这是因为这个语句会让编译器产生困惑：</p>\n<ol>\n<li>判断2147483648 &gt; INT_MAX，编译器决定用unsigned int;</li>\n<li>编译器发现负号，对2147483648取反(<em>编译器取反原理是将从高位到第一个1之间的位取反</em>)来尝试表达-2147483648；</li>\n<li>那么在圆图中可以发现，取反操作对2147483648来说依然表达原值。</li>\n</ol>\n<p>因此编译器会提示error:一元负运算符应用于无符号类型，结果仍为无符号类型。那么对-2147483648有两种可用的赋值：</p>\n<ol>\n<li>int n = INT_MIN;</li>\n<li>int n = (-2147483647 - 1);</li>\n</ol>\n<p><font color=\"red\">但是</font>，如果涉及到取反操作<code>-n</code>的计算,对于<code>n=INT_MIN</code>依然存在这个问题，因此需要分解’-n = INT_MAX+1’来分别计算<code>INT_MAX</code>与1的情况并组合。例如[这里][中括号很烦]<br>[中括号很烦]:<a href=\"https://github.com/applefishsky009/LeetCode/blob/master/50%20-%20Pow(x%2C%20n)/50%20-%20Pow(x%2C%20n)%20.cpp\" target=\"_blank\" rel=\"noopener\">https://github.com/applefishsky009/LeetCode/blob/master/50%20-%20Pow(x%2C%20n)/50%20-%20Pow(x%2C%20n)%20.cpp</a></p>\n","categories":["C++基础"],"tags":["C++"]},{"title":"编程技巧说明","url":"https://applefishsky009.github.io/2016/04/08/LeetCodeC1编程技巧说明/","content":"<h2 id=\"判断两个值a-b是否相等\"><a href=\"#判断两个值a-b是否相等\" class=\"headerlink\" title=\"判断两个值a,b是否相等\"></a>判断两个值a,b是否相等</h2><ol>\n<li>若为整型，应该为<code>a==b</code>；</li>\n<li>若为浮点型，应该用<code>fabs(a-b)&lt;1e-9</code>。(因为<a href=\"http://0.30000000000000004.com/\" target=\"_blank\" rel=\"noopener\">计算机中浮点型是不准确的</a>，<strong>与因数有关</strong>)</li>\n<li>另外，对于<code>bool</code>型，应该用<code>if(a)</code>，<code>if(!b)</code>这样的形式来强调变量<code>bool</code>类型。</li>\n</ol>\n<hr>\n<h2 id=\"判断一个整数是否为奇数\"><a href=\"#判断一个整数是否为奇数\" class=\"headerlink\" title=\"判断一个整数是否为奇数\"></a>判断一个整数是否为奇数</h2><ol>\n<li><code>x%2 != 0</code>用来判断一个整数是否是奇数，<strong>不能用<code>x%2 = 1</code></strong>，因为x可能是负数，余数就是-1。</li>\n<li><code>-3 = 2*-1+(-1)</code>，即<code>-3/2 = -1</code>;<code>-3%2= -1</code>;说明负奇数余数是-1。</li>\n<li>if (num &amp; 0x1)，判断奇数 WTF!!!</li>\n</ol>\n<hr>\n<h2 id=\"char值做数组下标的强制类型转化\"><a href=\"#char值做数组下标的强制类型转化\" class=\"headerlink\" title=\"char值做数组下标的强制类型转化\"></a>char值做数组下标的强制类型转化</h2><ol>\n<li>应该强制转化为<code>uchar</code>，作为数组下标。不能直接转化为<code>uint</code>。</li>\n<li>因为高位扩充有两种，有符号数扩充，在高位补符号位；无符号数高位直接用0。例如<code>char c = -1</code>。c在计算机中的补码是<code>11111111</code>。<code>uint a = c</code>，那么<code>a = 4294967295</code>。因为c有符号，扩充后高位补1。<code>uint b = (uchar) c</code>。那么<code>b = 255</code>。因为<code>(uchar) c</code>是无符号数，高位用0扩充。</li>\n<li>二进制中有符号向无符号数的强制转化非常简单，将<strong>符号位置为0</strong>。比如-2，原码是<code>10000010</code>，反码是<code>11111101</code>，补码是<code>11111110</code>。将符号位置0，得到<code>01111110</code>，为254。即<code>char -2</code>强制转化成<code>uchar</code>值为254。</li>\n<li>参照维基百科和C++plusP44<strong>圆图</strong>可以更清楚了解更多数据储存与二进制运算。</li>\n</ol>\n<hr>\n<h2 id=\"vector和string优先于动态数组的分配\"><a href=\"#vector和string优先于动态数组的分配\" class=\"headerlink\" title=\"vector和string优先于动态数组的分配\"></a>vector和string优先于动态数组的分配</h2><p>性能上，<code>vector</code>保证内存（分配在堆）连续，一旦分配后，性能和原始数组相当；<br>用<code>new</code>必须<code>delete</code>，不然会<code>bug</code>，代码行数不够短；<br>多维数组定义方法：</p>\n<ol>\n<li><p><code>new/delete</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int** array = new int*[row];</span><br><span class=\"line\">for(int i=0;i&lt;row;i++)</span><br><span class=\"line\">\tarray[i] = new int [col];</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>vector</code>:    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;vector&lt;int&gt;&gt; = array(row,vector&lt;int&gt;(col,0));</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<hr>\n<h2 id=\"使用reverse来避免不必要的重新分配\"><a href=\"#使用reverse来避免不必要的重新分配\" class=\"headerlink\" title=\"使用reverse来避免不必要的重新分配\"></a>使用reverse来避免<a href=\"http://blog.csdn.net/bichenggui/article/details/4690175\" target=\"_blank\" rel=\"noopener\">不必要的重新分配</a></h2><ol>\n<li><code>vector</code>需要更多空间，以类似<code>realloc</code>的思想来增长大小。分配，回收，拷贝和析构，这些步骤都很昂贵。并且每次这些步骤发生时，所有指向<code>vector</code>或<code>string</code>中的迭代器、指针和引用都会失效。</li>\n<li>据博客中所说，vector重新分配时容量翻倍。我在VS2012，WIN32编译器下结果如下，容量是翻<em>1.5</em>倍的。因此在1000次<code>push_back</code>中导致了18次重新分配。<img src=\"http://i.imgur.com/ooqb6by.png\" alt=\"reverse()\"></li>\n<li>在<strong>容器被构造之后</strong>进行<strong><code>reserve</code>设置容器容量</strong>可以避免不必要的重新分配。<code>a.reserve(1000)</code>即把a的容量设置为1000。</li>\n</ol>\n<hr>\n<h2 id=\"诊断宏\"><a href=\"#诊断宏\" class=\"headerlink\" title=\"诊断宏\"></a>诊断宏</h2><p><a href=\"https://zh.wikipedia.org/wiki/Assert.h\" target=\"_blank\" rel=\"noopener\">assert.h</a>,<code>assert()</code>是一个诊断宏，用于动态辨识程序的逻辑错误条件，原型：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">assert</span><span class=\"params\">(<span class=\"keyword\">int</span> expression)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>如果是非零值，不做任何操作；</li>\n<li>如果是零值，用宽字符打印诊断消息，然后调用<code>abort()</code>，诊断消息：<ul>\n<li>源文件名字；</li>\n<li>源文件行号；</li>\n<li>所在函数名；</li>\n<li>求值结果为0的表达式。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"const在C-与ANSI-C中的不同\"><a href=\"#const在C-与ANSI-C中的不同\" class=\"headerlink\" title=\"const在C++与ANSI C中的不同\"></a>const在C++与ANSI C中的不同</h2><p><a href=\"http://baike.baidu.com/subview/1065598/5048428.htm?fromTaglist=\" target=\"_blank\" rel=\"noopener\">为什么const不能用于数组初始化</a>，简单来说：</p>\n<ol>\n<li>ANSI C中<code>const</code>定义了只读变量，C++中<code>const</code>是常量，而数组初始化要求参数只能是常量；</li>\n<li>ANSI C中定义常量只能用枚举或宏。</li>\n<li>另外这样使用数组如果越界访问并存储，会按特定方式修改栈，造成安全隐患。<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n = <span class=\"number\">4</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a[n];</span><br><span class=\"line\">\ta[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;a[<span class=\"number\">1</span>] = <span class=\"number\">2</span>;a[<span class=\"number\">2</span>] = <span class=\"number\">3</span>;a[<span class=\"number\">3</span>] = <span class=\"number\">4</span>;a[<span class=\"number\">4</span>] = <span class=\"number\">5</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i &lt; n;++i)</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; a[i] &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; a[<span class=\"number\">4</span>] &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>这会破坏栈中的环境变量表或其他设置(开始执行main()时压入栈的东西)，提示：</p>\n<blockquote>\n<p>Run-Time Check Failure #2 - Stack around the variable ‘a’ was corrupted.</p>\n</blockquote>\n<p>如果使用vector,在越界访问时就会抛出一个错误，提示：</p>\n<blockquote>\n<p>vector subscript out of range.</p>\n</blockquote>\n","categories":["C++基础"],"tags":["C++"]},{"title":"类的构造函数与析构函数初探","url":"https://applefishsky009.github.io/2016/04/07/类的构造函数与析构函数初探/","content":"<p>首先强调很重要的一点，<font color=\"red\">类声明只描述如何分配内存，但其并不会分配内存。</font>，只有调用构造函数的时候才会分配内存。</p>\n<hr>\n<h2 id=\"类的简介\"><a href=\"#类的简介\" class=\"headerlink\" title=\"类的简介\"></a>类的简介</h2><h3 id=\"类的规范由两部分组成：\"><a href=\"#类的规范由两部分组成：\" class=\"headerlink\" title=\"类的规范由两部分组成：\"></a>类的规范由两部分组成：</h3><ol>\n<li>类声明（declaration） – 类的蓝图<ul>\n<li>以数据成员的方式描述数据，以成员函数的方式描述公有接口；</li>\n<li><strong>数据</strong>通常放在私有部分，组成类接口的<strong>成员函数</strong>放在公有部分，另外<strong>私有成员函数</strong>用来处理不属于公有接口的实现细节。</li>\n<li>定义位于声明中的函数都将自动成为内联函数，若定义位于声明之外，使用<code>inline</code>关键字成为内联函数。</li>\n</ul>\n</li>\n<li>类方法定义 – 类的实现细节<ul>\n<li>C++通常把接口（类声明）放在头文件中，并将实现（类方法代码）放在源代码中；</li>\n<li>定义成员函数时，使用作用域解析符（<code>::</code>）来表示函数所属的类；</li>\n<li>类方法可以访问类的<code>private</code>组件。</li>\n<li>只要类方法不修改调用对象，就应将其声明为<code>const</code>，如<code>void Stock::show() const</code>。</li>\n</ul>\n</li>\n</ol>\n<p>类所创建的每个新对象都有自己的存储空间，用于存储其内部变量和类成员；但同一个类的所有对象<strong>共享同一组类方法</strong>。</p>\n<h3 id=\"类成员的访问控制（封装）\"><a href=\"#类成员的访问控制（封装）\" class=\"headerlink\" title=\"类成员的访问控制（封装）\"></a>类成员的访问控制（封装）</h3><p>数据隐藏：防止程序直接访问数据。</p>\n<ul>\n<li>例如<code>int a</code>是类的私有数据成员，<code>cout&lt;&lt;a</code>是不对的，只有公有成员函数或友元函数才能访问。可以定义一个<code>show()</code>方法访问a用来输出。</li>\n</ul>\n<p>数据封装：实现细节放在一起并与抽象分开。</p>\n<ul>\n<li>数据隐藏（数据放在类的私有部分）</li>\n<li>私有成员函数（实现细节隐藏在私有部分）</li>\n<li>类函数定义和类声明放在不同的文件中。</li>\n</ul>\n<hr>\n<h2 id=\"类的构造函数与析构函数\"><a href=\"#类的构造函数与析构函数\" class=\"headerlink\" title=\"类的构造函数与析构函数\"></a>类的构造函数与析构函数</h2><h3 id=\"类的构造函数\"><a href=\"#类的构造函数\" class=\"headerlink\" title=\"类的构造函数\"></a>类的构造函数</h3><ol>\n<li>如果没有提供任何构造函数，C++自动提供默认构造函数，他不做任何工作，也就是说<strong>他的值在初始化时是未知的</strong>；但是如果定义了构造函数，程序员必须为他提供默认构造函数，用户定义的默认构造函数通常给所有成员提供隐式初始值（已知合理值）。</li>\n<li>构造函数被用来创造对象，而不能通过对象来调用。（因为在通过构造函数构造出对象之前，对象是不存在的）。</li>\n</ol>\n<h3 id=\"构造函数的列表初始化\"><a href=\"#构造函数的列表初始化\" class=\"headerlink\" title=\"构造函数的列表初始化\"></a>构造函数的列表初始化</h3><p>开始就说过，类声明只描述如何分配内存，并不会分配内存。那么考虑如果初始化一个队列，队列长度是<code>const</code>常量，他应该是在构造函数执行之前被创建，因为他可以初始化但是不能赋值；同理，引用也<strong>只能在被创建时</strong>进行初始化。这时候需要一个列表初始化：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Queue::Queue(int qs):qsize(qs),front(nullptr),rear(nullptr),items(0);</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>这种格式只能用于构造函数；</li>\n<li>必须用这种格式来初始化非静态<code>const</code>数据成员；</li>\n<li>必须用这种格式来初始化引用数据成员；</li>\n<li>列表初始化时的初始化顺序是按照数据成员定义的顺序，而不是列表顺序来初始化的。</li>\n</ol>\n<h3 id=\"类的析构函数\"><a href=\"#类的析构函数\" class=\"headerlink\" title=\"类的析构函数\"></a>类的析构函数</h3><ol>\n<li>对象过期时，程序自动调用析构函数；如果程序员没有声明，编译器隐式声明一个默认析构函数。</li>\n<li>注意窗口环境中，窗口关闭之前的代码包含在同一个代码块中，才能保证析构函数在窗口关闭之前执行。</li>\n<li>若构造函数中有<code>new</code>，则析构函数必须<code>delete</code>。</li>\n<li>析构函数指示在代码块结束之前的扫尾工作(销毁对象)，并不会释放内存(对自动变量这是在代码块结束时自动进行的)。注意，<strong>析构函数只销毁对象不释放内存</strong></li>\n<li>析构函数<font color=\"red\">不能，也不应该</font>抛出异常，因为如果对象在运行期间出现了异常，C++异常处理模型有责任清除那些由于出现异常所导致的已经失效的对象(超出原来的作用域)，并释放对象原来所分配的资源，这就是调用这些对象的析构函数来完成释放资源的任务。即<font color=\"red\">析构函数已经变成了异常处理的一部分</font>。<ul>\n<li>如果无法保证在析构函数中不发生异常，可以用<code>try...catch...</code>块把可能抛出异常的块包裹起来，保证<code>catch</code>块的程序抛出的异常不会被扔出析构函数之外。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"构造函数的语法\"><a href=\"#构造函数的语法\" class=\"headerlink\" title=\"构造函数的语法\"></a><a href=\"https://github.com/applefishsky009/Leetcode/blob/master/26%20-%20Remove%20Duplicates%20from%20Sorted%20Array/26%20-%20Remove%20Duplicates%20from%20Sorted%20Array.cpp\" target=\"_blank\" rel=\"noopener\">构造函数的语法</a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Num nums(initVector);</span><br><span class=\"line\">Num nums;</span><br><span class=\"line\">Num();</span><br><span class=\"line\">Num nums = Num();</span><br><span class=\"line\">Num nums = Num(initVector);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>1一定不会创建一个临时对象并析构；</li>\n<li>2会调用默认构造函数，没有析构过程；</li>\n<li>3中由于没有类的对象，因此会调用默认构造函数并析构；</li>\n<li>4在本人两个编译器上执行了2的构造过程(实际上没有调用重载的<code>=</code>运算符)，因此没有匿名对象的构造析构；</li>\n<li>5在编译器(VS2012)上会，编译器会先调用构造函数构造匿名对象，再调用复制构造函数，再析构匿名对象。但在编译器(VS2015不会)，直接将匿名对象给<code>nums</code>；</li>\n</ul>\n<p>但是对于5这种创建<strong>有指定值的对象</strong>(使用运算符<code>=</code>允许调用赋值运算符(5)，也可以不调用(4))。因此是否有临时对象是不确定的(取决于具体的实现是4还是5这种方式)。</p>\n<p>总之，1的效率最高。</p>\n","categories":["C++的类"],"tags":["C++"]},{"title":"五种变量存储方式与external关键字","url":"https://applefishsky009.github.io/2016/04/06/五种变量存储方式与external关键字/","content":"<h2 id=\"五种变量存储方式\"><a href=\"#五种变量存储方式\" class=\"headerlink\" title=\"五种变量存储方式\"></a>五种变量存储方式</h2><table>\n<thead>\n<tr>\n<th align=\"center\">存储描述</th>\n<th align=\"center\">持续性</th>\n<th align=\"center\">作用域</th>\n<th align=\"center\">链接性</th>\n<th align=\"center\">如何声明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">自动</td>\n<td align=\"center\">自动</td>\n<td align=\"center\">代码块</td>\n<td align=\"center\">无</td>\n<td align=\"center\">代码块中</td>\n</tr>\n<tr>\n<td align=\"center\">寄存器</td>\n<td align=\"center\">自动</td>\n<td align=\"center\">代码块</td>\n<td align=\"center\">无</td>\n<td align=\"center\">代码块中，<code>register</code></td>\n</tr>\n<tr>\n<td align=\"center\">静态，无链接性</td>\n<td align=\"center\">静态</td>\n<td align=\"center\">代码块</td>\n<td align=\"center\">无</td>\n<td align=\"center\">代码块中，<code>static</code></td>\n</tr>\n<tr>\n<td align=\"center\">静态，外部连接性</td>\n<td align=\"center\">静态</td>\n<td align=\"center\">文件</td>\n<td align=\"center\">外部</td>\n<td align=\"center\">不在任何代码块中，无关键字</td>\n</tr>\n<tr>\n<td align=\"center\">静态，内部链接性</td>\n<td align=\"center\">静态</td>\n<td align=\"center\">文件</td>\n<td align=\"center\">内部</td>\n<td align=\"center\">不在任何代码块中，<code>static</code></td>\n</tr>\n</tbody></table>\n<ul>\n<li><code>register</code>用于显示指出自动变量，没什么用处，C++11保留的目的是向下兼容；</li>\n<li>静态无链接性变量与自动变量的异同：<ul>\n<li>静态无链接性变量在编译器<strong>编译</strong>时，编译器在<strong>静态/全局存储区</strong>分配内存；</li>\n<li>自动变量在代码块<strong>运行</strong>时，编译器在<strong>栈</strong>中分配内存；</li>\n<li>二者均只能在代码块中运行。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"external关键字\"><a href=\"#external关键字\" class=\"headerlink\" title=\"external关键字\"></a>external关键字</h2><p>变量的声明有两种：定义声明（简称为定义）与引用声明（简称为声明）。如果要在一个文件中使用另一个文件中定义声明的变量，仅仅将这个变量储存为外部链接性的静态变量是不够的，还要在引用的文件中使用<code>external</code>关键字做<strong>引用声明</strong>。</p>\n<ol>\n<li>外部变量在<code>main()</code>前面或头文件中定义它，在文件中定义之后的任何位置使用它；</li>\n<li>单定义规则：变量只能定义声明一次；</li>\n<li>局部变量隐藏同名的全局变量。如果要访问全局变量，可用作用域解析符<code>：：</code>；<ul>\n<li>没有范围限定符的范围解析运算符表示全局命名空间。<a href=\"https://msdn.microsoft.com/zh-cn/library/b451xz31.aspx\" target=\"_blank\" rel=\"noopener\">范围解析运算符：::\n</a></li>\n</ul>\n</li>\n<li>静态变量将隐藏常规外部变量（使用<code>external</code>关键字引用）。</li>\n</ol>\n<p>关于<code>external</code>关键字的测试是很简单的，这里不给出代码。另外提到单定义规则，有一点需要注意。任何一个包含头文件的cpp都要重新编译这个头文件，因此头文件绝对不能包含函数体与变量。不然，两个或两个以上cpp包含它会出现重定义错误。</p>\n<hr>\n","categories":["C++基础"],"tags":["C++"]},{"title":"内存存储区","url":"https://applefishsky009.github.io/2016/04/05/内存存储区/","content":"<h2 id=\"C-内存分配方式有五种：\"><a href=\"#C-内存分配方式有五种：\" class=\"headerlink\" title=\"C++内存分配方式有五种：\"></a>C++内存分配方式有五种：</h2><ol>\n<li>栈：局部变量、函数参数等<ul>\n<li>可以实现函数调用；</li>\n<li>动态扩展、收缩；</li>\n<li>位于用户虚拟地址空间顶部。</li>\n</ul>\n</li>\n<li>堆：<code>new</code>分配的内存块，<code>delete</code>释放。</li>\n<li>自由存储区：<code>malloc</code>分配，<code>free</code>释放。</li>\n<li>全局/静态存储区：全局变量与静态变量</li>\n<li>常量存储区：存放常量<ul>\n<li>如 <code>string s1 = “abcd”</code>；<code>s1</code>是代码块中的指针，在栈中；<code>“abcd”</code>是常量，在常量存储区;</li>\n<li>相同的常量字符串编译器里只保留一份。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"new和malloc的区别：\"><a href=\"#new和malloc的区别：\" class=\"headerlink\" title=\"new和malloc的区别：\"></a>new和malloc的区别：</h2><ol>\n<li><code>new</code>可以认为是<code>malloc</code>加构造函数的执行；</li>\n<li><code>new</code>出来的指针是直接带类型信息的，<code>malloc</code>返回<code>void</code>指针；</li>\n<li><code>delete</code>会相应调用对象的析构函数。</li>\n</ol>\n<hr>\n<h2 id=\"堆和栈的区别：\"><a href=\"#堆和栈的区别：\" class=\"headerlink\" title=\"堆和栈的区别：\"></a>堆和栈的区别：</h2><ol>\n<li>管理方式：栈是编译器自助管理；堆是程序员控制，容易内存泄漏；<ul>\n<li>内存泄漏：申请指针，指针指向内存，作用域或生命周期到了，指针释 放，但内存并没有释放，也无法访问，变成“死内存”。</li>\n</ul>\n</li>\n<li>空间大小：堆内存几乎没有限制；栈一般有一定大小（编译器有默认值，可修改）</li>\n<li>碎片问题：堆频繁<code>new/delete</code>会产生大量碎片（<code>delete</code>出来的空间几乎不可能恰好等于<code>new</code>的空间）；栈不会；</li>\n<li>生长方向：堆向上；栈向下。</li>\n<li>分配方式：堆动态；栈动态（<code>alloca</code>，但他不需人工释放）或静态（编译器完成）</li>\n<li>分配效率：栈高于堆（栈：计算机系统提供，有底层支持；堆：C/C++库提供）</li>\n</ol>\n<hr>\n<p>以上内容主要来自于<a href=\"http://www.cnblogs.com/daocaoren/archive/2011/06/29/2092957.html\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>\n","categories":["C++基础"],"tags":["C++"]},{"title":"图像的基本操作4-迁移","url":"https://applefishsky009.github.io/2015/08/06/图像的基本操作4-迁移/","content":"<p>在OPENCV帮助文档，使用库的技术和例题中有这些函数的例子。</p>\n<hr>\n<h2 id=\"trackbar\"><a href=\"#trackbar\" class=\"headerlink\" title=\"trackbar\"></a>trackbar</h2><ol>\n<li><p>创建trackbar并将它添加到指定的窗口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int cvCreateTrackbar( const char* trackbar_name, const char* window_name,int* value, int count, CvTrackbarCallback on_change );</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>on_change：每次滑块位置被改变的时候，被调用函数的指针。这个函数应该被声明为void Foo(int)；</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"滑鼠事件呼叫\"><a href=\"#滑鼠事件呼叫\" class=\"headerlink\" title=\"滑鼠事件呼叫\"></a>滑鼠事件呼叫</h2><ol>\n<li><p>滑鼠事件呼叫函式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvSetMouseCallback( const char* window_name, CvMouseCallback on_mouse, void* param=NULL );</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>副程式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void on_mouse( int event, int x, int y, int flags, void *param )</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>具体使用方法查看事件信息和拖拽事件信息的整数代号。</p>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"视频读取显示\"><a href=\"#视频读取显示\" class=\"headerlink\" title=\"视频读取显示\"></a>视频读取显示</h2><ol>\n<li><p>初始化从文件中获取视频：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CvCapture* cvCreateFileCapture( const char* filename );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>从摄像头或者文件中抓取并返回一帧：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IplImage* cvQueryFrame( CvCapture* capture );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>获得视频获取结构的属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double cvGetCaptureProperty( CvCapture* capture, int property_id );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置视频获取属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int cvSetCaptureProperty( CvCapture* capture, int property_id, double value );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>图像的下采样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvPyrDown( const CvArr* src, CvArr* dst, int filter=CV_GAUSSIAN_5x5 );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建视频文件写入器：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CvVideoWriter* cvCreateVideoWriter( const char* filename, int fourcc, double fps, CvSize frame_size, int is_color=1 );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>写入一帧到一个视频文件中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int cvWriteFrame( CvVideoWriter* writer, const IplImage* image );</span><br></pre></td></tr></table></figure></li>\n</ol>\n","categories":["OPENCV"],"tags":["OPENCV"]},{"title":"图像的基本操作3-迁移","url":"https://applefishsky009.github.io/2015/08/04/图像的基本操作3-迁移/","content":"<h2 id=\"动态内存存储及操作\"><a href=\"#动态内存存储及操作\" class=\"headerlink\" title=\"动态内存存储及操作\"></a>动态内存存储及操作</h2><ol>\n<li><p>内存存储器：直接看<a href=\"http://blog.sina.com.cn/s/blog_6df50e1a0101bei1.html\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n</li>\n<li><p>创建内存块：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CvMemStorage* cvCreateMemStorage( int block_size=0 );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>释放内存块：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvReleaseMemStorage( CvMemStorage** storage );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>清空内存存储块：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvClearMemStorage( CvMemStorage* storage );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在存储块中分配内存缓冲区：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void* cvMemStorageAlloc( CvMemStorage* storage, size_t size );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在存储块中分配一文本字符串：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CvString cvMemStorageAllocString( CvMemStorage* storage, const char* ptr, int len=-1 );</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>CvString结构：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct CvString &#123; </span><br><span class=\"line\">\tint len; </span><br><span class=\"line\">\tchar* ptr; </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>保存内存块的位置(地址)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvSaveMemStoragePos( const CvMemStorage* storage, CvMemStoragePos* pos );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>恢复内存存储块的位置(地址): </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvRestoreMemStoragePos( CvMemStorage* storage, CvMemStoragePos* pos );</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<hr>\n<h2 id=\"轮廓\"><a href=\"#轮廓\" class=\"headerlink\" title=\"轮廓\"></a>轮廓</h2><ol>\n<li><p>创建一序列：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CvSeq* cvCreateSeq(int seq_flags,int header_size,int elem_size,CvMemStorage* storage)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>从二值图像中检索轮廓，并返回检测到的轮廓的个数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CvContourScanner cvStartFindContours( CvArr* image,CvMemStorage* storage,int header_size=sizeof(CvContour),int mode=CV_RETR_LIST,int method=CV_CHAIN_APPROX_SIMPLE,CvPoint offset=cvPoint(0,0) );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>绘制外部和内部轮廓：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvDrawContours( CvArr *img, CvSeq* contour,CvScalar external_color, CvScalar hole_color,int max_level, int thickness=1,int line_type=8, CvPoint offset=cvPoint(0,0) );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>计算整个或部分轮廓的面积</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double cvContourArea( const CvArr* contour, CvSlice slice=CV_WHOLE_SEQ );</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<hr>\n<h2 id=\"椭圆与多边形\"><a href=\"#椭圆与多边形\" class=\"headerlink\" title=\"椭圆与多边形\"></a>椭圆与多边形</h2><ol>\n<li><p>特殊函数CvScalar：一个单独的成员val，指向4个double型数组的指针；例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define CV_RGB(r,g,b) cvScalar((b),(g),(r),0)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>绘制椭圆圆弧和椭圆扇形：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvEllipse( CvArr* img, CvPoint center, CvSize axes, double angle,double start_angle, double end_angle, CvScalar color,int thickness=1, int line_type=8, int shift=0 );</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>例子：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cvEllipse(image,centerpoint,cvSize(20,20),0,0,45,cvScalar(20,48,160),1,8,0);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>用指定精度逼近多边形曲线：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CvSeq* cvApproxPoly( const void* src_seq, int header_size, CvMemStorage* storage,int method, double parameter, int parameter2=0 );</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用多边形来近似表示一个轮廓。多边形逼近的目的是为了减少轮廓的顶点数目。但多边形逼近的结果依然是一个轮廓，只是这个轮廓相对要粗旷一些。</li>\n</ul>\n</li>\n</ol>\n","categories":["OPENCV"],"tags":["OPENCV"]},{"title":"图像的基本操作2-迁移","url":"https://applefishsky009.github.io/2015/07/31/图像的基本操作2-迁移/","content":"<h2 id=\"图像膨胀腐蚀\"><a href=\"#图像膨胀腐蚀\" class=\"headerlink\" title=\"图像膨胀腐蚀\"></a>图像膨胀腐蚀</h2><ol>\n<li><p>结构体IplConvKernel:定义形态学操作的结构元素；</p>\n<ul>\n<li>nCols，nRows：结构元素的行宽与列高；</li>\n<li>anchorX，anchorY：结构元素原点（锚点）的位置坐标，水平，垂直；</li>\n<li>nShiftR：用于表示结构元素的形状类型。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct _IplConvKernel &#123;</span><br><span class=\"line\">    int  nCols;</span><br><span class=\"line\">    int  nRows;</span><br><span class=\"line\">    int  anchorX;</span><br><span class=\"line\">    int  anchorY;</span><br><span class=\"line\">    int *values;</span><br><span class=\"line\">    int  nShiftR;</span><br><span class=\"line\">&#125;IplConvKernel;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>图像腐蚀：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvErode( const CvArr* src, CvArr* dst, IplConvKernel* element=NULL, int iterations=1 );</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>结构元素默认为 NULL, 使用 3×3 长方形的结构元素；</li>\n</ul>\n</li>\n<li><p>图像膨胀：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvDilate( const CvArr* src, CvArr* dst, IplConvKernel* element=NULL, int iterations=1 );</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>结构元素默认为 NULL, 使用 3×3 长方形的结构元素；</li>\n</ul>\n</li>\n<li><p>彩蛋：颜色产生的方法一般采用加色法，因此0代表黑色(什么都没有),255代表白色(所有色彩组合),(另一种叫减色法);</p>\n</li>\n<li><p>彩蛋2：四舍五入，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int cvRound (double value);</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<hr>\n<h2 id=\"图像平滑\"><a href=\"#图像平滑\" class=\"headerlink\" title=\"图像平滑\"></a>图像平滑</h2><ol>\n<li>各种方法的图像平滑:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvSmooth( const CvArr* src, CvArr* dst,int smoothtype=CV_GAUSSIAN,int param1=3, int param2=0, double param3=0, double param4=0 );</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<hr>\n<h2 id=\"颜色空间操作\"><a href=\"#颜色空间操作\" class=\"headerlink\" title=\"颜色空间操作\"></a>颜色空间操作</h2><ol>\n<li><p>色彩空间转化：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvCvtColor( const CvArr* src, CvArr* dst, int code );</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>要注意正确制定色彩空间(code参数)。</li>\n</ul>\n</li>\n<li><p>分割多通道图像：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvSplit( const CvArr* src, CvArr* dst0, CvArr* dst1,CvArr* dst2, CvArr* dst3 );</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<hr>\n<h2 id=\"边缘与直线检测\"><a href=\"#边缘与直线检测\" class=\"headerlink\" title=\"边缘与直线检测\"></a>边缘与直线检测</h2><ol>\n<li><p>固定阈值操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvThreshold( const CvArr* src, CvArr* dst, double threshold,double max_value, int threshold_type );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用 Canny 算法做边缘检测：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvCanny( const CvArr* image, CvArr* edges, double threshold1,double threshold2, int aperture_size=3 );</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>aperture_size：Sobel算子内核大小。</li>\n<li>如果一个像素的梯度大于上限阈值，则被认为是边缘像素;如果低于下限阈值，则被抛弃;如果介于二者之间，只有当其与高于上限阈值的像素连接时才被接受。</li>\n<li>canny推荐的上下限阈值比是2:1-3:1；</li>\n</ul>\n</li>\n<li><p>自适应阈值方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvAdaptiveThreshold( const CvArr* src, CvArr* dst,double max_value,int adaptive_method=CV_ADAPTIVE_THRESH_MEAN_C,int threshold_type=CV_THRESH_BINARY,int block_size=3, double param1=5 );</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>自适应二值化对于光照不均的文字，条码等，效果很好。窗口大小选择，考虑被检测物体尺寸。</li>\n<li>自适应阈值化中的阈值完全是由你所选择的邻域所确定：<ul>\n<li>如果你所选择的邻域非常小（比如3×3），那么很显然阈值的“自适应程度”就非常高，这在结果图像中就表现为边缘检测的效果。</li>\n<li>域选择的比较大（比如31×31），那么阈值的“自适应程度”就比较低，这在结果图像中就表现为二值化的效果。</li>\n</ul>\n</li>\n<li>参数param1与方法有关，主要可以用来控制边缘的类型和粗细。选定合适的block_size后，我们就可以选定一个更大的阈值param1，更好的抑制噪声。</li>\n</ul>\n</li>\n<li><p>利用Hough变换在二值图像中找到直线：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CvSeq* cvHoughLines2( CvArr* image, void* line_storage, int method,double rho, double theta, int threshold,double param1=0, double param2=0 );</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>解释比较麻烦，直接上例子:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lines = cvHoughLines2( dst, storage, CV_HOUGH_PROBABILISTIC, 1, CV_PI/180, 80, 30, 10 );</span><br><span class=\"line\">for( i = 0; i &lt; lines-&gt;total; i++ )&#123;</span><br><span class=\"line\">\tCvPoint* line =(CvPoint*)cvGetSeqElem(lines,i);</span><br><span class=\"line\">\tcvLine( color_dst, line[0], line[1], CV_RGB(255,0,0), 3, 8 );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>绘制连接两个点的线段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvLine( CvArr* img, CvPoint pt1, CvPoint pt2, CvScalar color,int thickness=1, int line_type=8, int shift=0 );</span><br></pre></td></tr></table></figure></li>\n</ol>\n","categories":["OPENCV"],"tags":["OPENCV"]},{"title":"图像的基本操作1-迁移","url":"https://applefishsky009.github.io/2015/07/28/图像的基本操作1-迁移/","content":"<p>在部署这个博客之前初学OPENCV的时候，在CSDN上写过一段时间的博客，当然内容比较简单基础，现在将博客迁移过来，会有很大部分的删减(只提供接口和注意事项，已经养成了学习习惯，有问题多查opencv帮助文档)，以便以后温习OPENCV。</p>\n<hr>\n<h2 id=\"图像读取显示保存\"><a href=\"#图像读取显示保存\" class=\"headerlink\" title=\"图像读取显示保存\"></a>图像读取显示保存</h2><ol>\n<li><p>IPLImage结构用来定义图像指针</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IPLImage *src,*dst；</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Mat类型也可以代表和显示图像，但其侧重于计算，数学性较高；</li>\n<li>IplImage由CvMat派生，而CvMat由CvArr派生即CvArr -&gt; CvMat -&gt; IplImage，CvArr用作函数的参数，无论传入的是CvMat或IplImage，内部都是按CvMat处理。</li>\n</ul>\n</li>\n<li><p>读取图像：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IplImage* cvLoadImage(const char* filename,int iscolor);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建窗口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int cvNamedWindow (const char* name, int flags=CV_WINDOW_AUTOSIZE );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>显示图像：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvShowImage(const char* name,const CvArr* Image);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>该语句后要紧跟<code>int cvWaitKey(n);</code>语句防止窗口闪退。</li>\n</ul>\n</li>\n<li><p>创建图像容器：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IplImage* cvCreateImage(CvSize size,int depth,int channels);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>保存图像：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int cvSaveImage( const char* filename, const CvArr* image );</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>但只有8位单通道或者3通道（通道顺序为’BGR’）可以使用这个函数保存。如果格式，深度或者通道不符合要求，请先用<code>cvCvtScale</code>和<code>cvCvtColor</code>转换；或者使用通用的<code>cvSave</code>保存图像为XML或者YAML格式。</li>\n</ul>\n</li>\n<li><p>释放图像指针：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvRelease( void** struct_ptr );</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>struct_ptr,图像指针的地址,如<code>&amp;src</code>;</li>\n</ul>\n</li>\n<li><p>结构CvSize:OpenCV的基本数据类型之一。表示矩阵框大小，以像素为精度。</p>\n</li>\n<li><p>得到图像宽高：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CvSize cvGetSize( const CvArr* arr );</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>CvSize结构：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct CvSize&#123;</span><br><span class=\"line\">\tint width; /* 矩形宽 */</span><br><span class=\"line\">\tint height; /* 矩形高 */</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"尺寸变换\"><a href=\"#尺寸变换\" class=\"headerlink\" title=\"尺寸变换\"></a>尺寸变换</h2><ol>\n<li><p>尺寸变换：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvResize( const CvArr* src, CvArr* dst, int interpolation=CV_INTER_LINEAR );</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>interpolation:插值方法。</li>\n</ul>\n</li>\n<li><p><strong>开辟内存</strong>并复制图像：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IplImage*cvCloneImage(constIplImage*image);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>主要用于图像包括ROI的复制。</li>\n</ul>\n</li>\n<li><p>拷贝数组：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvCopy( const CvArr* src, CvArr* dst, const CvArr* mask=NULL );</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>主要用于图像ROI的提取。</li>\n</ul>\n</li>\n<li><p>图像作差：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvSub( const CvArr* src1, const CvArr* src2, CvArr* dst, const CvArr* mask=NULL );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>彩蛋：函数引用正确时未识别的标识符：</p>\n<ul>\n<li>error:函数头文件(.h)未包括；</li>\n<li>link error:该函数的库文件(.lib)未配置正确。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"旋转\"><a href=\"#旋转\" class=\"headerlink\" title=\"旋转\"></a>旋转</h2><ol>\n<li><p>图像缩放：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvGetQuadrangleSubPix( const CvArr* src, CvArr* dst, const CvMat* map_matrix );</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>2*3变换矩阵map_matrix如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m[0] = (float)(factor*cos(-angle*2*CV_PI/180.));</span><br><span class=\"line\">m[1] = (float)(factor*sin(-angle*2*CV_PI/180.));</span><br><span class=\"line\">m[2] = w*0.5f;</span><br><span class=\"line\">m[3] = -m[1];</span><br><span class=\"line\">m[4] = m[0];</span><br><span class=\"line\">m[5] = h*0.5f;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>上述factor = 1。</p>\n</li>\n</ul>\n</li>\n<li><p>结构CvMat用来初始化矩阵头(上述旋转中用到)，使用函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CvMat cvMat( int rows, int cols, int type, void* data=NULL );</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>或者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CvMat* cvInitMatHeader( CvMat* mat, int rows, int cols, int type,void* data=NULL, int step=CV_AUTOSTEP );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>参数分别是矩阵行，列，数据类型。</p>\n</li>\n</ul>\n</li>\n</ol>\n","categories":["OPENCV"],"tags":["OPENCV"]},{"title":"about","url":"https://applefishsky009.github.io/about/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"https://applefishsky009.github.io/category/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"https://applefishsky009.github.io/project/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"https://applefishsky009.github.io/link/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"https://applefishsky009.github.io/tag/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"https://applefishsky009.github.io/search/index.html","content":"","categories":[],"tags":[]}]