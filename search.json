[{"title":"vector之resize和reverse","url":"http://yoursite.com/2016/04/15/vector之resize和reverse/","content":"<h2 id=\"a-resize-和a-reverse\"><a href=\"#a-resize-和a-reverse\" class=\"headerlink\" title=\"a.resize()和a.reverse();\"></a>a.resize()和a.reverse();</h2><ol>\n<li>首先介绍容器的两个属性<code>capacity</code>和<code>size</code>。<code>capacity</code>存储区的大小；<code>size</code>容器的大小。</li>\n<li>‘reverse()’是预分配存储区的大小，预分配存储区，但存储区不一定有容器对象。</li>\n<li>‘resize()’是改变容器大小，容器中一定有容器对象。</li>\n</ol>\n<hr>\n<h3 id=\"a-reverse\"><a href=\"#a-reverse\" class=\"headerlink\" title=\"a.reverse();\"></a>a.reverse();</h3><p>看源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void reserve(size_type _Count)</span><br><span class=\"line\">&#123;\t// determine new minimum length of allocated storage</span><br><span class=\"line\">\tif (capacity() &lt; _Count)</span><br><span class=\"line\">\t&#123;// something to do, check and reallocate</span><br><span class=\"line\">\t\tif (max_size() &lt; _Count)</span><br><span class=\"line\">\t\t\tXlen();</span><br><span class=\"line\">\t\t_Reallocate(_Count);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>没有<code>else</code>，说明若当前的<code>capacity</code>大于传入的值，<strong><code>capacity</code>是不会减小的</strong>；</li>\n<li>里层的if是错误检测机制；</li>\n<li>验证<code>vector</code>的<code>reallocate</code>原理，实际上每次新的<code>capacity</code>是之前的1.5倍。因此在<strong>循环之前一定要<code>reserve</code>保证效率</strong>。</li>\n</ol>\n<hr>\n<h3 id=\"a-resize\"><a href=\"#a-resize\" class=\"headerlink\" title=\"a.resize();\"></a>a.resize();</h3><p>模板类提供了两个函数重载：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">表达式</th>\n<th style=\"text-align:center\"><strong>返回类型</strong></th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>a.resize(n)</code></td>\n<td style=\"text-align:center\">void</td>\n<td style=\"text-align:center\">容器大小设为n</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>a.resize(n,t)</code></td>\n<td style=\"text-align:center\">void</td>\n<td style=\"text-align:center\">容器大小设为n，必要时用t填充</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"a-resize-n\"><a href=\"#a-resize-n\" class=\"headerlink\" title=\"a.resize(n)\"></a>a.resize(n)</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void resize(size_type _Newsize)</span><br><span class=\"line\">&#123;\t// determine new length, padding as needed</span><br><span class=\"line\">\tif (_Newsize &lt; size())</span><br><span class=\"line\">\t\terase(begin() + _Newsize, end());</span><br><span class=\"line\">\telse if (size() &lt; _Newsize)</span><br><span class=\"line\">\t&#123;\t// pad as needed</span><br><span class=\"line\">\t\t_Alty _Alval(this-&gt;_Getal());</span><br><span class=\"line\">\t\t_Reserve(_Newsize - size());</span><br><span class=\"line\">\t\t_TRY_BEGIN</span><br><span class=\"line\">\t\t_Uninitialized_default_fill_n(this-&gt;_Mylast, _Newsize - size(),_Alval);</span><br><span class=\"line\">\t\t_CATCH_ALL</span><br><span class=\"line\">\t\t_Tidy();</span><br><span class=\"line\">\t\t_RERAISE;</span><br><span class=\"line\">\t\t_CATCH_END</span><br><span class=\"line\">\t\tthis-&gt;_Mylast += _Newsize - size();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>若容器新大小小于现在的大小，毁掉多余的对象；</li>\n<li>新大小大于现在的大小：<ul>\n<li>注意<code>_Reserve</code>和<code>.reverse</code>是两个不同的方法，一个比较<code>capacity</code>，一个比较<code>_Unused_capacity</code>；</li>\n<li>检查空间，不够则<code>reverse</code>；</li>\n<li>填充未初始化的对象</li>\n<li>修改尾指针</li>\n</ul>\n</li>\n</ol>\n<p>####a.resize(n,t)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void resize(size_type _Newsize, const value_type&amp; _Val)</span><br><span class=\"line\">&#123;\t// determine new length, padding with _Val elements as needed</span><br><span class=\"line\">\tif (_Newsize &lt; size())</span><br><span class=\"line\">\t\terase(begin() + _Newsize, end());</span><br><span class=\"line\">\telse if (size() &lt; _Newsize)</span><br><span class=\"line\">\t\t_Insert_n(end(), _Newsize - size(), _Val);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>若容器新大小小于现在的大小，毁掉多余的对象；</li>\n<li>新大小大于现在的大小，直接执行<code>insert</code>;</li>\n</ol>\n<hr>\n"},{"title":"vector之erase","url":"http://yoursite.com/2016/04/14/vector之erase/","content":"<h2 id=\"a-erase\"><a href=\"#a-erase\" class=\"headerlink\" title=\"a.erase();\"></a>a.erase();</h2><p>模板类提供了两个函数重载：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">表达式</th>\n<th style=\"text-align:center\"><strong>返回类型</strong></th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>a.erase(p)</code></td>\n<td style=\"text-align:center\"><strong>迭代器</strong></td>\n<td style=\"text-align:center\">删除p指向的元素</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>a.erase(p,q)</code></td>\n<td style=\"text-align:center\"><strong>迭代器</strong></td>\n<td style=\"text-align:center\">删除区间[p,q)中的元素</td>\n</tr>\n</tbody>\n</table>\n<p><strong>思考</strong>:</p>\n<ol>\n<li>在之前内存之中讨论过，<code>vector</code>是保证内存连续的，那么<code>erase</code>之后他是如何保证内存连续的？答案是让该元素之后的所有元素前移补充“空位”。这一点在<code>erase()</code>方法的代码中可以看到传入的p的形参是<code>const</code>类型的，也就是说p指向的地址并不发生变化，只不过是元素前移了。测试如下：<br><img src=\"http://i.imgur.com/TZxRRb6.png\" alt=\"STL的迭代器\"></li>\n<li>注意到<code>erase</code>返回的都是迭代器，由1中的分析可知，删除p指向的元素之后，他返回的迭代器的<strong>地址不变</strong>，值是删除之后可用的下一个元素，因此<strong>给人感觉是p指向了下一个元素</strong>。那么在这里有一个值得注意的问题，如下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;int&gt;::iterator p = b.begin();</span><br><span class=\"line\">for (;p!=b.end();p++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif (*p == 2)</span><br><span class=\"line\">\t\tb.erase(p);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这是错误的，<code>b.erase(p)</code>没有迭代器来承接p的返回值，它的返回值被释放了。然后执行p++很显然会出现野指针。但是如果修改为<code>p = b.erase(p)</code>也是不正确的。迭代器在进行删除的这一个循环里会<code>++</code>两次（<code>erase</code>可以当做<code>++</code>一次）。但如果在<code>if</code>语句中执行一次<code>p--</code>，这是正确的。即<code>p = b.erase(p--);</code></p>\n<p> <strong>迭代器的循环使用<code>while</code>可以降低错误率。</strong></p>\n<hr>\n<p>为简单，分析第一个表达式的源码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iterator erase(const_iterator _Where)</span><br><span class=\"line\">&#123;\t// erase element at where</span><br><span class=\"line\">\tif (_VICONT(_Where) != this</span><br><span class=\"line\">\t\t|| _VIPTR(_Where) &lt; this-&gt;_Myfirst</span><br><span class=\"line\">\t\t|| this-&gt;_Mylast &lt;= _VIPTR(_Where))</span><br><span class=\"line\">\t\t_DEBUG_ERROR(&quot;vector erase iterator outside range&quot;);</span><br><span class=\"line\">\t_Move(_VIPTR(_Where) + 1, this-&gt;_Mylast, _VIPTR(_Where));</span><br><span class=\"line\">\t_Destroy(this-&gt;_Mylast - 1, this-&gt;_Mylast);</span><br><span class=\"line\">\t_Orphan_range(_VIPTR(_Where), this-&gt;_Mylast);</span><br><span class=\"line\">\t--this-&gt;_Mylast;</span><br><span class=\"line\">\treturn (_Make_iter(_Where));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到他做了哪些工作,首先元素前移，然后毁掉最后一个对象(<code>capacity</code>不变)，之后<font color=\"red\">_Orphan_range发生了什么？</font>,接下来指针指向正确的位置，最后返回指向原地址的迭代器。</p>\n"},{"title":"vector之insert和emplace","url":"http://yoursite.com/2016/04/13/vector之insert和emplace/","content":"<h2 id=\"a-insert\"><a href=\"#a-insert\" class=\"headerlink\" title=\"a.insert();\"></a>a.insert();</h2><p>模板类提供了三个函数重载,这是一种<strong>拷贝</strong>插入方法：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">表达式</th>\n<th style=\"text-align:center\">返回类型</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>a.insert(p,t)</code></td>\n<td style=\"text-align:center\">迭代器</td>\n<td style=\"text-align:center\">指向原本指向的元素,将t插入到p前面</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>a.insert(p, n,t)</code></td>\n<td style=\"text-align:center\"><code>void</code></td>\n<td style=\"text-align:center\">将n个t插入到p前面</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>a.insert(p,i,j)</code></td>\n<td style=\"text-align:center\"><code>void</code></td>\n<td style=\"text-align:center\">将区间[i,j)插入到p的前面，注意是左闭右开区间，j可以是超尾</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2 id=\"a-emplace\"><a href=\"#a-emplace\" class=\"headerlink\" title=\"a.emplace();\"></a>a.emplace();</h2><p>新标准引入的<code>emplace_front</code>,<code>emplace</code>,<code>emplace_back</code>这些操作是构造而不是拷贝元素。当插入一个对象时，将会比<code>insert</code>少拷贝构造，析构的步骤。</p>\n<hr>\n<h3 id=\"注：\"><a href=\"#注：\" class=\"headerlink\" title=\"注：\"></a>注：</h3><ol>\n<li>调用<code>push</code>或<code>insert</code>成员函数，将元素类型对象传递进去，这些对象被拷贝到容器中；</li>\n<li><code>emplace()</code>在容器中构造元素，因此效率更高；</li>\n<li>注意<code>a.insert(p,t)</code>的源码提供了一个重载，若t是普通类型，则调用<code>a.emplace(p，t)</code>，若t是<code>const</code>类型，则调用<code>a.insert(p,t)</code>。</li>\n</ol>\n"},{"title":"vector简介及非STL函数用法-持续更新","url":"http://yoursite.com/2016/04/12/vector简介及非STL函数用法-持续更新/","content":"<h2 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h2><p><code>vector</code>模板类是最简单的序列类型，除非其他类型的特殊有点能够满足程序的要求，否则应该默认使用这种类型。以后将记录一些在编程过程中常用的<code>vector</code>方法作为笔记以便不时复习，必要时会分析源码。</p>\n<p>常见的方法有：<br><code>.insert()</code>，<code>a.emplace()</code>，<code>.resize()</code>，<code>.reverse()</code>，<code>.begin()</code>，<code>a.end()</code>，<code>a.rbegin()</code>，<br><code>a.rend()</code>，<code>a.size()</code>，<code>a.swap(b)</code>，<code>a.empty()</code>，<code>a.front()</code>，<code>a.back()</code>，<code>a.clear()</code>，<br><code>a.push_back(t)</code>，<code>a.popback(t)</code>，<code>a[n]</code>，<code>a.at(n)</code>。</p>\n<p>有<code>vector&lt;int&gt; a</code>;<code>vector&lt;int&gt; b</code>;即a,b是<code>vector&lt;int&gt;</code>的对象。<code>vector&lt;int&gt; ::iterator p</code>;p是指向<code>vector&lt;int&gt;</code>的迭代器。i、j、q均和p一样是指向<code>vector&lt;int&gt;</code>的迭代器。</p>\n<hr>\n<h2 id=\"sort-用于vector\"><a href=\"#sort-用于vector\" class=\"headerlink\" title=\"sort()用于vector;\"></a>sort()用于vector;</h2><p>在<code>algorithm&gt;</code>头文件中提供了<code>sort</code>的两个重载函数,查看源码可发现是用<strong>快排</strong>实现的。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">表达式</th>\n<th style=\"text-align:center\"><strong>返回类型</strong></th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>sort(p,q)</code></td>\n<td style=\"text-align:center\"><code>void</code></td>\n<td style=\"text-align:center\">对[p,q)升序排序</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>sort(p,q,cmp)</code></td>\n<td style=\"text-align:center\"><code>void</code></td>\n<td style=\"text-align:center\">对[p,q)使用<code>cmp</code>方法排序，<code>cmp</code></td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li>右闭左开区间，一般来讲<code>p = a.begin()</code>;<code>q = a.end()</code>完成了对容器的排序。</li>\n<li>升序排序直接用第一个方法，系统默认<code>a&lt;b</code>返回真，因此是升序。</li>\n<li>降序排序需要自定义<code>cmp</code>方法,方法如下，只需要将默认值改为<code>a&gt;b</code>。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool comp(const int &amp;a,const int &amp;b)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  \t\treturn a&gt;b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>以上参考了<a href=\"http://www.cnblogs.com/cj695/p/3863142.html\" title=\"这里\" target=\"_blank\" rel=\"external\">这里</a></p>\n"},{"title":"C++类的this指针","url":"http://yoursite.com/2016/04/12/C++类的this指针/","content":"<h2 id=\"C-类的this指针\"><a href=\"#C-类的this指针\" class=\"headerlink\" title=\"C++类的this指针\"></a>C++类的this指针</h2><p>如图，假设有一个类<code>Stock</code>，他有一个<code>private：int val</code>。他还有一个方法<code>const Stock&amp; Stock::compare(const Stock &amp;classIn) const</code>;这个方法要实现这样的功能：对于两个类<code>Stock</code>的对象a和b，比较a的<code>val</code>和b的<code>val</code>，返回<code>val</code>大的对象(a或者b)，可能性的写法如下：<code>a.compare(b)</code>。由于在类的方法定义中，还没有具体对象(a)。那么有这样一个问题，在方法<code>compare</code>中，如何返回以后才初始化的对象本身(也就是a)？<br><img src=\"http://i.imgur.com/qChOATG.png\" alt=\"为什么使用this指针\"></p>\n<ol>\n<li>一般来说，所有类方法都将<code>this</code>指针设置为调用它的<strong>地址</strong>。(因此返回对象使用<strong><code>*this</code></strong>)</li>\n<li><code>compare</code>方法返回类型是指针意味着返回的是调用对象本身，而不是其副本。</li>\n<li><code>compare</code>方法的最后一个<code>const</code>表示该方法不会修改隐式访问对象(即调用该方法的对象本身)，这在之前的博客中提到过。</li>\n<li>形参列表中的<code>const</code>表示该函数不会修改被显示访问的对象(即图中的s)。</li>\n<li>由于该函数返回了两个<code>const</code>对象之一的引用，因此<strong>返回类型也应该是<code>const</code>引用</strong>。</li>\n</ol>\n<p><img src=\"http://i.imgur.com/CzuJ4fG.png\" alt=\"this的实例\"></p>\n"},{"title":"C++溢出","url":"http://yoursite.com/2016/04/11/C++溢出/","content":"<h2 id=\"数值溢出原理\"><a href=\"#数值溢出原理\" class=\"headerlink\" title=\"数值溢出原理\"></a>数值溢出原理</h2><p><img src=\"http://i.imgur.com/W3CYdOb.png\" alt=\"数值圆图\"><br>C++Plus在P44已经说的很清楚，如下。<br>有几点需要注意的地方：</p>\n<ol>\n<li>上图下图中的圆在进行<strong>强制类型转化</strong>时也是<strong>对应</strong>的，这就是说<code>(uchar)-1 = 65535</code>。</li>\n<li>无符号数没有溢出，只有<strong>进/借位</strong>(微机原理<code>CF</code>标示)，因为C++确保无符号数类型超越限制后在另一极端取值的行为。</li>\n<li>有符号数没有进/借位，只有<strong>溢出</strong>(微机原理<code>OF</code>标示)，因为C++无法确保有符号数上溢下溢后在另一极端取值的行为。(在我测试的时候并没有发现违背这一现象，可能有特殊情况)。</li>\n</ol>\n<hr>\n<h2 id=\"运算溢出\"><a href=\"#运算溢出\" class=\"headerlink\" title=\"运算溢出\"></a>运算溢出</h2><h3 id=\"判断加法溢出\"><a href=\"#判断加法溢出\" class=\"headerlink\" title=\"判断加法溢出\"></a>判断加法溢出</h3><p>可以像这里一样分情况或者根据圆图分析，会发现</p>\n<ol>\n<li>所有上溢结果都小于任何一个操作数；</li>\n<li>所有下溢结果都大于任何一个操作数。</li>\n</ol>\n<h3 id=\"判断乘法溢出\"><a href=\"#判断乘法溢出\" class=\"headerlink\" title=\"判断乘法溢出\"></a>判断乘法溢出</h3><ol>\n<li>在这里提到，可以用检测<code>a*b/b</code>是否等于a来判断是否乘法溢出；</li>\n<li>在这里提到，可以先扩展再强制类型转化到低位，在判断是否相等来判断。</li>\n</ol>\n<p>值得注意的是，在之前的帖子中提到过判断是否相等对<strong>浮点数</strong>和整型的判断方式是不一样的。</p>\n<h3 id=\"除零是不是溢出？\"><a href=\"#除零是不是溢出？\" class=\"headerlink\" title=\"除零是不是溢出？\"></a>除零是不是溢出？</h3><p>任何数除以零的计算“不是”算术溢出的一种。在数学上只能明显算是不明确的定义；它计算出来的结果只能当成是“没有”值，而不是非常大的无限数值。</p>\n<p>应付溢出最佳的方法还是防范，充分了解数据类型，选择恰当的变量类型。比如，<code>c = a*b</code>一般都会选择c的长度为a的长度与b的长度之和。</p>\n<hr>\n<h2 id=\"堆栈溢出\"><a href=\"#堆栈溢出\" class=\"headerlink\" title=\"堆栈溢出\"></a><a href=\"https://zh.wikipedia.org/wiki/%E5%A0%86%E7%96%8A%E6%BA%A2%E4%BD%8D\" target=\"_blank\" rel=\"external\">堆栈溢出</a></h2><p>一般编译器默认的堆栈内存是1MB，若使用过多的堆栈内存时就会导致调用堆栈产生的溢出。一般产生于递归，或者静态申请过多的临时变量，比如<code>int a[1024[1024]</code>。</p>\n<ol>\n<li>若是静态内存导致的堆栈溢出，可以用动态申请使用堆内存。</li>\n<li>若是递归调用导致递归堆栈无法容纳调用的返回地址，要添加错误检查机制。注意数据类型或用循环处理来避免堆栈溢出。</li>\n</ol>\n<hr>\n<h2 id=\"缓冲区溢出\"><a href=\"#缓冲区溢出\" class=\"headerlink\" title=\"缓冲区溢出\"></a>缓冲区溢出</h2><p><a href=\"http://jingyan.baidu.com/article/e9fb46e1acc1267521f76633.html\" target=\"_blank\" rel=\"external\">缓冲区溢出</a>源于这样一个编程错误：复制一个内存区域的内容到另一个内存区域，而目标内存区域容量太小无法容纳。它允许传入函数的内存块以一种特定方式修改堆栈。</p>\n<p>此外的溢出还包括<a href=\"https://zh.wikipedia.org/wiki/%E7%AE%97%E6%9C%AF%E4%B8%8B%E6%BA%A2\" target=\"_blank\" rel=\"external\">算术下溢</a>(浮点数溢出)等。</p>\n"},{"title":"数据存储与二进制运算","url":"http://yoursite.com/2016/04/09/数据存储与二进制运算/","content":"<h2 id=\"数据存储\"><a href=\"#数据存储\" class=\"headerlink\" title=\"数据存储\"></a>数据存储</h2><h3 id=\"原、反、补码\"><a href=\"#原、反、补码\" class=\"headerlink\" title=\"原、反、补码\"></a>原、反、补码</h3><p>计算机为方便计算，内存中的数据都是以补码的形式储存、运算。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">数</th>\n<th style=\"text-align:center\">原码</th>\n<th style=\"text-align:center\">反码</th>\n<th style=\"text-align:center\">补码</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">正数</td>\n<td style=\"text-align:center\">二进制表示</td>\n<td style=\"text-align:center\">与原码相同</td>\n<td style=\"text-align:center\">与原码相同</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">负数</td>\n<td style=\"text-align:center\">对应正数符号位（最高位）置1</td>\n<td style=\"text-align:center\">负数原码<strong>非符号位</strong>按位取反</td>\n<td style=\"text-align:center\">负数反码加1</td>\n</tr>\n</tbody>\n</table>\n<p>举个例子，数据类型为<code>char</code>：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">原数字</th>\n<th style=\"text-align:center\">原码</th>\n<th style=\"text-align:center\">反码</th>\n<th style=\"text-align:center\">补码</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>+3</code></td>\n<td style=\"text-align:center\"><code>00000011</code></td>\n<td style=\"text-align:center\"><code>00000011</code></td>\n<td style=\"text-align:center\"><code>00000011</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>-3</code></td>\n<td style=\"text-align:center\"><code>10000011</code></td>\n<td style=\"text-align:center\"><code>11111100</code></td>\n<td style=\"text-align:center\"><code>11111101</code></td>\n</tr>\n</tbody>\n</table>\n<p>值得注意的是，如果这个数据为<code>unsigned char</code>，<code>11111101</code>对应的是253，这里涉及到溢出，详细讨论见下一博客。</p>\n<h3 id=\"消失的原码\"><a href=\"#消失的原码\" class=\"headerlink\" title=\"消失的原码\"></a>消失的原码</h3><p>对于<code>unsigned char</code>原反补相同，计算机存储的补码就是原码，原码二进制经典编码有256个；但是对于<code>signed char</code>，最高位是符号位，因此原码的取值范围是-127-127，只有<strong>255个编码</strong>，但是对内存来说，8bits可以编码256个，那多余的补码与消失的原码去了哪里？</p>\n<p>考虑到编码效率，补码与原码必须是一一对应的关系。很容易想到在有符号数中有<code>00000000</code>、<code>10000000</code>两个原码表示+0与-0，而这是没有意义的。我们保证<code>00000000</code>这个原码与<code>00000000</code>这个补码相对应来表示0就可以。这样找到了消失的原码：<code>10000000</code>。</p>\n<p>在这个基于256的数值域中，观察补码的<strong>重置点（溢出中非常重要的概念）</strong>127的补码<code>01111111</code>，-127的补码<code>10000001</code>，那么可以清楚的看到<code>127+1=？</code>、<code>？+1=127</code>。因此很好理解，多余的补码是<code>10000000</code>（与消失的原码相同，通过计算他的原码可以得到验证）。那么剩下的事情就是设置重置点了，有两个选择，128或者-128。考虑到符号位是1，我们人为规定-128是重置点。即<strong>-128的原码</strong>是<code>10000000</code>，<strong>补码</strong>也是<code>10000000</code>（它的<strong>反码</strong>是<code>11111111</code>？）。</p>\n<hr>\n<h2 id=\"二进制运算（移位得到CHAR-MAX和CHAR-MIN）\"><a href=\"#二进制运算（移位得到CHAR-MAX和CHAR-MIN）\" class=\"headerlink\" title=\"二进制运算（移位得到CHAR_MAX和CHAR_MIN）\"></a>二进制运算（移位得到CHAR_MAX和CHAR_MIN）</h2><p>明白上述数据存储概念之后，可以通过位运算来获得<code>char</code>的最大最小值。注意，其实在<code>climit</code>文件中有各种宏定义的最大最小值，比如<code>CHAR_MAX = 127</code>;<code>UCHAR_MAX = 0xff</code>;等。但是这里想利用位运算来实现这一目标(注意重置点)：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">CHAR_MAX</th>\n<th style=\"text-align:center\">CHAR_MIN</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>unsigned char max = 0-1</code></td>\n<td style=\"text-align:center\"><code>unsigned char min = 0</code>;</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>char max = (1&lt;&lt;7)-1</code></td>\n<td style=\"text-align:center\"><code>char min = 1&lt;&lt;7</code>(得到<code>10000000</code>);</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li>上述表格中<code>unsigned char max</code>本质为<code>signed char = -1</code>的强制类型转化</li>\n<li><code>char max</code> 是利用重置点<code>CHAR_MIN</code>得到<code>01111111</code></li>\n<li><code>char min</code> 是利用-128的特殊补码(而且与原码相同)赋值的</li>\n<li><code>+</code>、<code>-</code>运算的优先级是高于<code>&lt;&lt;</code>、<code>&gt;&gt;</code>的，因此<code>1&lt;&lt;7</code>要加括号<br>注意右值中运算表达式中的数字默认都是<code>int</code>类型的，这与C++整型提升有关，详情见另一篇博客。</li>\n</ol>\n<p>另，由以上解读可以很容易的得出<code>abs(int_X)</code>的工作原理，正数不变，负数求得原码后符号位取反，即原码也是补码。但是有<strong>例外</strong>：<code>abs(INT_MIN) = INT_MIN</code>。他是不变的。</p>\n<p>解读下边两式的区别（使用中<code>unsigned</code>与<code>signed</code>操作注意符号位扩充）：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><code>char a = abs((char)(1&lt;&lt;7)-1)</code></th>\n<th style=\"text-align:center\"><code>char b = abs((1&lt;&lt;7)-1)</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>(char)(1&lt;&lt;7)-1 = (int)-129</code></td>\n<td style=\"text-align:center\"><code>(1&lt;&lt;7)-1 = (int)127</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>1·</code></td>\n<td style=\"text-align:center\"><code>2·</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>a = -127</code></td>\n<td style=\"text-align:center\"><code>b = 127</code></td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li><code>11111111 11111111 11111111 10000000</code>+<code>11111111 11111111 11111111 11111111</code>=<code>11111111 11111111 11111111 01111111</code>(<code>char</code> 原码<code>10000001</code>)    </li>\n<li><code>00000000 00000000 00000000 1000000</code>-<code>00000000 00000000 00000000 0000001</code>=<code>00000000 00000000 00000000 01111111</code></li>\n</ol>\n"},{"title":"leetcode第一章：编程技巧说明","url":"http://yoursite.com/2016/04/08/leetcode第一章：编程技巧说明/","content":"<h2 id=\"判断两个值a-b是否相等\"><a href=\"#判断两个值a-b是否相等\" class=\"headerlink\" title=\"判断两个值a,b是否相等\"></a>判断两个值a,b是否相等</h2><ol>\n<li>若为整型，应该为<code>a==b</code>；</li>\n<li>若为浮点型，应该用<code>fabs(a-b)&lt;1e-9</code>。(因为<a href=\"http://0.30000000000000004.com/\" target=\"_blank\" rel=\"external\">计算机中浮点型是不准确的</a>，<strong>与因数有关</strong>)</li>\n<li>另外，对于<code>bool</code>型，应该用<code>if(a)</code>，<code>if(!b)</code>这样的形式来强调变量<code>bool</code>类型。</li>\n</ol>\n<hr>\n<h2 id=\"判断一个整数是否为奇数\"><a href=\"#判断一个整数是否为奇数\" class=\"headerlink\" title=\"判断一个整数是否为奇数\"></a>判断一个整数是否为奇数</h2><ol>\n<li><code>x%2 != 0</code>用来判断一个整数是否是奇数，<strong>不能用<code>x%2 = 1</code></strong>，因为x可能是负数，余数就是-1。</li>\n<li><code>-3 = 2*-1+(-1)</code>，即<code>-3/2 = -1</code>;<code>-3%2= -1</code>;说明负奇数余数是-1。</li>\n</ol>\n<hr>\n<h2 id=\"char值做数组下标的强制类型转化\"><a href=\"#char值做数组下标的强制类型转化\" class=\"headerlink\" title=\"char值做数组下标的强制类型转化\"></a>char值做数组下标的强制类型转化</h2><ol>\n<li>应该强制转化为<code>uchar</code>，作为数组下标。不能直接转化为<code>uint</code>。</li>\n<li>因为高位扩充有两种，有符号数扩充，在高位补符号位；无符号数高位直接用0。例如<code>char c = -1</code>。c在计算机中的补码是<code>11111111</code>。<code>uint a = c</code>，那么<code>a = 4294967295</code>。因为c有符号，扩充后高位补1。<code>uint b = (uchar) c</code>。那么<code>b = 255</code>。因为<code>(uchar) c</code>是无符号数，高位用0扩充。</li>\n<li>二进制中有符号向无符号数的强制转化非常简单，将<strong>符号位置为0</strong>。比如-2，原码是<code>10000010</code>，反码是<code>11111101</code>，补码是<code>11111110</code>。将符号位置0，得到<code>01111110</code>，为254。即<code>char -2</code>强制转化成<code>uchar</code>值为254。</li>\n<li>参照维基百科和C++plusP44<strong>圆图</strong>可以更清楚了解更多数据储存与二进制运算。</li>\n</ol>\n<hr>\n<h2 id=\"vector和string优先于动态数组的分配\"><a href=\"#vector和string优先于动态数组的分配\" class=\"headerlink\" title=\"vector和string优先于动态数组的分配\"></a>vector和string优先于动态数组的分配</h2><p>性能上，<code>vector</code>保证内存（分配在堆）连续，一旦分配后，性能和原始数组相当；<br>用<code>new</code>必须<code>delete</code>，不然会<code>bug</code>，代码行数不够短；<br>多维数组定义方法：</p>\n<ol>\n<li><p><code>new/delete</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int** array = new int*[row];</span><br><span class=\"line\">for(int i=0;i&lt;row;i++)</span><br><span class=\"line\">\tarray[i] = new int [col];</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>vector</code>:    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;vector&lt;int&gt;&gt; = array(row,vector&lt;int&gt;(col,0));</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<hr>\n<h2 id=\"使用reverse来避免不必要的重新分配\"><a href=\"#使用reverse来避免不必要的重新分配\" class=\"headerlink\" title=\"使用reverse来避免不必要的重新分配\"></a>使用reverse来避免<a href=\"http://blog.csdn.net/bichenggui/article/details/4690175\" target=\"_blank\" rel=\"external\">不必要的重新分配</a></h2><ol>\n<li><code>vector</code>需要更多空间，以类似<code>realloc</code>的思想来增长大小。分配，回收，拷贝和析构，这些步骤都很昂贵。并且每次这些步骤发生时，所有指向<code>vector</code>或<code>string</code>中的迭代器、指针和引用都会失效。</li>\n<li>据博客中所说，vector重新分配时容量翻倍。我在VS2012，WIN32编译器下结果如下，容量是翻<em>1.5</em>倍的。因此在1000次<code>push_back</code>中导致了18次重新分配。<img src=\"http://i.imgur.com/ooqb6by.png\" alt=\"reverse()\"></li>\n<li>在<strong>容器被构造之后</strong>进行<strong><code>reserve</code>设置容器容量</strong>可以避免不必要的重新分配。<code>a.reserve(1000)</code>即把a的容量设置为1000。</li>\n</ol>\n"},{"title":"类的构造函数与析构函数初探","url":"http://yoursite.com/2016/04/07/类的构造函数与析构函数初探/","content":"<h2 id=\"类的简介\"><a href=\"#类的简介\" class=\"headerlink\" title=\"类的简介\"></a>类的简介</h2><h3 id=\"类的规范由两部分组成：\"><a href=\"#类的规范由两部分组成：\" class=\"headerlink\" title=\"类的规范由两部分组成：\"></a>类的规范由两部分组成：</h3><ol>\n<li>类声明（declaration） – 类的蓝图<ul>\n<li>以数据成员的方式描述数据，以成员函数的方式描述公有接口；</li>\n<li><strong>数据</strong>通常放在私有部分，组成类接口的<strong>成员函数</strong>放在公有部分，另外<strong>私有成员函数</strong>用来处理不属于公有接口的实现细节。</li>\n<li>定义位于声明中的函数都将自动成为内联函数，若定义位于声明之外，使用<code>inline</code>关键字成为内联函数。</li>\n</ul>\n</li>\n<li>类方法定义 – 类的实现细节<ul>\n<li>C++通常把接口（类声明）放在头文件中，并将实现（类方法代码）放在源代码中；</li>\n<li>定义成员函数时，使用作用域解析符（<code>::</code>）来表示函数所属的类；</li>\n<li>类方法可以访问类的<code>private</code>组件。</li>\n<li>只要类方法不修改调用对象，就应将其声明为<code>const</code>，如<code>void Stock::show() const</code>。</li>\n</ul>\n</li>\n</ol>\n<p>类所创建的每个新对象都有自己的存储空间，用于存储其内部变量和类成员；但同一个类的所有对象<strong>共享同一组类方法</strong>。</p>\n<h3 id=\"类成员的访问控制（封装）\"><a href=\"#类成员的访问控制（封装）\" class=\"headerlink\" title=\"类成员的访问控制（封装）\"></a>类成员的访问控制（封装）</h3><p>数据隐藏：防止程序直接访问数据。</p>\n<ul>\n<li>例如<code>int a</code>是类的私有数据成员，<code>cout&lt;&lt;a</code>是不对的，只有公有成员函数或友元函数才能访问。可以定义一个<code>show()</code>方法访问a用来输出。</li>\n</ul>\n<p>数据封装：实现细节放在一起并与抽象分开。</p>\n<ul>\n<li>数据隐藏（数据放在类的私有部分）</li>\n<li>私有成员函数（实现细节隐藏在私有部分）</li>\n<li>类函数定义和类声明放在不同的文件中。</li>\n</ul>\n<hr>\n<h2 id=\"类的构造函数与析构函数\"><a href=\"#类的构造函数与析构函数\" class=\"headerlink\" title=\"类的构造函数与析构函数\"></a>类的构造函数与析构函数</h2><h3 id=\"类的构造函数\"><a href=\"#类的构造函数\" class=\"headerlink\" title=\"类的构造函数\"></a>类的构造函数</h3><ol>\n<li>如果没有提供任何构造函数，C++自动提供默认构造函数，他不做任何工作；但是如果定义了构造函数，程序员必须为他提供默认构造函数，用户定义的默认构造函数通常给所有成员提供隐式初始值（已知合理值）。</li>\n<li>构造函数被用来创造对象，而不能通过对象来调用。（因为在通过构造函数构造出对象之前，对象是不存在的）。</li>\n</ol>\n<h3 id=\"类的析构函数\"><a href=\"#类的析构函数\" class=\"headerlink\" title=\"类的析构函数\"></a>类的析构函数</h3><ol>\n<li>对象过期时，程序自动调用析构函数；如果程序员没有声明，编译器隐式声明一个默认析构函数。</li>\n<li>注意窗口环境中，窗口关闭之前的代码包含在同一个代码块中，才能保证析构函数在窗口关闭之前执行。</li>\n<li>若构造函数中有<code>new</code>，则析构函数必须<code>delete</code>。</li>\n</ol>\n<h3 id=\"构造函数的语法\"><a href=\"#构造函数的语法\" class=\"headerlink\" title=\"构造函数的语法\"></a><a href=\"https://github.com/applefishsky009/Leetcode/tree/master/2.1.1%20-%20Remove%20Duplicates%20from%20Sorted%20Array\" target=\"_blank\" rel=\"external\">构造函数的语法</a></h3><pre><code>1. Num nums(initVector);\n2. nums = Num(initVector)。\n3. Num();\n4. Num nums = Num();\n5. Num nums = Num(initVector)；\n</code></pre><ul>\n<li>1一定不会创建一个临时对象并析构；</li>\n<li>2是赋值语句一定会创建临时对象并析构(虽然有匿名对象但作用域限制)；</li>\n<li>3也会创建一个临时对象并析构(因为没有匿名对象的载体)；</li>\n<li>4不会(因为有匿名对象载体)；</li>\n<li>5会。但是对于5这种创建<strong>有指定值的对象</strong>，是否有临时对象是不确定的(取决于具体的实现)。</li>\n<li>总之，1的效率最高。</li>\n</ul>\n"},{"title":"C++五种变量存储方式与external关键字","url":"http://yoursite.com/2016/04/06/C++五种变量存储方式与external关键字/","content":"<h2 id=\"五种变量存储方式\"><a href=\"#五种变量存储方式\" class=\"headerlink\" title=\"五种变量存储方式\"></a>五种变量存储方式</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">存储描述</th>\n<th style=\"text-align:center\">持续性</th>\n<th style=\"text-align:center\">作用域</th>\n<th style=\"text-align:center\">链接性</th>\n<th style=\"text-align:center\">如何声明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">自动</td>\n<td style=\"text-align:center\">自动</td>\n<td style=\"text-align:center\">代码块</td>\n<td style=\"text-align:center\">无</td>\n<td style=\"text-align:center\">代码块中</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">寄存器</td>\n<td style=\"text-align:center\">自动</td>\n<td style=\"text-align:center\">代码块</td>\n<td style=\"text-align:center\">无</td>\n<td style=\"text-align:center\">代码块中，<code>register</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">静态，无链接性</td>\n<td style=\"text-align:center\">静态</td>\n<td style=\"text-align:center\">代码块</td>\n<td style=\"text-align:center\">无</td>\n<td style=\"text-align:center\">代码块中，<code>static</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">静态，外部连接性</td>\n<td style=\"text-align:center\">静态</td>\n<td style=\"text-align:center\">文件</td>\n<td style=\"text-align:center\">外部</td>\n<td style=\"text-align:center\">不在任何代码块中，无关键字</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">静态，内部链接性</td>\n<td style=\"text-align:center\">静态</td>\n<td style=\"text-align:center\">文件</td>\n<td style=\"text-align:center\">内部</td>\n<td style=\"text-align:center\">不在任何代码块中，<code>static</code></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><code>register</code>用于显示指出自动变量，没什么用处，C++11保留的目的是向下兼容；</li>\n<li>静态无链接性变量与自动变量的异同：<ul>\n<li>静态无链接性变量在编译器<strong>编译</strong>时，编译器在<strong>静态/全局存储区</strong>分配内存；</li>\n<li>自动变量在代码块<strong>运行</strong>时，编译器在<strong>栈</strong>中分配内存；</li>\n<li>二者均只能在代码块中运行。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"external关键字\"><a href=\"#external关键字\" class=\"headerlink\" title=\"external关键字\"></a>external关键字</h2><p>变量的声明有两种：定义声明（简称为定义）与引用声明（简称为声明）。如果要在一个文件中使用另一个文件中定义声明的变量，仅仅将这个变量储存为外部链接性的静态变量是不够的，还要在引用的文件中使用<code>external</code>关键字做<strong>引用声明</strong>。</p>\n<ol>\n<li>外部变量在<code>main()</code>前面或头文件中定义它，在文件中定义之后的任何位置使用它；</li>\n<li>单定义规则：变量只能定义声明一次；</li>\n<li>局部变量隐藏同名的全局变量。如果要访问全局变量，可用作用域解析符<code>：：</code>；</li>\n<li>静态变量将隐藏常规外部变量（使用<code>external</code>关键字引用）。</li>\n</ol>\n<p>关于<code>external</code>关键字的测试是很简单的，这里不给出代码。另外提到单定义规则，有一点需要注意。任何一个包含头文件的cpp都要重新编译这个头文件，因此头文件绝对不能包含函数体与变量。不然，两个或两个以上cpp包含它会出现重定义错误。</p>\n<hr>\n"},{"title":"C++内存存储区","url":"http://yoursite.com/2016/04/05/C++内存存储区/","content":"<h2 id=\"C-内存分配方式有五种：\"><a href=\"#C-内存分配方式有五种：\" class=\"headerlink\" title=\"C++内存分配方式有五种：\"></a>C++内存分配方式有五种：</h2><ol>\n<li>栈：局部变量、函数参数等<ul>\n<li>可以实现函数调用；</li>\n<li>动态扩展、收缩；</li>\n<li>位于用户虚拟地址空间顶部。</li>\n</ul>\n</li>\n<li>堆：<code>new</code>分配的内存块，<code>delete</code>释放。</li>\n<li>自由存储区：<code>malloc</code>分配，<code>free</code>释放。</li>\n<li>全局/静态存储区：全局变量与静态变量</li>\n<li>常量存储区：存放常量<ul>\n<li>如 <code>string s1 = “abcd”</code>；<code>s1</code>是代码块中的指针，在栈中；<code>“abcd”</code>是常量，在常量存储区。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"new和malloc的区别：\"><a href=\"#new和malloc的区别：\" class=\"headerlink\" title=\"new和malloc的区别：\"></a>new和malloc的区别：</h2><ol>\n<li><code>new</code>可以认为是<code>malloc</code>加构造函数的执行；</li>\n<li><code>new</code>出来的指针是直接带类型信息的，<code>malloc</code>返回<code>void</code>指针；</li>\n<li><code>delete</code>会相应调用对象的析构函数。</li>\n</ol>\n<hr>\n<h2 id=\"堆和栈的区别：\"><a href=\"#堆和栈的区别：\" class=\"headerlink\" title=\"堆和栈的区别：\"></a>堆和栈的区别：</h2><ol>\n<li>管理方式：栈是编译器自助管理；堆是程序员控制，容易内存泄漏；<ul>\n<li>内存泄漏：申请指针，指针指向内存，作用域或生命周期到了，指针释 放，但内存并没有释放，也无法访问，变成“死内存”。</li>\n</ul>\n</li>\n<li>空间大小：堆内存几乎没有限制；栈一般有一定大小（编译器有默认值，可修改）</li>\n<li>碎片问题：堆频繁<code>new/delete</code>会产生大量碎片（<code>delete</code>出来的空间几乎不可能恰好等于<code>new</code>的空间）；栈不会；</li>\n<li>生长方向：堆向上；栈向下。</li>\n<li>分配方式：堆动态；栈动态（<code>alloca</code>，但他不需人工释放）或静态（编译器完成）</li>\n<li>分配效率：栈高于堆（栈：计算机系统提供，有底层支持；堆：C/C++库提供）</li>\n</ol>\n<hr>\n<p>以上内容主要来自于<a href=\"http://www.cnblogs.com/daocaoren/archive/2011/06/29/2092957.html\" target=\"_blank\" rel=\"external\">这里</a>。</p>\n"}]