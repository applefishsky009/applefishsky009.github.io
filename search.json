[{"title":"C++五种变量存储方式与external关键字","url":"http://yoursite.com/2016/04/06/C++五种变量存储方式与external关键字/","content":"<h2 id=\"五种变量存储方式\"><a href=\"#五种变量存储方式\" class=\"headerlink\" title=\"五种变量存储方式\"></a>五种变量存储方式</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">存储描述</th>\n<th style=\"text-align:center\">持续性</th>\n<th style=\"text-align:center\">作用域</th>\n<th style=\"text-align:center\">链接性</th>\n<th style=\"text-align:center\">如何声明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">自动</td>\n<td style=\"text-align:center\">自动</td>\n<td style=\"text-align:center\">代码块</td>\n<td style=\"text-align:center\">无</td>\n<td style=\"text-align:center\">代码块中</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">寄存器</td>\n<td style=\"text-align:center\">自动</td>\n<td style=\"text-align:center\">代码块</td>\n<td style=\"text-align:center\">无</td>\n<td style=\"text-align:center\">代码块中，register</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">静态，无链接性</td>\n<td style=\"text-align:center\">静态</td>\n<td style=\"text-align:center\">代码块</td>\n<td style=\"text-align:center\">无</td>\n<td style=\"text-align:center\">代码块中，static</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">静态，外部连接性</td>\n<td style=\"text-align:center\">静态</td>\n<td style=\"text-align:center\">文件</td>\n<td style=\"text-align:center\">外部</td>\n<td style=\"text-align:center\">不在任何代码块中，无关键字</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">静态，内部链接性</td>\n<td style=\"text-align:center\">静态</td>\n<td style=\"text-align:center\">文件</td>\n<td style=\"text-align:center\">内部</td>\n<td style=\"text-align:center\">不在任何代码块中，static</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>register用于显示指出自动变量，没什么用处，C++11保留的目的是向下兼容；</li>\n<li>静态无链接性变量与自动变量的异同：<ul>\n<li>静态无链接性变量在编译器<strong>编译</strong>时，编译器在<strong>静态/全局存储区</strong>分配内存；</li>\n<li>自动变量在代码块<strong>运行</strong>时，编译器在<strong>栈</strong>中分配内存；</li>\n<li>二者均只能在代码块中运行。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"external关键字\"><a href=\"#external关键字\" class=\"headerlink\" title=\"external关键字\"></a>external关键字</h2><p>变量的声明有两种：定义声明（简称为定义）与引用声明（简称为声明）。如果要在一个文件中使用另一个文件中定义声明的变量，仅仅将这个变量储存为外部链接性的静态变量是不够的，还要在引用的文件中使用external关键字做<strong>引用声明</strong>。</p>\n<ol>\n<li>外部变量在main()前面或头文件中定义它，在文件中定义之后的任何位置使用它；</li>\n<li>单定义规则：变量只能定义声明一次；</li>\n<li>局部变量隐藏同名的全局变量。如果要访问全局变量，可用作用域解析符“：：”；</li>\n<li>静态变量将隐藏常规外部变量（使用external关键字引用）。</li>\n</ol>\n<p>关于external关键字的测试是很简单的，这里不给出代码。另外提到单定义规则，有一点需要注意。任何一个包含头文件的cpp都要重新编译这个头文件，因此头文件绝对不能包含函数体与变量。不然，两个或两个以上cpp包含它会出现重定义错误。</p>\n<hr>\n"},{"title":"C++内存存储区","url":"http://yoursite.com/2016/04/05/C++内存存储区/","content":"<h2 id=\"C-内存分配方式有五种：\"><a href=\"#C-内存分配方式有五种：\" class=\"headerlink\" title=\"C++内存分配方式有五种：\"></a>C++内存分配方式有五种：</h2><ol>\n<li>栈：局部变量、函数参数等<ul>\n<li>可以实现函数调用；</li>\n<li>动态扩展、收缩；</li>\n<li>位于用户虚拟地址空间顶部。</li>\n</ul>\n</li>\n<li>堆：new分配的内存块，delete释放。</li>\n<li>自由存储区：malloc分配，free释放。</li>\n<li>全局/静态存储区：全局变量与静态变量</li>\n<li>常量存储区：存放常量<ul>\n<li>如 string s1 = “abcd”；s1是代码块中的指针，在栈中；“abcd”是常量，在常量存储区。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"new和malloc的区别：\"><a href=\"#new和malloc的区别：\" class=\"headerlink\" title=\"new和malloc的区别：\"></a>new和malloc的区别：</h2><ol>\n<li>new可以认为是malloc加构造函数的执行；</li>\n<li>new出来的指针是直接带类型信息的，malloc返回void指针；</li>\n<li>delete会相应调用对象的析构函数。</li>\n</ol>\n<hr>\n<h2 id=\"堆和栈的区别：\"><a href=\"#堆和栈的区别：\" class=\"headerlink\" title=\"堆和栈的区别：\"></a>堆和栈的区别：</h2><ol>\n<li>管理方式：栈是编译器自助管理；堆是程序员控制，容易内存泄漏；<ul>\n<li>内存泄漏：申请指针，指针指向内存，作用域或生命周期到了，指针释 放，但内存并没有释放，也无法访问，变成“死内存”。</li>\n</ul>\n</li>\n<li>空间大小：堆内存几乎没有限制；栈一般有一定大小（编译器有默认值，可修改）</li>\n<li>碎片问题：堆频繁new/delete会产生大量碎片（delete出来的空间几乎不可能恰好等于new的空间）；栈不会；</li>\n<li>生长方向：堆向上；栈向下。</li>\n<li>分配方式：堆动态；栈动态（alloca，但他不需人工释放）或静态（编译器完成）</li>\n<li>分配效率：栈高于堆（栈：计算机系统提供，有底层支持；堆：C/C++库提供）</li>\n</ol>\n<hr>\n<p>以上内容主要来自于<a href=\"http://www.cnblogs.com/daocaoren/archive/2011/06/29/2092957.html\" target=\"_blank\" rel=\"external\">这里</a>。</p>\n"}]