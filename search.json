[{"title":"使用栈-持续更新","url":"http://rylcode.cn/2016/05/23/使用栈-持续更新/","content":"<p>在自己使用栈的时候，特别是对数组，有一个容易犯的错误，就是push数值，其实除非情况特别简单(邻近匹配，即便这样也不推荐，如第一个例子),这样使用栈是不可取的，栈是具有记忆功能的数据结构，我们需要记录的是<font color=\"red\">如何回到</font>我们记忆的路径，而不是我们记忆了什么东西。</p>\n<hr>\n<h2 id=\"数组，字符串的栈\"><a href=\"#数组，字符串的栈\" class=\"headerlink\" title=\"数组，字符串的栈\"></a>数组，字符串的栈</h2><ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/20%20-%20Valid%20Parentheses/20%20-%20Valid%20Parentheses.cpp\" target=\"_blank\" rel=\"external\">邻近括号匹配</a></li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/32%20-%20Longest%20Valid%，20Parentheses/32%20-%20Longest%20Valid%20Parentheses.cpp\" target=\"_blank\" rel=\"external\">非临近括号匹配</a>，注意匹配点的更新标记了不临近的匹配。</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/84%20-%20Largest%20Rectangle%20in%20Histogram/84%20-%20Largest%20Rectangle%20in%20Histogram.cpp\" target=\"_blank\" rel=\"external\">直方图的计算</a>，如<a href=\"http://www.cnblogs.com/lichen782/p/leetcode_Largest_Rectangle_in_Histogram.html\" target=\"_blank\" rel=\"external\">这里的解释</a>，稍微有点错误，正确如下：<ul>\n<li>栈为空，之前所有元素大于当前元素，宽度为i</li>\n<li>栈不空，宽度 = i-temp的位置(因为弹出了，所以temp = s.top()+1)</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"指针-主要是树-的栈\"><a href=\"#指针-主要是树-的栈\" class=\"headerlink\" title=\"指针(主要是树)的栈\"></a>指针(主要是树)的栈</h2><ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/144%20-%20Binary%20Tree%20Preorder%20Traversal/144%20-%20Binary%20Tree%20Preorder%20Traversal.cpp\" target=\"_blank\" rel=\"external\">前序遍历</a></li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/94%20-%20Binary%20Tree%20Inorder%20Traversal/94%20-%20Binary%20Tree%20Inorder%20Traversal.cpp\" target=\"_blank\" rel=\"external\">中序遍历</a></li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/145%20-%20Binary%20Tree%20Postorder%20Traversal/145%20-%20Binary%20Tree%20Postorder%20Traversal.cpp\" target=\"_blank\" rel=\"external\">后序遍历</a></li>\n</ol>\n<p>基本来讲，树的栈遍历都是用一个while以及嵌套在内的一个while与一个if实现的(只有后序可以例外，一个while,以及嵌套的if-else实现)。</p>\n"},{"title":"数字输入与atoi函数","url":"http://rylcode.cn/2016/05/22/数字输入与atoi函数/","content":"<p>这篇博客来源于编程中的数字输入检查，最终选择<code>cingetline()</code>加<code>atoi()</code>函数进行输入检查转换。</p>\n<hr>\n<h2 id=\"输入\"><a href=\"#输入\" class=\"headerlink\" title=\"输入\"></a>输入</h2><h3 id=\"cin的学问\"><a href=\"#cin的学问\" class=\"headerlink\" title=\"cin的学问\"></a>cin的学问</h3><p>首先分析<code>cin</code>,<code>cin.get()</code>,<code>cin.getline()</code>:</p>\n<ol>\n<li><code>cin&lt;&lt;</code>会忽略<strong>有效字符前的</strong>空格，换行符，制表符(开始有效输入之后非法就退出了)；</li>\n<li><code>cin.get()</code>读取每一个字符；</li>\n<li><code>cin.getline()</code>读取一行到字符串中，并把<code>\\n</code>替换为<code>\\0</code>存储。</li>\n</ol>\n<p>测试中发现更多的问题：</p>\n<ol>\n<li>cin.getline(字符指针(char*),字符个数N(int),结束符(char));其只读取N-1个字符，因为最后一个字符要补<code>\\0</code>,如果<font color=\"red\">输入超过N-1</font>,会将状态位设置：<code>ios_base::failbit</code>(表示轻微错误，可以挽回。查看<code>cin.getline()</code>源码很明显)，注意剩下的字符依然在输入队列中。</li>\n<li><code>cin.getline()</code>超过N-1输入状态位设置：<code>ios_base::failbit</code>(可修复的)，这时候不能使<code>cin&lt;&lt;</code>和<code>cin.get()</code>和<code>cin.getline()</code>，此时输入队列有值。应该用<code>cin.clear()</code>设置状态位<code>ios_base::goodbit</code>才能继续读取。</li>\n<li><a href=\"https://www.zhihu.com/question/40160488\" target=\"_blank\" rel=\"external\">cin.sync()</a>亲自测试<code>cin.sync()</code>并不是如网上所说的清空缓冲区(相信英语是对的…),<code>cin.ignore()</code>才是。</li>\n</ol>\n<p>在编写主界面时，经常会碰到如下语句：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int index = 0;</span><br><span class=\"line\">switch(index)&#123;</span><br><span class=\"line\">\tcase 1:</span><br><span class=\"line\">\tcase 2:</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\tdefault：</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上述语句没有对<code>index</code>变量进行输入检查，显然不安全，那么如何进行输入检查？</p>\n<h3 id=\"一般的错误处理机制\"><a href=\"#一般的错误处理机制\" class=\"headerlink\" title=\"一般的错误处理机制\"></a>一般的错误处理机制</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int index;</span><br><span class=\"line\">while (!cin&lt;&lt;idex) &#123;</span><br><span class=\"line\">\tcin.clear();</span><br><span class=\"line\">\twhile(cin.get()!=&apos;\\n&apos;)</span><br><span class=\"line\">\t\tcontinue;</span><br><span class=\"line\">\tcout&lt;&lt;&quot;请再次输入&quot;&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里会解决错误输入的问题,但是有一个新的问题，如输入<code>5a</code>，<code>cin&lt;&lt;</code>只会让<code>index=5</code>，<code>a</code>留在输入队列中，会影响下一次的输入。</p>\n<h3 id=\"atoi-引发的思考\"><a href=\"#atoi-引发的思考\" class=\"headerlink\" title=\"atoi()引发的思考\"></a>atoi()引发的思考</h3><p>原型：<code>int atoi(const char *nptr);</code>;<br>头文件：<code>#include &lt;cstdlib&gt;</code>;<br><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/8%20-%20String%20to%20Integer%20(atoi)/8%20-%20String%20to%20Integer%20(atoi).cpp\" target=\"_blank\" rel=\"external\">LeetCode</a></p>\n<p>这里有一个非常重要的概念，不管是数字输入韩式字符串转数字，都是<strong>遇到有效输入开始读取，直到碰到无效输入退出</strong><br>也就是说其实<code>cin&lt;&lt;</code>就是对输入缓存进行了一个atoi()。区别就是在<code>cin&lt;&lt;</code>退出之后同行中的非法输入(如果有)还是留在输入队列中，影响后续读入。<br>因此可以使用<code>cingetline()</code>加<code>atoi()</code>函数进行输入检查转换是安全的。代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int k = 0;</span><br><span class=\"line\">char s1[20];\t//注意分配空间和,很久没用char[]，</span><br><span class=\"line\">cin.getline(s1,20);</span><br><span class=\"line\">k = atoi(s1);</span><br></pre></td></tr></table></figure></p>\n"},{"title":"二元运算符重载与友元函数","url":"http://rylcode.cn/2016/05/21/二元运算符重载与友元函数/","content":"<p>一般来说，在基础知识的介绍中不会提供代码，无论哪一本语法书中都会有大篇幅的代码和例子，而博客只是用作总结提纲复习之用，没有必要提供代码(STL等代码分析除外)，如果需要细致的分析，建议查看《C++ primer plus》和《C++ Primer》</p>\n<hr>\n<h2 id=\"OPP特性的分析\"><a href=\"#OPP特性的分析\" class=\"headerlink\" title=\"OPP特性的分析\"></a>OPP特性的分析</h2><p>首先分析OPP特性：</p>\n<ol>\n<li>抽象：指抽象接口的类设计；</li>\n<li>封装和数据隐藏：通过访问控制实现封装，数据隐藏是封装的一种<ul>\n<li>数据隐藏(数据放在类的私有部分)</li>\n<li>私有成员函数(实现细节私有化)</li>\n<li>类函数定义和声明放在不同的文件中(类定义封装)</li>\n</ul>\n</li>\n<li>多态：通过重载(静态多态)和vtbl(虚函数表，动态多态)实现<ul>\n<li>vtbl</li>\n<li>运算符重载(成员函数和友元函数)</li>\n<li>函数重载</li>\n</ul>\n</li>\n<li>继承：is-a关系，公有继承(常用，派生类可以使用基类方法)，保护继承，私有继承。</li>\n<li>代码可重用性：库，类库，类继承。</li>\n</ol>\n<hr>\n<h2 id=\"运算符重载\"><a href=\"#运算符重载\" class=\"headerlink\" title=\"运算符重载\"></a>运算符重载</h2><h3 id=\"规则\"><a href=\"#规则\" class=\"headerlink\" title=\"规则\"></a>规则</h3><p>先上接口：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">operator+();</span><br><span class=\"line\">operator*();</span><br><span class=\"line\">operator[]();</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>注意在函数之前有返回类型和类的作用域声明。运算符重载有一定的限制：</p>\n<ol>\n<li>重载后的运算符必须至少有一个操作数是用户定义的类型(不然会引发已知类型的运算符冲突)；</li>\n<li>使用运算符不能违反运算符原来的句法规则(操作数数量和优先级不能改变，编译器无法解释)</li>\n<li>不能创建新的运算符，还有一些运算符不能重载(查看可重载运算符列表)</li>\n<li><code>=,(),[],-&gt;</code>只能通过成员函数重载。</li>\n</ol>\n<p><strong>一般而言(下面的问题2的解决方案中就有例外)，单目运算符最好重载为类的成员函数，双目运算符最好重载为类的友元函数。</strong></p>\n<h3 id=\"疑问\"><a href=\"#疑问\" class=\"headerlink\" title=\"疑问\"></a>疑问</h3><p>在运算符传递的过程中，运算符左侧的对象是调用对象，右侧的对象是传递的对象。于是就会产生两个问题：</p>\n<ol>\n<li>基本四则运算(<code>+，-，*，/</code>)的交换律怎么满足?(如<code>a = b*2</code>可以匹配，但<code>a = 2*b</code>无法匹配)</li>\n<li>如何对自定义的类使用<code>ostream</code>对象(<code>&lt;&lt;</code>如何重载)?(<code>a&lt;&lt;cout</code>太过奇怪)</li>\n</ol>\n<hr>\n<h2 id=\"友元函数\"><a href=\"#友元函数\" class=\"headerlink\" title=\"友元函数\"></a>友元函数</h2><p>先回答上面的问题,引入友元函数来解决,简单解释：</p>\n<h3 id=\"什么是友元\"><a href=\"#什么是友元\" class=\"headerlink\" title=\"什么是友元\"></a>什么是友元</h3><p>特性：访问权限与成员函数相同的非成员函数;<br>创建：</p>\n<ol>\n<li>在类声明中使用<code>friend</code>关键字；</li>\n<li>在类定义中不要使用<code>friend</code>和类限定符(因为不是成员函数);</li>\n</ol>\n<h3 id=\"如何解决问题\"><a href=\"#如何解决问题\" class=\"headerlink\" title=\"如何解决问题\"></a>如何解决问题</h3><p>问题的答案：</p>\n<ol>\n<li>问题1中的不同类型运算使用 成员函数重载+友元函数(不同类型)重载 做到分别匹配；或者使用自动转换(特定类型的构造函数)+友元函数(相同类型，都是自定义的)来实现。前者运行速度快但程序长，后者程序简短但时间内存开销大。</li>\n<li>非成员函数重载<code>&lt;&lt;</code>，并返回<code>ostream&amp;</code>来保证连续输出(必须返回引用，因为<code>ostream</code>没有共有的复制构造函数)。<code>ostream&amp; operator&lt;&lt;(ostream &amp;os,const A &amp;a)</code>。</li>\n</ol>\n<p>使用友元函数要注意规避二义性错误。自动转换和转换函数会在下一篇中分析。</p>\n"},{"title":"链表的精髓-持续更新","url":"http://rylcode.cn/2016/05/21/链表的精髓/","content":"<p>术有穷而道无穷。一些简单的方法在实践过程中往往知易行难。在这里我会持续记录一些链表操作中值得注意的事情以及一些小小的有趣的事情。希望大家可以会心一笑。在链表操作中，发现最重要的一个概念就是<font color=\"red\">前驱</font>(后继同样重要，但是链表的后继太容易得到)。对于链表的调整，包括插入，删除，转置等操作，都涉及到链表结构的重组，在重组中前驱就是串联各个节点的线。</p>\n<hr>\n<h2 id=\"前驱和后继\"><a href=\"#前驱和后继\" class=\"headerlink\" title=\"前驱和后继\"></a>前驱和后继</h2><p>链表自带后继<code>-&gt;next</code>,最后一个节点的后继通常为<code>nullptr</code>，可以看作超尾。而编程过程中往往喜欢创建一个头节点，这是由于链表头是最特殊的一个节点，他没有前驱，不能写入循环中，往往会有<code>if else</code>之类的语句单独处理头节点(深受其害)。于是产生了这种方法，给链表建立一个虚拟的头节点，一切问题引刃而解。</p>\n<h3 id=\"逆置部分链表\"><a href=\"#逆置部分链表\" class=\"headerlink\" title=\"逆置部分链表\"></a>逆置部分链表</h3><p><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/92%20-%20Reverse%20Linked%20List%20II/92%20-%20Reverse%20Linked%20List%20II.cpp\" target=\"_blank\" rel=\"external\">LeetCode链表的部分转置</a><br>头指针L永远是前驱,q是当前要处理的节点，p是pre指针，指向最前的节点(<code>q = p;p = p-&gt;next;</code>)。而转置的核心代码只有两行(<code>q-&gt;next = l;l = q;</code>)。</p>\n<h3 id=\"删除当前节点\"><a href=\"#删除当前节点\" class=\"headerlink\" title=\"删除当前节点\"></a>删除当前节点</h3><p><a href=\"https://github.com/applefishsky009/BeautyOfProgramming/blob/master/3.4%20-%20%E4%BB%8E%E6%97%A0%E5%A4%B4%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9/3.4.cpp\" target=\"_blank\" rel=\"external\">狸猫换太子</a><br>这个没见过很难想到，见过绝对就回了……</p>\n"},{"title":"Binary Search的陷阱","url":"http://rylcode.cn/2016/05/20/Binary-Search的陷阱/","content":"<p>先上<a href=\"https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95\" target=\"_blank\" rel=\"external\">二分搜索算法wiki</a>，再上<a href=\"http://www.cppblog.com/converse/archive/2009/09/21/96893.aspx\" target=\"_blank\" rel=\"external\">二分查找写正确的方法</a>。简单说说二分搜索：</p>\n<p>主要用于<font color=\"red\">有序数组</font>的遍历，时间复杂度O(log(n))，比之顺序遍历的时间复杂度O(n)更优，空间复杂度为O(1)。如用在插入排序中。</p>\n<hr>\n<h2 id=\"三点原则\"><a href=\"#三点原则\" class=\"headerlink\" title=\"三点原则\"></a>三点原则</h2><ol>\n<li>为了防止溢出折半时应该这么写<code>mid = start + (end - start) / 2;</code>；</li>\n<li>因为大部分情况不是大于就是小于，因此一般在最后检测相等(如下例，检测条件过于复杂，因此放在开始检测相等少写一个检测条件，写全条件容易出错，一般用于debug)。</li>\n<li>传入的一定是左闭右闭区间，因此递归入口为<code>low &lt;= high</code>，由原则2可知递归出口判断写在入口之后。</li>\n</ol>\n<hr>\n<h2 id=\"陷阱\"><a href=\"#陷阱\" class=\"headerlink\" title=\"陷阱\"></a>陷阱</h2><p>二分法，顾名思义，就是将区间一分为二传入递归函数，但是注意区间有开闭之分，因此在过程中一定要注意，例<a href=\"https://github.com/applefishsky009/LeetCode/blob/master/33%20-%20Search%20in%20Rotated%20Sorted%20Array/33%20-%20Search%20in%20Rotated%20Sorted%20Array.cpp\" target=\"_blank\" rel=\"external\">LeetCode - 33</a></p>\n<ol>\n<li>不建议传入左开右开区间，增加判断次数，但是这样写极为简单，不得已可以使用，如例子中的<code>Solution</code>;</li>\n<li>传入左闭右闭区间，递归入口一定是<code>low &lt;= high</code>,不能少等号;</li>\n<li>如例子中的<code>Solution1</code>所警示，在另外有区间判断的条件时注意<code>int</code>向下取整的特性，可能会有<code>low == mid;</code>需要特殊分析。</li>\n</ol>\n"},{"title":"模九同余与各位数字之和","url":"http://rylcode.cn/2016/05/18/模九同余与各位数字之和/","content":"<p>$$ a\\equiv b\\quad(mod\\ n) $$<br>此式即\\( a \\)与\\( b \\)同余于\\( n \\)；简称\\( a \\)与\\( b \\)模\\( n \\)同余。<br>同余运算见<a href=\"https://en.wikipedia.org/wiki/Modular_arithmetic\" target=\"_blank\" rel=\"external\">维基百科</a></p>\n<hr>\n<h2 id=\"模九同余\"><a href=\"#模九同余\" class=\"headerlink\" title=\"模九同余\"></a>模九同余</h2><p>结论：任何一个整数模9同余于它的各数位上数字之和。<br>题目：设自然数\\( N=a[n]a[n-1]\\ldots a[0] \\)，其中\\( a[0],a[1],\\ldots,a[n] \\)分别是个位、十位、…上的数字，再设\\( M=a[0]+a[1]+\\ldots+a[n] \\)<br>求证：\\( N\\equiv M\\quad(mod\\ 9) \\)<br>证明：</p>\n<p>$$ \\because N=a[n]a[n-1]…a[0]=a[n]\\times10^n+a[n-1]\\times10^{n-1}+\\cdots+a[1]\\times10+a[0] $$<br>又<br>$$ \\because 1\\equiv 1\\quad(mod\\ 9) $$<br>$$ 10\\equiv 1\\quad(mod\\ 9) $$<br>$$ 10^2\\equiv 1\\quad(mod\\ 9) $$<br>$$ \\cdots $$<br>$$ 10^n\\equiv 1\\quad(mod\\ 9) $$</p>\n<p>上面这些同余式两边分别同乘以\\( a[0],a[1],a[2],\\ldots,a[n] \\)<br>再相加得：</p>\n<p>$$ a[n]\\times10^n+a[n-1]\\times10^{n-1}+\\cdots+a[1]\\times10+a[0]\\equiv (a[0]+a[1]+…+a[n])\\quad(mod\\ 9) $$<br>即<br>$$ N\\equiv M\\quad(mod\\ 9) $$<br>得证。</p>\n<p>参考：<a href=\"http://www.cnblogs.com/Rinyo/archive/2012/12/20/2826755.html\" target=\"_blank\" rel=\"external\">找规律</a></p>\n<hr>\n<h2 id=\"LeetCode\"><a href=\"#LeetCode\" class=\"headerlink\" title=\"LeetCode\"></a><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/258%20-%20Add%20Digits/258%20-%20Add%20Digits.cpp\" target=\"_blank\" rel=\"external\">LeetCode</a></h2><hr>\n<h2 id=\"2012-2012\"><a href=\"#2012-2012\" class=\"headerlink\" title=\"\\( 2012^{2012} \\)\"></a>\\( 2012^{2012} \\)</h2><p>题目：记\\( 2012^{2012} \\)的各位数字之和为\\( A \\),\\( A \\)的各位数字之和是\\( B \\)，\\( B \\)的各位数字之和是\\( C \\)，求\\( C \\)的值。</p>\n<h3 id=\"2012-2012-的余数\"><a href=\"#2012-2012-的余数\" class=\"headerlink\" title=\"\\( 2012^{2012} \\)的余数\"></a>\\( 2012^{2012} \\)的余数</h3><p>$$ \\because 2012 \\equiv 5\\quad(mod\\ 9) $$<br>\\begin{equation}<br>\\begin{split}<br>\\therefore 2012^{2012} &amp; \\equiv 5^{2012}\\quad(mod\\ 9) \\\\<br>&amp; \\equiv 25^{1006}\\quad(mod\\ 9) \\\\<br>&amp; \\equiv (-2)^{1006}\\quad(mod\\ 9) \\\\<br>&amp; \\equiv 2^{1006}\\quad(mod\\ 9) \\\\<br>&amp; \\equiv 2\\times8^{335}\\quad(mod\\ 9) \\\\<br>&amp; \\equiv 2\\times(-1)^{335}\\quad(mod\\ 9) \\\\<br>&amp; \\equiv -2\\quad(mod\\ 9) \\\\<br>&amp; \\equiv 7<br>\\end{split}<br>\\end{equation}</p>\n<h3 id=\"C的最大值\"><a href=\"#C的最大值\" class=\"headerlink\" title=\"C的最大值\"></a>C的最大值</h3><p>$$ \\because 2012^{2012}&lt;10000^{2012}-1 $$<br>$$ \\Rightarrow A&lt;2012\\times4\\times9=72504 $$<br>$$ \\Rightarrow B&lt;6+4\\times9=42 $$<br>$$ \\Rightarrow C&lt;3+9=12 $$<br>$$ \\therefore C=7 $$</p>\n<p>思路：<strong>算出最大位数</strong>，每一位给9算出\\( A,B,C \\)的最大值。</p>\n"},{"title":"伯努利级数","url":"http://rylcode.cn/2016/05/18/伯努利级数/","content":"<p>先来彩蛋，在<a href=\"http://www.wolframalpha.com/\" target=\"_blank\" rel=\"external\">wolframalpha</a>使用Latex格式输入数学公式，可以快速得到结果。</p>\n<p>考虑以下四种无穷级数：<br>$$ \\sum_n\\frac{1}{n^2\\pm\\omega^2}\\qquad(1) $$</p>\n<p>$$ \\prod_n(1\\pm\\frac{\\omega^2}{n^2})\\qquad(2) $$</p>\n<p>在式\\( (1) \\)中当\\( \\omega=0 \\)时，公式变为伯努利级数：<br>$$ \\sum_n\\frac{1}{n^2}\\qquad(3) $$</p>\n<p>式\\( (3) \\)中是一个非常有意思的题目，下面考虑来解决他，式\\( (1) \\)和式\\( (2) \\)并不会经常用到，具体解答见<a href=\"http://mp.weixin.qq.com/s?__biz=MzA5ODUxOTA5Mg==&amp;mid=404226908&amp;idx=1&amp;sn=93aa43ffa9157af03ad82543493cfe51&amp;scene=23&amp;srcid=042515FZI3kzNY54U1YJaKv8#rd\" target=\"_blank\" rel=\"external\">算法与数学之美</a>的这篇文章。<a href=\"https://zh.wikipedia.org/wiki/%E5%B7%B4%E5%A1%9E%E5%B0%94%E9%97%AE%E9%A2%98\" target=\"_blank\" rel=\"external\">维基百科上的解答</a></p>\n<p>与式\\( (3) \\)相似的一个题目:<br>$$ \\sum_nn^2 = \\frac{1}{6}n(n+1)(2n+1)\\qquad(4)$$<br>这个题目可以用数学归纳法简单求得。</p>\n<hr>\n<h2 id=\"伯努利级数\"><a href=\"#伯努利级数\" class=\"headerlink\" title=\"伯努利级数\"></a>伯努利级数</h2><p>$$ \\sum_n\\frac{1}{n^2}=1+\\frac{1}{4}+\\frac{1}{9}+\\frac{1}{16}+\\cdots\\qquad(5) $$</p>\n<h3 id=\"泰勒展开\"><a href=\"#泰勒展开\" class=\"headerlink\" title=\"泰勒展开\"></a>泰勒展开</h3><p>首先，我们考虑式\\( \\frac{sin\\sqrt{x}}{\\sqrt{x}}=0 \\)的根为\\( n^2\\pi^2,n=1,2,3,\\ldots \\)<br>左侧泰勒展开式为<br>$$ \\frac{sin\\sqrt{x}}{\\sqrt{x}}=1-\\frac{x}{6}+\\frac{x^2}{120}-\\frac{x^3}{5040}+\\cdots\\qquad(6) $$</p>\n<h3 id=\"韦达定理\"><a href=\"#韦达定理\" class=\"headerlink\" title=\"韦达定理\"></a>韦达定理</h3><p>其次，考虑一元n次方程的韦达定理：<br>$$ 1+a_1x+a_2x^2+\\cdots+a_nx^n=0\\qquad(7) $$</p>\n<p>假设他有\\( n \\)个非零根\\( x_1,x_2,\\ldots,x_n \\),将它转化为关于\\( \\frac{1}{x} \\)的方程：<br>$$ (\\frac{1}{x})^n+a_1(\\frac{1}{x})^{n-1}+\\cdots+a_n=0\\qquad(8) $$<br>对应根变成\\( 1/x_1,1/x_2,\\ldots,1/x_n \\)，由韦达定理得到：<br>$$ \\frac{1}{x_1}+\\frac{1}{x_2}+\\cdots+\\frac{1}{x_n}=-a_1\\qquad(9) $$</p>\n<h3 id=\"欧拉的大胆推广\"><a href=\"#欧拉的大胆推广\" class=\"headerlink\" title=\"欧拉的大胆推广\"></a>欧拉的大胆推广</h3><p>将式\\( (9) \\)推广在式\\( (6) \\)为0的根中：</p>\n<p>$$ \\frac{1}{\\pi^2}+\\frac{1}{2^2\\pi^2}+\\frac{1}{3^2\\pi^2}+\\cdots=-a_1=\\frac{1}{6}\\qquad(10) $$<br>那么：<br>$$ 1+\\frac{1}{2^2}+\\frac{1}{3^2}+\\cdots=\\frac{\\pi^2}{6}\\qquad(11) $$</p>\n<p>如算法与数学之美中所说，其启发性创造性远远掩盖其不严格性。</p>\n<h3 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h3><p>如果直接在式\\( (7) \\)中使用韦达定理，得到<br>$$ -\\frac{a_{n-1}}{a_n}=\\pi^2\\sum_nn^2=\\frac{\\pi^2}{6}n(n+1)(2n+1)\\qquad(12) $$<br>但是这个只有在\\( n\\rightarrow\\infty \\)才是有意义的，例如不能取\\( n=3 \\)(一个特定数值)来使等式成立。就如式\\( (11) \\)中取级数前\\( n=3 \\)部分使之成立。因此对无穷级数的未知项用韦达定理是没有意义的。</p>\n"},{"title":"牛顿迭代法","url":"http://rylcode.cn/2016/05/17/牛顿迭代法/","content":"<p>牛顿迭代法是一种巧妙地(切线)逼近方法，它是一种在实数域和复数域上近似求解方程的方法。<a href=\"https://zh.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E6%B3%95\" target=\"_blank\" rel=\"external\">维基百科的介绍</a></p>\n<p>下面的图(来源于wiki)巧妙的解释了牛顿迭代法的过程：<br><img src=\"http://i.imgur.com/2y9UyHF.gif\" alt=\"牛顿迭代法\"></p>\n<p>公式如下：<br>$$ x_{n+1} = x_n-\\frac{f(x_n)}{f’(x_n)} $$</p>\n<p>Markdownpad2不支持Latex有点烦，使用atom编辑器和markdowm pas plus插件可以解决这个问题，在HEXO博客上部署数学公式需要给HEXO安装<a href=\"http://catx.me/2014/03/09/hexo-mathjax-plugin/\" target=\"_blank\" rel=\"external\">hexo-mathjax插件</a>,注意在本机中使用时不需要修改_config.yml配置文件，否则会生成错误。<br>参考：<a href=\"http://www.jeyzhang.com/how-to-insert-equations-in-markdown.html\" target=\"_blank\" rel=\"external\">MarkdownPad 2的MathJax插件</a></p>\n<hr>\n<h2 id=\"牛顿迭代法在开方中的应用\"><a href=\"#牛顿迭代法在开方中的应用\" class=\"headerlink\" title=\"牛顿迭代法在开方中的应用\"></a>牛顿迭代法在开方中的应用</h2><p>开方的迭代式：<br>$$ x_{k+1} = \\frac{1}{2}(x_k+\\frac{n}{x_k}) $$</p>\n<ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/69%20-%20Sqrt(x)/69%20-%20Sqrt(int%20x).cpp\" target=\"_blank\" rel=\"external\"><code>int</code>开方</a></li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/69%20-%20Sqrt(x)/69%20-%20Sqrt(int%20x).cpp\" target=\"_blank\" rel=\"external\"><code>float</code>开方</a></li>\n<li>Magic Number(只针对<code>float</code>，链接同2)</li>\n</ol>\n<ul>\n<li>在开方的计算中，二分查找和牛顿迭代法时间复杂度都是O(logn)，但是牛顿迭代法优于二分查找。</li>\n<li>基于牛顿迭代法的<code>float</code>开方中使用Magic Number，可以看到使用3次牛顿迭代法就可以得到较高的精确度(相同的迭代次数，要开放的数字越大，精度越低)，其原理与浮点数的存储相关，因此只用于浮点数。</li>\n<li>直观来看，开方(凹型曲线)时牛顿迭代法只从右侧逼近，二分查找从右侧左侧同时逼近,因此显然牛顿迭代法优于二分查找法，尤其对高阶的f(x),牛顿迭代法的逼近速度更快。</li>\n</ul>\n"},{"title":"multimap简介","url":"http://rylcode.cn/2016/05/16/multimap简介/","content":"<h2 id=\"multimap简介\"><a href=\"#multimap简介\" class=\"headerlink\" title=\"multimap简介\"></a>multimap简介</h2><p>multimap是一种Hash Table。首先使用<code>multimap</code>必须使用宏语句<code>#include &lt;map&gt;</code>。MSDN上对multimap的解释已经比较清楚<a href=\"http://blog.csdn.net/chenyujing1234/article/details/8193172\" target=\"_blank\" rel=\"external\">multimap基础</a>，<a href=\"http://blog.csdn.net/xz_rabbit/article/details/43907311\" target=\"_blank\" rel=\"external\">multimap与map，unorderedmap的对比</a><br>主要有以下几点：</p>\n<ol>\n<li>multimap多重映照容器:容器的数据结构采用红黑树进行管理(还没有深入理解)；</li>\n<li>multimap的所有元素都是pair:第一元素为键值(key),不能修改;第二元素为实值(value),可被修改 </li>\n<li>multimap特性以及用法与map完全相同，唯一的差别在于: 允许重复键值的元素插入容器(每一个都是用一个<strong>链表</strong>来链接的)，参考<a href=\"https://github.com/applefishsky009/LeetCode/blob/master/126%20-%20Word%20Ladder%20II/126%20-%20Word%20Ladder%20II.cpp\" target=\"_blank\" rel=\"external\">这里的github</a>；</li>\n<li><code>unordered_multimap</code>(目前还没有用到过)的无序存储特点，这是其与<code>multimap</code>最大的区别。</li>\n</ol>\n<hr>\n<h2 id=\"multimap的使用\"><a href=\"#multimap的使用\" class=\"headerlink\" title=\"multimap的使用\"></a>multimap的使用</h2><ol>\n<li>初始化:<code>multimap&lt;string, string&gt; father;</code>，第一个是key类型，第二个是映照类型；</li>\n<li>插入数据:<code>father.insert(make_pair(string1, string2);</code>，<a href=\"http://www.cnblogs.com/Nimeux/archive/2010/10/05/1844191.html\" target=\"_blank\" rel=\"external\"><code>pair</code>与<code>make_pair</code>介绍</a>。</li>\n<li>寻找某个键值:<code>pair&lt;multimap&lt;string, string&gt;::iterator, multimap&lt;string, string&gt;::iterator&gt; pos = father.equal_range(string1)</code>;<code>equal_range(string1);</code>注意其返回的是<code>pair</code>对象，<code>first</code>和<code>second</code>都是迭代器类型，他返回键值为<code>string1</code>的左指针和超尾(右)指针(最后一个键值为<code>string1</code>的下一个指针)，源码如下：</li>\n</ol>\n<pre><code>typedef pair&lt;iterator, iterator&gt; _Pairii;\n\n_Pairii equal_range(const key_type&amp; _Keyval)\n{    // find range equivalent to _Keyval in mutable tree\n    return (_Eqrange(_Keyval));\n}\n</code></pre>"},{"title":"i++与++i的区别","url":"http://rylcode.cn/2016/05/06/i++与++i的区别/","content":"<p>一直以来对<code>++i</code>与<code>i++</code>，知道前者效率更高，但是不知道为什么。有人说与寄存器有关，实际上寄存器都执行了一次加法，是一样的。看了<a href=\"http://falldog7.blogspot.jp/2007/10/programmer-i-i.html\" target=\"_blank\" rel=\"external\">这里的博客</a>才恍然大悟，原来是其实现的机制不同。</p>\n<p><code>++i</code>先加再用，其对i类型(假设为INT)的++运算符重载如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//++i</span><br><span class=\"line\">INT operator ++()&#123;</span><br><span class=\"line\">\tthis-&gt;_value++;</span><br><span class=\"line\">\treturn *this;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>i++</code>先用再加，创建临时变量保存原有值用来返回，后调用++i语句，重载如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//i++</span><br><span class=\"line\">INT operator ++(int t)&#123;</span><br><span class=\"line\">\tINT temp(_value);//!!! 必須create出一個temp的變數!!!</span><br><span class=\"line\">\tthis-&gt;_value++;</span><br><span class=\"line\">\treturn temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在这个函数中参数n是没有任何意义的，它的存在只是为了区分是前置形式还是后置形式。</p>\n<p>可以看到<code>i++</code>所必须付出的代价，就是多create出一个temp的变量，以及temp变量的的constructor()。</p>\n"},{"title":"二叉树的递归遍历与栈遍历","url":"http://rylcode.cn/2016/05/06/二叉树的递归遍历与栈遍历/","content":"<p>二叉树的遍历算法有三种，最简单的递归遍历，还有两种非递归遍历，分别是使用栈的遍历和Morris遍历。每一种遍历根据访问根节点的时机又分为前序，中序，后序三种。<br>二叉树节点的定义如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct TreeNode &#123;</span><br><span class=\"line\">\tint val;</span><br><span class=\"line\">\tTreeNode *left;</span><br><span class=\"line\">\tTreeNode *right;</span><br><span class=\"line\">\tTreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"二叉树的递归遍历\"><a href=\"#二叉树的递归遍历\" class=\"headerlink\" title=\"二叉树的递归遍历\"></a>二叉树的递归遍历</h2><p>没什么技巧，方式如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvoid Traversal(TreeNode* root,vector&lt;int&gt; &amp;result) &#123;</span><br><span class=\"line\">\t\tif (!root)</span><br><span class=\"line\">\t\t\treturn;</span><br><span class=\"line\">\t\t//result.push(root-&gt;val);\t//preorderTraversal</span><br><span class=\"line\">\t\tTraversal(root-&gt;left,result);</span><br><span class=\"line\">\t\t//result.push(root-&gt;val);\t//inorderTraversal</span><br><span class=\"line\">\t\tTraversal(root-&gt;right,result);</span><br><span class=\"line\">\t\t//result.push(root-&gt;val);\t//postorderTraversal</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"二叉树的栈遍历\"><a href=\"#二叉树的栈遍历\" class=\"headerlink\" title=\"二叉树的栈遍历\"></a>二叉树的栈遍历</h2><p>前序和中序可以用同一段代码来实现(用栈记忆所有左子树(while)，回溯一位(if)访问右子树)：<br><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/144%20-%20Binary%20Tree%20Preorder%20Traversal/144%20-%20Binary%20Tree%20Preorder%20Traversal.cpp\" target=\"_blank\" rel=\"external\">前序遍历</a><br><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/94%20-%20Binary%20Tree%20Inorder%20Traversal/94%20-%20Binary%20Tree%20Inorder%20Traversal.cpp\" target=\"_blank\" rel=\"external\">中序遍历</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class=\"line\">\t\tvector&lt;int&gt; result;</span><br><span class=\"line\">\t\tstack&lt;TreeNode*&gt; sS1;</span><br><span class=\"line\">\t\twhile (root||!sS1.empty())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\twhile (root)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t//result.push_back(root-&gt;val);\t//先序遍历的位置</span><br><span class=\"line\">\t\t\t\tsS1.push(root);</span><br><span class=\"line\">\t\t\t\troot = root-&gt;left;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tif (!sS1.empty())</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\troot = sS1.top();</span><br><span class=\"line\">\t\t\t\tsS1.pop();</span><br><span class=\"line\">\t\t\t\tresult.push_back(root-&gt;val);\t//中序遍历的位置</span><br><span class=\"line\">\t\t\t\troot = root-&gt;right;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn result;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>后序遍历稍微复杂一点，有两种思路：</p>\n<ol>\n<li>左子树-&gt;右子树-&gt;节点(后序)    转化为    节点-&gt;右子树-&gt;左子树(前序) 的翻转(栈)</li>\n<li>对于任一结点P，先将其入栈。如果P不存在左孩子和右孩子，则可以直接访问它。或者P存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。若非上述两种情况，则将P的右孩子和左孩子依次入栈。这样就保证了每次取栈顶元素的时候，左孩子和右孩子都在根结点前面被访问。</li>\n</ol>\n<p><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/145%20-%20Binary%20Tree%20Postorder%20Traversal/145%20-%20Binary%20Tree%20Postorder%20Traversal.cpp\" target=\"_blank\" rel=\"external\">后序遍历</a><br>第一种(变异的前序)：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution1 &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class=\"line\">\t\tvector&lt;int&gt; outTreeNode;</span><br><span class=\"line\">\t\tstack&lt;TreeNode*&gt; sTreeNode;</span><br><span class=\"line\">\t\tstack&lt;int&gt; sInt;</span><br><span class=\"line\">\t\twhile (root||!sTreeNode.empty())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\twhile (root)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tsInt.push(root-&gt;val);</span><br><span class=\"line\">\t\t\t\tsTreeNode.push(root);</span><br><span class=\"line\">\t\t\t\troot=root-&gt;right;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tif (!sTreeNode.empty())</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\troot=sTreeNode.top();</span><br><span class=\"line\">\t\t\t\tsTreeNode.pop();</span><br><span class=\"line\">\t\t\t\troot=root-&gt;left;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\twhile (!sInt.empty())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\toutTreeNode.push_back(sInt.top());</span><br><span class=\"line\">\t\t\tsInt.pop();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn outTreeNode;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>第二种(利用pre指针的后序)：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class=\"line\">\t\tvector&lt;int&gt; outTreeNode;</span><br><span class=\"line\">\t\tstack&lt;TreeNode*&gt; sTreeNode;</span><br><span class=\"line\">\t\tTreeNode* pre=nullptr;\t//指向之前访问的节点</span><br><span class=\"line\">\t\tif (root)</span><br><span class=\"line\">\t\t\tsTreeNode.push(root);</span><br><span class=\"line\">\t\twhile (!sTreeNode.empty())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\troot=sTreeNode.top();</span><br><span class=\"line\">\t\t\tif ((root-&gt;left==nullptr&amp;&amp;root-&gt;right==nullptr)||(pre!=nullptr&amp;&amp;(pre==root-&gt;left||pre==root-&gt;right)))</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\toutTreeNode.push_back(root-&gt;val);</span><br><span class=\"line\">\t\t\t\tpre=root;</span><br><span class=\"line\">\t\t\t\tsTreeNode.pop();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\telse</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tif (root-&gt;right)</span><br><span class=\"line\">\t\t\t\t\tsTreeNode.push(root-&gt;right);//右孩子先入栈，后访问</span><br><span class=\"line\">\t\t\t\tif (root-&gt;left)</span><br><span class=\"line\">\t\t\t\t\tsTreeNode.push(root-&gt;left);//左孩子后入栈，先访问</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn outTreeNode;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"BP、KMP、改进的KMP","url":"http://rylcode.cn/2016/05/03/BP、KMP、改进的KMP/","content":"<p>在主串S中，自low位置开始，查找与模式串T相等的子串。如果这样的子串存在，返回其第一次出现的位置。本文详细介绍三种字符串匹配算法:</p>\n<ol>\n<li>BF(Brute-Force)算法(暴力破解);</li>\n<li>KMP算法;</li>\n<li>改进的KMP算法。</li>\n</ol>\n<p>这三种算法的代码<a href=\"https://github.com/applefishsky009/Interface/blob/master/BF%E5%92%8CKMP/BF%E5%92%8CKMP.cpp\" target=\"_blank\" rel=\"external\">在这里</a>。</p>\n<hr>\n<h2 id=\"BF算法\"><a href=\"#BF算法\" class=\"headerlink\" title=\"BF算法\"></a>BF算法</h2><p>设主串从i位开始与子串(从0开始)判断是否匹配;到子串的j位置，对应主串的i+j位置失配;将主串左移一位(<code>i++</code>),j回到0位继续匹配。</p>\n<hr>\n<h2 id=\"KMP算法\"><a href=\"#KMP算法\" class=\"headerlink\" title=\"KMP算法\"></a>KMP算法</h2><h3 id=\"为什么是next-j\"><a href=\"#为什么是next-j\" class=\"headerlink\" title=\"为什么是next[j]\"></a>为什么是next[j]</h3><p>每次失配将i右移一位显然是低效的。<strong>主观上来考虑，如果在失配之前子串有相等的真后缀，那么就可以右移更多的位。</strong>考虑在i+j位失配时将主串左移k位(子串右移k位)，而不是一位。容易得到，这个k只与子串的性质有关。<br>我们使用next[j]来标识当j位失配时子串应向右移j-next[j]位。示例:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><code>abcdefg</code></th>\n<th style=\"text-align:center\">0 1 2 3 4 5 6</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>next[j]</code></td>\n<td style=\"text-align:center\">-1 0 0 0 0 0 0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">offset</td>\n<td style=\"text-align:center\">1 1 2 3 4 5 6</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><code>abcabcabc</code></th>\n<th style=\"text-align:center\">0 1 2 3 4 5 6 7 8</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>next[j]</code></td>\n<td style=\"text-align:center\">-1 0 0 0 1 2 3 4 5</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">offset</td>\n<td style=\"text-align:center\">1 1 2 3 3 3 3 3 3</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"如何求得next-j\"><a href=\"#如何求得next-j\" class=\"headerlink\" title=\"如何求得next[j]\"></a>如何求得next[j]</h3><p><img src=\"http://i.imgur.com/qc2eynB.png\" alt=\"这里\"></p>\n<p>在计算公式中第二行指的是:j位<strong>以前</strong>字串中真前后缀的最大<strong>公共</strong>元素长度。真前缀、真后缀指的不包含串本身的子串。那么我们可以这样来计算j:<br>tempNext[j]表示j位及以前子串真前缀最大公共元素长度。将tempNext[j]右移一位，初值赋为-1,得到next[j]</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><code>xyxyyxxyx</code></th>\n<th style=\"text-align:center\">0 1 2 3 4 5 6 7 8</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>tempNext[j]</code></td>\n<td style=\"text-align:center\">0 0 1 2 0 1 1 2 3</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>next[j]</code></td>\n<td style=\"text-align:center\">-1 0 0 1 2 0 1 1 2</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">offset</td>\n<td style=\"text-align:center\">1 1 2 2 2 5 5 6 6</td>\n</tr>\n</tbody>\n</table>\n<p>tempNext[j]的计算:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//计算j位及之前真前缀以及真后缀的最大公共元素长度</span><br><span class=\"line\">void calTempNext(vector&lt;int&gt;&amp;next)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif (s2.size() == 1)</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\tnext[0] = 0;</span><br><span class=\"line\">\tint k = 0;//前缀指针,j就是后缀指针</span><br><span class=\"line\">\tfor (int j = 1;j &lt; s2.size();j++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\twhile(k &gt; 0 &amp;&amp; s2[j] != s2[k])//k位失配，</span><br><span class=\"line\">\t\t\tk = next[k-1];//k-1是可靠匹配，next[k-1]记录了上一个真后缀出现的地方</span><br><span class=\"line\">\t\tif (s2[j] == s2[k])//匹配，k++,j++，next[j]赋值</span><br><span class=\"line\">\t\t\tk++;</span><br><span class=\"line\">\t\tnext[j] = k;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"如何在编程中求得next-j\"><a href=\"#如何在编程中求得next-j\" class=\"headerlink\" title=\"如何在编程中求得next[j]\"></a>如何在编程中求得next[j]</h3><p>如果使用上述计算过程，先计算tempNext[j]再计算next[j]，需要两次遍历。将tempNext[j]右移初值赋-1的过程可以直接融入程序中，使用一次遍历就可以得到next[j]，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//直接计算next(时间复杂度O(n))</span><br><span class=\"line\">void cal2Next(vector&lt;int&gt;&amp;next)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint j = -1;\t\t//j,偏移指针</span><br><span class=\"line\">\tint i = 0;\t\t//i,next下标（实际上是要计算的next下标-1,因为是先加后赋值）</span><br><span class=\"line\">\tnext[0] = -1;</span><br><span class=\"line\">\twhile (i &lt; s2.size()-1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif (j == -1 || s2[i]==s2[j])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ti++;</span><br><span class=\"line\">\t\t\tj++;</span><br><span class=\"line\">\t\t\tnext[i] = j;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\tj = next[j];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"改进的KMP算法\"><a href=\"#改进的KMP算法\" class=\"headerlink\" title=\"改进的KMP算法\"></a>改进的KMP算法</h2><p>next[j]值越小，模式匹配所需比较次数越少。next[j]的计算中先判断匹配，i,j自加再赋值。</p>\n<ol>\n<li>若自加之后失配，这时候i失配并不代表j失配，因此留给下次循环回溯后来判断。</li>\n<li>若自加之后匹配，说明i与j位置完全等效，i失配，j一定失配。，而朴素的KMP算法在失配之后要一次一次回溯。因此可以<font color=\"red\">一次回溯到底</font>节约比较次数。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><code>abcaabbabcaac</code></th>\n<th style=\"text-align:center\">0 1 2  3 4 5 6  7 8 9 10 11 12</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>next[j]</code></td>\n<td style=\"text-align:center\">-1 0 0  0 1 1 2  0 1 2  3  4  5</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">offset1</td>\n<td style=\"text-align:center\">1 1 2  3 3 4 4  7 7 7  7  7  7</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>nextVal[j]</code></td>\n<td style=\"text-align:center\">-1 0 0 -1 1 0 2 -1 0 0 -1  1  5</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">offset2</td>\n<td style=\"text-align:center\">1 1 2  4 3 5 4  8 8 9 11 10  7</td>\n</tr>\n</tbody>\n</table>\n<p><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/28%20-%20Implement%20strStr()/28%20-%20Implement%20strStr().cpp\" target=\"_blank\" rel=\"external\">LeetCode代码</a></p>\n"},{"title":"野指针与内存泄漏","url":"http://rylcode.cn/2016/04/25/野指针与内存泄漏/","content":"<p>野指针和内存泄漏是两个相联系的概念，一般来讲指针&lt;-&gt;内存相互对应，如果有一个指针但没有指向任何内存，就是野指针；如果有一块未释放的内存，但没有指针指向他，就是内存泄露。</p>\n<hr>\n<h2 id=\"野指针\"><a href=\"#野指针\" class=\"headerlink\" title=\"野指针\"></a>野指针</h2><p>野指针指向一个已删除对象或未申请访问受限内存区域的指针，一般来说野指针有三个成因：</p>\n<ol>\n<li>指针变量未初始化；</li>\n<li>指针释放后未置空；</li>\n<li>指针操作超越变量作用域。</li>\n</ol>\n<p>值得注意的是，如果有多个指针指向同一块内存，释放其中一个指针后，应将包含这个指针在内的指向这一块内存的所有指针都置空，否则都会成为野指针。</p>\n<h2 id=\"内存泄漏\"><a href=\"#内存泄漏\" class=\"headerlink\" title=\"内存泄漏\"></a>内存泄漏</h2><p>在某一块内存的生命周期内，指向它的指针全部指向别处时，用户无法访问，也无法申请到这一块内存。这就是内存泄露。</p>\n"},{"title":"Git命令","url":"http://rylcode.cn/2016/04/23/Git命令/","content":"<p>初学git，记录当时的一些解决方法。</p>\n<ol>\n<li><a href=\"https://www.zhihu.com/question/22132675\" target=\"_blank\" rel=\"external\">删除不想要的git历史</a><code>git rebase -i SHA</code>如果之后有版本，会有conflict，根据提示<code>git rebase --abort</code>会放弃修改，<code>git rebase --skip</code>会跳过这个(放弃冲突的提交,也就是说之后的提交都没了)<code>git rebase --continue</code>应该会保留之后的提交,暂时没有进行测试。</li>\n<li><a href=\"https://segmentfault.com/q/1010000000115900\" target=\"_blank\" rel=\"external\">删除版本库中的提交</a>注意，他将HEAD指向某一个commit，之后的commit和文件都被擦除了，删除前做好备份……</li>\n<li>博客中常用的命令：hexo clean(删除一些没有用的缓存，比如删掉的tag等);hexo generate(生成一个commit?);hexo deploy(提交到远程)</li>\n<li>使用过程中碰到<a href=\"http://stackoverflow.com/questions/9299651/git-says-warning-permanently-added-to-the-list-of-known-hosts\" target=\"_blank\" rel=\"external\">Warning: Permanently added ‘github.com,192.30.252.120’ (RSA) to the list of known hosts</a>.这个问题在linux下很好解决,但我用windows for github，困扰好久，方法如下：在C:/user/###(你的用户名)/.ssh/新建config文件(无后缀),添加UserKnownHostsFile ~/.ssh/known_hosts,下一次访问你还会看到，但是之后(可能要多几次，我的三次才可以，因为在这个文件夹下添加了三个ip)就没有了。</li>\n<li>windows下换行符<a href=\"http://www.luckyonecn.com/blog/git-auto-crlf-problem/\" target=\"_blank\" rel=\"external\">warning: LF will be replaced by CRLF</a>，不知道为什么我的<code>git config --global autocrlf false</code>没有用，因此直接在仓库中将config文件，core中修改autocrlf = false,没有则添加。</li>\n</ol>\n"},{"title":"动态规划","url":"http://rylcode.cn/2016/04/22/动态规划/","content":"<p>持续更新，记录在编程过程中关于动态规划(DP)的心得体会。算法分析以算法导论为主。主要是用于求解最优化问题，不同于递归用于解决互不相交的子问题，动态规划应用于子问题重叠的情况。在实际应用中发现他有两个关键点：</p>\n<ol>\n<li>子问题的<strong>状态转移方程</strong>(递推关系式)；</li>\n<li>保存子问题的解用于递归(自顶向下);</li>\n</ol>\n<p>它有两种等价的实现方式：</p>\n<ol>\n<li>带备忘的自顶向下；</li>\n<li>自底向上。</li>\n</ol>\n<p>一般来说自底向上更容易实现。实际中哪一种更容易编程取决于具体问题。</p>\n<ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/120%20-%20Triangle/120%20-%20Triangle.cpp\" target=\"_blank\" rel=\"external\">triangle</a></li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/tree/master/62%20-%20Unique%20Paths\" target=\"_blank\" rel=\"external\">Unique Paths</a></li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/53%20-%20Maximum%20Subarray/53%20-%20Maximum%20Subarray.cpp\" target=\"_blank\" rel=\"external\">LeetCode:Maximum Subarray</a>和<a href=\"https://github.com/applefishsky009/BeautyOfProgramming/blob/master/2.14%20-%20%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/2.14.cpp\" target=\"_blank\" rel=\"external\">BeautyOfProgramming:一维数组的最大子数组</a><ul>\n<li>注意递推关系式(未改进版)(主要是理清逻辑，需要一个\\( nStart[i] \\)的递推):</li>\n<li>\\( nStart[i] = max(nStart[i-1]+A[i],nAll[i-1]) \\);</li>\n<li>\\( nAll[i] = max(nStart[i],nAll[i-1]) \\) </li>\n</ul>\n</li>\n<li></li>\n</ol>\n"},{"title":"贪心算法","url":"http://rylcode.cn/2016/04/22/贪心算法/","content":"<p>持续更新，记录在编程过程中关于贪心算法的心得体会。算法分析以算法导论为主。求解最优化问题比动态规划更为简洁高效。其思想核心是<font color=\"red\">选择当前最优解</font>，虽然不一定是全局最优解。贪心算法主要应用有</p>\n<ol>\n<li>活动选择问题</li>\n<li>霍夫曼编码</li>\n<li>最小生成树</li>\n<li>单元最短路径的Dijkstra算法</li>\n<li>集合覆盖问题的贪心启发式算法</li>\n</ol>\n<p>贪心算法的形式一般有<strong>递归贪心算法</strong>，<strong>迭代贪心算法</strong>。</p>\n<hr>\n<h2 id=\"活动选择问题\"><a href=\"#活动选择问题\" class=\"headerlink\" title=\"活动选择问题\"></a>活动选择问题</h2><ol>\n<li>调度竞争共享资源的多个活动问题，选出最大的互相兼容的活动集合；<ul>\n<li>选择一个活动，选出他后剩下的资源能尽量多的被其他任务所用(算法导论16.1)；</li>\n</ul>\n</li>\n<li>Jump Game；<ul>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/55%20-%20Jump%20Game/55%20-%20Jump%20Game%20%20.cpp\" target=\"_blank\" rel=\"external\">Jump Game</a>,每个节点选择更新当前最优解。</li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/45%20-%20Jump%20Game%20II/45%20-%20Jump%20Game%20II.cpp\" target=\"_blank\" rel=\"external\">Jump GameⅡ</a>, 每一步选择当前最优解(层数，是一层一一层映射的关系，怎么感觉是在广搜？!)。</li>\n<li>Jump GameⅡ比Jump Game多出统计步数，在这个映射范围内选择最优解</li>\n</ul>\n</li>\n</ol>\n"},{"title":"函数参数的传递","url":"http://rylcode.cn/2016/04/22/函数参数的传递/","content":"<p>函数参数的传递有三种，按值传递，按址传递，按引用传递(C++新增)。</p>\n<hr>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><h3 id=\"引用的本质\"><a href=\"#引用的本质\" class=\"headerlink\" title=\"引用的本质\"></a>引用的本质</h3><p>C++将<code>&amp;</code>符号赋予了另一个含义，用来声明引用。引用是已定义变量的别名(同一块内存)。引用的主要作用是用作函数形参。<br>引用的本质是<font color=\"red\">指针常量</font>，例如<code>int &amp;pr = rats;</code>是<code>int* const pr = &amp;rats;</code>的伪装。它的含义是他是一个指针，指向一个常量地址。因此他有以下特性也就很好理解了：</p>\n<ol>\n<li>必须在声明引用是将其初始化；(因为指向常量地址)</li>\n<li>初始化时，省略了取地址符的操作<code>&amp;</code>,给我们感觉是别名；</li>\n<li>声明引用时，隐藏了对指针常量的自动间接引用，让我们看不到指针。</li>\n<li>使用引用时，隐藏了解除引用<code>*</code>,让我们觉得是在直接修改(别名)变量。<br>如下：<img src=\"http://i.imgur.com/idRXQZy.png\" alt=\"这里\"></li>\n</ol>\n<h3 id=\"返回引用\"><a href=\"#返回引用\" class=\"headerlink\" title=\"返回引用\"></a>返回引用</h3><ol>\n<li>返回引用比传统返回机制烧了拷贝复制，效率更高。</li>\n<li>返回引用本质是返回“别名”,因此要注意保证返回后这个内存依然存在。(变量持续性)</li>\n<li>返回类型<strong>一般</strong>用<font color=\"red\"><code>const</code>标识</font>，将其设置为不可修改的左值，避免数据损失。<ul>\n<li>赋值语句，左边必须是可修改的左值；</li>\n<li>常规返回类型是右值(因为其位于临时内存单元)-&gt;不能通过地址访问。(可以出现在表达式右边，但不能出现在左边，如字面值<code>10.0</code>,表达式<code>x+y</code>) </li>\n</ul>\n</li>\n</ol>\n<p>如果返回局部变量(运算符重载中)，不能返回引用。</p>\n<h3 id=\"C-C-中的左值和右值\"><a href=\"#C-C-中的左值和右值\" class=\"headerlink\" title=\"C/C++中的左值和右值\"></a>C/C++中的左值和右值</h3><ol>\n<li>左值是一个引用到对象的表达式，因此可以取址(可以赋值)；</li>\n<li>右值强调的不是表达式本身，而是该表达式运算后的结果。这个结果往往并不引用到某一对象，可以看成计算的中间结果(临时内存单元)；（当然它也可能引用到某一对象，但是通过该右值表达式我们不能直接修改该对象—）。</li>\n</ol>\n<hr>\n<h2 id=\"按值传递\"><a href=\"#按值传递\" class=\"headerlink\" title=\"按值传递\"></a>按值传递</h2><p>C++将数值参数传递给函数，函数将其赋给一个新的变量，新变量与旧变量在赋值之后没有任何关系。</p>\n<hr>\n<h2 id=\"按址传递\"><a href=\"#按址传递\" class=\"headerlink\" title=\"按址传递\"></a>按址传递</h2><p>C++将参数地址传递给函数，函数原型用指针(一般用<code>const</code>修饰表示指针不会乱指)指向这个地址</p>\n<hr>\n<h2 id=\"数组传递\"><a href=\"#数组传递\" class=\"headerlink\" title=\"数组传递\"></a>数组传递</h2><p>数组在传递时，编译器将数组名解释为第一个元素的地址，因此传递实参为数组时，形参应该是一个指针指向这个地址。<br>在用多维数组名作为形参时，可以指定所有维数的大小，也可以省略第一位的大小(高维大小必须指定)，这与编译器寻址有关，比如<code>int p[m][n]</code>如果要取<code>p[i][j]</code>的值，编译器会计算地址为<code>p+i*n+j;</code>，因此编译器可以不知道m的值，但必须知道n的值。</p>\n"},{"title":"BFS和DFS","url":"http://rylcode.cn/2016/04/21/BFS和DFS/","content":"<p>持续更新,该贴记录一些BFS和DFS在使用过程中的心得体会，以加深对BFS与DFS的理解。</p>\n<hr>\n<h2 id=\"BFS-广度优先搜索\"><a href=\"#BFS-广度优先搜索\" class=\"headerlink\" title=\"BFS(广度优先搜索)\"></a>BFS(广度优先搜索)</h2><p>BFS需要借助一个队列来记录遍历的”层数”；每遍历目标集合一次，<strong>步长</strong>加一；队列为空，结束搜寻。</p>\n<ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/127%20-%20World%20Ladder/127%20-%20World%20Ladder.cpp\" target=\"_blank\" rel=\"external\">Word Ladder</a></li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/126%20-%20Word%20Ladder%20II/126%20-%20Word%20Ladder%20II.cpp\" target=\"_blank\" rel=\"external\">Word Ladder II</a></li>\n</ol>\n<hr>\n<h2 id=\"DFS-深度优先搜索\"><a href=\"#DFS-深度优先搜索\" class=\"headerlink\" title=\"DFS(深度优先搜索)\"></a>DFS(深度优先搜索)</h2><p>DFS需要用递归或者借助栈来<strong>记录</strong>走过的路径；每遍历完这条分支，便要<strong>回溯</strong>到上一层；在递归之前可以记录深度。</p>\n<ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/131%20-%20Palindrome%20Partitioning/131%20-%20Palindrome%20Partitioning.cpp\" target=\"_blank\" rel=\"external\">Palindrome Partitioning</a></li>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/126%20-%20Word%20Ladder%20II/126%20-%20Word%20Ladder%20II.cpp\" target=\"_blank\" rel=\"external\">Word Ladder II</a></li>\n</ol>\n"},{"title":"共用体、枚举和浮点数存储","url":"http://rylcode.cn/2016/04/21/共用体、枚举和浮点数存储/","content":"<h2 id=\"共用体\"><a href=\"#共用体\" class=\"headerlink\" title=\"共用体\"></a>共用体</h2><p>是一种数据格式，简单来说，在同一块内存地址，可以同时起不同数据类型的名字，用这些名字来取值时，名字所对应的数据类型告诉编译器怎么去解释内存中的数据。他的特点：</p>\n<ol>\n<li>它的长度是最大数据类型长度，可以节省空间；</li>\n<li>数据不共存；</li>\n<li>关键字<code>union</code>，声明方式与结构体相同；</li>\n</ol>\n<hr>\n<h2 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h2><p>创建符号常量的方式，简单来说就是将一个“标签”与枚举量对应起来。特点：</p>\n<ol>\n<li>可以提升(常到<code>int</code>)，但<code>int</code>不能缩窄到它；</li>\n<li>可以显式设置枚举量，枚举范围内即使没有枚举量，也合法；</li>\n<li>关键词<code>enum</code>，声明方式与结构体相似；</li>\n<li>他没有算术运算，一般常用于<code>swith</code>语句中的标签。</li>\n</ol>\n<hr>\n<h2 id=\"浮点数存储方式\"><a href=\"#浮点数存储方式\" class=\"headerlink\" title=\"浮点数存储方式\"></a>浮点数存储方式</h2><p>不管是什么数据类型，在内存中的表示方式都是一样的(0或者1)，数据类型的作用只是告诉编译器如何去解释内存中的数据，那么编译器是如何解释浮点型的？<br>首先，二进制科学法表示中，一个浮点型S = M*2^N，内存会存储三部分：符号位+阶码(N)+尾数(M)；</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">数据</th>\n<th style=\"text-align:center\">符号位</th>\n<th style=\"text-align:center\">阶码</th>\n<th style=\"text-align:center\">尾数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>float</code></td>\n<td style=\"text-align:center\">1位</td>\n<td style=\"text-align:center\">8位</td>\n<td style=\"text-align:center\">23位</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">内存位</td>\n<td style=\"text-align:center\">31</td>\n<td style=\"text-align:center\">30-23</td>\n<td style=\"text-align:center\">22-0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>double</code></td>\n<td style=\"text-align:center\">1位</td>\n<td style=\"text-align:center\">11位</td>\n<td style=\"text-align:center\">52位</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">内存位</td>\n<td style=\"text-align:center\">63</td>\n<td style=\"text-align:center\">62-52</td>\n<td style=\"text-align:center\">51-0</td>\n</tr>\n</tbody>\n</table>\n<p>其次，阶码使用中间偏置(固定量为2^N-1)的移码表示的,M的整数部分为1,不存储，只存储尾数即可。<br>例如，125.5f = <code>1111101.1</code> = 1.1111011*2^6 =&gt;移码127+6 = 133 = <code>10000101</code> =&gt;正数符号位是0，尾数补0到够23位,那么计算机中：<code>01000010 10000000 00000000 01111011</code>。</p>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><ol>\n<li>整型常量默认情况下是int型,浮点常量在默认情况下是<code>double</code>型,如果需要<code>float</code>型，需要这样表示：<code>3.25f</code>；</li>\n</ol>\n"},{"title":"string类与结构体","url":"http://rylcode.cn/2016/04/21/string类与结构体/","content":"<h2 id=\"string类\"><a href=\"#string类\" class=\"headerlink\" title=\"string类\"></a>string类</h2><h3 id=\"string运算符\"><a href=\"#string运算符\" class=\"headerlink\" title=\"string运算符\"></a>string运算符</h3><p><code>string</code>类的运算符重载在头文件<code>string</code>里,如<code>+</code>,<code>&lt;&lt;</code>。注意<code>&quot;a&quot;+&quot;b&quot; = &quot;ab&quot;</code>,<code>&#39;a&#39;+&#39;b&#39; = 195</code>,前者是字符串拼接，后者是字符常量相加。但是<code>cout&lt;&lt;&quot;a&quot;+&quot;b&quot;;</code>这个语句是错误的，必须至少声明两个<code>string</code>类型。</p>\n<h3 id=\"string-find\"><a href=\"#string-find\" class=\"headerlink\" title=\"string.find()\"></a>string.find()</h3><p><code>string</code>类的<code>find()</code>方法，可以用于找子串，返回子串在原串出现的下标。<a href=\"http://www.cnblogs.com/web100/archive/2012/12/02/cpp-string-find-npos.html\" target=\"_blank\" rel=\"external\">这里</a>和<a href=\"http://www.cplusplus.com/reference/string/string/find/\" target=\"_blank\" rel=\"external\">这里</a>有详细解释，使用时注意以下三点：</p>\n<ul>\n<li>接受三个参数，第一个是子串，第二个是开始寻找的下标，第三个参数是匹配字串的字符数。可以用于找全部的匹配子串；</li>\n<li>如果没有找到，返回值是<code>string::npos</code>，他是一个很大的正数；</li>\n<li>返回值是<code>size_t</code>，一般可用<code>auto</code>来代替。</li>\n</ul>\n<p>以下代码可以输出全部的匹配位置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string s1 = &quot;abcdbcgbcdbjjkklbcdbcdbcdghjbcd&quot;;</span><br><span class=\"line\">string s2 = &quot;bcd&quot;;</span><br><span class=\"line\">auto k  = s1.find(s2);</span><br><span class=\"line\">while (k != string::npos)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tcout&lt;&lt;k&lt;&lt;endl;</span><br><span class=\"line\">\tk = s1.find(s2,k+1);\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"string-substr\"><a href=\"#string-substr\" class=\"headerlink\" title=\"string.substr()\"></a>string.substr()</h3><p>函数声明如下：<code>_Myt substr(size_type _Off = 0, size_type _Count = npos) const</code>，返回从指定位置(_Off)开始的长度为(_Count)的子字符串。</p>\n<hr>\n<h2 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h2><ol>\n<li>基本项，可以列表化，提倡外部结构声明，可以使用赋值运算符,列表初始化不允许缩窄转换。</li>\n<li>结构体对准：<ul>\n<li>结构体首地址能被其最宽基本类型成员的大小所整除；</li>\n<li>结构体每个成员相对于结构体首地址的偏移量(offset)都是成员大小整数倍；</li>\n<li>结构体的总大小是结构体最宽基本类型成员大小的整数倍。</li>\n</ul>\n</li>\n<li>与此相关还有栈对准，某些编译器(x64?)按大小对准，<code>char</code>位于栈底，<code>double</code>位于栈顶排列。找不到相关资料了，需要深入了解。</li>\n</ol>\n<p>示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Definition for a binary tree node.</span><br><span class=\"line\">struct TreeNode &#123;</span><br><span class=\"line\">\tint val;</span><br><span class=\"line\">\tTreeNode *left;</span><br><span class=\"line\">\tTreeNode *right;</span><br><span class=\"line\">\tTreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"cctype与进制数转化","url":"http://rylcode.cn/2016/04/21/cctype与进制数转化/","content":"<h2 id=\"进制转化\"><a href=\"#进制转化\" class=\"headerlink\" title=\"进制转化\"></a>进制转化</h2><ol>\n<li>控制符dec，hex，oct用于设置整数显式的进制数，分别对应十进制，16进制，八进制，语法：<code>cout&lt;&lt;dec;</code>,<code>cout&lt;&lt;hex;</code>,<code>cout&lt;&lt;oct</code>。</li>\n<li>头文件<code>cstdlib</code>中的<code>char *_itoa(int value,char string,int radix)</code>可以设置任一进制的输出。<ul>\n<li>参数一：要转换的数据；</li>\n<li>参数二：存放结果的字符串地址；</li>\n<li>参数三：进制数；</li>\n<li>返回值：指向结果字符串的指针。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"cctype\"><a href=\"#cctype\" class=\"headerlink\" title=\"cctype\"></a>cctype</h2><p>主要是<code>cctype</code>头文件中的字符函数在编程过程中可以带来很多便利，常用的总结如下：</p>\n<ol>\n<li><code>isalpha()</code>,<code>isdigit()</code>,<code>isalnum()</code>可以用于判断是字符、数字、字母或数字。返回<code>true</code>或<code>false</code>。</li>\n<li><code>islower()</code>,<code>isupper()</code>,<code>isprint()</code>可以用于判断是小写字母、大写字符、可显示字符。返回<code>true</code>或<code>false</code>。<a href=\"https://zh.wikipedia.org/wiki/ASCII#.E5.8F.AF.E6.98.BE.E7.A4.BA.E5.AD.97.E7.AC.A6\" target=\"_blank\" rel=\"external\">可显示字符</a>从32到126一共95个。</li>\n<li><code>tolower()</code>,<code>toupper()</code>用于大小写字母的转换，如果不需要转换，字符不变。</li>\n<li>另外一些不常用的字符函数,<code>isgraph()</code>(除空格之外的打印字符),<code>ispunct()</code>(标点符号),<code>isspace()</code>(标准空白字符),<code>iscntrl()</code>(控制字符),<code>isxdigit()</code>(16进制,即1-9,a-f,A-F)。</li>\n</ol>\n<hr>\n"},{"title":"类型转换","url":"http://rylcode.cn/2016/04/20/类型转换/","content":"<p>C++自动执行以下类型转换：</p>\n<ul>\n<li>不同算术类型的赋值；</li>\n<li>包含不同类型的表达式；</li>\n<li>函数调用</li>\n</ul>\n<hr>\n<h2 id=\"初始化和赋值进行的转换\"><a href=\"#初始化和赋值进行的转换\" class=\"headerlink\" title=\"初始化和赋值进行的转换\"></a>初始化和赋值进行的转换</h2><p>扩展没有问题；缩窄可能会有一些问题:</p>\n<ul>\n<li>精度降低(double-&gt;float等);</li>\n<li>数字截短(float-&gt;int等);</li>\n<li>数据丢失(long-&gt;short等)。</li>\n</ul>\n<hr>\n<h2 id=\"列表初始化时的转换\"><a href=\"#列表初始化时的转换\" class=\"headerlink\" title=\"列表初始化时的转换\"></a>列表初始化时的转换</h2><p>不允许缩窄。</p>\n<hr>\n<h2 id=\"表达式的转换\"><a href=\"#表达式的转换\" class=\"headerlink\" title=\"表达式的转换\"></a>表达式的转换</h2><h3 id=\"自动转化\"><a href=\"#自动转化\" class=\"headerlink\" title=\"自动转化\"></a>自动转化</h3><p><code>int</code>型是计算机最自然的语言，运算速度最快。整型提升(integral promotion)规则如下:</p>\n<ol>\n<li>计算表达式时，C++将<code>bool</code>，<code>char</code>，<code>unsigned char</code>，<code>signed char</code>，<code>short</code>都转换为<code>int</code>；</li>\n<li>如果<code>short</code>和<code>int</code>一样长，<code>unsigned short</code>转换为<code>unsigned int</code>，如果<code>short</code>比<code>int</code>短，<code>unsigned short</code>转换为<code>int</code>。总之，以不损失数据为原则。</li>\n<li>在不损失数据的原则下，同级别有符号数比无符号数优先。</li>\n</ol>\n<h3 id=\"算术运算的转化\"><a href=\"#算术运算的转化\" class=\"headerlink\" title=\"算术运算的转化\"></a>算术运算的转化</h3><p>将较小的类型转换成较大的类型。依次判断long double?-&gt;double?-&gt;float?-&gt;integral promotion!可以看到浮点型优先于整型。具体过程可以查看C++11版本的效验表。</p>\n<hr>\n<h2 id=\"传递参数时的转换\"><a href=\"#传递参数时的转换\" class=\"headerlink\" title=\"传递参数时的转换\"></a>传递参数时的转换</h2><p>由C++函数原型控制，若取消函数原型的控制:</p>\n<ul>\n<li>将对<code>char</code>和<code>short</code>整型提升;</li>\n<li>将<code>float</code>参数提升为<code>double</code>。</li>\n</ul>\n<hr>\n<h2 id=\"强制类型转换\"><a href=\"#强制类型转换\" class=\"headerlink\" title=\"强制类型转换\"></a>强制类型转换</h2><p>C++设计新格式，让强制类型转换像函数一样调用:<code>typename (value)</code>更严格的限制允许的类型转换，以下4个类型转换符：</p>\n<ul>\n<li><code>dynamic_cast</code>;</li>\n<li><code>const_cast</code>;</li>\n<li><code>static_cast</code>;</li>\n<li><code>reinterpret_cast</code>;</li>\n</ul>\n<p>相关：因为指针大小固定(指针的本质是一个存放地址的内存，32位编译器是4字节),任意指针之间可以进行强制转化。</p>\n"},{"title":"栈与字符型变量的地址","url":"http://rylcode.cn/2016/04/20/栈与字符型变量的地址/","content":"<h2 id=\"栈的存储机制\"><a href=\"#栈的存储机制\" class=\"headerlink\" title=\"栈的存储机制\"></a>栈的存储机制</h2><p>在之前的内存存储区之中讲过栈，他大概有以下特点：编译器自助管理；空间大小指定；不会产生碎片；向下生长；静态(主要)或动态(不需要人工释放)分配；效率高。这里以下边的语句为例说明栈的存储：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint a[4] = &#123;1,2,3,4&#125;;</span><br><span class=\"line\">\tint b[4] = &#123;5,6,7,8&#125;;</span><br><span class=\"line\">\tint c[4] = &#123;9,10,11,12&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://i.imgur.com/r0E1t24.jpg\" alt=\"栈\"></p>\n<ol>\n<li>数组名称是一个指针，指向数组的第一个元素；</li>\n<li>a[-2]指的是a指针向栈的地址低位移动2个数据元素大小(例子中是int型)，即访问到b[2]，<strong>但是</strong>实际情况与编译器相关，他会做一些对准或者优化，明白访问原理即可；</li>\n<li>每一个元素在栈中的字节序是Little Endian，即低位字节排放在地址的低地址端，高位字节排放在地址的高地址端。与之对应的还有Big Endian，排放次序相反。</li>\n</ol>\n<hr>\n<h2 id=\"字符型变量的地址\"><a href=\"#字符型变量的地址\" class=\"headerlink\" title=\"字符型变量的地址\"></a>字符型变量的地址</h2><p>字符型变量<code>char c</code>的地址不能用<code>cout&lt;&lt;&amp;c；</code>来表示，因为<code>&amp;c</code>实际上是一个<code>char *</code>型的变量，它输出字符串的值，而字符串只有在内存中读到<code>\\0</code>才会终止，因此会出现乱码。所以要输出字符变量的地址，应该用以下语句告诉编译器如何解释：</p>\n<ol>\n<li><code>(int *)&amp;c</code>;</li>\n<li><code>(static_cast&lt;void *&gt;(&amp;jc)</code>。</li>\n</ol>\n<p>上述的<code>static_cast</code>用于显式类型转换。</p>\n"},{"title":"unordered_set简介","url":"http://rylcode.cn/2016/04/19/unordered_set简介/","content":"<h2 id=\"unordered-set简介\"><a href=\"#unordered-set简介\" class=\"headerlink\" title=\"unordered_set简介\"></a>unordered_set简介</h2><p>首先使用<code>unordered_set</code>必须使用宏语句<code>#include &lt;unordered_set&gt;</code>。MSDN上有对<a href=\"https://msdn.microsoft.com/zh-cn/library/bb982739.aspx\" target=\"_blank\" rel=\"external\">unordered_set</a>描述，CSDN上有博客对<a href=\"http://blog.csdn.net/oabid/article/details/4562577\" target=\"_blank\" rel=\"external\">unordered_set</a>描述，这是一个哈希表。一般来说，一些简单功能可以当做STL里的容器来用：<code>insert()</code>、<font color=\"red\"><code>find()</code></font>、<code>erase()</code>、<code>size()</code>、<code>empty()</code>、<code>begin()</code>、<code>end()</code>。</p>\n<hr>\n<h2 id=\"unordered-set-无序关联容器-与vector的异同\"><a href=\"#unordered-set-无序关联容器-与vector的异同\" class=\"headerlink\" title=\"unordered_set(无序关联容器)与vector的异同\"></a>unordered_set(无序关联容器)与vector的异同</h2><ol>\n<li><code>_Pairib insert(const value_type&amp; _Val);</code>;基本与<code>vector</code>用法相同，参数为要插入的值。</li>\n<li><code>iterator find(const key_type&amp; _Keyval);</code>;若找到该元素，返回的指针指向该元素，没找到返回的指针会指向超尾即<code>end()</code>。与<code>size_type find(_Elem _Ch, size_type _Off = 0) const;</code>有区别，后者会返回下标(<code>size_type</code>可以看做一种足够大的<code>unsigned</code>类型来表示下标)，如果没找到，返回<code>string::npos</code>。而</li>\n<li><code>size_type erase(const key_type&amp; _Keyval);</code>;擦除指定值，返回该指定值的位置。<code>iterator erase(const_iterator _Where);</code>擦除指针指向的值，容器重排，指针不变。</li>\n<li><code>size_type count(const Key&amp; keyval) const;</code>返回unordered_set中指定键对应的元素个数，k-要查找的key值。</li>\n</ol>\n"},{"title":"默认参数与内联函数","url":"http://rylcode.cn/2016/04/19/默认参数与内联函数/","content":"<h2 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h2><p>省略实参时自动使用的值，必须通过函数原型(这是因为函数调用时通过函数原型将函数参数压入栈帧)，使用方法是将值赋给原型中的值(压入栈帧并初始化)。 </p>\n<hr>\n<h2 id=\"内联函数\"><a href=\"#内联函数\" class=\"headerlink\" title=\"内联函数\"></a>内联函数</h2><p>常规函数和内联函数之间的主要区别是C++编译器如何将它们组合到程序中去。</p>\n<h3 id=\"C语言的宏\"><a href=\"#C语言的宏\" class=\"headerlink\" title=\"C语言的宏\"></a>C语言的宏</h3><p>宏是内联代码的原始实现，它的本质是<strong>文本替换</strong></p>\n<ol>\n<li>普通宏定义中，预处理器将空格解释成分段标志；</li>\n<li><code>##</code>是一种分隔连接方式，作用是先分隔后强制连接；</li>\n<li><code>#</code>表示变量替换后加双引号括起来。</li>\n<li>另外一些分隔符、操作符如<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>[</code>、<code>]</code>依然有意义。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define A1(name,type) type name_##type##_type</span><br><span class=\"line\">\tA1(a1,int) &lt;=&gt; int name_int_type</span><br><span class=\"line\">#define A1(name,type) type name##_##type##_type</span><br><span class=\"line\">\tA1(a1,int) &lt;=&gt; int a1_int_type</span><br><span class=\"line\">#define stringify(x) #x</span><br><span class=\"line\">\tstringify(linux) &lt;=&gt; &quot;linux&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"C-内联函数\"><a href=\"#C-内联函数\" class=\"headerlink\" title=\"C++内联函数\"></a>C++内联函数</h3><ol>\n<li>编译器将使用相应的函数代码替换函数调用(省略了来回跳跃并记录跳跃位置的过程)；</li>\n<li>运行速度较快，但占用更多的内存(同一个内联函数调用多少次，就有多少次副本)；</li>\n<li>一般省略原型(但原型特性仍在起作用)，将整个定义放在原本该提供原型的地方(这是首次使用前的函数定义，充当原型)，并使用<code>inline</code>关键字</li>\n<li>编译器并不一定满足程序员内联函数的请求，比如函数过大或者函数调用了自己(递归不能内联)。</li>\n</ol>\n<p>注意类成员函数中的内联函数并不一定使用<code>inline</code>关键字。定义位于类声明中自动成为内联函数；否则使用<code>inline</code>关键字作为内联函数。</p>\n"},{"title":"函数原型与函数调用","url":"http://rylcode.cn/2016/04/18/函数原型与函数调用/","content":"<h2 id=\"函数原型\"><a href=\"#函数原型\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h2><h3 id=\"为什么需要原型\"><a href=\"#为什么需要原型\" class=\"headerlink\" title=\"为什么需要原型\"></a>为什么需要原型</h3><p>原型是函数到编译器的接口，他将函数返回值的类型以及参数的类型和数量告诉编译器。</p>\n<ol>\n<li>原型告诉编译器函数参数类型和数量，如果不准确，它让编译器捕获这种错误</li>\n<li>函数完成计算后，将返回值放在指定的位置(<strong>CPU寄存器或者内存</strong>)以供调用函数取得。</li>\n<li>原型指出返回类型，让编译器知道应检索多少字节以及如何<em>解释</em>他们。</li>\n</ol>\n<h3 id=\"原型语法\"><a href=\"#原型语法\" class=\"headerlink\" title=\"原型语法\"></a>原型语法</h3><p>以<code>void cheers(int);</code>为例，</p>\n<ol>\n<li>函数原型是一条语句，必须以分号结尾；</li>\n<li>函数原型不要求提供变量名，有类型列表就够了(这与函数调用有关，原型中的变量名其实就是栈中的占位符)</li>\n</ol>\n<h3 id=\"原型功能\"><a href=\"#原型功能\" class=\"headerlink\" title=\"原型功能\"></a>原型功能</h3><ol>\n<li>编译器正确处理函数返回值(就是说在<strong>指定位置如何解释</strong>)；</li>\n<li>编译器检查使用的参数数目是否正确(<strong>不正确让编译器捕获错误</strong>)；</li>\n<li>编译器检查参数类型是否正确，如果不正确，可能的话转换为正确类型(编译阶段进行的原型化，静态类型检查)。如下<br><img src=\"http://i.imgur.com/5aaLwcA.png\" alt=\"函数原型进行类型转化\"></li>\n</ol>\n<hr>\n<h2 id=\"函数调用\"><a href=\"#函数调用\" class=\"headerlink\" title=\"函数调用\"></a>函数调用</h2><p>详细过程见<a href=\"http://www.zhihu.com/question/22444939#answer-4080329\" title=\"函数调用中栈的变化\" target=\"_blank\" rel=\"external\">这里</a></p>\n<h3 id=\"相关寄存器\"><a href=\"#相关寄存器\" class=\"headerlink\" title=\"相关寄存器\"></a>相关寄存器</h3><ol>\n<li>栈指针寄存器：指向系统栈最上面一个帧栈栈底的指针；</li>\n<li>基址指针寄存器：指向系统栈最上面一个帧栈栈底的指针；</li>\n<li>指令寄存器：指向下一条待执行的指令地址。</li>\n</ol>\n<h3 id=\"函数调用步骤\"><a href=\"#函数调用步骤\" class=\"headerlink\" title=\"函数调用步骤\"></a>函数调用步骤</h3><ol>\n<li>参数入栈：C++将参数从右向左依次入栈；</li>\n<li>返回地址入栈：将<em>当前</em>代码区调用指令的<em>下一条</em>指令地址压入栈，函数返回时继续执行；</li>\n<li>代码区跳转：从当前代码区跳转到被调函数入口处；</li>\n<li>栈帧调整：<ul>\n<li>当前栈帧的EPB入栈；</li>\n<li>切换到新栈帧,ESP装入EBP；</li>\n<li>给新栈帧分配空间；</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h3><h4 id=\"为什么参数要入栈？\"><a href=\"#为什么参数要入栈？\" class=\"headerlink\" title=\"为什么参数要入栈？\"></a>为什么参数要入栈？</h4><p>为了保存现场，例如一个递归：<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int sum(int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif (n == 0)</span><br><span class=\"line\">\t\treturn 0;</span><br><span class=\"line\">\treturn sum(n-1)+n</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当<code>sum(n-1)</code>返回，他的栈帧被释放，还原到<code>sum(n)</code>的栈帧，那么n的值怎么获得？假如<code>sum</code>是在<code>main()</code>调用的，n在调用时压入了<code>main()</code>的栈帧，并对一个匿名对象拷贝了n的值供<code>sum()</code>计算，如果传地址或者引用就可以直接修改栈帧中的值。<br>这就可以解释为什么按值传递时不能修改上一级函数的数值，因为栈帧会还原，按值传递修改的也不是栈帧中的值。</p>\n"},{"title":"类的复制构造函数和赋值运算符重载","url":"http://rylcode.cn/2016/04/18/类的复制构造函数和赋值运算符重载/","content":"<p>C++会自动提供以下成员函数：</p>\n<ol>\n<li>默认构造函数；</li>\n<li>默认析构函数</li>\n<li>复制构造函数</li>\n<li>赋值运算符</li>\n<li>地址运算符</li>\n</ol>\n<p>之前讨论过构造函数与析构函数，今天讨论复制构造函数与赋值运算符。</p>\n<h2 id=\"类的复制构造函数\"><a href=\"#类的复制构造函数\" class=\"headerlink\" title=\"类的复制构造函数\"></a>类的复制构造函数</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ol>\n<li>作用：复制构造函数用于将一个对象复制到新创建的对象中。也就是用于初始化过程（包括按值传递）,而不是常规的赋值过程。<strong>隐式构造函数<font color=\"red\">按值</font>逐个复制非静态成员</strong>,静态成员属于整个类，不属于某一个对象，因此不受影响。</li>\n<li>何时调用：新建一个对象并将其初始化为同类现有对象。有以下四种可能语法：<ul>\n<li><code>StringBad ditto(motto)</code>;</li>\n<li><code>StringBad *pStringBad = new StringBad(motto)</code>;</li>\n<li><code>StringBad metoo = motto</code>;</li>\n<li><code>StringBad also = StringBad(motto)</code>。</li>\n</ul>\n</li>\n</ol>\n<p>1、2两种声明没有临时匿名对象(或者说临时匿名对象有外部载体);3、4两种声明值是接创建metoo和also还是用复制构造函数构造临时对象然后对象赋值给metoo和also，取决于具体实现。<font color=\"red\">特点是有赋值运算符的非指针构造</font>，在本人的编译器上(VS2012 32)是有临时对象并析构的。</p>\n<h4 id=\"注：\"><a href=\"#注：\" class=\"headerlink\" title=\"注：\"></a>注：</h4><ol>\n<li>无论哪种编译器，按值传递和返回对象时，都将调用复制构造函数。</li>\n<li>由于1，复制构造函数必须<strong>接受类对象的常量引用</strong>作为参数，否则会无限递归调用自身导致堆栈溢出。</li>\n</ol>\n<h3 id=\"默认复制构造函数的缺陷-浅复制\"><a href=\"#默认复制构造函数的缺陷-浅复制\" class=\"headerlink\" title=\"默认复制构造函数的缺陷(浅复制)\"></a>默认复制构造函数的缺陷(浅复制)</h3><ol>\n<li>对象计数器：默认构造函数+显式构造函数+显式构造函数=析构函数。</li>\n<li>隐式复制构造函数是<strong>按值复制</strong>，对于指针指向的new出来的空间，它会使两个指针指向同一块内容，因此在析构时，编译器尝试两次释放同一块内存，这会导致不确定的可能有害的结果。必须定义一个显式复制构造函数给指针开辟新的内存、</li>\n</ol>\n<hr>\n<h2 id=\"类的复制运算符重载-深度复制\"><a href=\"#类的复制运算符重载-深度复制\" class=\"headerlink\" title=\"类的复制运算符重载(深度复制)\"></a>类的复制运算符重载(深度复制)</h2><p>C++的类对象赋值通过自动为类重载赋值运算符实现。赋值运算符是只能由类成员函数重载的运算符之一。<br>如上所说四种新建对象方法，<em>8初始化时总会调用复制构造函数，而是用<code>=</code>运算符也允许调用赋值运算符。</em>但是！赋值运算符的隐式实现也是对成员逐个赋值。那么如上也有两次析构的问题，因此应该提供赋值运算符进行深度复制。<br>其与复制构造函数的差别：</p>\n<ol>\n<li>应该首先检查自我复制，相同返回自身。否则未复制前释放了自身；</li>\n<li>释放拷贝对象之前引用的数据，否则会内存泄露(因为要深度复制会申请新的内存空间并指向他进行数据拷贝，之前的内存指针就丢失了)。</li>\n<li>返回一个指向调用对象的引用以便连续赋值。</li>\n</ol>\n<p>下面这个例子同时犯了复制构造函数和赋值运算符重载的浅复制错误：<br><img src=\"http://i.imgur.com/OwHR2qp.png\" alt=\"典型的浅复制错误\"></p>\n<hr>\n<h2 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h2><ol>\n<li>为什么赋值运算符重载返回类型是引用？之前在<code>*this</code>指针中提过，返回类型为引用意味着返回对象本身而不是其副本。这样在一些含有赋值运算符的初始化中也可以防止递归调用。</li>\n<li>为什么参数类型为引用？对<em>复制构造函数</em>和<em>赋值运算符重载</em>，都是为了防止递归调用。</li>\n</ol>\n"},{"title":"vector之resize方法和reverse方法","url":"http://rylcode.cn/2016/04/15/vector之resize方法和reverse方法/","content":"<h2 id=\"a-resize-和a-reverse\"><a href=\"#a-resize-和a-reverse\" class=\"headerlink\" title=\"a.resize()和a.reverse();\"></a>a.resize()和a.reverse();</h2><ol>\n<li>首先介绍容器的两个属性<code>capacity</code>和<code>size</code>。<code>capacity</code>存储区的大小；<code>size</code>容器的大小。</li>\n<li>‘reverse()’是预分配存储区的大小，预分配存储区，但存储区不一定有容器对象。</li>\n<li>‘resize()’是改变容器大小，容器中一定有容器对象。</li>\n</ol>\n<hr>\n<h3 id=\"a-reverse\"><a href=\"#a-reverse\" class=\"headerlink\" title=\"a.reverse();\"></a>a.reverse();</h3><p>看源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void reserve(size_type _Count)</span><br><span class=\"line\">&#123;\t// determine new minimum length of allocated storage</span><br><span class=\"line\">\tif (capacity() &lt; _Count)</span><br><span class=\"line\">\t&#123;// something to do, check and reallocate</span><br><span class=\"line\">\t\tif (max_size() &lt; _Count)</span><br><span class=\"line\">\t\t\tXlen();</span><br><span class=\"line\">\t\t_Reallocate(_Count);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>没有<code>else</code>，说明若当前的<code>capacity</code>大于传入的值，<strong><code>capacity</code>是不会减小的</strong>；</li>\n<li>里层的if是错误检测机制；</li>\n<li>验证<code>vector</code>的<code>reallocate</code>原理，实际上每次新的<code>capacity</code>是之前的1.5倍。因此在<strong>循环之前一定要<code>reserve</code>保证效率</strong>。</li>\n</ol>\n<hr>\n<h3 id=\"a-resize\"><a href=\"#a-resize\" class=\"headerlink\" title=\"a.resize();\"></a>a.resize();</h3><p>模板类提供了两个函数重载：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">表达式</th>\n<th style=\"text-align:center\"><strong>返回类型</strong></th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>a.resize(n)</code></td>\n<td style=\"text-align:center\">void</td>\n<td style=\"text-align:center\">容器大小设为n</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>a.resize(n,t)</code></td>\n<td style=\"text-align:center\">void</td>\n<td style=\"text-align:center\">容器大小设为n，必要时用t填充</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"a-resize-n\"><a href=\"#a-resize-n\" class=\"headerlink\" title=\"a.resize(n)\"></a>a.resize(n)</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void resize(size_type _Newsize)</span><br><span class=\"line\">&#123;\t// determine new length, padding as needed</span><br><span class=\"line\">\tif (_Newsize &lt; size())</span><br><span class=\"line\">\t\terase(begin() + _Newsize, end());</span><br><span class=\"line\">\telse if (size() &lt; _Newsize)</span><br><span class=\"line\">\t&#123;\t// pad as needed</span><br><span class=\"line\">\t\t_Alty _Alval(this-&gt;_Getal());</span><br><span class=\"line\">\t\t_Reserve(_Newsize - size());</span><br><span class=\"line\">\t\t_TRY_BEGIN</span><br><span class=\"line\">\t\t_Uninitialized_default_fill_n(this-&gt;_Mylast, _Newsize - size(),_Alval);</span><br><span class=\"line\">\t\t_CATCH_ALL</span><br><span class=\"line\">\t\t_Tidy();</span><br><span class=\"line\">\t\t_RERAISE;</span><br><span class=\"line\">\t\t_CATCH_END</span><br><span class=\"line\">\t\tthis-&gt;_Mylast += _Newsize - size();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>若容器新大小小于现在的大小，毁掉多余的对象；</li>\n<li>新大小大于现在的大小：<ul>\n<li>注意<code>_Reserve</code>和<code>.reverse</code>是两个不同的方法，一个比较<code>capacity</code>，一个比较<code>_Unused_capacity</code>；</li>\n<li>检查空间，不够则<code>reverse</code>；</li>\n<li>填充未初始化的对象</li>\n<li>修改尾指针</li>\n</ul>\n</li>\n</ol>\n<p>####a.resize(n,t)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void resize(size_type _Newsize, const value_type&amp; _Val)</span><br><span class=\"line\">&#123;\t// determine new length, padding with _Val elements as needed</span><br><span class=\"line\">\tif (_Newsize &lt; size())</span><br><span class=\"line\">\t\terase(begin() + _Newsize, end());</span><br><span class=\"line\">\telse if (size() &lt; _Newsize)</span><br><span class=\"line\">\t\t_Insert_n(end(), _Newsize - size(), _Val);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>若容器新大小小于现在的大小，毁掉多余的对象；</li>\n<li>新大小大于现在的大小，直接执行<code>insert</code>;</li>\n</ol>\n<hr>\n"},{"title":"vector之erase方法","url":"http://rylcode.cn/2016/04/14/vector之erase方法/","content":"<h2 id=\"a-erase\"><a href=\"#a-erase\" class=\"headerlink\" title=\"a.erase();\"></a>a.erase();</h2><p>模板类提供了两个函数重载：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">表达式</th>\n<th style=\"text-align:center\"><strong>返回类型</strong></th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>a.erase(p)</code></td>\n<td style=\"text-align:center\"><strong>迭代器</strong></td>\n<td style=\"text-align:center\">删除p指向的元素</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>a.erase(p,q)</code></td>\n<td style=\"text-align:center\"><strong>迭代器</strong></td>\n<td style=\"text-align:center\">删除区间[p,q)中的元素</td>\n</tr>\n</tbody>\n</table>\n<p><strong>思考</strong>:</p>\n<ol>\n<li>在之前内存之中讨论过，<code>vector</code>是保证内存连续的，那么<code>erase</code>之后他是如何保证内存连续的？答案是让该元素之后的所有元素前移补充“空位”。这一点在<code>erase()</code>方法的代码中可以看到传入的p的形参是<code>const</code>类型的，也就是说p指向的地址并不发生变化，只不过是元素前移了。测试如下：<br><img src=\"http://i.imgur.com/TZxRRb6.png\" alt=\"STL的迭代器\"></li>\n<li>注意到<code>erase</code>返回的都是迭代器，由1中的分析可知，删除p指向的元素之后，他返回的迭代器的<strong>地址不变</strong>，值是删除之后可用的下一个元素，因此<strong>给人感觉是p指向了下一个元素</strong>。那么在这里有一个值得注意的问题，如下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;int&gt;::iterator p = b.begin();</span><br><span class=\"line\">for (;p!=b.end();p++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif (*p == 2)</span><br><span class=\"line\">\t\tb.erase(p);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这是错误的，<code>b.erase(p)</code>没有迭代器来承接p的返回值，它的返回值被释放了。然后执行p++很显然会出现野指针。但是如果修改为<code>p = b.erase(p)</code>也是不正确的。迭代器在进行删除的这一个循环里会<code>++</code>两次（<code>erase</code>可以当做<code>++</code>一次）。但如果在<code>if</code>语句中执行一次<code>p--</code>，这是正确的。即<code>p = --b.erase(p);</code></p>\n<ol>\n<li>不能用<code>p-- = b.erase(p);</code>，因为<code>p--</code>是表达式，不能为左值；</li>\n<li><p>不能用<code>p = b.erase(p--);</code>，也是因为<code>p--</code>是一个表达式，强调计算结果，不能作为左值，也不能取址。</p>\n<p><strong>迭代器的循环使用<code>while</code>可以降低错误率。</strong></p>\n</li>\n</ol>\n<hr>\n<p>为简单，分析第一个表达式的源码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iterator erase(const_iterator _Where)</span><br><span class=\"line\">&#123;\t// erase element at where</span><br><span class=\"line\">\tif (_VICONT(_Where) != this</span><br><span class=\"line\">\t\t|| _VIPTR(_Where) &lt; this-&gt;_Myfirst</span><br><span class=\"line\">\t\t|| this-&gt;_Mylast &lt;= _VIPTR(_Where))</span><br><span class=\"line\">\t\t_DEBUG_ERROR(&quot;vector erase iterator outside range&quot;);</span><br><span class=\"line\">\t_Move(_VIPTR(_Where) + 1, this-&gt;_Mylast, _VIPTR(_Where));</span><br><span class=\"line\">\t_Destroy(this-&gt;_Mylast - 1, this-&gt;_Mylast);</span><br><span class=\"line\">\t_Orphan_range(_VIPTR(_Where), this-&gt;_Mylast);</span><br><span class=\"line\">\t--this-&gt;_Mylast;</span><br><span class=\"line\">\treturn (_Make_iter(_Where));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到他做了哪些工作,首先元素前移，然后毁掉最后一个对象(<code>capacity</code>不变)，之后<font color=\"red\">_Orphan_range发生了什么？</font>,接下来指针指向正确的位置，最后返回指向原地址的迭代器。</p>\n"},{"title":"vector之insert方法和emplace方法","url":"http://rylcode.cn/2016/04/13/vector之insert方法和emplace方法/","content":"<h2 id=\"a-insert\"><a href=\"#a-insert\" class=\"headerlink\" title=\"a.insert();\"></a>a.insert();</h2><p>模板类提供了三个函数重载,这是一种<strong>拷贝</strong>插入方法：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">表达式</th>\n<th style=\"text-align:center\">返回类型</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>a.insert(p,t)</code></td>\n<td style=\"text-align:center\">迭代器</td>\n<td style=\"text-align:center\">指向原本指向的元素,将t插入到p前面</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>a.insert(p, n,t)</code></td>\n<td style=\"text-align:center\"><code>void</code></td>\n<td style=\"text-align:center\">将n个t插入到p前面</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>a.insert(p,i,j)</code></td>\n<td style=\"text-align:center\"><code>void</code></td>\n<td style=\"text-align:center\">将区间[i,j)插入到p的前面，注意是左闭右开区间，j可以是超尾</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2 id=\"a-emplace\"><a href=\"#a-emplace\" class=\"headerlink\" title=\"a.emplace();\"></a>a.emplace();</h2><p>新标准引入的<code>emplace_front</code>,<code>emplace</code>,<code>emplace_back</code>这些操作是构造而不是拷贝元素。当插入一个对象时，将会比<code>insert</code>少拷贝构造，析构的步骤。</p>\n<hr>\n<h3 id=\"注：\"><a href=\"#注：\" class=\"headerlink\" title=\"注：\"></a>注：</h3><ol>\n<li>调用<code>push</code>或<code>insert</code>成员函数，将元素类型对象传递进去，这些对象被拷贝到容器中；</li>\n<li><code>emplace()</code>在容器中构造元素，因此效率更高；</li>\n<li>注意<code>a.insert(p,t)</code>的源码提供了一个重载，若t是普通类型，则调用<code>a.emplace(p，t)</code>，若t是<code>const</code>类型，则调用<code>a.insert(p,t)</code>。</li>\n</ol>\n"},{"title":"vector简介及非STL函数用法-持续更新","url":"http://rylcode.cn/2016/04/12/vector简介及非STL函数用法-持续更新/","content":"<h2 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h2><p><code>vector</code>模板类是最简单的序列类型，除非其他类型的特殊有点能够满足程序的要求，否则应该默认使用这种类型。以后将记录一些在编程过程中常用的<code>vector</code>方法作为笔记以便不时复习，必要时会分析源码。</p>\n<p>常见的方法有：<br><code>.insert()</code>，<code>a.emplace()</code>，<code>.resize()</code>，<code>.reverse()</code>，<code>.begin()</code>，<code>a.end()</code>，<code>a.rbegin()</code>，<br><code>a.rend()</code>，<code>a.size()</code>，<code>a.swap(b)</code>，<code>a.empty()</code>，<code>a.front()</code>，<code>a.back()</code>，<code>a.clear()</code>，<br><code>a.push_back(t)</code>，<code>a.popback(t)</code>，<code>a[n]</code>，<code>a.at(n)</code>。</p>\n<p>有<code>vector&lt;int&gt; a</code>;<code>vector&lt;int&gt; b</code>;即a,b是<code>vector&lt;int&gt;</code>的对象。<code>vector&lt;int&gt; ::iterator p</code>;p是指向<code>vector&lt;int&gt;</code>的迭代器。i、j、q均和p一样是指向<code>vector&lt;int&gt;</code>的迭代器。</p>\n<hr>\n<h2 id=\"sort-用于vector\"><a href=\"#sort-用于vector\" class=\"headerlink\" title=\"sort()用于vector;\"></a>sort()用于vector;</h2><p>在<code>algorithm&gt;</code>头文件中提供了<code>sort</code>的两个重载函数,查看源码可发现是用<strong>快排</strong>实现的。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">表达式</th>\n<th style=\"text-align:center\"><strong>返回类型</strong></th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>sort(p,q)</code></td>\n<td style=\"text-align:center\"><code>void</code></td>\n<td style=\"text-align:center\">对[p,q)升序排序</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>sort(p,q,cmp)</code></td>\n<td style=\"text-align:center\"><code>void</code></td>\n<td style=\"text-align:center\">对[p,q)使用<code>cmp</code>方法排序，<code>cmp</code></td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li>右闭左开区间，一般来讲<code>p = a.begin()</code>;<code>q = a.end()</code>完成了对容器的排序。</li>\n<li>升序排序直接用第一个方法，系统默认<code>a&lt;b</code>返回真，因此是升序。</li>\n<li>降序排序需要自定义<code>cmp</code>方法,方法如下，只需要将默认值改为<code>a&gt;b</code>。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool comp(const int &amp;a,const int &amp;b)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  \t\treturn a&gt;b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>以上参考了<a href=\"http://www.cnblogs.com/cj695/p/3863142.html\" title=\"这里\" target=\"_blank\" rel=\"external\">这里</a></p>\n"},{"title":"类的this指针","url":"http://rylcode.cn/2016/04/12/类的this指针/","content":"<h2 id=\"C-类的this指针\"><a href=\"#C-类的this指针\" class=\"headerlink\" title=\"C++类的this指针\"></a>C++类的this指针</h2><p>如图，假设有一个类<code>Stock</code>，他有一个<code>private：int val</code>。他还有一个方法<code>const Stock&amp; Stock::compare(const Stock &amp;classIn) const</code>;这个方法要实现这样的功能：对于两个类<code>Stock</code>的对象a和b，比较a的<code>val</code>和b的<code>val</code>，返回<code>val</code>大的对象(a或者b)，可能性的写法如下：<code>a.compare(b)</code>。由于在类的方法定义中，还没有具体对象(a)。那么有这样一个问题，在方法<code>compare</code>中，如何返回以后才初始化的对象本身(也就是a)？<br><img src=\"http://i.imgur.com/qChOATG.png\" alt=\"为什么使用this指针\"></p>\n<ol>\n<li>一般来说，所有类方法都将<code>this</code>指针设置为调用它的<strong>地址</strong>。(因此返回对象使用<strong><code>*this</code></strong>)</li>\n<li><code>compare</code>方法返回类型是<em>指针意味着返回的是调用对象本身，而不是其副本</em>。</li>\n<li><code>compare</code>方法的最后一个<code>const</code>表示该方法不会修改隐式访问对象(即调用该方法的对象本身)，这在之前的博客中提到过。</li>\n<li>形参列表中的<code>const</code>表示该函数不会修改被显示访问的对象(即图中的s)。</li>\n<li>由于该函数返回了两个<code>const</code>对象之一的引用，因此<strong>返回类型也应该是<code>const</code>引用</strong>。</li>\n</ol>\n<p><img src=\"http://i.imgur.com/CzuJ4fG.png\" alt=\"this的实例\"></p>\n"},{"title":"溢出","url":"http://rylcode.cn/2016/04/11/溢出/","content":"<h2 id=\"数值溢出原理\"><a href=\"#数值溢出原理\" class=\"headerlink\" title=\"数值溢出原理\"></a>数值溢出原理</h2><p><img src=\"http://i.imgur.com/W3CYdOb.png\" alt=\"数值圆图\"><br>C++Plus在P44已经说的很清楚，如下。<br>有几点需要注意的地方：</p>\n<ol>\n<li>上图下图中的圆在进行<strong>强制类型转化</strong>时也是<strong>对应</strong>的，这就是说<code>(uchar)-1 = 65535</code>。</li>\n<li>无符号数没有溢出，只有<strong>进/借位</strong>(微机原理<code>CF</code>标示)，因为C++确保无符号数类型超越限制后在另一极端取值的行为。</li>\n<li>有符号数没有进/借位，只有<strong>溢出</strong>(微机原理<code>OF</code>标示)，因为C++无法确保有符号数上溢下溢后在另一极端取值的行为。(在我测试的时候并没有发现违背这一现象，可能有特殊情况)。</li>\n</ol>\n<p>(2016.5.23更新)，明白了反码存在的意义，很显然就清楚数值转化的原理，也就是说，补码中没有任何变化(因为硬件没有有符号无符号，只能根据输出设置标识位让编译器去解释)，就只是最高位解释为数字还是符号位!!!<br><a href=\"http://blog.sina.com.cn/s/blog_6e44841b0100n2h6.html\" target=\"_blank\" rel=\"external\">汇编的一个标准两套指令</a></p>\n<hr>\n<h2 id=\"运算溢出\"><a href=\"#运算溢出\" class=\"headerlink\" title=\"运算溢出\"></a>运算溢出</h2><h3 id=\"判断加法溢出\"><a href=\"#判断加法溢出\" class=\"headerlink\" title=\"判断加法溢出\"></a>判断加法溢出</h3><p>可以像这里一样分情况或者根据圆图分析，会发现</p>\n<ol>\n<li>所有上溢结果都小于任何一个操作数；</li>\n<li>所有下溢结果都大于任何一个操作数。</li>\n</ol>\n<h3 id=\"判断乘法溢出\"><a href=\"#判断乘法溢出\" class=\"headerlink\" title=\"判断乘法溢出\"></a>判断乘法溢出</h3><ol>\n<li>在这里提到，可以用检测<code>a*b/b</code>是否等于a来判断是否乘法溢出；</li>\n<li>在这里提到，可以先扩展再强制类型转化到低位，在判断是否相等来判断。</li>\n</ol>\n<p>值得注意的是，在之前的帖子中提到过判断是否相等对<strong>浮点数</strong>和整型的判断方式是不一样的。</p>\n<h3 id=\"除零是不是溢出？\"><a href=\"#除零是不是溢出？\" class=\"headerlink\" title=\"除零是不是溢出？\"></a>除零是不是溢出？</h3><p>任何数除以零的计算“不是”算术溢出的一种。在数学上只能明显算是不明确的定义；它计算出来的结果只能当成是“没有”值，而不是非常大的无限数值。</p>\n<p>应付溢出最佳的方法还是防范，充分了解数据类型，选择恰当的变量类型。比如，<code>c = a*b</code>一般都会选择c的长度为a的长度与b的长度之和。</p>\n<hr>\n<h2 id=\"堆栈溢出\"><a href=\"#堆栈溢出\" class=\"headerlink\" title=\"堆栈溢出\"></a><a href=\"https://zh.wikipedia.org/wiki/%E5%A0%86%E7%96%8A%E6%BA%A2%E4%BD%8D\" target=\"_blank\" rel=\"external\">堆栈溢出</a></h2><p>一般编译器默认的堆栈内存是1MB，若使用过多的堆栈内存时就会导致调用堆栈产生的溢出。一般产生于递归，或者静态申请过多的临时变量，比如<code>int a[1024[1024]</code>。</p>\n<ol>\n<li>若是静态内存导致的堆栈溢出，可以用动态申请使用堆内存。</li>\n<li>若是递归调用导致递归堆栈无法容纳调用的返回地址，要添加错误检查机制。注意数据类型或用循环处理来避免堆栈溢出。</li>\n</ol>\n<hr>\n<h2 id=\"缓冲区溢出\"><a href=\"#缓冲区溢出\" class=\"headerlink\" title=\"缓冲区溢出\"></a>缓冲区溢出</h2><p><a href=\"http://jingyan.baidu.com/article/e9fb46e1acc1267521f76633.html\" target=\"_blank\" rel=\"external\">缓冲区溢出</a>源于这样一个编程错误：复制一个内存区域的内容到另一个内存区域，而目标内存区域容量太小无法容纳。它允许传入函数的内存块以一种特定方式修改堆栈。</p>\n<p>此外的溢出还包括<a href=\"https://zh.wikipedia.org/wiki/%E7%AE%97%E6%9C%AF%E4%B8%8B%E6%BA%A2\" target=\"_blank\" rel=\"external\">算术下溢</a>(浮点数溢出)等。</p>\n"},{"title":"数据存储与二进制运算","url":"http://rylcode.cn/2016/04/09/数据存储与二进制运算/","content":"<h2 id=\"数据存储\"><a href=\"#数据存储\" class=\"headerlink\" title=\"数据存储\"></a>数据存储</h2><h3 id=\"为什么需要反码和补码-2016-5-23添加\"><a href=\"#为什么需要反码和补码-2016-5-23添加\" class=\"headerlink\" title=\"为什么需要反码和补码(2016.5.23添加)\"></a>为什么需要反码和补码(2016.5.23添加)</h3><p>之前几乎在所有的课本上看到为了方便计算，所以有了反码和补码，但是为什么?这两天在看斯坦福的公开课的时候恍然大悟，一个例子说明，<code>1+-1=0</code>在内存中怎么计算?<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00000001+10000001=10000010;1+-1=-2? WTF?</span><br><span class=\"line\">\\therefore</span><br><span class=\"line\">00000001+11111110(反码)=11111111;</span><br><span class=\"line\">11111111+00000001=0;</span><br></pre></td></tr></table></figure></p>\n<p>因此很显然，反码存在就是和原码相加之后得到所有位都是1，然后加1就得到了0。<br>多么美妙的二进制运算,以前太多孤陋寡闻,居然不知道这个道理。</p>\n<h3 id=\"原、反、补码\"><a href=\"#原、反、补码\" class=\"headerlink\" title=\"原、反、补码\"></a>原、反、补码</h3><p>计算机为方便计算，内存中的数据都是以补码的形式储存、运算。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">数</th>\n<th style=\"text-align:center\">原码</th>\n<th style=\"text-align:center\">反码</th>\n<th style=\"text-align:center\">补码</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">正数</td>\n<td style=\"text-align:center\">二进制表示</td>\n<td style=\"text-align:center\">与原码相同</td>\n<td style=\"text-align:center\">与原码相同</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">负数</td>\n<td style=\"text-align:center\">对应正数符号位（最高位）置1</td>\n<td style=\"text-align:center\">负数原码<strong>非符号位</strong>按位取反</td>\n<td style=\"text-align:center\">负数反码加1</td>\n</tr>\n</tbody>\n</table>\n<p>举个例子，数据类型为<code>char</code>：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">原数字</th>\n<th style=\"text-align:center\">原码</th>\n<th style=\"text-align:center\">反码</th>\n<th style=\"text-align:center\">补码</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>+3</code></td>\n<td style=\"text-align:center\"><code>00000011</code></td>\n<td style=\"text-align:center\"><code>00000011</code></td>\n<td style=\"text-align:center\"><code>00000011</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>-3</code></td>\n<td style=\"text-align:center\"><code>10000011</code></td>\n<td style=\"text-align:center\"><code>11111100</code></td>\n<td style=\"text-align:center\"><code>11111101</code></td>\n</tr>\n</tbody>\n</table>\n<p>值得注意的是，如果这个数据为<code>unsigned char</code>，<code>11111101</code>对应的是253，这里涉及到溢出，详细讨论见下一博客。</p>\n<h3 id=\"消失的原码\"><a href=\"#消失的原码\" class=\"headerlink\" title=\"消失的原码\"></a>消失的原码</h3><p>对于<code>unsigned char</code>原反补相同，计算机存储的补码就是原码，原码二进制经典编码有256个；但是对于<code>signed char</code>，最高位是符号位，因此原码的取值范围是-127-127，只有<strong>255个编码</strong>，但是对内存来说，8bits可以编码256个，那多余的补码与消失的原码去了哪里？</p>\n<p>考虑到编码效率，补码与原码必须是一一对应的关系。很容易想到在有符号数中有<code>00000000</code>、<code>10000000</code>两个原码表示+0与-0，而这是没有意义的。我们保证<code>00000000</code>这个原码与<code>00000000</code>这个补码相对应来表示0就可以。这样找到了消失的原码：<code>10000000</code>。</p>\n<p>在这个基于256的数值域中，观察补码的<strong>重置点（溢出中非常重要的概念）</strong>127的补码<code>01111111</code>，-127的补码<code>10000001</code>，那么可以清楚的看到<code>127+1=？</code>、<code>？+1=127</code>。因此很好理解，多余的补码是<code>10000000</code>（与消失的原码相同，通过计算他的原码可以得到验证）。那么剩下的事情就是设置重置点了，有两个选择，128或者-128。考虑到符号位是1，我们人为规定-128是重置点。即<strong>-128的原码</strong>是<code>10000000</code>，<strong>补码</strong>也是<code>10000000</code>（显然它的<strong>反码</strong>是<code>01111111</code>）。</p>\n<h3 id=\"数据扩充和缩窄\"><a href=\"#数据扩充和缩窄\" class=\"headerlink\" title=\"数据扩充和缩窄\"></a>数据扩充和缩窄</h3><ol>\n<li>数据扩充在之前<a href=\"http://rylcode.cn/2016/04/08/LeetCodeC1%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%E8%AF%B4%E6%98%8E/\">LeetCode编程技巧说明</a>提到过，有符号扩充符号位，无符号扩充0;</li>\n<li>数据缩窄，编译器认为你只对低位感兴趣，因此会丢掉高位(栈中从变量开始字节访问固定的字节结束)。列表初始化和枚举是不允许缩窄的。</li>\n</ol>\n<hr>\n<h2 id=\"二进制运算（移位得到CHAR-MAX和CHAR-MIN）\"><a href=\"#二进制运算（移位得到CHAR-MAX和CHAR-MIN）\" class=\"headerlink\" title=\"二进制运算（移位得到CHAR_MAX和CHAR_MIN）\"></a>二进制运算（移位得到CHAR_MAX和CHAR_MIN）</h2><p>明白上述数据存储概念之后，可以通过位运算来获得<code>char</code>的最大最小值。注意，其实在<code>climit</code>文件中有各种宏定义的最大最小值，比如<code>CHAR_MAX = 127</code>;<code>UCHAR_MAX = 0xff</code>;等。但是这里想利用位运算来实现这一目标(注意重置点)：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">CHAR_MAX</th>\n<th style=\"text-align:center\">CHAR_MIN</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>unsigned char max = 0-1</code></td>\n<td style=\"text-align:center\"><code>unsigned char min = 0</code>;</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>char max = (1&lt;&lt;7)-1</code></td>\n<td style=\"text-align:center\"><code>char min = 1&lt;&lt;7</code>(得到<code>10000000</code>);</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li>上述表格中<code>unsigned char max</code>本质为<code>signed char = -1</code>的强制类型转化</li>\n<li><code>char max</code> 是利用重置点<code>CHAR_MIN</code>得到<code>01111111</code></li>\n<li><code>char min</code> 是利用-128的特殊补码(而且与原码相同)赋值的</li>\n<li><code>+</code>、<code>-</code>运算的优先级是高于<code>&lt;&lt;</code>、<code>&gt;&gt;</code>的，因此<code>1&lt;&lt;7</code>要加括号<br>注意右值中运算表达式中的数字默认都是<code>int</code>类型的，这与C++整型提升有关，详情见另一篇博客。</li>\n</ol>\n<p>另，由以上解读可以很容易的得出<code>abs(int_X)</code>的工作原理，正数不变，负数求得原码后符号位取反，即原码也是补码。但是有<strong>例外</strong>：<code>abs(INT_MIN) = INT_MIN</code>。他是不变的。</p>\n<p>解读下边两式的区别（使用中<code>unsigned</code>与<code>signed</code>操作注意符号位扩充）：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><code>char a = abs((char)(1&lt;&lt;7)-1)</code></th>\n<th style=\"text-align:center\"><code>char b = abs((1&lt;&lt;7)-1)</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>(char)(1&lt;&lt;7)-1 = (int)-129</code></td>\n<td style=\"text-align:center\"><code>(1&lt;&lt;7)-1 = (int)127</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>1·</code></td>\n<td style=\"text-align:center\"><code>2·</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>a = -127</code></td>\n<td style=\"text-align:center\"><code>b = 127</code></td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li><code>11111111 11111111 11111111 10000000</code>+<code>11111111 11111111 11111111 11111111</code>=<code>11111111 11111111 11111111 01111111</code>(<code>char</code> 原码<code>10000001</code>)    </li>\n<li><code>00000000 00000000 00000000 1000000</code>-<code>00000000 00000000 00000000 0000001</code>=<code>00000000 00000000 00000000 01111111</code></li>\n</ol>\n<hr>\n<h2 id=\"编译器的困惑\"><a href=\"#编译器的困惑\" class=\"headerlink\" title=\"编译器的困惑\"></a>编译器的困惑</h2><p>在编程过程中碰到了<a href=\"http://www.hankcs.com/program/cpp/error-c4146-%E4%B8%80%E5%85%83%E8%B4%9F%E8%BF%90%E7%AE%97%E7%AC%A6%E5%BA%94%E7%94%A8%E4%BA%8E%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B%EF%BC%8C%E7%BB%93%E6%9E%9C%E4%BB%8D%E4%B8%BA%E6%97%A0.html\" target=\"_blank\" rel=\"external\">这个疑惑</a>,后来发现，明明 int 最小值是 -2147483648，但我们就是<strong>无法</strong>用<code>int n = -2147483648</code>;表示。这是因为这个语句会让编译器产生困惑：</p>\n<ol>\n<li>判断2147483648 &gt; INT_MAX，编译器决定用unsigned int;</li>\n<li>编译器发现负号，对2147483648取反(<em>编译器取反原理是将从高位到第一个1之间的位取反</em>)来尝试表达-2147483648；</li>\n<li>那么在圆图中可以发现，取反操作对2147483648来说依然表达原值。</li>\n</ol>\n<p>因此编译器会提示error:一元负运算符应用于无符号类型，结果仍为无符号类型。那么对-2147483648有两种可用的赋值：</p>\n<ol>\n<li>int n = INT_MIN;</li>\n<li>int n = (-2147483647 - 1);</li>\n</ol>\n<p><font color=\"red\">但是</font>，如果涉及到取反操作<code>-n</code>的计算,对于<code>n=INT_MIN</code>依然存在这个问题，因此需要分解’-n = INT_MAX+1’来分别计算<code>INT_MAX</code>与1的情况并组合。例如<a href=\"https://github.com/applefishsky009/LeetCode/blob/master/50%20-%20Pow(x%2C%20n)/50%20-%20Pow(x%2C%20n)%20.cpp\" target=\"_blank\" rel=\"external\">这里</a></p>\n"},{"title":"LeetCodeC1编程技巧说明","url":"http://rylcode.cn/2016/04/08/LeetCodeC1编程技巧说明/","content":"<h2 id=\"判断两个值a-b是否相等\"><a href=\"#判断两个值a-b是否相等\" class=\"headerlink\" title=\"判断两个值a,b是否相等\"></a>判断两个值a,b是否相等</h2><ol>\n<li>若为整型，应该为<code>a==b</code>；</li>\n<li>若为浮点型，应该用<code>fabs(a-b)&lt;1e-9</code>。(因为<a href=\"http://0.30000000000000004.com/\" target=\"_blank\" rel=\"external\">计算机中浮点型是不准确的</a>，<strong>与因数有关</strong>)</li>\n<li>另外，对于<code>bool</code>型，应该用<code>if(a)</code>，<code>if(!b)</code>这样的形式来强调变量<code>bool</code>类型。</li>\n</ol>\n<hr>\n<h2 id=\"判断一个整数是否为奇数\"><a href=\"#判断一个整数是否为奇数\" class=\"headerlink\" title=\"判断一个整数是否为奇数\"></a>判断一个整数是否为奇数</h2><ol>\n<li><code>x%2 != 0</code>用来判断一个整数是否是奇数，<strong>不能用<code>x%2 = 1</code></strong>，因为x可能是负数，余数就是-1。</li>\n<li><code>-3 = 2*-1+(-1)</code>，即<code>-3/2 = -1</code>;<code>-3%2= -1</code>;说明负奇数余数是-1。</li>\n</ol>\n<hr>\n<h2 id=\"char值做数组下标的强制类型转化\"><a href=\"#char值做数组下标的强制类型转化\" class=\"headerlink\" title=\"char值做数组下标的强制类型转化\"></a>char值做数组下标的强制类型转化</h2><ol>\n<li>应该强制转化为<code>uchar</code>，作为数组下标。不能直接转化为<code>uint</code>。</li>\n<li>因为高位扩充有两种，有符号数扩充，在高位补符号位；无符号数高位直接用0。例如<code>char c = -1</code>。c在计算机中的补码是<code>11111111</code>。<code>uint a = c</code>，那么<code>a = 4294967295</code>。因为c有符号，扩充后高位补1。<code>uint b = (uchar) c</code>。那么<code>b = 255</code>。因为<code>(uchar) c</code>是无符号数，高位用0扩充。</li>\n<li>二进制中有符号向无符号数的强制转化非常简单，将<strong>符号位置为0</strong>。比如-2，原码是<code>10000010</code>，反码是<code>11111101</code>，补码是<code>11111110</code>。将符号位置0，得到<code>01111110</code>，为254。即<code>char -2</code>强制转化成<code>uchar</code>值为254。</li>\n<li>参照维基百科和C++plusP44<strong>圆图</strong>可以更清楚了解更多数据储存与二进制运算。</li>\n</ol>\n<hr>\n<h2 id=\"vector和string优先于动态数组的分配\"><a href=\"#vector和string优先于动态数组的分配\" class=\"headerlink\" title=\"vector和string优先于动态数组的分配\"></a>vector和string优先于动态数组的分配</h2><p>性能上，<code>vector</code>保证内存（分配在堆）连续，一旦分配后，性能和原始数组相当；<br>用<code>new</code>必须<code>delete</code>，不然会<code>bug</code>，代码行数不够短；<br>多维数组定义方法：</p>\n<ol>\n<li><p><code>new/delete</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int** array = new int*[row];</span><br><span class=\"line\">for(int i=0;i&lt;row;i++)</span><br><span class=\"line\">\tarray[i] = new int [col];</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>vector</code>:    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;vector&lt;int&gt;&gt; = array(row,vector&lt;int&gt;(col,0));</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<hr>\n<h2 id=\"使用reverse来避免不必要的重新分配\"><a href=\"#使用reverse来避免不必要的重新分配\" class=\"headerlink\" title=\"使用reverse来避免不必要的重新分配\"></a>使用reverse来避免<a href=\"http://blog.csdn.net/bichenggui/article/details/4690175\" target=\"_blank\" rel=\"external\">不必要的重新分配</a></h2><ol>\n<li><code>vector</code>需要更多空间，以类似<code>realloc</code>的思想来增长大小。分配，回收，拷贝和析构，这些步骤都很昂贵。并且每次这些步骤发生时，所有指向<code>vector</code>或<code>string</code>中的迭代器、指针和引用都会失效。</li>\n<li>据博客中所说，vector重新分配时容量翻倍。我在VS2012，WIN32编译器下结果如下，容量是翻<em>1.5</em>倍的。因此在1000次<code>push_back</code>中导致了18次重新分配。<img src=\"http://i.imgur.com/ooqb6by.png\" alt=\"reverse()\"></li>\n<li>在<strong>容器被构造之后</strong>进行<strong><code>reserve</code>设置容器容量</strong>可以避免不必要的重新分配。<code>a.reserve(1000)</code>即把a的容量设置为1000。</li>\n</ol>\n"},{"title":"类的构造函数与析构函数初探","url":"http://rylcode.cn/2016/04/07/类的构造函数与析构函数初探/","content":"<h2 id=\"类的简介\"><a href=\"#类的简介\" class=\"headerlink\" title=\"类的简介\"></a>类的简介</h2><h3 id=\"类的规范由两部分组成：\"><a href=\"#类的规范由两部分组成：\" class=\"headerlink\" title=\"类的规范由两部分组成：\"></a>类的规范由两部分组成：</h3><ol>\n<li>类声明（declaration） – 类的蓝图<ul>\n<li>以数据成员的方式描述数据，以成员函数的方式描述公有接口；</li>\n<li><strong>数据</strong>通常放在私有部分，组成类接口的<strong>成员函数</strong>放在公有部分，另外<strong>私有成员函数</strong>用来处理不属于公有接口的实现细节。</li>\n<li>定义位于声明中的函数都将自动成为内联函数，若定义位于声明之外，使用<code>inline</code>关键字成为内联函数。</li>\n</ul>\n</li>\n<li>类方法定义 – 类的实现细节<ul>\n<li>C++通常把接口（类声明）放在头文件中，并将实现（类方法代码）放在源代码中；</li>\n<li>定义成员函数时，使用作用域解析符（<code>::</code>）来表示函数所属的类；</li>\n<li>类方法可以访问类的<code>private</code>组件。</li>\n<li>只要类方法不修改调用对象，就应将其声明为<code>const</code>，如<code>void Stock::show() const</code>。</li>\n</ul>\n</li>\n</ol>\n<p>类所创建的每个新对象都有自己的存储空间，用于存储其内部变量和类成员；但同一个类的所有对象<strong>共享同一组类方法</strong>。</p>\n<h3 id=\"类成员的访问控制（封装）\"><a href=\"#类成员的访问控制（封装）\" class=\"headerlink\" title=\"类成员的访问控制（封装）\"></a>类成员的访问控制（封装）</h3><p>数据隐藏：防止程序直接访问数据。</p>\n<ul>\n<li>例如<code>int a</code>是类的私有数据成员，<code>cout&lt;&lt;a</code>是不对的，只有公有成员函数或友元函数才能访问。可以定义一个<code>show()</code>方法访问a用来输出。</li>\n</ul>\n<p>数据封装：实现细节放在一起并与抽象分开。</p>\n<ul>\n<li>数据隐藏（数据放在类的私有部分）</li>\n<li>私有成员函数（实现细节隐藏在私有部分）</li>\n<li>类函数定义和类声明放在不同的文件中。</li>\n</ul>\n<hr>\n<h2 id=\"类的构造函数与析构函数\"><a href=\"#类的构造函数与析构函数\" class=\"headerlink\" title=\"类的构造函数与析构函数\"></a>类的构造函数与析构函数</h2><h3 id=\"类的构造函数\"><a href=\"#类的构造函数\" class=\"headerlink\" title=\"类的构造函数\"></a>类的构造函数</h3><ol>\n<li>如果没有提供任何构造函数，C++自动提供默认构造函数，他不做任何工作，也就是说<strong>他的值在初始化时是未知的</strong>；但是如果定义了构造函数，程序员必须为他提供默认构造函数，用户定义的默认构造函数通常给所有成员提供隐式初始值（已知合理值）。</li>\n<li>构造函数被用来创造对象，而不能通过对象来调用。（因为在通过构造函数构造出对象之前，对象是不存在的）。</li>\n</ol>\n<h3 id=\"类的析构函数\"><a href=\"#类的析构函数\" class=\"headerlink\" title=\"类的析构函数\"></a>类的析构函数</h3><ol>\n<li>对象过期时，程序自动调用析构函数；如果程序员没有声明，编译器隐式声明一个默认析构函数。</li>\n<li>注意窗口环境中，窗口关闭之前的代码包含在同一个代码块中，才能保证析构函数在窗口关闭之前执行。</li>\n<li>若构造函数中有<code>new</code>，则析构函数必须<code>delete</code>。</li>\n</ol>\n<h3 id=\"构造函数的语法\"><a href=\"#构造函数的语法\" class=\"headerlink\" title=\"构造函数的语法\"></a><a href=\"https://github.com/applefishsky009/Leetcode/blob/master/26%20-%20Remove%20Duplicates%20from%20Sorted%20Array/26%20-%20Remove%20Duplicates%20from%20Sorted%20Array.cpp\" target=\"_blank\" rel=\"external\">构造函数的语法</a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Num nums(initVector);</span><br><span class=\"line\">Num nums;</span><br><span class=\"line\">Num();</span><br><span class=\"line\">Num nums = Num();</span><br><span class=\"line\">Num nums = Num(initVector);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>1一定不会创建一个临时对象并析构；</li>\n<li>2会调用默认构造函数，没有析构过程；</li>\n<li>3中由于没有类的对象，因此会调用默认构造函数并析构；</li>\n<li>4在本人两个编译器上执行了2的构造过程(实际上没有调用重载的<code>=</code>运算符)，因此没有匿名对象的构造析构；</li>\n<li>5在编译器(VS2012)上会，编译器会先调用构造函数构造匿名对象，再调用复制构造函数，再析构匿名对象。但在编译器(VS2015不会)，直接将匿名对象给<code>nums</code>；</li>\n</ul>\n<p>但是对于5这种创建<strong>有指定值的对象</strong>(使用运算符<code>=</code>允许调用赋值运算符(5)，也可以不调用(4))。因此是否有临时对象是不确定的(取决于具体的实现是4还是5这种方式)。</p>\n<p>总之，1的效率最高。</p>\n"},{"title":"五种变量存储方式与external关键字","url":"http://rylcode.cn/2016/04/06/五种变量存储方式与external关键字/","content":"<h2 id=\"五种变量存储方式\"><a href=\"#五种变量存储方式\" class=\"headerlink\" title=\"五种变量存储方式\"></a>五种变量存储方式</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">存储描述</th>\n<th style=\"text-align:center\">持续性</th>\n<th style=\"text-align:center\">作用域</th>\n<th style=\"text-align:center\">链接性</th>\n<th style=\"text-align:center\">如何声明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">自动</td>\n<td style=\"text-align:center\">自动</td>\n<td style=\"text-align:center\">代码块</td>\n<td style=\"text-align:center\">无</td>\n<td style=\"text-align:center\">代码块中</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">寄存器</td>\n<td style=\"text-align:center\">自动</td>\n<td style=\"text-align:center\">代码块</td>\n<td style=\"text-align:center\">无</td>\n<td style=\"text-align:center\">代码块中，<code>register</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">静态，无链接性</td>\n<td style=\"text-align:center\">静态</td>\n<td style=\"text-align:center\">代码块</td>\n<td style=\"text-align:center\">无</td>\n<td style=\"text-align:center\">代码块中，<code>static</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">静态，外部连接性</td>\n<td style=\"text-align:center\">静态</td>\n<td style=\"text-align:center\">文件</td>\n<td style=\"text-align:center\">外部</td>\n<td style=\"text-align:center\">不在任何代码块中，无关键字</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">静态，内部链接性</td>\n<td style=\"text-align:center\">静态</td>\n<td style=\"text-align:center\">文件</td>\n<td style=\"text-align:center\">内部</td>\n<td style=\"text-align:center\">不在任何代码块中，<code>static</code></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><code>register</code>用于显示指出自动变量，没什么用处，C++11保留的目的是向下兼容；</li>\n<li>静态无链接性变量与自动变量的异同：<ul>\n<li>静态无链接性变量在编译器<strong>编译</strong>时，编译器在<strong>静态/全局存储区</strong>分配内存；</li>\n<li>自动变量在代码块<strong>运行</strong>时，编译器在<strong>栈</strong>中分配内存；</li>\n<li>二者均只能在代码块中运行。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"external关键字\"><a href=\"#external关键字\" class=\"headerlink\" title=\"external关键字\"></a>external关键字</h2><p>变量的声明有两种：定义声明（简称为定义）与引用声明（简称为声明）。如果要在一个文件中使用另一个文件中定义声明的变量，仅仅将这个变量储存为外部链接性的静态变量是不够的，还要在引用的文件中使用<code>external</code>关键字做<strong>引用声明</strong>。</p>\n<ol>\n<li>外部变量在<code>main()</code>前面或头文件中定义它，在文件中定义之后的任何位置使用它；</li>\n<li>单定义规则：变量只能定义声明一次；</li>\n<li>局部变量隐藏同名的全局变量。如果要访问全局变量，可用作用域解析符<code>：：</code>；</li>\n<li>静态变量将隐藏常规外部变量（使用<code>external</code>关键字引用）。</li>\n</ol>\n<p>关于<code>external</code>关键字的测试是很简单的，这里不给出代码。另外提到单定义规则，有一点需要注意。任何一个包含头文件的cpp都要重新编译这个头文件，因此头文件绝对不能包含函数体与变量。不然，两个或两个以上cpp包含它会出现重定义错误。</p>\n<hr>\n"},{"title":"内存存储区","url":"http://rylcode.cn/2016/04/05/内存存储区/","content":"<h2 id=\"C-内存分配方式有五种：\"><a href=\"#C-内存分配方式有五种：\" class=\"headerlink\" title=\"C++内存分配方式有五种：\"></a>C++内存分配方式有五种：</h2><ol>\n<li>栈：局部变量、函数参数等<ul>\n<li>可以实现函数调用；</li>\n<li>动态扩展、收缩；</li>\n<li>位于用户虚拟地址空间顶部。</li>\n</ul>\n</li>\n<li>堆：<code>new</code>分配的内存块，<code>delete</code>释放。</li>\n<li>自由存储区：<code>malloc</code>分配，<code>free</code>释放。</li>\n<li>全局/静态存储区：全局变量与静态变量</li>\n<li>常量存储区：存放常量<ul>\n<li>如 <code>string s1 = “abcd”</code>；<code>s1</code>是代码块中的指针，在栈中；<code>“abcd”</code>是常量，在常量存储区。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"new和malloc的区别：\"><a href=\"#new和malloc的区别：\" class=\"headerlink\" title=\"new和malloc的区别：\"></a>new和malloc的区别：</h2><ol>\n<li><code>new</code>可以认为是<code>malloc</code>加构造函数的执行；</li>\n<li><code>new</code>出来的指针是直接带类型信息的，<code>malloc</code>返回<code>void</code>指针；</li>\n<li><code>delete</code>会相应调用对象的析构函数。</li>\n</ol>\n<hr>\n<h2 id=\"堆和栈的区别：\"><a href=\"#堆和栈的区别：\" class=\"headerlink\" title=\"堆和栈的区别：\"></a>堆和栈的区别：</h2><ol>\n<li>管理方式：栈是编译器自助管理；堆是程序员控制，容易内存泄漏；<ul>\n<li>内存泄漏：申请指针，指针指向内存，作用域或生命周期到了，指针释 放，但内存并没有释放，也无法访问，变成“死内存”。</li>\n</ul>\n</li>\n<li>空间大小：堆内存几乎没有限制；栈一般有一定大小（编译器有默认值，可修改）</li>\n<li>碎片问题：堆频繁<code>new/delete</code>会产生大量碎片（<code>delete</code>出来的空间几乎不可能恰好等于<code>new</code>的空间）；栈不会；</li>\n<li>生长方向：堆向上；栈向下。</li>\n<li>分配方式：堆动态；栈动态（<code>alloca</code>，但他不需人工释放）或静态（编译器完成）</li>\n<li>分配效率：栈高于堆（栈：计算机系统提供，有底层支持；堆：C/C++库提供）</li>\n</ol>\n<hr>\n<p>以上内容主要来自于<a href=\"http://www.cnblogs.com/daocaoren/archive/2011/06/29/2092957.html\" target=\"_blank\" rel=\"external\">这里</a>。</p>\n"},{"title":"图像的基本操作4-迁移","url":"http://rylcode.cn/2015/08/06/图像的基本操作4-迁移/","content":"<p>在OPENCV帮助文档，使用库的技术和例题中有这些函数的例子。</p>\n<hr>\n<h2 id=\"trackbar\"><a href=\"#trackbar\" class=\"headerlink\" title=\"trackbar\"></a>trackbar</h2><ol>\n<li><p>创建trackbar并将它添加到指定的窗口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int cvCreateTrackbar( const char* trackbar_name, const char* window_name,int* value, int count, CvTrackbarCallback on_change );</span><br></pre></td></tr></table></figure>\n<ul>\n<li>on_change：每次滑块位置被改变的时候，被调用函数的指针。这个函数应该被声明为void Foo(int)；</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"滑鼠事件呼叫\"><a href=\"#滑鼠事件呼叫\" class=\"headerlink\" title=\"滑鼠事件呼叫\"></a>滑鼠事件呼叫</h2><ol>\n<li><p>滑鼠事件呼叫函式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvSetMouseCallback( const char* window_name, CvMouseCallback on_mouse, void* param=NULL );</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>副程式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void on_mouse( int event, int x, int y, int flags, void *param )</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>具体使用方法查看事件信息和拖拽事件信息的整数代号。</p>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"视频读取显示\"><a href=\"#视频读取显示\" class=\"headerlink\" title=\"视频读取显示\"></a>视频读取显示</h2><ol>\n<li><p>初始化从文件中获取视频：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CvCapture* cvCreateFileCapture( const char* filename );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>从摄像头或者文件中抓取并返回一帧：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IplImage* cvQueryFrame( CvCapture* capture );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>获得视频获取结构的属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double cvGetCaptureProperty( CvCapture* capture, int property_id );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置视频获取属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int cvSetCaptureProperty( CvCapture* capture, int property_id, double value );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>图像的下采样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvPyrDown( const CvArr* src, CvArr* dst, int filter=CV_GAUSSIAN_5x5 );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建视频文件写入器：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CvVideoWriter* cvCreateVideoWriter( const char* filename, int fourcc, double fps, CvSize frame_size, int is_color=1 );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>写入一帧到一个视频文件中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int cvWriteFrame( CvVideoWriter* writer, const IplImage* image );</span><br></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"图像的基本操作3-迁移","url":"http://rylcode.cn/2015/08/04/图像的基本操作3-迁移/","content":"<h2 id=\"动态内存存储及操作\"><a href=\"#动态内存存储及操作\" class=\"headerlink\" title=\"动态内存存储及操作\"></a>动态内存存储及操作</h2><ol>\n<li>内存存储器：直接看<a href=\"http://blog.sina.com.cn/s/blog_6df50e1a0101bei1.html\" target=\"_blank\" rel=\"external\">这里</a></li>\n<li><p>创建内存块：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CvMemStorage* cvCreateMemStorage( int block_size=0 );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>释放内存块：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvReleaseMemStorage( CvMemStorage** storage );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>清空内存存储块：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvClearMemStorage( CvMemStorage* storage );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在存储块中分配内存缓冲区：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void* cvMemStorageAlloc( CvMemStorage* storage, size_t size );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在存储块中分配一文本字符串：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CvString cvMemStorageAllocString( CvMemStorage* storage, const char* ptr, int len=-1 );</span><br></pre></td></tr></table></figure>\n<ul>\n<li>CvString结构：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct CvString &#123; </span><br><span class=\"line\">\tint len; </span><br><span class=\"line\">\tchar* ptr; </span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>保存内存块的位置(地址)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvSaveMemStoragePos( const CvMemStorage* storage, CvMemStoragePos* pos );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>恢复内存存储块的位置(地址): </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvRestoreMemStoragePos( CvMemStorage* storage, CvMemStoragePos* pos );</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<hr>\n<h2 id=\"轮廓\"><a href=\"#轮廓\" class=\"headerlink\" title=\"轮廓\"></a>轮廓</h2><ol>\n<li><p>创建一序列：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CvSeq* cvCreateSeq(int seq_flags,int header_size,int elem_size,CvMemStorage* storage)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>从二值图像中检索轮廓，并返回检测到的轮廓的个数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CvContourScanner cvStartFindContours( CvArr* image,CvMemStorage* storage,int header_size=sizeof(CvContour),int mode=CV_RETR_LIST,int method=CV_CHAIN_APPROX_SIMPLE,CvPoint offset=cvPoint(0,0) );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>绘制外部和内部轮廓：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvDrawContours( CvArr *img, CvSeq* contour,CvScalar external_color, CvScalar hole_color,int max_level, int thickness=1,int line_type=8, CvPoint offset=cvPoint(0,0) );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>计算整个或部分轮廓的面积</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double cvContourArea( const CvArr* contour, CvSlice slice=CV_WHOLE_SEQ );</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<hr>\n<h2 id=\"椭圆与多边形\"><a href=\"#椭圆与多边形\" class=\"headerlink\" title=\"椭圆与多边形\"></a>椭圆与多边形</h2><ol>\n<li><p>特殊函数CvScalar：一个单独的成员val，指向4个double型数组的指针；例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define CV_RGB(r,g,b) cvScalar((b),(g),(r),0)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>绘制椭圆圆弧和椭圆扇形：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvEllipse( CvArr* img, CvPoint center, CvSize axes, double angle,double start_angle, double end_angle, CvScalar color,int thickness=1, int line_type=8, int shift=0 );</span><br></pre></td></tr></table></figure>\n<ul>\n<li>例子：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cvEllipse(image,centerpoint,cvSize(20,20),0,0,45,cvScalar(20,48,160),1,8,0);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>用指定精度逼近多边形曲线：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CvSeq* cvApproxPoly( const void* src_seq, int header_size, CvMemStorage* storage,int method, double parameter, int parameter2=0 );</span><br></pre></td></tr></table></figure>\n<ul>\n<li>使用多边形来近似表示一个轮廓。多边形逼近的目的是为了减少轮廓的顶点数目。但多边形逼近的结果依然是一个轮廓，只是这个轮廓相对要粗旷一些。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"图像的基本操作2-迁移","url":"http://rylcode.cn/2015/07/31/图像的基本操作2-迁移/","content":"<h2 id=\"图像膨胀腐蚀\"><a href=\"#图像膨胀腐蚀\" class=\"headerlink\" title=\"图像膨胀腐蚀\"></a>图像膨胀腐蚀</h2><ol>\n<li><p>结构体IplConvKernel:定义形态学操作的结构元素；</p>\n<ul>\n<li>nCols，nRows：结构元素的行宽与列高；</li>\n<li>anchorX，anchorY：结构元素原点（锚点）的位置坐标，水平，垂直；</li>\n<li>nShiftR：用于表示结构元素的形状类型。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct _IplConvKernel &#123;</span><br><span class=\"line\">    int  nCols;</span><br><span class=\"line\">    int  nRows;</span><br><span class=\"line\">    int  anchorX;</span><br><span class=\"line\">    int  anchorY;</span><br><span class=\"line\">    int *values;</span><br><span class=\"line\">    int  nShiftR;</span><br><span class=\"line\">&#125;IplConvKernel;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>图像腐蚀：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvErode( const CvArr* src, CvArr* dst, IplConvKernel* element=NULL, int iterations=1 );</span><br></pre></td></tr></table></figure>\n<ul>\n<li>结构元素默认为 NULL, 使用 3×3 长方形的结构元素；</li>\n</ul>\n</li>\n<li><p>图像膨胀：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvDilate( const CvArr* src, CvArr* dst, IplConvKernel* element=NULL, int iterations=1 );</span><br></pre></td></tr></table></figure>\n<ul>\n<li>结构元素默认为 NULL, 使用 3×3 长方形的结构元素；</li>\n</ul>\n</li>\n<li>彩蛋：颜色产生的方法一般采用加色法，因此0代表黑色(什么都没有),255代表白色(所有色彩组合),(另一种叫减色法);</li>\n<li>彩蛋2：四舍五入，<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int cvRound (double value);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<hr>\n<h2 id=\"图像平滑\"><a href=\"#图像平滑\" class=\"headerlink\" title=\"图像平滑\"></a>图像平滑</h2><ol>\n<li>各种方法的图像平滑:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvSmooth( const CvArr* src, CvArr* dst,int smoothtype=CV_GAUSSIAN,int param1=3, int param2=0, double param3=0, double param4=0 );</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<hr>\n<h2 id=\"颜色空间操作\"><a href=\"#颜色空间操作\" class=\"headerlink\" title=\"颜色空间操作\"></a>颜色空间操作</h2><ol>\n<li><p>色彩空间转化：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvCvtColor( const CvArr* src, CvArr* dst, int code );</span><br></pre></td></tr></table></figure>\n<ul>\n<li>要注意正确制定色彩空间(code参数)。</li>\n</ul>\n</li>\n<li>分割多通道图像：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvSplit( const CvArr* src, CvArr* dst0, CvArr* dst1,CvArr* dst2, CvArr* dst3 );</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<hr>\n<h2 id=\"边缘与直线检测\"><a href=\"#边缘与直线检测\" class=\"headerlink\" title=\"边缘与直线检测\"></a>边缘与直线检测</h2><ol>\n<li><p>固定阈值操作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvThreshold( const CvArr* src, CvArr* dst, double threshold,double max_value, int threshold_type );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用 Canny 算法做边缘检测：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvCanny( const CvArr* image, CvArr* edges, double threshold1,double threshold2, int aperture_size=3 );</span><br></pre></td></tr></table></figure>\n<ul>\n<li>aperture_size：Sobel算子内核大小。</li>\n<li>如果一个像素的梯度大于上限阈值，则被认为是边缘像素;如果低于下限阈值，则被抛弃;如果介于二者之间，只有当其与高于上限阈值的像素连接时才被接受。</li>\n<li>canny推荐的上下限阈值比是2:1-3:1；</li>\n</ul>\n</li>\n<li><p>自适应阈值方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvAdaptiveThreshold( const CvArr* src, CvArr* dst,double max_value,int adaptive_method=CV_ADAPTIVE_THRESH_MEAN_C,int threshold_type=CV_THRESH_BINARY,int block_size=3, double param1=5 );</span><br></pre></td></tr></table></figure>\n<ul>\n<li>自适应二值化对于光照不均的文字，条码等，效果很好。窗口大小选择，考虑被检测物体尺寸。</li>\n<li>自适应阈值化中的阈值完全是由你所选择的邻域所确定：<ul>\n<li>如果你所选择的邻域非常小（比如3×3），那么很显然阈值的“自适应程度”就非常高，这在结果图像中就表现为边缘检测的效果。</li>\n<li>域选择的比较大（比如31×31），那么阈值的“自适应程度”就比较低，这在结果图像中就表现为二值化的效果。</li>\n</ul>\n</li>\n<li>参数param1与方法有关，主要可以用来控制边缘的类型和粗细。选定合适的block_size后，我们就可以选定一个更大的阈值param1，更好的抑制噪声。</li>\n</ul>\n</li>\n<li><p>利用Hough变换在二值图像中找到直线：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CvSeq* cvHoughLines2( CvArr* image, void* line_storage, int method,double rho, double theta, int threshold,double param1=0, double param2=0 );</span><br></pre></td></tr></table></figure>\n<ul>\n<li>解释比较麻烦，直接上例子:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lines = cvHoughLines2( dst, storage, CV_HOUGH_PROBABILISTIC, 1, CV_PI/180, 80, 30, 10 );</span><br><span class=\"line\">for( i = 0; i &lt; lines-&gt;total; i++ )&#123;</span><br><span class=\"line\">\tCvPoint* line =(CvPoint*)cvGetSeqElem(lines,i);</span><br><span class=\"line\">\tcvLine( color_dst, line[0], line[1], CV_RGB(255,0,0), 3, 8 );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>绘制连接两个点的线段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvLine( CvArr* img, CvPoint pt1, CvPoint pt2, CvScalar color,int thickness=1, int line_type=8, int shift=0 );</span><br></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"图像的基本操作1-迁移","url":"http://rylcode.cn/2015/07/28/图像的基本操作1-迁移/","content":"<p>在部署这个博客之前初学OPENCV的时候，在CSDN上写过一段时间的博客，当然内容比较简单基础，现在将博客迁移过来，会有很大部分的删减(只提供接口和注意事项，已经养成了学习习惯，有问题多查opencv帮助文档)，以便以后温习OPENCV。</p>\n<hr>\n<h2 id=\"图像读取显示保存\"><a href=\"#图像读取显示保存\" class=\"headerlink\" title=\"图像读取显示保存\"></a>图像读取显示保存</h2><ol>\n<li><p>IPLImage结构用来定义图像指针</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IPLImage *src,*dst；</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Mat类型也可以代表和显示图像，但其侧重于计算，数学性较高；</li>\n<li>IplImage由CvMat派生，而CvMat由CvArr派生即CvArr -&gt; CvMat -&gt; IplImage，CvArr用作函数的参数，无论传入的是CvMat或IplImage，内部都是按CvMat处理。</li>\n</ul>\n</li>\n<li><p>读取图像：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IplImage* cvLoadImage(const char* filename,int iscolor);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>创建窗口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int cvNamedWindow (const char* name, int flags=CV_WINDOW_AUTOSIZE );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>显示图像：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvShowImage(const char* name,const CvArr* Image);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>该语句后要紧跟<code>int cvWaitKey(n);</code>语句防止窗口闪退。</li>\n</ul>\n</li>\n<li><p>创建图像容器：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IplImage* cvCreateImage(CvSize size,int depth,int channels);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>保存图像：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int cvSaveImage( const char* filename, const CvArr* image );</span><br></pre></td></tr></table></figure>\n<ul>\n<li>但只有8位单通道或者3通道（通道顺序为’BGR’）可以使用这个函数保存。如果格式，深度或者通道不符合要求，请先用<code>cvCvtScale</code>和<code>cvCvtColor</code>转换；或者使用通用的<code>cvSave</code>保存图像为XML或者YAML格式。</li>\n</ul>\n</li>\n<li><p>释放图像指针：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvRelease( void** struct_ptr );</span><br></pre></td></tr></table></figure>\n<ul>\n<li>struct_ptr,图像指针的地址,如<code>&amp;src</code>;</li>\n</ul>\n</li>\n<li>结构CvSize:OpenCV的基本数据类型之一。表示矩阵框大小，以像素为精度。</li>\n<li><p>得到图像宽高：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CvSize cvGetSize( const CvArr* arr );</span><br></pre></td></tr></table></figure>\n<ul>\n<li>CvSize结构：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct CvSize&#123;</span><br><span class=\"line\">\tint width; /* 矩形宽 */</span><br><span class=\"line\">\tint height; /* 矩形高 */</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"尺寸变换\"><a href=\"#尺寸变换\" class=\"headerlink\" title=\"尺寸变换\"></a>尺寸变换</h2><ol>\n<li><p>尺寸变换：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvResize( const CvArr* src, CvArr* dst, int interpolation=CV_INTER_LINEAR );</span><br></pre></td></tr></table></figure>\n<ul>\n<li>interpolation:插值方法。</li>\n</ul>\n</li>\n<li><p><strong>开辟内存</strong>并复制图像：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IplImage*cvCloneImage(constIplImage*image);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>主要用于图像包括ROI的复制。</li>\n</ul>\n</li>\n<li><p>拷贝数组：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvCopy( const CvArr* src, CvArr* dst, const CvArr* mask=NULL );</span><br></pre></td></tr></table></figure>\n<ul>\n<li>主要用于图像ROI的提取。</li>\n</ul>\n</li>\n<li><p>图像作差：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvSub( const CvArr* src1, const CvArr* src2, CvArr* dst, const CvArr* mask=NULL );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>彩蛋：函数引用正确时未识别的标识符：</p>\n<ul>\n<li>error:函数头文件(.h)未包括；</li>\n<li>link error:该函数的库文件(.lib)未配置正确。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"旋转\"><a href=\"#旋转\" class=\"headerlink\" title=\"旋转\"></a>旋转</h2><ol>\n<li><p>图像缩放：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void cvGetQuadrangleSubPix( const CvArr* src, CvArr* dst, const CvMat* map_matrix );</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>2*3变换矩阵map_matrix如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m[0] = (float)(factor*cos(-angle*2*CV_PI/180.));</span><br><span class=\"line\">m[1] = (float)(factor*sin(-angle*2*CV_PI/180.));</span><br><span class=\"line\">m[2] = w*0.5f;</span><br><span class=\"line\">m[3] = -m[1];</span><br><span class=\"line\">m[4] = m[0];</span><br><span class=\"line\">m[5] = h*0.5f;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>上述factor = 1。</p>\n</li>\n</ul>\n</li>\n<li><p>结构CvMat用来初始化矩阵头(上述旋转中用到)，使用函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CvMat cvMat( int rows, int cols, int type, void* data=NULL );</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>或者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CvMat* cvInitMatHeader( CvMat* mat, int rows, int cols, int type,void* data=NULL, int step=CV_AUTOSTEP );</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>参数分别是矩阵行，列，数据类型。</p>\n</li>\n</ul>\n</li>\n</ol>\n"}]