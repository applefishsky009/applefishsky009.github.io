[{"title":"i++与++i的区别","url":"http://yoursite.com/2016/05/06/i++与++i的区别/","content":"<p>一直以来对<code>++i</code>与<code>i++</code>，知道前者效率更高，但是不知道为什么。有人说与寄存器有关，实际上寄存器都执行了一次加法，是一样的。看了<a href=\"http://falldog7.blogspot.jp/2007/10/programmer-i-i.html\" target=\"_blank\" rel=\"external\">这里的博客</a>才恍然大悟，原来是其实现的机制不同。</p>\n<p><code>++i</code>先加再用，其对i类型(假设为INT)的++运算符重载如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//++i</span><br><span class=\"line\">INT operator ++()&#123;</span><br><span class=\"line\">\tthis-&gt;_value++;</span><br><span class=\"line\">\treturn *this;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>i++</code>先用再加，创建临时变量保存原有值用来返回，后调用++i语句，重载如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//i++</span><br><span class=\"line\">INT operator ++(int t)&#123;</span><br><span class=\"line\">\tINT temp(_value);//!!! 必須create出一個temp的變數!!!</span><br><span class=\"line\">\tthis-&gt;_value++;</span><br><span class=\"line\">\treturn temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在这个函数中参数n是没有任何意义的，它的存在只是为了区分是前置形式还是后置形式。</p>\n<p>可以看到<code>i++</code>所必须付出的代价，就是多create出一个temp的变量，以及temp变量的的constructor()。</p>\n"},{"title":"二叉树的递归遍历与栈遍历","url":"http://yoursite.com/2016/05/06/二叉树的递归遍历与栈遍历/","content":"<p>二叉树的遍历算法有三种，最简单的递归遍历，还有两种非递归遍历，分别是使用栈的遍历和Morris遍历。每一种遍历根据访问根节点的时机又分为前序，中序，后序三种。<br>二叉树节点的定义如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct TreeNode &#123;</span><br><span class=\"line\">\tint val;</span><br><span class=\"line\">\tTreeNode *left;</span><br><span class=\"line\">\tTreeNode *right;</span><br><span class=\"line\">\tTreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"二叉树的递归遍历\"><a href=\"#二叉树的递归遍历\" class=\"headerlink\" title=\"二叉树的递归遍历\"></a>二叉树的递归遍历</h2><p>没什么技巧，方式如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvoid Traversal(TreeNode* root,vector&lt;int&gt; &amp;result) &#123;</span><br><span class=\"line\">\t\tif (!root)</span><br><span class=\"line\">\t\t\treturn;</span><br><span class=\"line\">\t\t//result.push(root-&gt;val);\t//preorderTraversal</span><br><span class=\"line\">\t\tTraversal(root-&gt;left,result);</span><br><span class=\"line\">\t\t//result.push(root-&gt;val);\t//inorderTraversal</span><br><span class=\"line\">\t\tTraversal(root-&gt;right,result);</span><br><span class=\"line\">\t\t//result.push(root-&gt;val);\t//postorderTraversal</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"二叉树的栈遍历\"><a href=\"#二叉树的栈遍历\" class=\"headerlink\" title=\"二叉树的栈遍历\"></a>二叉树的栈遍历</h2><p>前序和中序可以用同一段代码来实现(用栈记忆所有左子树(while)，回溯一位(if)访问右子树)：<br><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/144%20-%20Binary%20Tree%20Preorder%20Traversal/144%20-%20Binary%20Tree%20Preorder%20Traversal.cpp\" target=\"_blank\" rel=\"external\">前序遍历</a><br><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/94%20-%20Binary%20Tree%20Inorder%20Traversal/94%20-%20Binary%20Tree%20Inorder%20Traversal.cpp\" target=\"_blank\" rel=\"external\">中序遍历</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class=\"line\">\t\tvector&lt;int&gt; result;</span><br><span class=\"line\">\t\tstack&lt;TreeNode*&gt; sS1;</span><br><span class=\"line\">\t\twhile (root||!sS1.empty())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\twhile (root)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t//result.push_back(root-&gt;val);\t//先序遍历的位置</span><br><span class=\"line\">\t\t\t\tsS1.push(root);</span><br><span class=\"line\">\t\t\t\troot = root-&gt;left;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tif (!sS1.empty())</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\troot = sS1.top();</span><br><span class=\"line\">\t\t\t\tsS1.pop();</span><br><span class=\"line\">\t\t\t\tresult.push_back(root-&gt;val);\t//中序遍历的位置</span><br><span class=\"line\">\t\t\t\troot = root-&gt;right;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn result;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>后序遍历稍微复杂一点，有两种思路：</p>\n<ol>\n<li>左子树-&gt;右子树-&gt;节点(后序)    转化为    节点-&gt;右子树-&gt;左子树(前序) 的翻转(栈)</li>\n<li>对于任一结点P，先将其入栈。如果P不存在左孩子和右孩子，则可以直接访问它。或者P存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。若非上述两种情况，则将P的右孩子和左孩子依次入栈。这样就保证了每次取栈顶元素的时候，左孩子和右孩子都在根结点前面被访问。</li>\n</ol>\n<p><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/145%20-%20Binary%20Tree%20Postorder%20Traversal/145%20-%20Binary%20Tree%20Postorder%20Traversal.cpp\" target=\"_blank\" rel=\"external\">后序遍历</a><br>第一种(变异的前序)：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution1 &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class=\"line\">\t\tvector&lt;int&gt; outTreeNode;</span><br><span class=\"line\">\t\tstack&lt;TreeNode*&gt; sTreeNode;</span><br><span class=\"line\">\t\tstack&lt;int&gt; sInt;</span><br><span class=\"line\">\t\twhile (root||!sTreeNode.empty())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\twhile (root)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tsInt.push(root-&gt;val);</span><br><span class=\"line\">\t\t\t\tsTreeNode.push(root);</span><br><span class=\"line\">\t\t\t\troot=root-&gt;right;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tif (!sTreeNode.empty())</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\troot=sTreeNode.top();</span><br><span class=\"line\">\t\t\t\tsTreeNode.pop();</span><br><span class=\"line\">\t\t\t\troot=root-&gt;left;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\twhile (!sInt.empty())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\toutTreeNode.push_back(sInt.top());</span><br><span class=\"line\">\t\t\tsInt.pop();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn outTreeNode;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>第二种(利用pre指针的后序)：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class=\"line\">\t\tvector&lt;int&gt; outTreeNode;</span><br><span class=\"line\">\t\tstack&lt;TreeNode*&gt; sTreeNode;</span><br><span class=\"line\">\t\tTreeNode* pre=nullptr;\t//指向之前访问的节点</span><br><span class=\"line\">\t\tif (root)</span><br><span class=\"line\">\t\t\tsTreeNode.push(root);</span><br><span class=\"line\">\t\twhile (!sTreeNode.empty())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\troot=sTreeNode.top();</span><br><span class=\"line\">\t\t\tif ((root-&gt;left==nullptr&amp;&amp;root-&gt;right==nullptr)||(pre!=nullptr&amp;&amp;(pre==root-&gt;left||pre==root-&gt;right)))</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\toutTreeNode.push_back(root-&gt;val);</span><br><span class=\"line\">\t\t\t\tpre=root;</span><br><span class=\"line\">\t\t\t\tsTreeNode.pop();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\telse</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tif (root-&gt;right)</span><br><span class=\"line\">\t\t\t\t\tsTreeNode.push(root-&gt;right);//右孩子先入栈，后访问</span><br><span class=\"line\">\t\t\t\tif (root-&gt;left)</span><br><span class=\"line\">\t\t\t\t\tsTreeNode.push(root-&gt;left);//左孩子后入栈，先访问</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn outTreeNode;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"BP、KMP、改进的KMP","url":"http://yoursite.com/2016/05/03/BP、KMP、改进的KMP/","content":"<p>在主串S中，自low位置开始，查找与模式串T相等的子串。如果这样的子串存在，返回其第一次出现的位置。本文详细介绍三种字符串匹配算法:</p>\n<ol>\n<li>BF(Brute-Force)算法(暴力破解);</li>\n<li>KMP算法;</li>\n<li>改进的KMP算法。</li>\n</ol>\n<p>这三种算法的代码<a href=\"https://github.com/applefishsky009/Interface/blob/master/BF%E5%92%8CKMP/BF%E5%92%8CKMP.cpp\" target=\"_blank\" rel=\"external\">在这里</a>。</p>\n<hr>\n<h2 id=\"BF算法\"><a href=\"#BF算法\" class=\"headerlink\" title=\"BF算法\"></a>BF算法</h2><p>设主串从i位开始与子串(从0开始)判断是否匹配;到子串的j位置，对应主串的i+j位置失配;将主串左移一位(<code>i++</code>),j回到0位继续匹配。</p>\n<hr>\n<h2 id=\"KMP算法\"><a href=\"#KMP算法\" class=\"headerlink\" title=\"KMP算法\"></a>KMP算法</h2><h3 id=\"为什么是next-j\"><a href=\"#为什么是next-j\" class=\"headerlink\" title=\"为什么是next[j]\"></a>为什么是next[j]</h3><p>每次失配将i右移一位显然是低效的。<strong>主观上来考虑，如果在失配之前子串有相等的真后缀，那么就可以右移更多的位。</strong>考虑在i+j位失配时将主串左移k位(子串右移k位)，而不是一位。容易得到，这个k只与子串的性质有关。<br>我们使用next[j]来标识当j位失配时子串应向右移j-next[j]位。示例:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><code>abcdefg</code></th>\n<th style=\"text-align:center\">0 1 2 3 4 5 6</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>next[j]</code></td>\n<td style=\"text-align:center\">-1 0 0 0 0 0 0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">offset</td>\n<td style=\"text-align:center\">1 1 2 3 4 5 6</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><code>abcabcabc</code></th>\n<th style=\"text-align:center\">0 1 2 3 4 5 6 7 8</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>next[j]</code></td>\n<td style=\"text-align:center\">-1 0 0 0 1 2 3 4 5</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">offset</td>\n<td style=\"text-align:center\">1 1 2 3 3 3 3 3 3</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"如何求得next-j\"><a href=\"#如何求得next-j\" class=\"headerlink\" title=\"如何求得next[j]\"></a>如何求得next[j]</h3><p><img src=\"http://i.imgur.com/qc2eynB.png\" alt=\"这里\"></p>\n<p>在计算公式中第二行指的是:j位<strong>以前</strong>字串中真前后缀的最大<strong>公共</strong>元素长度。真前缀、真后缀指的不包含串本身的子串。那么我们可以这样来计算j:<br>tempNext[j]表示j位及以前子串真前缀最大公共元素长度。将tempNext[j]右移一位，初值赋为-1,得到next[j]</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><code>xyxyyxxyx</code></th>\n<th style=\"text-align:center\">0 1 2 3 4 5 6 7 8</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>tempNext[j]</code></td>\n<td style=\"text-align:center\">0 0 1 2 0 1 1 2 3</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>next[j]</code></td>\n<td style=\"text-align:center\">-1 0 0 1 2 0 1 1 2</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">offset</td>\n<td style=\"text-align:center\">1 1 2 2 2 5 5 6 6</td>\n</tr>\n</tbody>\n</table>\n<p>tempNext[j]的计算:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//计算j位及之前真前缀以及真后缀的最大公共元素长度</span><br><span class=\"line\">void calTempNext(vector&lt;int&gt;&amp;next)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif (s2.size() == 1)</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\tnext[0] = 0;</span><br><span class=\"line\">\tint k = 0;//前缀指针,j就是后缀指针</span><br><span class=\"line\">\tfor (int j = 1;j &lt; s2.size();j++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\twhile(k &gt; 0 &amp;&amp; s2[j] != s2[k])//k位失配，</span><br><span class=\"line\">\t\t\tk = next[k-1];//k-1是可靠匹配，next[k-1]记录了上一个真后缀出现的地方</span><br><span class=\"line\">\t\tif (s2[j] == s2[k])//匹配，k++,j++，next[j]赋值</span><br><span class=\"line\">\t\t\tk++;</span><br><span class=\"line\">\t\tnext[j] = k;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"如何在编程中求得next-j\"><a href=\"#如何在编程中求得next-j\" class=\"headerlink\" title=\"如何在编程中求得next[j]\"></a>如何在编程中求得next[j]</h3><p>如果使用上述计算过程，先计算tempNext[j]再计算next[j]，需要两次遍历。将tempNext[j]右移初值赋-1的过程可以直接融入程序中，使用一次遍历就可以得到next[j]，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//直接计算next(时间复杂度O(n))</span><br><span class=\"line\">void cal2Next(vector&lt;int&gt;&amp;next)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint j = -1;\t\t//j,偏移指针</span><br><span class=\"line\">\tint i = 0;\t\t//i,next下标（实际上是要计算的next下标-1,因为是先加后赋值）</span><br><span class=\"line\">\tnext[0] = -1;</span><br><span class=\"line\">\twhile (i &lt; s2.size()-1)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tif (j == -1 || s2[i]==s2[j])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ti++;</span><br><span class=\"line\">\t\t\tj++;</span><br><span class=\"line\">\t\t\tnext[i] = j;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\tj = next[j];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"改进的KMP算法\"><a href=\"#改进的KMP算法\" class=\"headerlink\" title=\"改进的KMP算法\"></a>改进的KMP算法</h2><p>next[j]值越小，模式匹配所需比较次数越少。next[j]的计算中先判断匹配，i,j自加再赋值。</p>\n<ol>\n<li>若自加之后失配，这时候i失配并不代表j失配，因此留给下次循环回溯后来判断。</li>\n<li>若自加之后匹配，说明i与j位置完全等效，i失配，j一定失配。，而朴素的KMP算法在失配之后要一次一次回溯。因此可以<font color=\"red\">一次回溯到底</font>节约比较次数。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><code>abcaabbabcaac</code></th>\n<th style=\"text-align:center\">0 1 2  3 4 5 6  7 8 9 10 11 12</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>next[j]</code></td>\n<td style=\"text-align:center\">-1 0 0  0 1 1 2  0 1 2  3  4  5</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">offset1</td>\n<td style=\"text-align:center\">1 1 2  3 3 4 4  7 7 7  7  7  7</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>nextVal[j]</code></td>\n<td style=\"text-align:center\">-1 0 0 -1 1 0 2 -1 0 0 -1  1  5</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">offset2</td>\n<td style=\"text-align:center\">1 1 2  4 3 5 4  8 8 9 11 10  7</td>\n</tr>\n</tbody>\n</table>\n<p><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/28%20-%20Implement%20strStr()/28%20-%20Implement%20strStr().cpp\" target=\"_blank\" rel=\"external\">LeetCode代码</a></p>\n"},{"title":"野指针与内存泄漏","url":"http://yoursite.com/2016/04/25/野指针与内存泄漏/","content":"<p>野指针和内存泄漏是两个相联系的概念，一般来讲指针&lt;-&gt;内存相互对应，如果有一个指针但没有指向任何内存，就是野指针；如果有一块未释放的内存，但没有指针指向他，就是内存泄露。</p>\n<hr>\n<h2 id=\"野指针\"><a href=\"#野指针\" class=\"headerlink\" title=\"野指针\"></a>野指针</h2><p>野指针指向一个已删除对象或未申请访问受限内存区域的指针，一般来说野指针有三个成因：</p>\n<ol>\n<li>指针变量未初始化；</li>\n<li>指针释放后未置空；</li>\n<li>指针操作超越变量作用域。</li>\n</ol>\n<p>值得注意的是，如果有多个指针指向同一块内存，释放其中一个指针后，应将包含这个指针在内的指向这一块内存的所有指针都置空，否则都会成为野指针。</p>\n<h2 id=\"内存泄漏\"><a href=\"#内存泄漏\" class=\"headerlink\" title=\"内存泄漏\"></a>内存泄漏</h2><p>在某一块内存的生命周期内，指向它的指针全部指向别处时，用户无法访问，也无法申请到这一块内存。这就是内存泄露。</p>\n"},{"title":"Git命令","url":"http://yoursite.com/2016/04/23/Git命令/","content":"<p>初学git，记录当时的一些解决方法。</p>\n<ol>\n<li><a href=\"https://www.zhihu.com/question/22132675\" target=\"_blank\" rel=\"external\">删除不想要的git历史</a></li>\n<li><a href=\"https://segmentfault.com/q/1010000000115900\" target=\"_blank\" rel=\"external\">删除版本库中的提交</a>注意，他将HEAD指向某一个commit，之后的commit和文件都被擦除了，删除前做好备份……</li>\n<li>博客中常用的命令：hexo clean(删除一些没有用的缓存，比如删掉的tag等);hexo generate(生成一个commit?);hexo deploy(提交到远程)</li>\n</ol>\n"},{"title":"动态规划","url":"http://yoursite.com/2016/04/22/动态规划/","content":"<p>持续更新，记录在编程过程中关于动态规划(DP)的心得体会。算法分析以算法导论为主。主要是用于求解最优化问题，不同于递归用于解决互不相交的子问题，动态规划应用于子问题重叠的情况。在实际应用中发现他有两个关键点：</p>\n<ol>\n<li>子问题的状态转移方程；</li>\n<li>保存子问题的解用于递归;</li>\n</ol>\n<p>它有两种等价的实现方式：</p>\n<ol>\n<li>带备忘的自顶向下；</li>\n<li>自底向上。</li>\n</ol>\n<p>一般来说自底向上更容易实现。实际中哪一种更容易编程取决于具体问题。</p>\n<ol>\n<li><a href=\"https://github.com/applefishsky009/LeetCode/blob/master/120%20-%20Triangle/120%20-%20Triangle.cpp\" target=\"_blank\" rel=\"external\">triangle</a></li>\n</ol>\n"},{"title":"贪心算法","url":"http://yoursite.com/2016/04/22/贪心算法/","content":"<p>持续更新，记录在编程过程中关于贪心算法的心得体会。算法分析以算法导论为主。求解最优化问题比动态规划更为简洁高效。其思想核心是<font color=\"red\">选择当前最优解</font>，虽然不一定是全局最优解。贪心算法主要应用有</p>\n<ol>\n<li>活动选择问题</li>\n<li>霍夫曼编码</li>\n<li>最小生成树</li>\n<li>单元最短路径的Dijkstra算法</li>\n<li>集合覆盖问题的贪心启发式算法</li>\n</ol>\n<p>贪心算法的形式一般有<strong>递归贪心算法</strong>，<strong>迭代贪心算法</strong>。</p>\n<hr>\n<h2 id=\"活动选择问题\"><a href=\"#活动选择问题\" class=\"headerlink\" title=\"活动选择问题\"></a>活动选择问题</h2><ol>\n<li>调度竞争共享资源的多个活动问题，选出最大的互相兼容的活动集合；<ul>\n<li>选择一个活动，选出他后剩下的资源能尽量多的被其他任务所用(算法导论16.1)；</li>\n</ul>\n</li>\n<li>LeetCode跳跃游戏；<ul>\n<li>Jump Game,选择当前最优解,更新当前最优解。</li>\n<li>Jump GameⅡ, 在选择当前最优解的时候统计步数(层数，是一层一一层映射的关系，怎么感觉是在广搜？!)。</li>\n</ul>\n</li>\n</ol>\n"},{"title":"函数参数的传递","url":"http://yoursite.com/2016/04/22/函数参数的传递/","content":"<p>函数参数的传递有三种，按值传递，按址传递，按引用传递(C++新增)。</p>\n<hr>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><h3 id=\"引用的本质\"><a href=\"#引用的本质\" class=\"headerlink\" title=\"引用的本质\"></a>引用的本质</h3><p>C++将<code>&amp;</code>符号赋予了另一个含义，用来声明引用。引用是已定义变量的别名(同一块内存)。引用的主要作用是用作函数形参。<br>引用的本质是<font color=\"red\">指针常量</font>，例如<code>int &amp;pr = rats;</code>是<code>int* const pr = &amp;rats;</code>的伪装。它的含义是他是一个指针，指向一个常量地址。因此他有以下特性也就很好理解了：</p>\n<ol>\n<li>必须在声明引用是将其初始化；(因为指向常量地址)</li>\n<li>初始化时，省略了取地址符的操作<code>&amp;</code>,给我们感觉是别名；</li>\n<li>声明引用时，隐藏了对指针常量的自动间接引用，让我们看不到指针。</li>\n<li>使用引用时，隐藏了解除引用<code>*</code>,让我们觉得是在直接修改(别名)变量。<br>如下：<img src=\"http://i.imgur.com/idRXQZy.png\" alt=\"这里\"></li>\n</ol>\n<h3 id=\"返回引用\"><a href=\"#返回引用\" class=\"headerlink\" title=\"返回引用\"></a>返回引用</h3><ol>\n<li>返回引用比传统返回机制烧了拷贝复制，效率更高。</li>\n<li>返回引用本质是返回“别名”,因此要注意保证返回后这个内存依然存在。(变量持续性)</li>\n<li>返回类型<strong>一般</strong>用<font color=\"red\"><code>const</code>标识</font>，将其设置为不可修改的左值，避免数据损失。<ul>\n<li>赋值语句，左边必须是可修改的左值；</li>\n<li>常规返回类型是右值(因为其位于临时内存单元)-&gt;不能通过地址访问。(可以出现在表达式右边，但不能出现在左边，如字面值<code>10.0</code>,表达式<code>x+y</code>) </li>\n</ul>\n</li>\n</ol>\n<p>如果返回局部变量(运算符重载中)，不能返回引用。</p>\n<h3 id=\"C-C-中的左值和右值\"><a href=\"#C-C-中的左值和右值\" class=\"headerlink\" title=\"C/C++中的左值和右值\"></a>C/C++中的左值和右值</h3><ol>\n<li>左值是一个引用到对象的表达式，因此可以取址(可以赋值)；</li>\n<li>右值强调的不是表达式本身，而是该表达式运算后的结果。这个结果往往并不引用到某一对象，可以看成计算的中间结果(临时内存单元)；（当然它也可能引用到某一对象，但是通过该右值表达式我们不能直接修改该对象—）。</li>\n</ol>\n<hr>\n<h2 id=\"按值传递\"><a href=\"#按值传递\" class=\"headerlink\" title=\"按值传递\"></a>按值传递</h2><p>C++将数值参数传递给函数，函数将其赋给一个新的变量，新变量与旧变量在赋值之后没有任何关系。</p>\n<hr>\n<h2 id=\"按址传递\"><a href=\"#按址传递\" class=\"headerlink\" title=\"按址传递\"></a>按址传递</h2><p>C++将参数地址传递给函数，函数原型用指针(一般用<code>const</code>修饰表示指针不会乱指)指向这个地址</p>\n<hr>\n<h2 id=\"数组传递\"><a href=\"#数组传递\" class=\"headerlink\" title=\"数组传递\"></a>数组传递</h2><p>数组在传递时，编译器将数组名解释为第一个元素的地址，因此传递实参为数组时，形参应该是一个指针指向这个地址。<br>在用多维数组名作为形参时，可以指定所有维数的大小，也可以省略第一位的大小(高维大小必须指定)，这与编译器寻址有关，比如<code>int p[m][n]</code>如果要取<code>p[i][j]</code>的值，编译器会计算地址为<code>p+i*n+j;</code>，因此编译器可以不知道m的值，但必须知道n的值。</p>\n"},{"title":"BFS和DFS","url":"http://yoursite.com/2016/04/21/BFS和DFS/","content":"<p>持续更新,该贴记录一些BFS和DFS在使用过程中的心得体会，以加深对BFS与DFS的理解。</p>\n<hr>\n<h2 id=\"BFS-广度优先搜索\"><a href=\"#BFS-广度优先搜索\" class=\"headerlink\" title=\"BFS(广度优先搜索)\"></a>BFS(广度优先搜索)</h2><ol>\n<li>BFS需要借助一个队列来记录遍历的”层数”；每遍历目标集合一次，<strong>步长</strong>加一；队列为空，结束搜寻。分析见<a href=\"https://github.com/applefishsky009/LeetCode/blob/master/127%20-%20World%20Ladder/127%20-%20World%20Ladder.cpp\" target=\"_blank\" rel=\"external\">这里</a></li>\n</ol>\n<hr>\n<h2 id=\"DFS-深度优先搜索\"><a href=\"#DFS-深度优先搜索\" class=\"headerlink\" title=\"DFS(深度优先搜索)\"></a>DFS(深度优先搜索)</h2><ol>\n<li>DFS需要用递归或者借助栈来<strong>记录</strong>走过的路径；每遍历完这条分支，便要回溯到上一层；在递归之前可以记录深度。分析见<a href=\"https://github.com/applefishsky009/LeetCode/blob/master/131%20-%20Palindrome%20Partitioning/131%20-%20Palindrome%20Partitioning.cpp\" target=\"_blank\" rel=\"external\">这里</a></li>\n</ol>\n"},{"title":"共用体、枚举和浮点数存储","url":"http://yoursite.com/2016/04/21/共用体、枚举和浮点数存储/","content":"<h2 id=\"共用体\"><a href=\"#共用体\" class=\"headerlink\" title=\"共用体\"></a>共用体</h2><p>是一种数据格式，简单来说，在同一块内存地址，可以同时起不同数据类型的名字，用这些名字来取值时，名字所对应的数据类型告诉编译器怎么去解释内存中的数据。他的特点：</p>\n<ol>\n<li>它的长度是最大数据类型长度，可以节省空间；</li>\n<li>数据不共存；</li>\n<li>关键字<code>union</code>，声明方式与结构体相同；</li>\n</ol>\n<hr>\n<h2 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h2><p>创建符号常量的方式，简单来说就是将一个“标签”与枚举量对应起来。特点：</p>\n<ol>\n<li>可以提升(常到<code>int</code>)，但<code>int</code>不能缩窄到它；</li>\n<li>可以显式设置枚举量，枚举范围内即使没有枚举量，也合法；</li>\n<li>关键词<code>enum</code>，声明方式与结构体相似；</li>\n<li>他没有算术运算，一般常用于<code>swith</code>语句中的标签。</li>\n</ol>\n<hr>\n<h2 id=\"浮点数存储方式\"><a href=\"#浮点数存储方式\" class=\"headerlink\" title=\"浮点数存储方式\"></a>浮点数存储方式</h2><p>不管是什么数据类型，在内存中的表示方式都是一样的(0或者1)，数据类型的作用只是告诉编译器如何去解释内存中的数据，那么编译器是如何解释浮点型的？<br>首先，二进制科学法表示中，一个浮点型S = M*2^N，内存会存储三部分：符号位+阶码(N)+尾数(M)；</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">数据</th>\n<th style=\"text-align:center\">符号位</th>\n<th style=\"text-align:center\">阶码</th>\n<th style=\"text-align:center\">尾数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>float</code></td>\n<td style=\"text-align:center\">1位</td>\n<td style=\"text-align:center\">8位</td>\n<td style=\"text-align:center\">23位</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">内存位</td>\n<td style=\"text-align:center\">31</td>\n<td style=\"text-align:center\">30-23</td>\n<td style=\"text-align:center\">22-0</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>double</code></td>\n<td style=\"text-align:center\">1位</td>\n<td style=\"text-align:center\">11位</td>\n<td style=\"text-align:center\">52位</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">内存位</td>\n<td style=\"text-align:center\">63</td>\n<td style=\"text-align:center\">62-52</td>\n<td style=\"text-align:center\">51-0</td>\n</tr>\n</tbody>\n</table>\n<p>其次，阶码使用中间偏置(固定量为2^N-1)的移码表示的,M的整数部分为1,不存储，只存储尾数即可。<br>例如，125.5f = <code>1111101.1</code> = 1.1111011*2^6 =&gt;移码127+6 = 133 = <code>10000101</code> =&gt;正数符号位是0，尾数补0到够23位,那么计算机中：<code>01000010 10000000 00000000 01111011</code>。</p>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><ol>\n<li>整型常量默认情况下是int型,浮点常量在默认情况下是<code>double</code>型,如果需要<code>float</code>型，需要这样表示：<code>3.25f</code>；</li>\n</ol>\n"},{"title":"string类与结构体","url":"http://yoursite.com/2016/04/21/string类与结构体/","content":"<h2 id=\"string类\"><a href=\"#string类\" class=\"headerlink\" title=\"string类\"></a>string类</h2><h3 id=\"string运算符\"><a href=\"#string运算符\" class=\"headerlink\" title=\"string运算符\"></a>string运算符</h3><p><code>string</code>类的运算符重载在头文件<code>string</code>里,如<code>+</code>,<code>&lt;&lt;</code>。注意<code>&quot;a&quot;+&quot;b&quot; = &quot;ab&quot;</code>,<code>&#39;a&#39;+&#39;b&#39; = 195</code>,前者是字符串拼接，后者是字符常量相加。但是<code>cout&lt;&lt;&quot;a&quot;+&quot;b&quot;;</code>这个语句是错误的，必须至少声明两个<code>string</code>类型。</p>\n<h3 id=\"string-find\"><a href=\"#string-find\" class=\"headerlink\" title=\"string.find()\"></a>string.find()</h3><p><code>string</code>类的<code>find()</code>方法，可以用于找子串，返回子串在原串出现的下标。<a href=\"http://www.cnblogs.com/web100/archive/2012/12/02/cpp-string-find-npos.html\" target=\"_blank\" rel=\"external\">这里</a>和<a href=\"http://www.cplusplus.com/reference/string/string/find/\" target=\"_blank\" rel=\"external\">这里</a>有详细解释，使用时注意以下三点：</p>\n<ul>\n<li>接受三个参数，第一个是子串，第二个是开始寻找的下标，第三个参数是匹配字串的字符数。可以用于找全部的匹配子串；</li>\n<li>如果没有找到，返回值是<code>string::npos</code>，他是一个很大的正数；</li>\n<li>返回值是<code>size_t</code>，一般可用<code>auto</code>来代替。</li>\n</ul>\n<p>以下代码可以输出全部的匹配位置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string s1 = &quot;abcdbcgbcdbjjkklbcdbcdbcdghjbcd&quot;;</span><br><span class=\"line\">string s2 = &quot;bcd&quot;;</span><br><span class=\"line\">auto k  = s1.find(s2);</span><br><span class=\"line\">while (k != string::npos)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tcout&lt;&lt;k&lt;&lt;endl;</span><br><span class=\"line\">\tk = s1.find(s2,k+1);\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"string-substr\"><a href=\"#string-substr\" class=\"headerlink\" title=\"string.substr()\"></a>string.substr()</h3><p>函数声明如下：<code>_Myt substr(size_type _Off = 0, size_type _Count = npos) const</code>，返回从指定位置(_Off)开始的长度为(_Count)的子字符串。</p>\n<hr>\n<h2 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h2><ol>\n<li>基本项，可以列表化，提倡外部结构声明，可以使用赋值运算符,列表初始化不允许缩窄转换。</li>\n<li>结构体对准：<ul>\n<li>结构体首地址能被其最宽基本类型成员的大小所整除；</li>\n<li>结构体每个成员相对于结构体首地址的偏移量(offset)都是成员大小整数倍；</li>\n<li>结构体的总大小是结构体最宽基本类型成员大小的整数倍。</li>\n</ul>\n</li>\n<li>与此相关还有栈对准，某些编译器(x64?)按大小对准，<code>char</code>位于栈底，<code>double</code>位于栈顶排列。找不到相关资料了，需要深入了解。</li>\n</ol>\n<p>示例：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Definition for a binary tree node.</span><br><span class=\"line\">struct TreeNode &#123;</span><br><span class=\"line\">\tint val;</span><br><span class=\"line\">\tTreeNode *left;</span><br><span class=\"line\">\tTreeNode *right;</span><br><span class=\"line\">\tTreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"cctype与进制数转化","url":"http://yoursite.com/2016/04/21/cctype与进制数转化/","content":"<h2 id=\"进制转化\"><a href=\"#进制转化\" class=\"headerlink\" title=\"进制转化\"></a>进制转化</h2><ol>\n<li>控制符dec，hex，oct用于设置整数显式的进制数，分别对应十进制，16进制，八进制，语法：<code>cout&lt;&lt;dec;</code>,<code>cout&lt;&lt;hex;</code>,<code>cout&lt;&lt;oct</code>。</li>\n<li>头文件<code>cstdlib</code>中的<code>char *_itoa(int value,char string,int radix)</code>可以设置任一进制的输出。<ul>\n<li>参数一：要转换的数据；</li>\n<li>参数二：存放结果的字符串地址；</li>\n<li>参数三：进制数；</li>\n<li>返回值：指向结果字符串的指针。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"cctype\"><a href=\"#cctype\" class=\"headerlink\" title=\"cctype\"></a>cctype</h2><p>主要是<code>cctype</code>头文件中的字符函数在编程过程中可以带来很多便利，常用的总结如下：</p>\n<ol>\n<li><code>isalpha()</code>,<code>isdigit()</code>,<code>isalnum()</code>可以用于判断是字符、数字、字母或数字。返回<code>true</code>或<code>false</code>。</li>\n<li><code>islower()</code>,<code>isupper()</code>,<code>isprint()</code>可以用于判断是小写字母、大写字符、可显示字符。返回<code>true</code>或<code>false</code>。<a href=\"https://zh.wikipedia.org/wiki/ASCII#.E5.8F.AF.E6.98.BE.E7.A4.BA.E5.AD.97.E7.AC.A6\" target=\"_blank\" rel=\"external\">可显示字符</a>从32到126一共95个。</li>\n<li><code>tolower()</code>,<code>toupper()</code>用于大小写字母的转换，如果不需要转换，字符不变。</li>\n<li>另外一些不常用的字符函数,<code>isgraph()</code>(除空格之外的打印字符),<code>ispunct()</code>(标点符号),<code>isspace()</code>(标准空白字符),<code>iscntrl()</code>(控制字符),<code>isxdigit()</code>(16进制,即1-9,a-f,A-F)。</li>\n</ol>\n<hr>\n"},{"title":"类型转换","url":"http://yoursite.com/2016/04/20/类型转换/","content":"<p>C++自动执行以下类型转换：</p>\n<ul>\n<li>不同算术类型的赋值；</li>\n<li>包含不同类型的表达式；</li>\n<li>函数调用</li>\n</ul>\n<hr>\n<h2 id=\"初始化和赋值进行的转换\"><a href=\"#初始化和赋值进行的转换\" class=\"headerlink\" title=\"初始化和赋值进行的转换\"></a>初始化和赋值进行的转换</h2><p>扩展没有问题；缩窄可能会有一些问题:</p>\n<ul>\n<li>精度降低(double-&gt;float等);</li>\n<li>数字截短(float-&gt;int等);</li>\n<li>数据丢失(long-&gt;short等)。</li>\n</ul>\n<hr>\n<h2 id=\"列表初始化时的转换\"><a href=\"#列表初始化时的转换\" class=\"headerlink\" title=\"列表初始化时的转换\"></a>列表初始化时的转换</h2><p>不允许缩窄。</p>\n<hr>\n<h2 id=\"表达式的转换\"><a href=\"#表达式的转换\" class=\"headerlink\" title=\"表达式的转换\"></a>表达式的转换</h2><h3 id=\"自动转化\"><a href=\"#自动转化\" class=\"headerlink\" title=\"自动转化\"></a>自动转化</h3><p><code>int</code>型是计算机最自然的语言，运算速度最快。整型提升(integral promotion)规则如下:</p>\n<ol>\n<li>计算表达式时，C++将<code>bool</code>，<code>char</code>，<code>unsigned char</code>，<code>signed char</code>，<code>short</code>都转换为<code>int</code>；</li>\n<li>如果<code>short</code>和<code>int</code>一样长，<code>unsigned short</code>转换为<code>unsigned int</code>，如果<code>short</code>比<code>int</code>短，<code>unsigned short</code>转换为<code>int</code>。总之，以不损失数据为原则。</li>\n<li>在不损失数据的原则下，同级别有符号数比无符号数优先。</li>\n</ol>\n<h3 id=\"算术运算的转化\"><a href=\"#算术运算的转化\" class=\"headerlink\" title=\"算术运算的转化\"></a>算术运算的转化</h3><p>将较小的类型转换成较大的类型。依次判断long double?-&gt;double?-&gt;float?-&gt;integral promotion!可以看到浮点型优先于整型。具体过程可以查看C++11版本的效验表。</p>\n<hr>\n<h2 id=\"传递参数时的转换\"><a href=\"#传递参数时的转换\" class=\"headerlink\" title=\"传递参数时的转换\"></a>传递参数时的转换</h2><p>由C++函数原型控制，若取消函数原型的控制:</p>\n<ul>\n<li>将对<code>char</code>和<code>short</code>整型提升;</li>\n<li>将<code>float</code>参数提升为<code>double</code>。</li>\n</ul>\n<hr>\n<h2 id=\"强制类型转换\"><a href=\"#强制类型转换\" class=\"headerlink\" title=\"强制类型转换\"></a>强制类型转换</h2><p>C++设计新格式，让强制类型转换像函数一样调用:<code>typename (value)</code>更严格的限制允许的类型转换，以下4个类型转换符：</p>\n<ul>\n<li><code>dynamic_cast</code>;</li>\n<li><code>const_cast</code>;</li>\n<li><code>static_cast</code>;</li>\n<li><code>reinterpret_cast</code>;</li>\n</ul>\n<p>相关：因为指针大小固定(指针的本质是一个存放地址的内存，32位编译器是4字节),任意指针之间可以进行强制转化。</p>\n"},{"title":"栈与字符型变量的地址","url":"http://yoursite.com/2016/04/20/栈与字符型变量的地址/","content":"<h2 id=\"栈的存储机制\"><a href=\"#栈的存储机制\" class=\"headerlink\" title=\"栈的存储机制\"></a>栈的存储机制</h2><p>在之前的内存存储区之中讲过栈，他大概有以下特点：编译器自助管理；空间大小指定；不会产生碎片；向下生长；静态(主要)或动态(不需要人工释放)分配；效率高。这里以下边的语句为例说明栈的存储：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint a[4] = &#123;1,2,3,4&#125;;</span><br><span class=\"line\">\tint b[4] = &#123;5,6,7,8&#125;;</span><br><span class=\"line\">\tint c[4] = &#123;9,10,11,12&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://i.imgur.com/r0E1t24.jpg\" alt=\"栈\"></p>\n<ol>\n<li>数组名称是一个指针，指向数组的第一个元素；</li>\n<li>a[-2]指的是a指针向栈的地址低位移动2个数据元素大小(例子中是int型)，即访问到b[2]，<strong>但是</strong>实际情况与编译器相关，他会做一些对准或者优化，明白访问原理即可；</li>\n<li>每一个元素在栈中的字节序是Little Endian，即低位字节排放在地址的低地址端，高位字节排放在地址的高地址端。与之对应的还有Big Endian，排放次序相反。</li>\n</ol>\n<hr>\n<h2 id=\"字符型变量的地址\"><a href=\"#字符型变量的地址\" class=\"headerlink\" title=\"字符型变量的地址\"></a>字符型变量的地址</h2><p>字符型变量<code>char c</code>的地址不能用<code>cout&lt;&lt;&amp;c；</code>来表示，因为<code>&amp;c</code>实际上是一个<code>char *</code>型的变量，它输出字符串的值，而字符串只有在内存中读到<code>\\0</code>才会终止，因此会出现乱码。所以要输出字符变量的地址，应该用以下语句告诉编译器如何解释：</p>\n<ol>\n<li><code>(int *)&amp;c</code>;</li>\n<li><code>(static_cast&lt;void *&gt;(&amp;jc)</code>。</li>\n</ol>\n<p>上述的<code>static_cast</code>用于显式类型转换。</p>\n"},{"title":"unordered_set简介","url":"http://yoursite.com/2016/04/19/unordered_set简介/","content":"<h2 id=\"unordered-set简介\"><a href=\"#unordered-set简介\" class=\"headerlink\" title=\"unordered_set简介\"></a>unordered_set简介</h2><p>MSDN上有对<a href=\"https://msdn.microsoft.com/zh-cn/library/bb982739.aspx\" target=\"_blank\" rel=\"external\">unordered_set</a>描述，CSDN上有博客对<a href=\"http://blog.csdn.net/oabid/article/details/4562577\" target=\"_blank\" rel=\"external\">unordered_set</a>描述，这是一个哈希表。一般来说，一些简单功能可以当做STL里的容器来用：<code>insert()</code>、<font color=\"red\"><code>find()</code></font>、<code>erase()</code>、<code>size()</code>、<code>empty()</code>、<code>begin()</code>、<code>end()</code>。</p>\n<hr>\n<h2 id=\"unordered-set-无序关联容器-与vector的异同\"><a href=\"#unordered-set-无序关联容器-与vector的异同\" class=\"headerlink\" title=\"unordered_set(无序关联容器)与vector的异同\"></a>unordered_set(无序关联容器)与vector的异同</h2><ol>\n<li><code>_Pairib insert(const value_type&amp; _Val)</code>;基本与<code>vector</code>用法相同，参数为要插入的值。</li>\n<li><code>iterator find(const key_type&amp; _Keyval)</code>;若找到该元素，返回的指针指向该元素，没找到返回的指针会指向超尾即<code>end()</code>。与<code>size_type find(_Elem _Ch, size_type _Off = 0) const</code>有区别，后者会返回下标(<code>size_type</code>可以看做一种足够大的<code>unsigned</code>类型来表示下标)，如果没找到，返回<code>string::npos</code>。而</li>\n<li><code>size_type erase(const key_type&amp; _Keyval)</code>;擦除指定值，返回该指定值的位置。<code>iterator erase(const_iterator _Where)</code>擦除指针指向的值，容器重排，指针不变。</li>\n</ol>\n"},{"title":"默认参数与内联函数","url":"http://yoursite.com/2016/04/19/默认参数与内联函数/","content":"<h2 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h2><p>省略实参时自动使用的值，必须通过函数原型(这是因为函数调用时通过函数原型将函数参数压入栈帧)，使用方法是将值赋给原型中的值(压入栈帧并初始化)。 </p>\n<hr>\n<h2 id=\"内联函数\"><a href=\"#内联函数\" class=\"headerlink\" title=\"内联函数\"></a>内联函数</h2><p>常规函数和内联函数之间的主要区别是C++编译器如何将它们组合到程序中去。</p>\n<h3 id=\"C语言的宏\"><a href=\"#C语言的宏\" class=\"headerlink\" title=\"C语言的宏\"></a>C语言的宏</h3><p>宏是内联代码的原始实现，它的本质是<strong>文本替换</strong></p>\n<ol>\n<li>普通宏定义中，预处理器将空格解释成分段标志；</li>\n<li><code>##</code>是一种分隔连接方式，作用是先分隔后强制连接；</li>\n<li><code>#</code>表示变量替换后加双引号括起来。</li>\n<li>另外一些分隔符、操作符如<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>[</code>、<code>]</code>依然有意义。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define A1(name,type) type name_##type##_type</span><br><span class=\"line\">\tA1(a1,int) &lt;=&gt; int name_int_type</span><br><span class=\"line\">#define A1(name,type) type name##_##type##_type</span><br><span class=\"line\">\tA1(a1,int) &lt;=&gt; int a1_int_type</span><br><span class=\"line\">#define stringify(x) #x</span><br><span class=\"line\">\tstringify(linux) &lt;=&gt; &quot;linux&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"C-内联函数\"><a href=\"#C-内联函数\" class=\"headerlink\" title=\"C++内联函数\"></a>C++内联函数</h3><ol>\n<li>编译器将使用相应的函数代码替换函数调用(省略了来回跳跃并记录跳跃位置的过程)；</li>\n<li>运行速度较快，但占用更多的内存(同一个内联函数调用多少次，就有多少次副本)；</li>\n<li>一般省略原型(但原型特性仍在起作用)，将整个定义放在原本该提供原型的地方(这是首次使用前的函数定义，充当原型)，并使用<code>inline</code>关键字</li>\n<li>编译器并不一定满足程序员内联函数的请求，比如函数过大或者函数调用了自己(递归不能内联)。</li>\n</ol>\n<p>注意类成员函数中的内联函数并不一定使用<code>inline</code>关键字。定义位于类声明中自动成为内联函数；否则使用<code>inline</code>关键字作为内联函数。</p>\n"},{"title":"函数原型与函数调用","url":"http://yoursite.com/2016/04/18/函数原型与函数调用/","content":"<h2 id=\"函数原型\"><a href=\"#函数原型\" class=\"headerlink\" title=\"函数原型\"></a>函数原型</h2><h3 id=\"为什么需要原型\"><a href=\"#为什么需要原型\" class=\"headerlink\" title=\"为什么需要原型\"></a>为什么需要原型</h3><p>原型是函数到编译器的接口，他将函数返回值的类型以及参数的类型和数量告诉编译器。</p>\n<ol>\n<li>原型告诉编译器函数参数类型和数量，如果不准确，它让编译器捕获这种错误</li>\n<li>函数完成计算后，将返回值放在指定的位置(<strong>CPU寄存器或者内存</strong>)以供调用函数取得。</li>\n<li>原型指出返回类型，让编译器知道应检索多少字节以及如何<em>解释</em>他们。</li>\n</ol>\n<h3 id=\"原型语法\"><a href=\"#原型语法\" class=\"headerlink\" title=\"原型语法\"></a>原型语法</h3><p>以<code>void cheers(int);</code>为例，</p>\n<ol>\n<li>函数原型是一条语句，必须以分号结尾；</li>\n<li>函数原型不要求提供变量名，有类型列表就够了(这与函数调用有关，原型中的变量名其实就是栈中的占位符)</li>\n</ol>\n<h3 id=\"原型功能\"><a href=\"#原型功能\" class=\"headerlink\" title=\"原型功能\"></a>原型功能</h3><ol>\n<li>编译器正确处理函数返回值(就是说在<strong>指定位置如何解释</strong>)；</li>\n<li>编译器检查使用的参数数目是否正确(<strong>不正确让编译器捕获错误</strong>)；</li>\n<li>编译器检查参数类型是否正确，如果不正确，可能的话转换为正确类型(编译阶段进行的原型化，静态类型检查)。如下<br><img src=\"http://i.imgur.com/5aaLwcA.png\" alt=\"函数原型进行类型转化\"></li>\n</ol>\n<hr>\n<h2 id=\"函数调用\"><a href=\"#函数调用\" class=\"headerlink\" title=\"函数调用\"></a>函数调用</h2><p>详细过程见<a href=\"http://www.zhihu.com/question/22444939#answer-4080329\" title=\"函数调用中栈的变化\" target=\"_blank\" rel=\"external\">这里</a></p>\n<h3 id=\"相关寄存器\"><a href=\"#相关寄存器\" class=\"headerlink\" title=\"相关寄存器\"></a>相关寄存器</h3><ol>\n<li>栈指针寄存器：指向系统栈最上面一个帧栈栈底的指针；</li>\n<li>基址指针寄存器：指向系统栈最上面一个帧栈栈底的指针；</li>\n<li>指令寄存器：指向下一条待执行的指令地址。</li>\n</ol>\n<h3 id=\"函数调用步骤\"><a href=\"#函数调用步骤\" class=\"headerlink\" title=\"函数调用步骤\"></a>函数调用步骤</h3><ol>\n<li>参数入栈：C++将参数从右向左依次入栈；</li>\n<li>返回地址入栈：将<em>当前</em>代码区调用指令的<em>下一条</em>指令地址压入栈，函数返回时继续执行；</li>\n<li>代码区跳转：从当前代码区跳转到被调函数入口处；</li>\n<li>栈帧调整：<ul>\n<li>当前栈帧的EPB入栈；</li>\n<li>切换到新栈帧,ESP装入EBP；</li>\n<li>给新栈帧分配空间；</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h3><h4 id=\"为什么参数要入栈？\"><a href=\"#为什么参数要入栈？\" class=\"headerlink\" title=\"为什么参数要入栈？\"></a>为什么参数要入栈？</h4><p>为了保存现场，例如一个递归：<br>    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int sum(int n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif (n == 0)</span><br><span class=\"line\">\t\treturn 0;</span><br><span class=\"line\">\treturn sum(n-1)+n</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当<code>sum(n-1)</code>返回，他的栈帧被释放，还原到<code>sum(n)</code>的栈帧，那么n的值怎么获得？假如<code>sum</code>是在<code>main()</code>调用的，n在调用时压入了<code>main()</code>的栈帧，并对一个匿名对象拷贝了n的值供<code>sum()</code>计算，如果传地址或者引用就可以直接修改栈帧中的值。<br>这就可以解释为什么按值传递时不能修改上一级函数的数值，因为栈帧会还原，按值传递修改的也不是栈帧中的值。</p>\n"},{"title":"类的复制构造函数和赋值运算符重载","url":"http://yoursite.com/2016/04/18/类的复制构造函数和赋值运算符重载/","content":"<p>C++会自动提供以下成员函数：</p>\n<ol>\n<li>默认构造函数；</li>\n<li>默认析构函数</li>\n<li>复制构造函数</li>\n<li>赋值运算符</li>\n<li>地址运算符</li>\n</ol>\n<p>之前讨论过构造函数与析构函数，今天讨论复制构造函数与赋值运算符。</p>\n<h2 id=\"类的复制构造函数\"><a href=\"#类的复制构造函数\" class=\"headerlink\" title=\"类的复制构造函数\"></a>类的复制构造函数</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ol>\n<li>作用：复制构造函数用于将一个对象复制到新创建的对象中。也就是用于初始化过程（包括按值传递）,而不是常规的赋值过程。<strong>隐式构造函数<font color=\"red\">按值</font>逐个复制非静态成员</strong>,静态成员属于整个类，不属于某一个对象，因此不受影响。</li>\n<li>何时调用：新建一个对象并将其初始化为同类现有对象。有以下四种可能语法：<ul>\n<li><code>StringBad ditto(motto)</code>;</li>\n<li><code>StringBad *pStringBad = new StringBad(motto)</code>;</li>\n<li><code>StringBad metoo = motto</code>;</li>\n<li><code>StringBad also = StringBad(motto)</code>。</li>\n</ul>\n</li>\n</ol>\n<p>1、2两种声明没有临时匿名对象(或者说临时匿名对象有外部载体);3、4两种声明值是接创建metoo和also还是用复制构造函数构造临时对象然后对象赋值给metoo和also，取决于具体实现。<font color=\"red\">特点是有赋值运算符的非指针构造</font>，在本人的编译器上(VS2012 32)是有临时对象并析构的。</p>\n<h4 id=\"注：\"><a href=\"#注：\" class=\"headerlink\" title=\"注：\"></a>注：</h4><ol>\n<li>无论哪种编译器，按值传递和返回对象时，都将调用复制构造函数。</li>\n<li>由于1，复制构造函数必须<strong>接受类对象的常量引用</strong>作为参数，否则会无限递归调用自身导致堆栈溢出。</li>\n</ol>\n<h3 id=\"默认复制构造函数的缺陷-浅复制\"><a href=\"#默认复制构造函数的缺陷-浅复制\" class=\"headerlink\" title=\"默认复制构造函数的缺陷(浅复制)\"></a>默认复制构造函数的缺陷(浅复制)</h3><ol>\n<li>对象计数器：默认构造函数+显式构造函数+显式构造函数=析构函数。</li>\n<li>隐式复制构造函数是<strong>按值复制</strong>，对于指针指向的new出来的空间，它会使两个指针指向同一块内容，因此在析构时，编译器尝试两次释放同一块内存，这会导致不确定的可能有害的结果。必须定义一个显式复制构造函数给指针开辟新的内存、</li>\n</ol>\n<hr>\n<h2 id=\"类的复制运算符重载-深度复制\"><a href=\"#类的复制运算符重载-深度复制\" class=\"headerlink\" title=\"类的复制运算符重载(深度复制)\"></a>类的复制运算符重载(深度复制)</h2><p>C++的类对象赋值通过自动为类重载赋值运算符实现。赋值运算符是只能由类成员函数重载的运算符之一。<br>如上所说四种新建对象方法，<em>8初始化时总会调用复制构造函数，而是用<code>=</code>运算符也允许调用赋值运算符。</em>但是！赋值运算符的隐式实现也是对成员逐个赋值。那么如上也有两次析构的问题，因此应该提供赋值运算符进行深度复制。<br>其与复制构造函数的差别：</p>\n<ol>\n<li>应该首先检查自我复制，相同返回自身。否则未复制前释放了自身；</li>\n<li>释放拷贝对象之前引用的数据，否则会内存泄露(因为要深度复制会申请新的内存空间并指向他进行数据拷贝，之前的内存指针就丢失了)。</li>\n<li>返回一个指向调用对象的引用以便连续赋值。</li>\n</ol>\n<p>下面这个例子同时犯了复制构造函数和赋值运算符重载的浅复制错误：<br><img src=\"http://i.imgur.com/OwHR2qp.png\" alt=\"典型的浅复制错误\"></p>\n<hr>\n<h2 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h2><ol>\n<li>为什么赋值运算符重载返回类型是引用？之前在<code>*this</code>指针中提过，返回类型为引用意味着返回对象本身而不是其副本。这样在一些含有赋值运算符的初始化中也可以防止递归调用。</li>\n<li>为什么参数类型为引用？对<em>复制构造函数</em>和<em>赋值运算符重载</em>，都是为了防止递归调用。</li>\n</ol>\n"},{"title":"vector之resize方法和reverse方法","url":"http://yoursite.com/2016/04/15/vector之resize方法和reverse方法/","content":"<h2 id=\"a-resize-和a-reverse\"><a href=\"#a-resize-和a-reverse\" class=\"headerlink\" title=\"a.resize()和a.reverse();\"></a>a.resize()和a.reverse();</h2><ol>\n<li>首先介绍容器的两个属性<code>capacity</code>和<code>size</code>。<code>capacity</code>存储区的大小；<code>size</code>容器的大小。</li>\n<li>‘reverse()’是预分配存储区的大小，预分配存储区，但存储区不一定有容器对象。</li>\n<li>‘resize()’是改变容器大小，容器中一定有容器对象。</li>\n</ol>\n<hr>\n<h3 id=\"a-reverse\"><a href=\"#a-reverse\" class=\"headerlink\" title=\"a.reverse();\"></a>a.reverse();</h3><p>看源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void reserve(size_type _Count)</span><br><span class=\"line\">&#123;\t// determine new minimum length of allocated storage</span><br><span class=\"line\">\tif (capacity() &lt; _Count)</span><br><span class=\"line\">\t&#123;// something to do, check and reallocate</span><br><span class=\"line\">\t\tif (max_size() &lt; _Count)</span><br><span class=\"line\">\t\t\tXlen();</span><br><span class=\"line\">\t\t_Reallocate(_Count);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>没有<code>else</code>，说明若当前的<code>capacity</code>大于传入的值，<strong><code>capacity</code>是不会减小的</strong>；</li>\n<li>里层的if是错误检测机制；</li>\n<li>验证<code>vector</code>的<code>reallocate</code>原理，实际上每次新的<code>capacity</code>是之前的1.5倍。因此在<strong>循环之前一定要<code>reserve</code>保证效率</strong>。</li>\n</ol>\n<hr>\n<h3 id=\"a-resize\"><a href=\"#a-resize\" class=\"headerlink\" title=\"a.resize();\"></a>a.resize();</h3><p>模板类提供了两个函数重载：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">表达式</th>\n<th style=\"text-align:center\"><strong>返回类型</strong></th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>a.resize(n)</code></td>\n<td style=\"text-align:center\">void</td>\n<td style=\"text-align:center\">容器大小设为n</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>a.resize(n,t)</code></td>\n<td style=\"text-align:center\">void</td>\n<td style=\"text-align:center\">容器大小设为n，必要时用t填充</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"a-resize-n\"><a href=\"#a-resize-n\" class=\"headerlink\" title=\"a.resize(n)\"></a>a.resize(n)</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void resize(size_type _Newsize)</span><br><span class=\"line\">&#123;\t// determine new length, padding as needed</span><br><span class=\"line\">\tif (_Newsize &lt; size())</span><br><span class=\"line\">\t\terase(begin() + _Newsize, end());</span><br><span class=\"line\">\telse if (size() &lt; _Newsize)</span><br><span class=\"line\">\t&#123;\t// pad as needed</span><br><span class=\"line\">\t\t_Alty _Alval(this-&gt;_Getal());</span><br><span class=\"line\">\t\t_Reserve(_Newsize - size());</span><br><span class=\"line\">\t\t_TRY_BEGIN</span><br><span class=\"line\">\t\t_Uninitialized_default_fill_n(this-&gt;_Mylast, _Newsize - size(),_Alval);</span><br><span class=\"line\">\t\t_CATCH_ALL</span><br><span class=\"line\">\t\t_Tidy();</span><br><span class=\"line\">\t\t_RERAISE;</span><br><span class=\"line\">\t\t_CATCH_END</span><br><span class=\"line\">\t\tthis-&gt;_Mylast += _Newsize - size();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>若容器新大小小于现在的大小，毁掉多余的对象；</li>\n<li>新大小大于现在的大小：<ul>\n<li>注意<code>_Reserve</code>和<code>.reverse</code>是两个不同的方法，一个比较<code>capacity</code>，一个比较<code>_Unused_capacity</code>；</li>\n<li>检查空间，不够则<code>reverse</code>；</li>\n<li>填充未初始化的对象</li>\n<li>修改尾指针</li>\n</ul>\n</li>\n</ol>\n<p>####a.resize(n,t)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void resize(size_type _Newsize, const value_type&amp; _Val)</span><br><span class=\"line\">&#123;\t// determine new length, padding with _Val elements as needed</span><br><span class=\"line\">\tif (_Newsize &lt; size())</span><br><span class=\"line\">\t\terase(begin() + _Newsize, end());</span><br><span class=\"line\">\telse if (size() &lt; _Newsize)</span><br><span class=\"line\">\t\t_Insert_n(end(), _Newsize - size(), _Val);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>若容器新大小小于现在的大小，毁掉多余的对象；</li>\n<li>新大小大于现在的大小，直接执行<code>insert</code>;</li>\n</ol>\n<hr>\n"},{"title":"vector之erase方法","url":"http://yoursite.com/2016/04/14/vector之erase方法/","content":"<h2 id=\"a-erase\"><a href=\"#a-erase\" class=\"headerlink\" title=\"a.erase();\"></a>a.erase();</h2><p>模板类提供了两个函数重载：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">表达式</th>\n<th style=\"text-align:center\"><strong>返回类型</strong></th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>a.erase(p)</code></td>\n<td style=\"text-align:center\"><strong>迭代器</strong></td>\n<td style=\"text-align:center\">删除p指向的元素</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>a.erase(p,q)</code></td>\n<td style=\"text-align:center\"><strong>迭代器</strong></td>\n<td style=\"text-align:center\">删除区间[p,q)中的元素</td>\n</tr>\n</tbody>\n</table>\n<p><strong>思考</strong>:</p>\n<ol>\n<li>在之前内存之中讨论过，<code>vector</code>是保证内存连续的，那么<code>erase</code>之后他是如何保证内存连续的？答案是让该元素之后的所有元素前移补充“空位”。这一点在<code>erase()</code>方法的代码中可以看到传入的p的形参是<code>const</code>类型的，也就是说p指向的地址并不发生变化，只不过是元素前移了。测试如下：<br><img src=\"http://i.imgur.com/TZxRRb6.png\" alt=\"STL的迭代器\"></li>\n<li>注意到<code>erase</code>返回的都是迭代器，由1中的分析可知，删除p指向的元素之后，他返回的迭代器的<strong>地址不变</strong>，值是删除之后可用的下一个元素，因此<strong>给人感觉是p指向了下一个元素</strong>。那么在这里有一个值得注意的问题，如下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;int&gt;::iterator p = b.begin();</span><br><span class=\"line\">for (;p!=b.end();p++)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tif (*p == 2)</span><br><span class=\"line\">\t\tb.erase(p);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这是错误的，<code>b.erase(p)</code>没有迭代器来承接p的返回值，它的返回值被释放了。然后执行p++很显然会出现野指针。但是如果修改为<code>p = b.erase(p)</code>也是不正确的。迭代器在进行删除的这一个循环里会<code>++</code>两次（<code>erase</code>可以当做<code>++</code>一次）。但如果在<code>if</code>语句中执行一次<code>p--</code>，这是正确的。即<code>p = --b.erase(p);</code></p>\n<ol>\n<li>不能用<code>p-- = b.erase(p);</code>，因为<code>p--</code>是表达式，不能为左值；</li>\n<li><p>不能用<code>p = b.erase(p--);</code>，也是因为<code>p--</code>是一个表达式，强调计算结果，不能作为左值，也不能取址。</p>\n<p><strong>迭代器的循环使用<code>while</code>可以降低错误率。</strong></p>\n</li>\n</ol>\n<hr>\n<p>为简单，分析第一个表达式的源码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iterator erase(const_iterator _Where)</span><br><span class=\"line\">&#123;\t// erase element at where</span><br><span class=\"line\">\tif (_VICONT(_Where) != this</span><br><span class=\"line\">\t\t|| _VIPTR(_Where) &lt; this-&gt;_Myfirst</span><br><span class=\"line\">\t\t|| this-&gt;_Mylast &lt;= _VIPTR(_Where))</span><br><span class=\"line\">\t\t_DEBUG_ERROR(&quot;vector erase iterator outside range&quot;);</span><br><span class=\"line\">\t_Move(_VIPTR(_Where) + 1, this-&gt;_Mylast, _VIPTR(_Where));</span><br><span class=\"line\">\t_Destroy(this-&gt;_Mylast - 1, this-&gt;_Mylast);</span><br><span class=\"line\">\t_Orphan_range(_VIPTR(_Where), this-&gt;_Mylast);</span><br><span class=\"line\">\t--this-&gt;_Mylast;</span><br><span class=\"line\">\treturn (_Make_iter(_Where));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到他做了哪些工作,首先元素前移，然后毁掉最后一个对象(<code>capacity</code>不变)，之后<font color=\"red\">_Orphan_range发生了什么？</font>,接下来指针指向正确的位置，最后返回指向原地址的迭代器。</p>\n"},{"title":"vector之insert方法和emplace方法","url":"http://yoursite.com/2016/04/13/vector之insert方法和emplace方法/","content":"<h2 id=\"a-insert\"><a href=\"#a-insert\" class=\"headerlink\" title=\"a.insert();\"></a>a.insert();</h2><p>模板类提供了三个函数重载,这是一种<strong>拷贝</strong>插入方法：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">表达式</th>\n<th style=\"text-align:center\">返回类型</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>a.insert(p,t)</code></td>\n<td style=\"text-align:center\">迭代器</td>\n<td style=\"text-align:center\">指向原本指向的元素,将t插入到p前面</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>a.insert(p, n,t)</code></td>\n<td style=\"text-align:center\"><code>void</code></td>\n<td style=\"text-align:center\">将n个t插入到p前面</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>a.insert(p,i,j)</code></td>\n<td style=\"text-align:center\"><code>void</code></td>\n<td style=\"text-align:center\">将区间[i,j)插入到p的前面，注意是左闭右开区间，j可以是超尾</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2 id=\"a-emplace\"><a href=\"#a-emplace\" class=\"headerlink\" title=\"a.emplace();\"></a>a.emplace();</h2><p>新标准引入的<code>emplace_front</code>,<code>emplace</code>,<code>emplace_back</code>这些操作是构造而不是拷贝元素。当插入一个对象时，将会比<code>insert</code>少拷贝构造，析构的步骤。</p>\n<hr>\n<h3 id=\"注：\"><a href=\"#注：\" class=\"headerlink\" title=\"注：\"></a>注：</h3><ol>\n<li>调用<code>push</code>或<code>insert</code>成员函数，将元素类型对象传递进去，这些对象被拷贝到容器中；</li>\n<li><code>emplace()</code>在容器中构造元素，因此效率更高；</li>\n<li>注意<code>a.insert(p,t)</code>的源码提供了一个重载，若t是普通类型，则调用<code>a.emplace(p，t)</code>，若t是<code>const</code>类型，则调用<code>a.insert(p,t)</code>。</li>\n</ol>\n"},{"title":"vector简介及非STL函数用法-持续更新","url":"http://yoursite.com/2016/04/12/vector简介及非STL函数用法-持续更新/","content":"<h2 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h2><p><code>vector</code>模板类是最简单的序列类型，除非其他类型的特殊有点能够满足程序的要求，否则应该默认使用这种类型。以后将记录一些在编程过程中常用的<code>vector</code>方法作为笔记以便不时复习，必要时会分析源码。</p>\n<p>常见的方法有：<br><code>.insert()</code>，<code>a.emplace()</code>，<code>.resize()</code>，<code>.reverse()</code>，<code>.begin()</code>，<code>a.end()</code>，<code>a.rbegin()</code>，<br><code>a.rend()</code>，<code>a.size()</code>，<code>a.swap(b)</code>，<code>a.empty()</code>，<code>a.front()</code>，<code>a.back()</code>，<code>a.clear()</code>，<br><code>a.push_back(t)</code>，<code>a.popback(t)</code>，<code>a[n]</code>，<code>a.at(n)</code>。</p>\n<p>有<code>vector&lt;int&gt; a</code>;<code>vector&lt;int&gt; b</code>;即a,b是<code>vector&lt;int&gt;</code>的对象。<code>vector&lt;int&gt; ::iterator p</code>;p是指向<code>vector&lt;int&gt;</code>的迭代器。i、j、q均和p一样是指向<code>vector&lt;int&gt;</code>的迭代器。</p>\n<hr>\n<h2 id=\"sort-用于vector\"><a href=\"#sort-用于vector\" class=\"headerlink\" title=\"sort()用于vector;\"></a>sort()用于vector;</h2><p>在<code>algorithm&gt;</code>头文件中提供了<code>sort</code>的两个重载函数,查看源码可发现是用<strong>快排</strong>实现的。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">表达式</th>\n<th style=\"text-align:center\"><strong>返回类型</strong></th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>sort(p,q)</code></td>\n<td style=\"text-align:center\"><code>void</code></td>\n<td style=\"text-align:center\">对[p,q)升序排序</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>sort(p,q,cmp)</code></td>\n<td style=\"text-align:center\"><code>void</code></td>\n<td style=\"text-align:center\">对[p,q)使用<code>cmp</code>方法排序，<code>cmp</code></td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li>右闭左开区间，一般来讲<code>p = a.begin()</code>;<code>q = a.end()</code>完成了对容器的排序。</li>\n<li>升序排序直接用第一个方法，系统默认<code>a&lt;b</code>返回真，因此是升序。</li>\n<li>降序排序需要自定义<code>cmp</code>方法,方法如下，只需要将默认值改为<code>a&gt;b</code>。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool comp(const int &amp;a,const int &amp;b)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  \t\treturn a&gt;b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>以上参考了<a href=\"http://www.cnblogs.com/cj695/p/3863142.html\" title=\"这里\" target=\"_blank\" rel=\"external\">这里</a></p>\n"},{"title":"类的this指针","url":"http://yoursite.com/2016/04/12/类的this指针/","content":"<h2 id=\"C-类的this指针\"><a href=\"#C-类的this指针\" class=\"headerlink\" title=\"C++类的this指针\"></a>C++类的this指针</h2><p>如图，假设有一个类<code>Stock</code>，他有一个<code>private：int val</code>。他还有一个方法<code>const Stock&amp; Stock::compare(const Stock &amp;classIn) const</code>;这个方法要实现这样的功能：对于两个类<code>Stock</code>的对象a和b，比较a的<code>val</code>和b的<code>val</code>，返回<code>val</code>大的对象(a或者b)，可能性的写法如下：<code>a.compare(b)</code>。由于在类的方法定义中，还没有具体对象(a)。那么有这样一个问题，在方法<code>compare</code>中，如何返回以后才初始化的对象本身(也就是a)？<br><img src=\"http://i.imgur.com/qChOATG.png\" alt=\"为什么使用this指针\"></p>\n<ol>\n<li>一般来说，所有类方法都将<code>this</code>指针设置为调用它的<strong>地址</strong>。(因此返回对象使用<strong><code>*this</code></strong>)</li>\n<li><code>compare</code>方法返回类型是<em>指针意味着返回的是调用对象本身，而不是其副本</em>。</li>\n<li><code>compare</code>方法的最后一个<code>const</code>表示该方法不会修改隐式访问对象(即调用该方法的对象本身)，这在之前的博客中提到过。</li>\n<li>形参列表中的<code>const</code>表示该函数不会修改被显示访问的对象(即图中的s)。</li>\n<li>由于该函数返回了两个<code>const</code>对象之一的引用，因此<strong>返回类型也应该是<code>const</code>引用</strong>。</li>\n</ol>\n<p><img src=\"http://i.imgur.com/CzuJ4fG.png\" alt=\"this的实例\"></p>\n"},{"title":"溢出","url":"http://yoursite.com/2016/04/11/溢出/","content":"<h2 id=\"数值溢出原理\"><a href=\"#数值溢出原理\" class=\"headerlink\" title=\"数值溢出原理\"></a>数值溢出原理</h2><p><img src=\"http://i.imgur.com/W3CYdOb.png\" alt=\"数值圆图\"><br>C++Plus在P44已经说的很清楚，如下。<br>有几点需要注意的地方：</p>\n<ol>\n<li>上图下图中的圆在进行<strong>强制类型转化</strong>时也是<strong>对应</strong>的，这就是说<code>(uchar)-1 = 65535</code>。</li>\n<li>无符号数没有溢出，只有<strong>进/借位</strong>(微机原理<code>CF</code>标示)，因为C++确保无符号数类型超越限制后在另一极端取值的行为。</li>\n<li>有符号数没有进/借位，只有<strong>溢出</strong>(微机原理<code>OF</code>标示)，因为C++无法确保有符号数上溢下溢后在另一极端取值的行为。(在我测试的时候并没有发现违背这一现象，可能有特殊情况)。</li>\n</ol>\n<hr>\n<h2 id=\"运算溢出\"><a href=\"#运算溢出\" class=\"headerlink\" title=\"运算溢出\"></a>运算溢出</h2><h3 id=\"判断加法溢出\"><a href=\"#判断加法溢出\" class=\"headerlink\" title=\"判断加法溢出\"></a>判断加法溢出</h3><p>可以像这里一样分情况或者根据圆图分析，会发现</p>\n<ol>\n<li>所有上溢结果都小于任何一个操作数；</li>\n<li>所有下溢结果都大于任何一个操作数。</li>\n</ol>\n<h3 id=\"判断乘法溢出\"><a href=\"#判断乘法溢出\" class=\"headerlink\" title=\"判断乘法溢出\"></a>判断乘法溢出</h3><ol>\n<li>在这里提到，可以用检测<code>a*b/b</code>是否等于a来判断是否乘法溢出；</li>\n<li>在这里提到，可以先扩展再强制类型转化到低位，在判断是否相等来判断。</li>\n</ol>\n<p>值得注意的是，在之前的帖子中提到过判断是否相等对<strong>浮点数</strong>和整型的判断方式是不一样的。</p>\n<h3 id=\"除零是不是溢出？\"><a href=\"#除零是不是溢出？\" class=\"headerlink\" title=\"除零是不是溢出？\"></a>除零是不是溢出？</h3><p>任何数除以零的计算“不是”算术溢出的一种。在数学上只能明显算是不明确的定义；它计算出来的结果只能当成是“没有”值，而不是非常大的无限数值。</p>\n<p>应付溢出最佳的方法还是防范，充分了解数据类型，选择恰当的变量类型。比如，<code>c = a*b</code>一般都会选择c的长度为a的长度与b的长度之和。</p>\n<hr>\n<h2 id=\"堆栈溢出\"><a href=\"#堆栈溢出\" class=\"headerlink\" title=\"堆栈溢出\"></a><a href=\"https://zh.wikipedia.org/wiki/%E5%A0%86%E7%96%8A%E6%BA%A2%E4%BD%8D\" target=\"_blank\" rel=\"external\">堆栈溢出</a></h2><p>一般编译器默认的堆栈内存是1MB，若使用过多的堆栈内存时就会导致调用堆栈产生的溢出。一般产生于递归，或者静态申请过多的临时变量，比如<code>int a[1024[1024]</code>。</p>\n<ol>\n<li>若是静态内存导致的堆栈溢出，可以用动态申请使用堆内存。</li>\n<li>若是递归调用导致递归堆栈无法容纳调用的返回地址，要添加错误检查机制。注意数据类型或用循环处理来避免堆栈溢出。</li>\n</ol>\n<hr>\n<h2 id=\"缓冲区溢出\"><a href=\"#缓冲区溢出\" class=\"headerlink\" title=\"缓冲区溢出\"></a>缓冲区溢出</h2><p><a href=\"http://jingyan.baidu.com/article/e9fb46e1acc1267521f76633.html\" target=\"_blank\" rel=\"external\">缓冲区溢出</a>源于这样一个编程错误：复制一个内存区域的内容到另一个内存区域，而目标内存区域容量太小无法容纳。它允许传入函数的内存块以一种特定方式修改堆栈。</p>\n<p>此外的溢出还包括<a href=\"https://zh.wikipedia.org/wiki/%E7%AE%97%E6%9C%AF%E4%B8%8B%E6%BA%A2\" target=\"_blank\" rel=\"external\">算术下溢</a>(浮点数溢出)等。</p>\n"},{"title":"数据存储与二进制运算","url":"http://yoursite.com/2016/04/09/数据存储与二进制运算/","content":"<h2 id=\"数据存储\"><a href=\"#数据存储\" class=\"headerlink\" title=\"数据存储\"></a>数据存储</h2><h3 id=\"原、反、补码\"><a href=\"#原、反、补码\" class=\"headerlink\" title=\"原、反、补码\"></a>原、反、补码</h3><p>计算机为方便计算，内存中的数据都是以补码的形式储存、运算。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">数</th>\n<th style=\"text-align:center\">原码</th>\n<th style=\"text-align:center\">反码</th>\n<th style=\"text-align:center\">补码</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">正数</td>\n<td style=\"text-align:center\">二进制表示</td>\n<td style=\"text-align:center\">与原码相同</td>\n<td style=\"text-align:center\">与原码相同</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">负数</td>\n<td style=\"text-align:center\">对应正数符号位（最高位）置1</td>\n<td style=\"text-align:center\">负数原码<strong>非符号位</strong>按位取反</td>\n<td style=\"text-align:center\">负数反码加1</td>\n</tr>\n</tbody>\n</table>\n<p>举个例子，数据类型为<code>char</code>：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">原数字</th>\n<th style=\"text-align:center\">原码</th>\n<th style=\"text-align:center\">反码</th>\n<th style=\"text-align:center\">补码</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>+3</code></td>\n<td style=\"text-align:center\"><code>00000011</code></td>\n<td style=\"text-align:center\"><code>00000011</code></td>\n<td style=\"text-align:center\"><code>00000011</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>-3</code></td>\n<td style=\"text-align:center\"><code>10000011</code></td>\n<td style=\"text-align:center\"><code>11111100</code></td>\n<td style=\"text-align:center\"><code>11111101</code></td>\n</tr>\n</tbody>\n</table>\n<p>值得注意的是，如果这个数据为<code>unsigned char</code>，<code>11111101</code>对应的是253，这里涉及到溢出，详细讨论见下一博客。</p>\n<h3 id=\"消失的原码\"><a href=\"#消失的原码\" class=\"headerlink\" title=\"消失的原码\"></a>消失的原码</h3><p>对于<code>unsigned char</code>原反补相同，计算机存储的补码就是原码，原码二进制经典编码有256个；但是对于<code>signed char</code>，最高位是符号位，因此原码的取值范围是-127-127，只有<strong>255个编码</strong>，但是对内存来说，8bits可以编码256个，那多余的补码与消失的原码去了哪里？</p>\n<p>考虑到编码效率，补码与原码必须是一一对应的关系。很容易想到在有符号数中有<code>00000000</code>、<code>10000000</code>两个原码表示+0与-0，而这是没有意义的。我们保证<code>00000000</code>这个原码与<code>00000000</code>这个补码相对应来表示0就可以。这样找到了消失的原码：<code>10000000</code>。</p>\n<p>在这个基于256的数值域中，观察补码的<strong>重置点（溢出中非常重要的概念）</strong>127的补码<code>01111111</code>，-127的补码<code>10000001</code>，那么可以清楚的看到<code>127+1=？</code>、<code>？+1=127</code>。因此很好理解，多余的补码是<code>10000000</code>（与消失的原码相同，通过计算他的原码可以得到验证）。那么剩下的事情就是设置重置点了，有两个选择，128或者-128。考虑到符号位是1，我们人为规定-128是重置点。即<strong>-128的原码</strong>是<code>10000000</code>，<strong>补码</strong>也是<code>10000000</code>（它的<strong>反码</strong>是<code>11111111</code>？）。</p>\n<hr>\n<h2 id=\"二进制运算（移位得到CHAR-MAX和CHAR-MIN）\"><a href=\"#二进制运算（移位得到CHAR-MAX和CHAR-MIN）\" class=\"headerlink\" title=\"二进制运算（移位得到CHAR_MAX和CHAR_MIN）\"></a>二进制运算（移位得到CHAR_MAX和CHAR_MIN）</h2><p>明白上述数据存储概念之后，可以通过位运算来获得<code>char</code>的最大最小值。注意，其实在<code>climit</code>文件中有各种宏定义的最大最小值，比如<code>CHAR_MAX = 127</code>;<code>UCHAR_MAX = 0xff</code>;等。但是这里想利用位运算来实现这一目标(注意重置点)：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">CHAR_MAX</th>\n<th style=\"text-align:center\">CHAR_MIN</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>unsigned char max = 0-1</code></td>\n<td style=\"text-align:center\"><code>unsigned char min = 0</code>;</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>char max = (1&lt;&lt;7)-1</code></td>\n<td style=\"text-align:center\"><code>char min = 1&lt;&lt;7</code>(得到<code>10000000</code>);</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li>上述表格中<code>unsigned char max</code>本质为<code>signed char = -1</code>的强制类型转化</li>\n<li><code>char max</code> 是利用重置点<code>CHAR_MIN</code>得到<code>01111111</code></li>\n<li><code>char min</code> 是利用-128的特殊补码(而且与原码相同)赋值的</li>\n<li><code>+</code>、<code>-</code>运算的优先级是高于<code>&lt;&lt;</code>、<code>&gt;&gt;</code>的，因此<code>1&lt;&lt;7</code>要加括号<br>注意右值中运算表达式中的数字默认都是<code>int</code>类型的，这与C++整型提升有关，详情见另一篇博客。</li>\n</ol>\n<p>另，由以上解读可以很容易的得出<code>abs(int_X)</code>的工作原理，正数不变，负数求得原码后符号位取反，即原码也是补码。但是有<strong>例外</strong>：<code>abs(INT_MIN) = INT_MIN</code>。他是不变的。</p>\n<p>解读下边两式的区别（使用中<code>unsigned</code>与<code>signed</code>操作注意符号位扩充）：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><code>char a = abs((char)(1&lt;&lt;7)-1)</code></th>\n<th style=\"text-align:center\"><code>char b = abs((1&lt;&lt;7)-1)</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>(char)(1&lt;&lt;7)-1 = (int)-129</code></td>\n<td style=\"text-align:center\"><code>(1&lt;&lt;7)-1 = (int)127</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>1·</code></td>\n<td style=\"text-align:center\"><code>2·</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>a = -127</code></td>\n<td style=\"text-align:center\"><code>b = 127</code></td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li><code>11111111 11111111 11111111 10000000</code>+<code>11111111 11111111 11111111 11111111</code>=<code>11111111 11111111 11111111 01111111</code>(<code>char</code> 原码<code>10000001</code>)    </li>\n<li><code>00000000 00000000 00000000 1000000</code>-<code>00000000 00000000 00000000 0000001</code>=<code>00000000 00000000 00000000 01111111</code></li>\n</ol>\n<hr>\n<h2 id=\"编译器的困惑\"><a href=\"#编译器的困惑\" class=\"headerlink\" title=\"编译器的困惑\"></a>编译器的困惑</h2><p>在编程过程中碰到了<a href=\"http://www.hankcs.com/program/cpp/error-c4146-%E4%B8%80%E5%85%83%E8%B4%9F%E8%BF%90%E7%AE%97%E7%AC%A6%E5%BA%94%E7%94%A8%E4%BA%8E%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B%EF%BC%8C%E7%BB%93%E6%9E%9C%E4%BB%8D%E4%B8%BA%E6%97%A0.html\" target=\"_blank\" rel=\"external\">这个疑惑</a>,后来发现，明明 int 最小值是 -2147483648，但我们就是<strong>无法</strong>用<code>int n = -2147483648</code>;表示。这是因为这个语句会让编译器产生困惑：</p>\n<ol>\n<li>判断2147483648 &gt; INT_MAX，编译器决定用unsigned int;</li>\n<li>编译器发现负号，对2147483648取反(<em>编译器取反原理是将从高位到第一个1之间的位取反</em>)来尝试表达-2147483648；</li>\n<li>那么在圆图中可以发现，取反操作对2147483648来说依然表达原值。</li>\n</ol>\n<p>因此编译器会提示error:一元负运算符应用于无符号类型，结果仍为无符号类型。那么对-2147483648有两种可用的赋值：</p>\n<ol>\n<li>int n = INT_MIN;</li>\n<li>int n = (-2147483647 - 1);</li>\n</ol>\n<p><font color=\"red\">但是</font>，如果涉及到取反操作<code>-n</code>的计算,对于<code>n=INT_MIN</code>依然存在这个问题，因此需要分解’-n = INT_MAX+1’来分别计算<code>INT_MAX</code>与1的情况并组合。例如<a href=\"https://github.com/applefishsky009/LeetCode/blob/master/50%20-%20Pow(x%2C%20n)/50%20-%20Pow(x%2C%20n)%20.cpp\" target=\"_blank\" rel=\"external\">这里</a></p>\n"},{"title":"LeetCodeC1编程技巧说明","url":"http://yoursite.com/2016/04/08/LeetCodeC1编程技巧说明/","content":"<h2 id=\"判断两个值a-b是否相等\"><a href=\"#判断两个值a-b是否相等\" class=\"headerlink\" title=\"判断两个值a,b是否相等\"></a>判断两个值a,b是否相等</h2><ol>\n<li>若为整型，应该为<code>a==b</code>；</li>\n<li>若为浮点型，应该用<code>fabs(a-b)&lt;1e-9</code>。(因为<a href=\"http://0.30000000000000004.com/\" target=\"_blank\" rel=\"external\">计算机中浮点型是不准确的</a>，<strong>与因数有关</strong>)</li>\n<li>另外，对于<code>bool</code>型，应该用<code>if(a)</code>，<code>if(!b)</code>这样的形式来强调变量<code>bool</code>类型。</li>\n</ol>\n<hr>\n<h2 id=\"判断一个整数是否为奇数\"><a href=\"#判断一个整数是否为奇数\" class=\"headerlink\" title=\"判断一个整数是否为奇数\"></a>判断一个整数是否为奇数</h2><ol>\n<li><code>x%2 != 0</code>用来判断一个整数是否是奇数，<strong>不能用<code>x%2 = 1</code></strong>，因为x可能是负数，余数就是-1。</li>\n<li><code>-3 = 2*-1+(-1)</code>，即<code>-3/2 = -1</code>;<code>-3%2= -1</code>;说明负奇数余数是-1。</li>\n</ol>\n<hr>\n<h2 id=\"char值做数组下标的强制类型转化\"><a href=\"#char值做数组下标的强制类型转化\" class=\"headerlink\" title=\"char值做数组下标的强制类型转化\"></a>char值做数组下标的强制类型转化</h2><ol>\n<li>应该强制转化为<code>uchar</code>，作为数组下标。不能直接转化为<code>uint</code>。</li>\n<li>因为高位扩充有两种，有符号数扩充，在高位补符号位；无符号数高位直接用0。例如<code>char c = -1</code>。c在计算机中的补码是<code>11111111</code>。<code>uint a = c</code>，那么<code>a = 4294967295</code>。因为c有符号，扩充后高位补1。<code>uint b = (uchar) c</code>。那么<code>b = 255</code>。因为<code>(uchar) c</code>是无符号数，高位用0扩充。</li>\n<li>二进制中有符号向无符号数的强制转化非常简单，将<strong>符号位置为0</strong>。比如-2，原码是<code>10000010</code>，反码是<code>11111101</code>，补码是<code>11111110</code>。将符号位置0，得到<code>01111110</code>，为254。即<code>char -2</code>强制转化成<code>uchar</code>值为254。</li>\n<li>参照维基百科和C++plusP44<strong>圆图</strong>可以更清楚了解更多数据储存与二进制运算。</li>\n</ol>\n<hr>\n<h2 id=\"vector和string优先于动态数组的分配\"><a href=\"#vector和string优先于动态数组的分配\" class=\"headerlink\" title=\"vector和string优先于动态数组的分配\"></a>vector和string优先于动态数组的分配</h2><p>性能上，<code>vector</code>保证内存（分配在堆）连续，一旦分配后，性能和原始数组相当；<br>用<code>new</code>必须<code>delete</code>，不然会<code>bug</code>，代码行数不够短；<br>多维数组定义方法：</p>\n<ol>\n<li><p><code>new/delete</code>:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int** array = new int*[row];</span><br><span class=\"line\">for(int i=0;i&lt;row;i++)</span><br><span class=\"line\">\tarray[i] = new int [col];</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>vector</code>:    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;vector&lt;int&gt;&gt; = array(row,vector&lt;int&gt;(col,0));</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<hr>\n<h2 id=\"使用reverse来避免不必要的重新分配\"><a href=\"#使用reverse来避免不必要的重新分配\" class=\"headerlink\" title=\"使用reverse来避免不必要的重新分配\"></a>使用reverse来避免<a href=\"http://blog.csdn.net/bichenggui/article/details/4690175\" target=\"_blank\" rel=\"external\">不必要的重新分配</a></h2><ol>\n<li><code>vector</code>需要更多空间，以类似<code>realloc</code>的思想来增长大小。分配，回收，拷贝和析构，这些步骤都很昂贵。并且每次这些步骤发生时，所有指向<code>vector</code>或<code>string</code>中的迭代器、指针和引用都会失效。</li>\n<li>据博客中所说，vector重新分配时容量翻倍。我在VS2012，WIN32编译器下结果如下，容量是翻<em>1.5</em>倍的。因此在1000次<code>push_back</code>中导致了18次重新分配。<img src=\"http://i.imgur.com/ooqb6by.png\" alt=\"reverse()\"></li>\n<li>在<strong>容器被构造之后</strong>进行<strong><code>reserve</code>设置容器容量</strong>可以避免不必要的重新分配。<code>a.reserve(1000)</code>即把a的容量设置为1000。</li>\n</ol>\n"},{"title":"类的构造函数与析构函数初探","url":"http://yoursite.com/2016/04/07/类的构造函数与析构函数初探/","content":"<h2 id=\"类的简介\"><a href=\"#类的简介\" class=\"headerlink\" title=\"类的简介\"></a>类的简介</h2><h3 id=\"类的规范由两部分组成：\"><a href=\"#类的规范由两部分组成：\" class=\"headerlink\" title=\"类的规范由两部分组成：\"></a>类的规范由两部分组成：</h3><ol>\n<li>类声明（declaration） – 类的蓝图<ul>\n<li>以数据成员的方式描述数据，以成员函数的方式描述公有接口；</li>\n<li><strong>数据</strong>通常放在私有部分，组成类接口的<strong>成员函数</strong>放在公有部分，另外<strong>私有成员函数</strong>用来处理不属于公有接口的实现细节。</li>\n<li>定义位于声明中的函数都将自动成为内联函数，若定义位于声明之外，使用<code>inline</code>关键字成为内联函数。</li>\n</ul>\n</li>\n<li>类方法定义 – 类的实现细节<ul>\n<li>C++通常把接口（类声明）放在头文件中，并将实现（类方法代码）放在源代码中；</li>\n<li>定义成员函数时，使用作用域解析符（<code>::</code>）来表示函数所属的类；</li>\n<li>类方法可以访问类的<code>private</code>组件。</li>\n<li>只要类方法不修改调用对象，就应将其声明为<code>const</code>，如<code>void Stock::show() const</code>。</li>\n</ul>\n</li>\n</ol>\n<p>类所创建的每个新对象都有自己的存储空间，用于存储其内部变量和类成员；但同一个类的所有对象<strong>共享同一组类方法</strong>。</p>\n<h3 id=\"类成员的访问控制（封装）\"><a href=\"#类成员的访问控制（封装）\" class=\"headerlink\" title=\"类成员的访问控制（封装）\"></a>类成员的访问控制（封装）</h3><p>数据隐藏：防止程序直接访问数据。</p>\n<ul>\n<li>例如<code>int a</code>是类的私有数据成员，<code>cout&lt;&lt;a</code>是不对的，只有公有成员函数或友元函数才能访问。可以定义一个<code>show()</code>方法访问a用来输出。</li>\n</ul>\n<p>数据封装：实现细节放在一起并与抽象分开。</p>\n<ul>\n<li>数据隐藏（数据放在类的私有部分）</li>\n<li>私有成员函数（实现细节隐藏在私有部分）</li>\n<li>类函数定义和类声明放在不同的文件中。</li>\n</ul>\n<hr>\n<h2 id=\"类的构造函数与析构函数\"><a href=\"#类的构造函数与析构函数\" class=\"headerlink\" title=\"类的构造函数与析构函数\"></a>类的构造函数与析构函数</h2><h3 id=\"类的构造函数\"><a href=\"#类的构造函数\" class=\"headerlink\" title=\"类的构造函数\"></a>类的构造函数</h3><ol>\n<li>如果没有提供任何构造函数，C++自动提供默认构造函数，他不做任何工作，也就是说<strong>他的值在初始化时是未知的</strong>；但是如果定义了构造函数，程序员必须为他提供默认构造函数，用户定义的默认构造函数通常给所有成员提供隐式初始值（已知合理值）。</li>\n<li>构造函数被用来创造对象，而不能通过对象来调用。（因为在通过构造函数构造出对象之前，对象是不存在的）。</li>\n</ol>\n<h3 id=\"类的析构函数\"><a href=\"#类的析构函数\" class=\"headerlink\" title=\"类的析构函数\"></a>类的析构函数</h3><ol>\n<li>对象过期时，程序自动调用析构函数；如果程序员没有声明，编译器隐式声明一个默认析构函数。</li>\n<li>注意窗口环境中，窗口关闭之前的代码包含在同一个代码块中，才能保证析构函数在窗口关闭之前执行。</li>\n<li>若构造函数中有<code>new</code>，则析构函数必须<code>delete</code>。</li>\n</ol>\n<h3 id=\"构造函数的语法\"><a href=\"#构造函数的语法\" class=\"headerlink\" title=\"构造函数的语法\"></a><a href=\"https://github.com/applefishsky009/Leetcode/blob/master/26%20-%20Remove%20Duplicates%20from%20Sorted%20Array/26%20-%20Remove%20Duplicates%20from%20Sorted%20Array.cpp\" target=\"_blank\" rel=\"external\">构造函数的语法</a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Num nums(initVector);</span><br><span class=\"line\">Num nums;</span><br><span class=\"line\">Num();</span><br><span class=\"line\">Num nums = Num();</span><br><span class=\"line\">Num nums = Num(initVector);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>1一定不会创建一个临时对象并析构；</li>\n<li>2会调用默认构造函数，没有析构过程；</li>\n<li>3中由于没有类的对象，因此会调用默认构造函数并析构；</li>\n<li>4在本人编译器上执行了2的构造过程(实际上没有调用重载的<code>=</code>运算符)，因此没有匿名对象的构造析构；</li>\n<li>5在本人编译器上会，编译器会先调用构造函数构造匿名对象，再调用复制构造函数，再析构匿名对象。</li>\n</ul>\n<p>但是对于4、5这种创建<strong>有指定值的对象</strong>(使用运算符<code>=</code>允许调用赋值运算符(5)，也可以不调用(4))。因此是否有临时对象是不确定的(取决于具体的实现是4还是5这种方式)。</p>\n<p>总之，1的效率最高。</p>\n"},{"title":"五种变量存储方式与external关键字","url":"http://yoursite.com/2016/04/06/五种变量存储方式与external关键字/","content":"<h2 id=\"五种变量存储方式\"><a href=\"#五种变量存储方式\" class=\"headerlink\" title=\"五种变量存储方式\"></a>五种变量存储方式</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">存储描述</th>\n<th style=\"text-align:center\">持续性</th>\n<th style=\"text-align:center\">作用域</th>\n<th style=\"text-align:center\">链接性</th>\n<th style=\"text-align:center\">如何声明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">自动</td>\n<td style=\"text-align:center\">自动</td>\n<td style=\"text-align:center\">代码块</td>\n<td style=\"text-align:center\">无</td>\n<td style=\"text-align:center\">代码块中</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">寄存器</td>\n<td style=\"text-align:center\">自动</td>\n<td style=\"text-align:center\">代码块</td>\n<td style=\"text-align:center\">无</td>\n<td style=\"text-align:center\">代码块中，<code>register</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">静态，无链接性</td>\n<td style=\"text-align:center\">静态</td>\n<td style=\"text-align:center\">代码块</td>\n<td style=\"text-align:center\">无</td>\n<td style=\"text-align:center\">代码块中，<code>static</code></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">静态，外部连接性</td>\n<td style=\"text-align:center\">静态</td>\n<td style=\"text-align:center\">文件</td>\n<td style=\"text-align:center\">外部</td>\n<td style=\"text-align:center\">不在任何代码块中，无关键字</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">静态，内部链接性</td>\n<td style=\"text-align:center\">静态</td>\n<td style=\"text-align:center\">文件</td>\n<td style=\"text-align:center\">内部</td>\n<td style=\"text-align:center\">不在任何代码块中，<code>static</code></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><code>register</code>用于显示指出自动变量，没什么用处，C++11保留的目的是向下兼容；</li>\n<li>静态无链接性变量与自动变量的异同：<ul>\n<li>静态无链接性变量在编译器<strong>编译</strong>时，编译器在<strong>静态/全局存储区</strong>分配内存；</li>\n<li>自动变量在代码块<strong>运行</strong>时，编译器在<strong>栈</strong>中分配内存；</li>\n<li>二者均只能在代码块中运行。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"external关键字\"><a href=\"#external关键字\" class=\"headerlink\" title=\"external关键字\"></a>external关键字</h2><p>变量的声明有两种：定义声明（简称为定义）与引用声明（简称为声明）。如果要在一个文件中使用另一个文件中定义声明的变量，仅仅将这个变量储存为外部链接性的静态变量是不够的，还要在引用的文件中使用<code>external</code>关键字做<strong>引用声明</strong>。</p>\n<ol>\n<li>外部变量在<code>main()</code>前面或头文件中定义它，在文件中定义之后的任何位置使用它；</li>\n<li>单定义规则：变量只能定义声明一次；</li>\n<li>局部变量隐藏同名的全局变量。如果要访问全局变量，可用作用域解析符<code>：：</code>；</li>\n<li>静态变量将隐藏常规外部变量（使用<code>external</code>关键字引用）。</li>\n</ol>\n<p>关于<code>external</code>关键字的测试是很简单的，这里不给出代码。另外提到单定义规则，有一点需要注意。任何一个包含头文件的cpp都要重新编译这个头文件，因此头文件绝对不能包含函数体与变量。不然，两个或两个以上cpp包含它会出现重定义错误。</p>\n<hr>\n"},{"title":"内存存储区","url":"http://yoursite.com/2016/04/05/内存存储区/","content":"<h2 id=\"C-内存分配方式有五种：\"><a href=\"#C-内存分配方式有五种：\" class=\"headerlink\" title=\"C++内存分配方式有五种：\"></a>C++内存分配方式有五种：</h2><ol>\n<li>栈：局部变量、函数参数等<ul>\n<li>可以实现函数调用；</li>\n<li>动态扩展、收缩；</li>\n<li>位于用户虚拟地址空间顶部。</li>\n</ul>\n</li>\n<li>堆：<code>new</code>分配的内存块，<code>delete</code>释放。</li>\n<li>自由存储区：<code>malloc</code>分配，<code>free</code>释放。</li>\n<li>全局/静态存储区：全局变量与静态变量</li>\n<li>常量存储区：存放常量<ul>\n<li>如 <code>string s1 = “abcd”</code>；<code>s1</code>是代码块中的指针，在栈中；<code>“abcd”</code>是常量，在常量存储区。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2 id=\"new和malloc的区别：\"><a href=\"#new和malloc的区别：\" class=\"headerlink\" title=\"new和malloc的区别：\"></a>new和malloc的区别：</h2><ol>\n<li><code>new</code>可以认为是<code>malloc</code>加构造函数的执行；</li>\n<li><code>new</code>出来的指针是直接带类型信息的，<code>malloc</code>返回<code>void</code>指针；</li>\n<li><code>delete</code>会相应调用对象的析构函数。</li>\n</ol>\n<hr>\n<h2 id=\"堆和栈的区别：\"><a href=\"#堆和栈的区别：\" class=\"headerlink\" title=\"堆和栈的区别：\"></a>堆和栈的区别：</h2><ol>\n<li>管理方式：栈是编译器自助管理；堆是程序员控制，容易内存泄漏；<ul>\n<li>内存泄漏：申请指针，指针指向内存，作用域或生命周期到了，指针释 放，但内存并没有释放，也无法访问，变成“死内存”。</li>\n</ul>\n</li>\n<li>空间大小：堆内存几乎没有限制；栈一般有一定大小（编译器有默认值，可修改）</li>\n<li>碎片问题：堆频繁<code>new/delete</code>会产生大量碎片（<code>delete</code>出来的空间几乎不可能恰好等于<code>new</code>的空间）；栈不会；</li>\n<li>生长方向：堆向上；栈向下。</li>\n<li>分配方式：堆动态；栈动态（<code>alloca</code>，但他不需人工释放）或静态（编译器完成）</li>\n<li>分配效率：栈高于堆（栈：计算机系统提供，有底层支持；堆：C/C++库提供）</li>\n</ol>\n<hr>\n<p>以上内容主要来自于<a href=\"http://www.cnblogs.com/daocaoren/archive/2011/06/29/2092957.html\" target=\"_blank\" rel=\"external\">这里</a>。</p>\n"}]