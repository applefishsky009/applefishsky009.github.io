<!DOCTYPE html>


  <html class="dark page-home">


<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>异常 | 孤云两角，去天一握</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="C++,">
  

  <meta name="description" content="异常预防运行阶段错误。 异常终止(abort())程序员可以调用abort()函数来终止程序。其位于&amp;lt; cstdlib &amp;gt;中，向标准错误流发送消息abnormal program termination(程序异常终止)(这个消息随编译器而异)，并终止程序。 数值检查防止异常终止依靠程序来避免错误导致的程序终止(可靠性)，但是不需要经常这么做，因为程序过于冗长(一般以短小精悍实现目的为主">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="异常">
<meta property="og:url" content="applefishsky009.github.io/2016/06/27/异常/index.html">
<meta property="og:site_name" content="孤云两角，去天一握">
<meta property="og:description" content="异常预防运行阶段错误。 异常终止(abort())程序员可以调用abort()函数来终止程序。其位于&amp;lt; cstdlib &amp;gt;中，向标准错误流发送消息abnormal program termination(程序异常终止)(这个消息随编译器而异)，并终止程序。 数值检查防止异常终止依靠程序来避免错误导致的程序终止(可靠性)，但是不需要经常这么做，因为程序过于冗长(一般以短小精悍实现目的为主">
<meta property="og:locale" content="Chinese">
<meta property="og:updated_time" content="2020-05-11T23:57:44.024Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="异常">
<meta name="twitter:description" content="异常预防运行阶段错误。 异常终止(abort())程序员可以调用abort()函数来终止程序。其位于&amp;lt; cstdlib &amp;gt;中，向标准错误流发送消息abnormal program termination(程序异常终止)(这个消息随编译器而异)，并终止程序。 数值检查防止异常终止依靠程序来避免错误导致的程序终止(可靠性)，但是不需要经常这么做，因为程序过于冗长(一般以短小精悍实现目的为主">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=32204ee7" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-76667484-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics --><!-- hexo-inject:begin --><!-- hexo-inject:end -->


</head>
</html>
<body>

  
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/archives/"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/category/"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/about/"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/tag/"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/link/"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/project/"
            target="_self"
            >
            项目
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/search/"
            target="_self"
            >
            搜索
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#异常"><span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#异常终止-abort"><span class="toc-text">异常终止(abort())</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数值检查防止异常终止"><span class="toc-text">数值检查防止异常终止</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用异常机制"><span class="toc-text">使用异常机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#将对象作为异常类型"><span class="toc-text">将对象作为异常类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-11唯一支持的异常规范"><span class="toc-text">C++11唯一支持的异常规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈解退"><span class="toc-text">栈解退</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异常特性"><span class="toc-text">异常特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exception类"><span class="toc-text">exception类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异常，类和继承"><span class="toc-text">异常，类和继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迷失方向的异常"><span class="toc-text">迷失方向的异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#未捕获异常"><span class="toc-text">未捕获异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#意外异常"><span class="toc-text">意外异常</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注意事项"><span class="toc-text">注意事项</span></a></li></ol></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-异常" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">异常</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2016.06.27</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>ryl</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/C-基础/">C++基础</a>
  </span>



      
        <span>
          <i class="icon-comment"></i>
          <a href="http://applefishsky009.github.io/2016/06/27/异常/#disqus_thread"></a>
        </span>
      

    </div>
  </header>

  <div class="article-content">
    
      <h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>预防运行阶段错误。</p>
<h3 id="异常终止-abort"><a href="#异常终止-abort" class="headerlink" title="异常终止(abort())"></a>异常终止(abort())</h3><p>程序员可以调用abort()函数来终止程序。其位于&lt; cstdlib &gt;中，向标准错误流发送消息abnormal program termination(程序异常终止)(这个消息随编译器而异)，并终止程序。</p>
<h3 id="数值检查防止异常终止"><a href="#数值检查防止异常终止" class="headerlink" title="数值检查防止异常终止"></a>数值检查防止异常终止</h3><p>依靠程序来避免错误导致的程序终止(可靠性)，但是不需要经常这么做，因为程序过于冗长(一般以短小精悍实现目的为主)。</p>
<ol>
<li>对于有返回值的函数，可以讲返回值作为<strong>指针</strong>或引用传递(可以明显区分哪个参数用于答案)，将返回值设置为<code>bool</code>标识是否有错误，以便在调用中检查异常。</li>
</ol>
<h3 id="使用异常机制"><a href="#使用异常机制" class="headerlink" title="使用异常机制"></a>使用异常机制</h3><p>使用三个关键字将控制权从程序的一个部分传递到另一部分的途径。</p>
<ol>
<li>使用<code>throw</code>引发异常；</li>
<li>使用<code>catch</code>捕获特定异常(一个<code>try</code>块可以跟多个<code>catch</code>块)；</li>
<li>使用<code>try</code>标志可能激活特定异常的代码块。</li>
</ol>
<p>注意不一定抛出<code>exception</code>类，只要<code>throw</code>和<code>catch</code>的类型一致，异常就能捕获。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="string">"Now I throw a string"</span></span><br><span class="line"><span class="keyword">catch</span>(<span class="keyword">const</span> <span class="keyword">char</span> *s)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>throw</code>会执行返回语句，终止函数执行；</li>
<li>返回后在<code>catch</code>中进行异常匹配，如果没有匹配，将会调用<code>abort()</code>(这个行为可以修改)。</li>
</ol>
<h3 id="将对象作为异常类型"><a href="#将对象作为异常类型" class="headerlink" title="将对象作为异常类型"></a>将对象作为异常类型</h3><p>异常类型指的是抛出的类型(字符串或对象)，使用对象有两个好处：</p>
<ol>
<li>不同的异常类型(抛出对象)区分不同的函数引发的异常；</li>
<li>这个返回的异常可以携带信息，便于确定引发异常的原因。</li>
</ol>
<h3 id="C-11唯一支持的异常规范"><a href="#C-11唯一支持的异常规范" class="headerlink" title="C++11唯一支持的异常规范"></a>C++11唯一支持的异常规范</h3><p>C++98新增异常规范功能,他主要告诉用户函数可能引发异常，因此建议对这个函数使用异常机制</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">test</span><span class="params">(<span class="keyword">double</span> a)</span> <span class="title">throw</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;	<span class="comment">//这项工作显然在注释中可以完成</span></span><br></pre></td></tr></table></figure>

<p>C++11唯一支持的异常规范,指出这个函数不会引发异常</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">test</span><span class="params">(<span class="keyword">double</span>)</span> noexpect</span></span><br></pre></td></tr></table></figure>

<h3 id="栈解退"><a href="#栈解退" class="headerlink" title="栈解退"></a>栈解退</h3><p>不同于函数调用和返回的过程(释放栈到第一个返回地址停止)，如果引发异常，程序一直释放栈直到第一个位于<code>try</code>块中的返回地址(块中函数的返回地址<code>;</code>)，然后程序转移到<code>catch</code>块而不是调用函数的下一条语句.</p>
<ol>
<li>引发异常时栈解退到能引发异常的地方；</li>
<li>和函数返回一样，栈中的自动类对象，类的析构函数将被调用；</li>
<li>如果返回到最近的<code>try</code>块但是没有异常匹配，那么会继续栈解退，直到最后的<code>try</code>块，不匹配再调用<code>abort()</code>； </li>
<li><code>catch</code>块使用<code>exit(EXIT_FAILURE)</code>立即终止程序，异常机制依然负责释放自动变量。</li>
</ol>
<h3 id="异常特性"><a href="#异常特性" class="headerlink" title="异常特性"></a>异常特性</h3><ol>
<li>如果返回到最近的<code>try</code>块但是没有异常匹配，那么会继续栈解退，直到最后的<code>try</code>块，不匹配再调用<code>abort()</code>；</li>
<li>引发异常时，编译器总会创建一个临时拷贝，即使异常规范和<code>catch</code>块中指定的是引用(这是作用域的问题)。</li>
<li><font color="red">有2的特性为什么还要使用引用？</font>这是因为基类引用可以引用派生类对象。因此在异常类继承层次结构中，更具体的异常类应该放在前边匹配(<code>catch</code>)，而在<code>throw</code>中，恰好相反(is-a关系，基类不是派生类，而派生类是基类)。</li>
</ol>
<p>捕获一切异常(与<code>switch</code>中的<code>default</code>相似)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (...)&#123;</span><br><span class="line">	...	<span class="comment">//statement</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="exception类"><a href="#exception类" class="headerlink" title="exception类"></a>exception类</h3><p><a href="http://www.cplusplus.com/reference/exception/exception/?kw=exception" target="_blank" rel="noopener">&lt; exception &gt;</a>头文件定义的<code>exception</code>类提供异常的语言支持(可以作为其他异常的基类)。</p>
<ol>
<li>公有虚成员函数<code>const char * what(){return &quot;Your own description&quot;}</code>，继承并隐藏后可以代替用字符串作为异常类型。</li>
</ol>
<p><a href="http://www.cplusplus.com/reference/stdexcept/?kw=stdexcept" target="_blank" rel="noopener">&lt; stdexcept &gt;</a>头文件从&lt; exception &gt;公有派生，定义了<code>logic_error</code>和<code>runtime_error</code>类。</p>
<ol>
<li>共7种异常类型(定义域错误，参数错误，空间不足，索引错误，范围溢出，上溢，下溢)，每个类有一个构造函数，提供方法<code>what()</code>返回的字符串。</li>
</ol>
<p><a href="http://www.cplusplus.com/reference/new/bad_alloc/" target="_blank" rel="noopener">&lt; new &gt;</a>头文件包含<code>bad_alloc</code>类的声明，从&lt; exception &gt;类公有派生而来，用来标识无法分配请求的内存量(new引发)。</p>
<ol>
<li>可以设计使<code>new</code>失败时返回空指针(这很合理)，C++提供了一种用法，指出不会抛出异常(用空指针代替)：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> (<span class="built_in">std</span>::nothrow) <span class="keyword">int</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="异常，类和继承"><a href="#异常，类和继承" class="headerlink" title="异常，类和继承"></a>异常，类和继承</h3><p>因为异常类也是类，所以可以继承，可以嵌套。</p>
<ol>
<li>从一个异常类中派生出另一个类；</li>
<li>在类定义中嵌套异常类声明来组合异常，被嵌套类的方法定义式需要使用多个作用域解析符；</li>
<li>嵌套的类(一般在类公有部分声明)本身可以被继承，可用作基类。</li>
</ol>
<h3 id="迷失方向的异常"><a href="#迷失方向的异常" class="headerlink" title="迷失方向的异常"></a>迷失方向的异常</h3><p>即对未捕获异常或者意外异常的反应。<br>引发异常后两种情况会导致问题：</p>
<ol>
<li>异常规范没有异常匹配导致程序异常终止；</li>
<li>异常不在函数中引发(或者函数没有异常规范)，必须捕获，否则也会异常终止。</li>
</ol>
<h4 id="未捕获异常"><a href="#未捕获异常" class="headerlink" title="未捕获异常"></a>未捕获异常</h4><p>程序意外终止时，不直接调用<code>abort()</code>函数，他通过<code>terminate()</code>函数调用<code>abort()</code>(默认)，因此可以修改<code>terminate()</code>调用的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myAbort</span><span class="params">()</span></span>&#123;</span><br><span class="line">	...;</span><br><span class="line">&#125;</span><br><span class="line">set_terminate(myAbort);</span><br></pre></td></tr></table></figure>

<h4 id="意外异常"><a href="#意外异常" class="headerlink" title="意外异常"></a>意外异常</h4><p>函数引发了异常规范中没有的异常。将调用<code>unexpected()</code>函数，这个函数调用<code>terminate()</code>(默认)，<code>terminate()</code>调用<code>abort()</code>,同理可修改这个默认值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myUnexpected</span><span class="params">()</span></span>&#123;	<span class="comment">//将意外异常转化为bad_exception</span></span><br><span class="line">	<span class="keyword">throw</span> bad_exception;	<span class="comment">//如果不指定抛出的异常，会重新引发原来的异常</span></span><br><span class="line">&#125;</span><br><span class="line">set_unexpected(myunexpected);</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>可能内存泄漏，栈解退对动态管理的内存是ok的,但是程序员管理的内存，解退时可能释放指针造成内存泄漏，有两个解决方案：</p>
<ol>
<li>在调用的函数中也使用异常机制，抓取所有异常来管理内存并抛出原本想抛出的异常(这是在原本的异常层次中强行植入一层来执行想要的操作，原本程序的代码顺序没有任何变化)；<ul>
<li>简单理解不同的地方，逻辑为，函数中有异常要先释放内存再抛出异常(那么不使用异常机制，在抛出异常前释放也ok?)。</li>
</ul>
</li>
<li>使用智能指针模板。</li>
</ol>

    
  </div>
</article>

</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/archives/"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/category/"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/about/"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/tag/"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/link/"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/project/"
              target="_self"
              >
              项目
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/search/"
              target="_self"
              >
              搜索
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    
  <section class="disqus-comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
  </section>

  <script>
    var disqus_shortname = 'rylcode';
    
    var disqus_url = 'applefishsky009.github.io/2016/06/27/异常/';
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>

  <script id="dsq-count-scr" src="//rylcode.disqus.com/count.js" async></script>



    




  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235687', function() {
      // load success
    });
  }
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
