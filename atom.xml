<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孤云两角，去天一握</title>
  <subtitle>山在地下，地山谦</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-04-15T09:33:24.810Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ryl</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vector之resize和reverse</title>
    <link href="http://yoursite.com/2016/04/15/vector%E4%B9%8Bresize%E5%92%8Creverse/"/>
    <id>http://yoursite.com/2016/04/15/vector之resize和reverse/</id>
    <published>2016-04-15T06:39:13.000Z</published>
    <updated>2016-04-15T09:33:24.810Z</updated>
    
    <content type="html">&lt;h2 id=&quot;a-resize-和a-reverse&quot;&gt;&lt;a href=&quot;#a-resize-和a-reverse&quot; class=&quot;headerlink&quot; title=&quot;a.resize()和a.reverse();&quot;&gt;&lt;/a&gt;a.resize()和a.reverse();&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;首先介绍容器的两个属性&lt;code&gt;capacity&lt;/code&gt;和&lt;code&gt;size&lt;/code&gt;。&lt;code&gt;capacity&lt;/code&gt;存储区的大小；&lt;code&gt;size&lt;/code&gt;容器的大小。&lt;/li&gt;
&lt;li&gt;‘reverse()’是预分配存储区的大小，预分配存储区，但存储区不一定有容器对象。&lt;/li&gt;
&lt;li&gt;‘resize()’是改变容器大小，容器中一定有容器对象。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&quot;a-reverse&quot;&gt;&lt;a href=&quot;#a-reverse&quot; class=&quot;headerlink&quot; title=&quot;a.reverse();&quot;&gt;&lt;/a&gt;a.reverse();&lt;/h3&gt;&lt;p&gt;看源码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void reserve(size_type _Count)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;	// determine new minimum length of allocated storage&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if (capacity() &amp;lt; _Count)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#123;// something to do, check and reallocate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if (max_size() &amp;lt; _Count)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			Xlen();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		_Reallocate(_Count);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;没有&lt;code&gt;else&lt;/code&gt;，说明若当前的&lt;code&gt;capacity&lt;/code&gt;大于传入的值，&lt;strong&gt;&lt;code&gt;capacity&lt;/code&gt;是不会减小的&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;里层的if是错误检测机制；&lt;/li&gt;
&lt;li&gt;验证&lt;code&gt;vector&lt;/code&gt;的&lt;code&gt;reallocate&lt;/code&gt;原理，实际上每次新的&lt;code&gt;capacity&lt;/code&gt;是之前的1.5倍。因此在&lt;strong&gt;循环之前一定要&lt;code&gt;reserve&lt;/code&gt;保证效率&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&quot;a-resize&quot;&gt;&lt;a href=&quot;#a-resize&quot; class=&quot;headerlink&quot; title=&quot;a.resize();&quot;&gt;&lt;/a&gt;a.resize();&lt;/h3&gt;&lt;p&gt;模板类提供了两个函数重载：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;表达式&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;strong&gt;返回类型&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;a.resize(n)&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;void&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;容器大小设为n&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;a.resize(n,t)&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;void&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;容器大小设为n，必要时用t填充&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&quot;a-resize-n&quot;&gt;&lt;a href=&quot;#a-resize-n&quot; class=&quot;headerlink&quot; title=&quot;a.resize(n)&quot;&gt;&lt;/a&gt;a.resize(n)&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void resize(size_type _Newsize)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;	// determine new length, padding as needed&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if (_Newsize &amp;lt; size())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		erase(begin() + _Newsize, end());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	else if (size() &amp;lt; _Newsize)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#123;	// pad as needed&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		_Alty _Alval(this-&amp;gt;_Getal());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		_Reserve(_Newsize - size());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		_TRY_BEGIN&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		_Uninitialized_default_fill_n(this-&amp;gt;_Mylast, _Newsize - size(),_Alval);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		_CATCH_ALL&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		_Tidy();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		_RERAISE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		_CATCH_END&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		this-&amp;gt;_Mylast += _Newsize - size();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;若容器新大小小于现在的大小，毁掉多余的对象；&lt;/li&gt;
&lt;li&gt;新大小大于现在的大小：&lt;ul&gt;
&lt;li&gt;注意&lt;code&gt;_Reserve&lt;/code&gt;和&lt;code&gt;.reverse&lt;/code&gt;是两个不同的方法，一个比较&lt;code&gt;capacity&lt;/code&gt;，一个比较&lt;code&gt;_Unused_capacity&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;检查空间，不够则&lt;code&gt;reverse&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;填充未初始化的对象&lt;/li&gt;
&lt;li&gt;修改尾指针&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;####a.resize(n,t)&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void resize(size_type _Newsize, const value_type&amp;amp; _Val)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;	// determine new length, padding with _Val elements as needed&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if (_Newsize &amp;lt; size())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		erase(begin() + _Newsize, end());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	else if (size() &amp;lt; _Newsize)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		_Insert_n(end(), _Newsize - size(), _Val);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若容器新大小小于现在的大小，毁掉多余的对象；&lt;/li&gt;
&lt;li&gt;新大小大于现在的大小，直接执行&lt;code&gt;insert&lt;/code&gt;;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;a-resize-和a-reverse&quot;&gt;&lt;a href=&quot;#a-resize-和a-reverse&quot; class=&quot;headerlink&quot; title=&quot;a.resize()和a.reverse();&quot;&gt;&lt;/a&gt;a.resize()和a.reverse();&lt;/
    
    </summary>
    
      <category term="STL-vector" scheme="http://yoursite.com/categories/STL-vector/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>vector之erase</title>
    <link href="http://yoursite.com/2016/04/14/vector%E4%B9%8Berase/"/>
    <id>http://yoursite.com/2016/04/14/vector之erase/</id>
    <published>2016-04-14T02:52:25.000Z</published>
    <updated>2016-04-15T09:33:24.809Z</updated>
    
    <content type="html">&lt;h2 id=&quot;a-erase&quot;&gt;&lt;a href=&quot;#a-erase&quot; class=&quot;headerlink&quot; title=&quot;a.erase();&quot;&gt;&lt;/a&gt;a.erase();&lt;/h2&gt;&lt;p&gt;模板类提供了两个函数重载：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;表达式&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;strong&gt;返回类型&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;a.erase(p)&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;strong&gt;迭代器&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;删除p指向的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;a.erase(p,q)&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;strong&gt;迭代器&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;删除区间[p,q)中的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;思考&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在之前内存之中讨论过，&lt;code&gt;vector&lt;/code&gt;是保证内存连续的，那么&lt;code&gt;erase&lt;/code&gt;之后他是如何保证内存连续的？答案是让该元素之后的所有元素前移补充“空位”。这一点在&lt;code&gt;erase()&lt;/code&gt;方法的代码中可以看到传入的p的形参是&lt;code&gt;const&lt;/code&gt;类型的，也就是说p指向的地址并不发生变化，只不过是元素前移了。测试如下：&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/TZxRRb6.png&quot; alt=&quot;STL的迭代器&quot;&gt;&lt;/li&gt;
&lt;li&gt;注意到&lt;code&gt;erase&lt;/code&gt;返回的都是迭代器，由1中的分析可知，删除p指向的元素之后，他返回的迭代器的&lt;strong&gt;地址不变&lt;/strong&gt;，值是删除之后可用的下一个元素，因此&lt;strong&gt;给人感觉是p指向了下一个元素&lt;/strong&gt;。那么在这里有一个值得注意的问题，如下：&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vector&amp;lt;int&amp;gt;::iterator p = b.begin();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for (;p!=b.end();p++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if (*p == 2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		b.erase(p);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这是错误的，&lt;code&gt;b.erase(p)&lt;/code&gt;没有迭代器来承接p的返回值，它的返回值被释放了。然后执行p++很显然会出现野指针。但是如果修改为&lt;code&gt;p = b.erase(p)&lt;/code&gt;也是不正确的。迭代器在进行删除的这一个循环里会&lt;code&gt;++&lt;/code&gt;两次（&lt;code&gt;erase&lt;/code&gt;可以当做&lt;code&gt;++&lt;/code&gt;一次）。但如果在&lt;code&gt;if&lt;/code&gt;语句中执行一次&lt;code&gt;p--&lt;/code&gt;，这是正确的。即&lt;code&gt;p = b.erase(p--);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;迭代器的循环使用&lt;code&gt;while&lt;/code&gt;可以降低错误率。&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;为简单，分析第一个表达式的源码如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;iterator erase(const_iterator _Where)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;	// erase element at where&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if (_VICONT(_Where) != this&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		|| _VIPTR(_Where) &amp;lt; this-&amp;gt;_Myfirst&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		|| this-&amp;gt;_Mylast &amp;lt;= _VIPTR(_Where))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		_DEBUG_ERROR(&amp;quot;vector erase iterator outside range&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	_Move(_VIPTR(_Where) + 1, this-&amp;gt;_Mylast, _VIPTR(_Where));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	_Destroy(this-&amp;gt;_Mylast - 1, this-&amp;gt;_Mylast);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	_Orphan_range(_VIPTR(_Where), this-&amp;gt;_Mylast);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	--this-&amp;gt;_Mylast;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return (_Make_iter(_Where));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以看到他做了哪些工作,首先元素前移，然后毁掉最后一个对象(&lt;code&gt;capacity&lt;/code&gt;不变)，之后&lt;font color=&quot;red&quot;&gt;_Orphan_range发生了什么？&lt;/font&gt;,接下来指针指向正确的位置，最后返回指向原地址的迭代器。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;a-erase&quot;&gt;&lt;a href=&quot;#a-erase&quot; class=&quot;headerlink&quot; title=&quot;a.erase();&quot;&gt;&lt;/a&gt;a.erase();&lt;/h2&gt;&lt;p&gt;模板类提供了两个函数重载：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th s
    
    </summary>
    
      <category term="STL-vector" scheme="http://yoursite.com/categories/STL-vector/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>vector之insert和emplace</title>
    <link href="http://yoursite.com/2016/04/13/vector%E4%B9%8Binsert%E5%92%8Cemplace/"/>
    <id>http://yoursite.com/2016/04/13/vector之insert和emplace/</id>
    <published>2016-04-13T12:39:29.000Z</published>
    <updated>2016-04-15T08:42:26.084Z</updated>
    
    <content type="html">&lt;h2 id=&quot;a-insert&quot;&gt;&lt;a href=&quot;#a-insert&quot; class=&quot;headerlink&quot; title=&quot;a.insert();&quot;&gt;&lt;/a&gt;a.insert();&lt;/h2&gt;&lt;p&gt;模板类提供了三个函数重载,这是一种&lt;strong&gt;拷贝&lt;/strong&gt;插入方法：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;表达式&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;返回类型&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;a.insert(p,t)&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;迭代器&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;指向原本指向的元素,将t插入到p前面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;a.insert(p, n,t)&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将n个t插入到p前面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;a.insert(p,i,j)&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将区间[i,j)插入到p的前面，注意是左闭右开区间，j可以是超尾&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&quot;a-emplace&quot;&gt;&lt;a href=&quot;#a-emplace&quot; class=&quot;headerlink&quot; title=&quot;a.emplace();&quot;&gt;&lt;/a&gt;a.emplace();&lt;/h2&gt;&lt;p&gt;新标准引入的&lt;code&gt;emplace_front&lt;/code&gt;,&lt;code&gt;emplace&lt;/code&gt;,&lt;code&gt;emplace_back&lt;/code&gt;这些操作是构造而不是拷贝元素。当插入一个对象时，将会比&lt;code&gt;insert&lt;/code&gt;少拷贝构造，析构的步骤。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;注：&quot;&gt;&lt;a href=&quot;#注：&quot; class=&quot;headerlink&quot; title=&quot;注：&quot;&gt;&lt;/a&gt;注：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;调用&lt;code&gt;push&lt;/code&gt;或&lt;code&gt;insert&lt;/code&gt;成员函数，将元素类型对象传递进去，这些对象被拷贝到容器中；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;emplace()&lt;/code&gt;在容器中构造元素，因此效率更高；&lt;/li&gt;
&lt;li&gt;注意&lt;code&gt;a.insert(p,t)&lt;/code&gt;的源码提供了一个重载，若t是普通类型，则调用&lt;code&gt;a.emplace(p，t)&lt;/code&gt;，若t是&lt;code&gt;const&lt;/code&gt;类型，则调用&lt;code&gt;a.insert(p,t)&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;a-insert&quot;&gt;&lt;a href=&quot;#a-insert&quot; class=&quot;headerlink&quot; title=&quot;a.insert();&quot;&gt;&lt;/a&gt;a.insert();&lt;/h2&gt;&lt;p&gt;模板类提供了三个函数重载,这是一种&lt;strong&gt;拷贝&lt;/strong&gt;插入方法
    
    </summary>
    
      <category term="STL-vector" scheme="http://yoursite.com/categories/STL-vector/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>vector简介及非STL函数用法-持续更新</title>
    <link href="http://yoursite.com/2016/04/13/vector%E7%AE%80%E4%BB%8B%E5%8F%8A%E9%9D%9ESTL%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <id>http://yoursite.com/2016/04/13/vector简介及非STL函数用法-持续更新/</id>
    <published>2016-04-13T06:54:50.000Z</published>
    <updated>2016-04-15T09:36:30.853Z</updated>
    
    <content type="html">&lt;h2 id=&quot;vector&quot;&gt;&lt;a href=&quot;#vector&quot; class=&quot;headerlink&quot; title=&quot;vector&quot;&gt;&lt;/a&gt;vector&lt;/h2&gt;&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;模板类是最简单的序列类型，除非其他类型的特殊有点能够满足程序的要求，否则应该默认使用这种类型。以后将记录一些在编程过程中常用的&lt;code&gt;vector&lt;/code&gt;方法作为笔记以便不时复习，必要时会分析源码。&lt;/p&gt;
&lt;p&gt;常见的方法有：&lt;br&gt;&lt;code&gt;.insert()&lt;/code&gt;，&lt;code&gt;a.emplace()&lt;/code&gt;，&lt;code&gt;.resize()&lt;/code&gt;，&lt;code&gt;.reverse()&lt;/code&gt;，&lt;code&gt;.begin()&lt;/code&gt;，&lt;code&gt;a.end()&lt;/code&gt;，&lt;br&gt;&lt;code&gt;a.rbegin()&lt;/code&gt;，&lt;code&gt;a.rend()&lt;/code&gt;，&lt;code&gt;a.size()&lt;/code&gt;，&lt;code&gt;a.swap(b)&lt;/code&gt;，&lt;code&gt;a.empty()&lt;/code&gt;，&lt;code&gt;a.front()&lt;/code&gt;，&lt;br&gt;&lt;code&gt;a.back()&lt;/code&gt;，&lt;code&gt;a.clear()&lt;/code&gt;，&lt;code&gt;a.push_back(t)&lt;/code&gt;，&lt;code&gt;a.popback(t)&lt;/code&gt;，&lt;code&gt;a[n]&lt;/code&gt;，&lt;code&gt;a.at(n)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;有&lt;code&gt;vector&amp;lt;int&amp;gt; a&lt;/code&gt;;&lt;code&gt;vector&amp;lt;int&amp;gt; b&lt;/code&gt;;即a,b是&lt;code&gt;vector&amp;lt;int&amp;gt;&lt;/code&gt;的对象。&lt;code&gt;vector&amp;lt;int&amp;gt; ::iterator p&lt;/code&gt;;p是指向&lt;code&gt;vector&amp;lt;int&amp;gt;&lt;/code&gt;的迭代器。i、j、q均和p一样是指向&lt;code&gt;vector&amp;lt;int&amp;gt;&lt;/code&gt;的迭代器。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;sort-用于vector&quot;&gt;&lt;a href=&quot;#sort-用于vector&quot; class=&quot;headerlink&quot; title=&quot;sort()用于vector;&quot;&gt;&lt;/a&gt;sort()用于vector;&lt;/h2&gt;&lt;p&gt;在&lt;code&gt;algorithm&amp;gt;&lt;/code&gt;头文件中提供了&lt;code&gt;sort&lt;/code&gt;的两个重载函数,查看源码可发现是用&lt;strong&gt;快排&lt;/strong&gt;实现的。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;表达式&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;strong&gt;返回类型&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;sort(p,q)&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;对[p,q)升序排序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;sort(p,q,cmp)&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;对[p,q)使用&lt;code&gt;cmp&lt;/code&gt;方法排序，&lt;code&gt;cmp&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol&gt;
&lt;li&gt;右闭左开区间，一般来讲&lt;code&gt;p = a.begin()&lt;/code&gt;;&lt;code&gt;q = a.end()&lt;/code&gt;完成了对容器的排序。&lt;/li&gt;
&lt;li&gt;升序排序直接用第一个方法，系统默认&lt;code&gt;a&amp;lt;b&lt;/code&gt;返回真，因此是升序。&lt;/li&gt;
&lt;li&gt;降序排序需要自定义&lt;code&gt;cmp&lt;/code&gt;方法,方法如下，只需要将默认值改为&lt;code&gt;a&amp;gt;b&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bool comp(const int &amp;amp;a,const int &amp;amp;b)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  		return a&amp;gt;b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;以上参考了&lt;a href=&quot;http://www.cnblogs.com/cj695/p/3863142.html&quot; title=&quot;这里&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;vector&quot;&gt;&lt;a href=&quot;#vector&quot; class=&quot;headerlink&quot; title=&quot;vector&quot;&gt;&lt;/a&gt;vector&lt;/h2&gt;&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;模板类是最简单的序列类型，除非其他类型的特殊有点能够满足程序的要求，否
    
    </summary>
    
      <category term="STL-vector" scheme="http://yoursite.com/categories/STL-vector/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++类的this指针</title>
    <link href="http://yoursite.com/2016/04/12/C++%E7%B1%BB%E7%9A%84this%E6%8C%87%E9%92%88/"/>
    <id>http://yoursite.com/2016/04/12/C++类的this指针/</id>
    <published>2016-04-12T01:08:44.000Z</published>
    <updated>2016-04-15T01:48:02.149Z</updated>
    
    <content type="html">&lt;h2 id=&quot;C-类的this指针&quot;&gt;&lt;a href=&quot;#C-类的this指针&quot; class=&quot;headerlink&quot; title=&quot;C++类的this指针&quot;&gt;&lt;/a&gt;C++类的this指针&lt;/h2&gt;&lt;p&gt;如图，假设有一个类&lt;code&gt;Stock&lt;/code&gt;，他有一个&lt;code&gt;private：int val&lt;/code&gt;。他还有一个方法&lt;code&gt;const Stock&amp;amp; Stock::compare(const Stock &amp;amp;classIn) const&lt;/code&gt;;这个方法要实现这样的功能：对于两个类&lt;code&gt;Stock&lt;/code&gt;的对象a和b，比较a的&lt;code&gt;val&lt;/code&gt;和b的&lt;code&gt;val&lt;/code&gt;，返回&lt;code&gt;val&lt;/code&gt;大的对象(a或者b)，可能性的写法如下：&lt;code&gt;a.compare(b)&lt;/code&gt;。由于在类的方法定义中，还没有具体对象(a)。那么有这样一个问题，在方法&lt;code&gt;compare&lt;/code&gt;中，如何返回以后才初始化的对象本身(也就是a)？&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/qChOATG.png&quot; alt=&quot;为什么使用this指针&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一般来说，所有类方法都将&lt;code&gt;this&lt;/code&gt;指针设置为调用它的&lt;strong&gt;地址&lt;/strong&gt;。(因此返回对象使用&lt;strong&gt;&lt;code&gt;*this&lt;/code&gt;&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compare&lt;/code&gt;方法返回类型是指针意味着返回的是调用对象本身，而不是其副本。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compare&lt;/code&gt;方法的最后一个&lt;code&gt;const&lt;/code&gt;表示该方法不会修改隐式访问对象(即调用该方法的对象本身)，这在之前的博客中提到过。&lt;/li&gt;
&lt;li&gt;形参列表中的&lt;code&gt;const&lt;/code&gt;表示该函数不会修改被显示访问的对象(即图中的s)。&lt;/li&gt;
&lt;li&gt;由于该函数返回了两个&lt;code&gt;const&lt;/code&gt;对象之一的引用，因此&lt;strong&gt;返回类型也应该是&lt;code&gt;const&lt;/code&gt;引用&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/CzuJ4fG.png&quot; alt=&quot;this的实例&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;C-类的this指针&quot;&gt;&lt;a href=&quot;#C-类的this指针&quot; class=&quot;headerlink&quot; title=&quot;C++类的this指针&quot;&gt;&lt;/a&gt;C++类的this指针&lt;/h2&gt;&lt;p&gt;如图，假设有一个类&lt;code&gt;Stock&lt;/code&gt;，他有一个&lt;cod
    
    </summary>
    
      <category term="类" scheme="http://yoursite.com/categories/%E7%B1%BB/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++溢出</title>
    <link href="http://yoursite.com/2016/04/11/C++%E6%BA%A2%E5%87%BA/"/>
    <id>http://yoursite.com/2016/04/11/C++溢出/</id>
    <published>2016-04-11T12:35:24.000Z</published>
    <updated>2016-04-15T01:42:43.660Z</updated>
    
    <content type="html">&lt;h2 id=&quot;数值溢出原理&quot;&gt;&lt;a href=&quot;#数值溢出原理&quot; class=&quot;headerlink&quot; title=&quot;数值溢出原理&quot;&gt;&lt;/a&gt;数值溢出原理&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/W3CYdOb.png&quot; alt=&quot;数值圆图&quot;&gt;&lt;br&gt;C++Plus在P44已经说的很清楚，如下。&lt;br&gt;有几点需要注意的地方：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;上图下图中的圆在进行&lt;strong&gt;强制类型转化&lt;/strong&gt;时也是&lt;strong&gt;对应&lt;/strong&gt;的，这就是说&lt;code&gt;(uchar)-1 = 65535&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;无符号数没有溢出，只有&lt;strong&gt;进/借位&lt;/strong&gt;(微机原理&lt;code&gt;CF&lt;/code&gt;标示)，因为C++确保无符号数类型超越限制后在另一极端取值的行为。&lt;/li&gt;
&lt;li&gt;有符号数没有进/借位，只有&lt;strong&gt;溢出&lt;/strong&gt;(微机原理&lt;code&gt;OF&lt;/code&gt;标示)，因为C++无法确保有符号数上溢下溢后在另一极端取值的行为。(在我测试的时候并没有发现违背这一现象，可能有特殊情况)。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;运算溢出&quot;&gt;&lt;a href=&quot;#运算溢出&quot; class=&quot;headerlink&quot; title=&quot;运算溢出&quot;&gt;&lt;/a&gt;运算溢出&lt;/h2&gt;&lt;h3 id=&quot;判断加法溢出&quot;&gt;&lt;a href=&quot;#判断加法溢出&quot; class=&quot;headerlink&quot; title=&quot;判断加法溢出&quot;&gt;&lt;/a&gt;判断加法溢出&lt;/h3&gt;&lt;p&gt;可以像这里一样分情况或者根据圆图分析，会发现&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;所有上溢结果都小于任何一个操作数；&lt;/li&gt;
&lt;li&gt;所有下溢结果都大于任何一个操作数。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;判断乘法溢出&quot;&gt;&lt;a href=&quot;#判断乘法溢出&quot; class=&quot;headerlink&quot; title=&quot;判断乘法溢出&quot;&gt;&lt;/a&gt;判断乘法溢出&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;在这里提到，可以用检测&lt;code&gt;a*b/b&lt;/code&gt;是否等于a来判断是否乘法溢出；&lt;/li&gt;
&lt;li&gt;在这里提到，可以先扩展再强制类型转化到低位，在判断是否相等来判断。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;值得注意的是，在之前的帖子中提到过判断是否相等对&lt;strong&gt;浮点数&lt;/strong&gt;和整型的判断方式是不一样的。&lt;/p&gt;
&lt;h3 id=&quot;除零是不是溢出？&quot;&gt;&lt;a href=&quot;#除零是不是溢出？&quot; class=&quot;headerlink&quot; title=&quot;除零是不是溢出？&quot;&gt;&lt;/a&gt;除零是不是溢出？&lt;/h3&gt;&lt;p&gt;任何数除以零的计算“不是”算术溢出的一种。在数学上只能明显算是不明确的定义；它计算出来的结果只能当成是“没有”值，而不是非常大的无限数值。&lt;/p&gt;
&lt;p&gt;应付溢出最佳的方法还是防范，充分了解数据类型，选择恰当的变量类型。比如，&lt;code&gt;c = a*b&lt;/code&gt;一般都会选择c的长度为a的长度与b的长度之和。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;堆栈溢出&quot;&gt;&lt;a href=&quot;#堆栈溢出&quot; class=&quot;headerlink&quot; title=&quot;堆栈溢出&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%A0%86%E7%96%8A%E6%BA%A2%E4%BD%8D&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;堆栈溢出&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;一般编译器默认的堆栈内存是1MB，若使用过多的堆栈内存时就会导致调用堆栈产生的溢出。一般产生于递归，或者静态申请过多的临时变量，比如&lt;code&gt;int a[1024[1024]&lt;/code&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若是静态内存导致的堆栈溢出，可以用动态申请使用堆内存。&lt;/li&gt;
&lt;li&gt;若是递归调用导致递归堆栈无法容纳调用的返回地址，要添加错误检查机制。注意数据类型或用循环处理来避免堆栈溢出。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;缓冲区溢出&quot;&gt;&lt;a href=&quot;#缓冲区溢出&quot; class=&quot;headerlink&quot; title=&quot;缓冲区溢出&quot;&gt;&lt;/a&gt;缓冲区溢出&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://jingyan.baidu.com/article/e9fb46e1acc1267521f76633.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;缓冲区溢出&lt;/a&gt;源于这样一个编程错误：复制一个内存区域的内容到另一个内存区域，而目标内存区域容量太小无法容纳。它允许传入函数的内存块以一种特定方式修改堆栈。&lt;/p&gt;
&lt;p&gt;此外的溢出还包括&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%AE%97%E6%9C%AF%E4%B8%8B%E6%BA%A2&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;算术下溢&lt;/a&gt;(浮点数溢出)等。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数值溢出原理&quot;&gt;&lt;a href=&quot;#数值溢出原理&quot; class=&quot;headerlink&quot; title=&quot;数值溢出原理&quot;&gt;&lt;/a&gt;数值溢出原理&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/W3CYdOb.png&quot; alt=&quot;数值圆图&quot;&gt;&lt;
    
    </summary>
    
      <category term="溢出" scheme="http://yoursite.com/categories/%E6%BA%A2%E5%87%BA/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据存储与二进制运算</title>
    <link href="http://yoursite.com/2016/04/09/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BF%90%E7%AE%97/"/>
    <id>http://yoursite.com/2016/04/09/数据存储与二进制运算/</id>
    <published>2016-04-09T12:07:02.000Z</published>
    <updated>2016-04-15T06:59:46.184Z</updated>
    
    <content type="html">&lt;h2 id=&quot;数据存储&quot;&gt;&lt;a href=&quot;#数据存储&quot; class=&quot;headerlink&quot; title=&quot;数据存储&quot;&gt;&lt;/a&gt;数据存储&lt;/h2&gt;&lt;h3 id=&quot;原、反、补码&quot;&gt;&lt;a href=&quot;#原、反、补码&quot; class=&quot;headerlink&quot; title=&quot;原、反、补码&quot;&gt;&lt;/a&gt;原、反、补码&lt;/h3&gt;&lt;p&gt;计算机为方便计算，内存中的数据都是以补码的形式储存、运算。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;数&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;原码&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;反码&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;补码&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;正数&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;二进制表示&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;与原码相同&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;与原码相同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;负数&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;对应正数符号位（最高位）置1&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;负数原码&lt;strong&gt;非符号位&lt;/strong&gt;按位取反&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;负数反码加1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;举个例子，数据类型为&lt;code&gt;char&lt;/code&gt;：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;原数字&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;原码&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;反码&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;补码&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;+3&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;00000011&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;00000011&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;00000011&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;-3&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;10000011&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;11111100&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;11111101&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;值得注意的是，如果这个数据为&lt;code&gt;unsigned char&lt;/code&gt;，&lt;code&gt;11111101&lt;/code&gt;对应的是253，这里涉及到溢出，详细讨论见下一博客。&lt;/p&gt;
&lt;h3 id=&quot;消失的原码&quot;&gt;&lt;a href=&quot;#消失的原码&quot; class=&quot;headerlink&quot; title=&quot;消失的原码&quot;&gt;&lt;/a&gt;消失的原码&lt;/h3&gt;&lt;p&gt;对于&lt;code&gt;unsigned char&lt;/code&gt;原反补相同，计算机存储的补码就是原码，原码二进制经典编码有256个；但是对于&lt;code&gt;signed char&lt;/code&gt;，最高位是符号位，因此原码的取值范围是-127-127，只有&lt;strong&gt;255个编码&lt;/strong&gt;，但是对内存来说，8bits可以编码256个，那多余的补码与消失的原码去了哪里？&lt;/p&gt;
&lt;p&gt;考虑到编码效率，补码与原码必须是一一对应的关系。很容易想到在有符号数中有&lt;code&gt;00000000&lt;/code&gt;、&lt;code&gt;10000000&lt;/code&gt;两个原码表示+0与-0，而这是没有意义的。我们保证&lt;code&gt;00000000&lt;/code&gt;这个原码与&lt;code&gt;00000000&lt;/code&gt;这个补码相对应来表示0就可以。这样找到了消失的原码：&lt;code&gt;10000000&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在这个基于256的数值域中，观察补码的&lt;strong&gt;重置点（溢出中非常重要的概念）&lt;/strong&gt;127的补码&lt;code&gt;01111111&lt;/code&gt;，-127的补码&lt;code&gt;10000001&lt;/code&gt;，那么可以清楚的看到&lt;code&gt;127+1=？&lt;/code&gt;、&lt;code&gt;？+1=127&lt;/code&gt;。因此很好理解，多余的补码是&lt;code&gt;10000000&lt;/code&gt;（与消失的原码相同，通过计算他的原码可以得到验证）。那么剩下的事情就是设置重置点了，有两个选择，128或者-128。考虑到符号位是1，我们人为规定-128是重置点。即&lt;strong&gt;-128的原码&lt;/strong&gt;是&lt;code&gt;10000000&lt;/code&gt;，&lt;strong&gt;补码&lt;/strong&gt;也是&lt;code&gt;10000000&lt;/code&gt;（它的&lt;strong&gt;反码&lt;/strong&gt;是&lt;code&gt;11111111&lt;/code&gt;？）。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;二进制运算（移位得到CHAR-MAX和CHAR-MIN）&quot;&gt;&lt;a href=&quot;#二进制运算（移位得到CHAR-MAX和CHAR-MIN）&quot; class=&quot;headerlink&quot; title=&quot;二进制运算（移位得到CHAR_MAX和CHAR_MIN）&quot;&gt;&lt;/a&gt;二进制运算（移位得到CHAR_MAX和CHAR_MIN）&lt;/h2&gt;&lt;p&gt;明白上述数据存储概念之后，可以通过位运算来获得&lt;code&gt;char&lt;/code&gt;的最大最小值。注意，其实在&lt;code&gt;climit&lt;/code&gt;文件中有各种宏定义的最大最小值，比如&lt;code&gt;CHAR_MAX = 127&lt;/code&gt;;&lt;code&gt;UCHAR_MAX = 0xff&lt;/code&gt;;等。但是这里想利用位运算来实现这一目标(注意重置点)：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;CHAR_MAX&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;CHAR_MIN&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;unsigned char max = 0-1&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;unsigned char min = 0&lt;/code&gt;;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;char max = (1&amp;lt;&amp;lt;7)-1&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;char min = 1&amp;lt;&amp;lt;7&lt;/code&gt;(得到&lt;code&gt;10000000&lt;/code&gt;);&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol&gt;
&lt;li&gt;上述表格中&lt;code&gt;unsigned char max&lt;/code&gt;本质为&lt;code&gt;signed char = -1&lt;/code&gt;的强制类型转化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;char max&lt;/code&gt; 是利用重置点&lt;code&gt;CHAR_MIN&lt;/code&gt;得到&lt;code&gt;01111111&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;char min&lt;/code&gt; 是利用-128的特殊补码(而且与原码相同)赋值的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt;、&lt;code&gt;-&lt;/code&gt;运算的优先级是高于&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;、&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;的，因此&lt;code&gt;1&amp;lt;&amp;lt;7&lt;/code&gt;要加括号&lt;br&gt;注意右值中运算表达式中的数字默认都是&lt;code&gt;int&lt;/code&gt;类型的，这与C++整型提升有关，详情见另一篇博客。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另，由以上解读可以很容易的得出&lt;code&gt;abs(int_X)&lt;/code&gt;的工作原理，正数不变，负数求得原码后符号位取反，即原码也是补码。但是有&lt;strong&gt;例外&lt;/strong&gt;：&lt;code&gt;abs(INT_MIN) = INT_MIN&lt;/code&gt;。他是不变的。&lt;/p&gt;
&lt;p&gt;解读下边两式的区别（使用中&lt;code&gt;unsigned&lt;/code&gt;与&lt;code&gt;signed&lt;/code&gt;操作注意符号位扩充）：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;code&gt;char a = abs((char)(1&amp;lt;&amp;lt;7)-1)&lt;/code&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;code&gt;char b = abs((1&amp;lt;&amp;lt;7)-1)&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;(char)(1&amp;lt;&amp;lt;7)-1 = (int)-129&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;(1&amp;lt;&amp;lt;7)-1 = (int)127&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;1·&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;2·&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;a = -127&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;b = 127&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;11111111 11111111 11111111 10000000&lt;/code&gt;+&lt;code&gt;11111111 11111111 11111111 11111111&lt;/code&gt;=&lt;code&gt;11111111 11111111 11111111 01111111&lt;/code&gt;(&lt;code&gt;char&lt;/code&gt; 原码&lt;code&gt;10000001&lt;/code&gt;)    &lt;/li&gt;
&lt;li&gt;&lt;code&gt;00000000 00000000 00000000 1000000&lt;/code&gt;-&lt;code&gt;00000000 00000000 00000000 0000001&lt;/code&gt;=&lt;code&gt;00000000 00000000 00000000 01111111&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据存储&quot;&gt;&lt;a href=&quot;#数据存储&quot; class=&quot;headerlink&quot; title=&quot;数据存储&quot;&gt;&lt;/a&gt;数据存储&lt;/h2&gt;&lt;h3 id=&quot;原、反、补码&quot;&gt;&lt;a href=&quot;#原、反、补码&quot; class=&quot;headerlink&quot; title=&quot;原、反、补
    
    </summary>
    
      <category term="存储" scheme="http://yoursite.com/categories/%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>leetcode第一章：编程技巧说明</title>
    <link href="http://yoursite.com/2016/04/08/leetcode%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%E8%AF%B4%E6%98%8E/"/>
    <id>http://yoursite.com/2016/04/08/leetcode第一章：编程技巧说明/</id>
    <published>2016-04-08T11:44:02.000Z</published>
    <updated>2016-04-15T01:42:20.311Z</updated>
    
    <content type="html">&lt;h2 id=&quot;判断两个值a-b是否相等&quot;&gt;&lt;a href=&quot;#判断两个值a-b是否相等&quot; class=&quot;headerlink&quot; title=&quot;判断两个值a,b是否相等&quot;&gt;&lt;/a&gt;判断两个值a,b是否相等&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;若为整型，应该为&lt;code&gt;a==b&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;若为浮点型，应该用&lt;code&gt;fabs(a-b)&amp;lt;1e-9&lt;/code&gt;。(因为&lt;a href=&quot;http://0.30000000000000004.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;计算机中浮点型是不准确的&lt;/a&gt;，&lt;strong&gt;与因数有关&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;另外，对于&lt;code&gt;bool&lt;/code&gt;型，应该用&lt;code&gt;if(a)&lt;/code&gt;，&lt;code&gt;if(!b)&lt;/code&gt;这样的形式来强调变量&lt;code&gt;bool&lt;/code&gt;类型。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;判断一个整数是否为奇数&quot;&gt;&lt;a href=&quot;#判断一个整数是否为奇数&quot; class=&quot;headerlink&quot; title=&quot;判断一个整数是否为奇数&quot;&gt;&lt;/a&gt;判断一个整数是否为奇数&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;x%2 != 0&lt;/code&gt;用来判断一个整数是否是奇数，&lt;strong&gt;不能用&lt;code&gt;x%2 = 1&lt;/code&gt;&lt;/strong&gt;，因为x可能是负数，余数就是-1。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-3 = 2*-1+(-1)&lt;/code&gt;，即&lt;code&gt;-3/2 = -1&lt;/code&gt;;&lt;code&gt;-3%2= -1&lt;/code&gt;;说明负奇数余数是-1。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;char值做数组下标的强制类型转化&quot;&gt;&lt;a href=&quot;#char值做数组下标的强制类型转化&quot; class=&quot;headerlink&quot; title=&quot;char值做数组下标的强制类型转化&quot;&gt;&lt;/a&gt;char值做数组下标的强制类型转化&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;应该强制转化为&lt;code&gt;uchar&lt;/code&gt;，作为数组下标。不能直接转化为&lt;code&gt;uint&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;因为高位扩充有两种，有符号数扩充，在高位补符号位；无符号数高位直接用0。例如&lt;code&gt;char c = -1&lt;/code&gt;。c在计算机中的补码是&lt;code&gt;11111111&lt;/code&gt;。&lt;code&gt;uint a = c&lt;/code&gt;，那么&lt;code&gt;a = 4294967295&lt;/code&gt;。因为c有符号，扩充后高位补1。&lt;code&gt;uint b = (uchar) c&lt;/code&gt;。那么&lt;code&gt;b = 255&lt;/code&gt;。因为&lt;code&gt;(uchar) c&lt;/code&gt;是无符号数，高位用0扩充。&lt;/li&gt;
&lt;li&gt;二进制中有符号向无符号数的强制转化非常简单，将&lt;strong&gt;符号位置为0&lt;/strong&gt;。比如-2，原码是&lt;code&gt;10000010&lt;/code&gt;，反码是&lt;code&gt;11111101&lt;/code&gt;，补码是&lt;code&gt;11111110&lt;/code&gt;。将符号位置0，得到&lt;code&gt;01111110&lt;/code&gt;，为254。即&lt;code&gt;char -2&lt;/code&gt;强制转化成&lt;code&gt;uchar&lt;/code&gt;值为254。&lt;/li&gt;
&lt;li&gt;参照维基百科和C++plusP44&lt;strong&gt;圆图&lt;/strong&gt;可以更清楚了解更多数据储存与二进制运算。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;vector和string优先于动态数组的分配&quot;&gt;&lt;a href=&quot;#vector和string优先于动态数组的分配&quot; class=&quot;headerlink&quot; title=&quot;vector和string优先于动态数组的分配&quot;&gt;&lt;/a&gt;vector和string优先于动态数组的分配&lt;/h2&gt;&lt;p&gt;性能上，&lt;code&gt;vector&lt;/code&gt;保证内存（分配在堆）连续，一旦分配后，性能和原始数组相当；&lt;br&gt;用&lt;code&gt;new&lt;/code&gt;必须&lt;code&gt;delete&lt;/code&gt;，不然会&lt;code&gt;bug&lt;/code&gt;，代码行数不够短；&lt;br&gt;多维数组定义方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;new/delete&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int** array = new int*[row];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for(int i=0;i&amp;lt;row;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	array[i] = new int [col];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;:    &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; = array(row,vector&amp;lt;int&amp;gt;(col,0));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;使用reverse来避免不必要的重新分配&quot;&gt;&lt;a href=&quot;#使用reverse来避免不必要的重新分配&quot; class=&quot;headerlink&quot; title=&quot;使用reverse来避免不必要的重新分配&quot;&gt;&lt;/a&gt;使用reverse来避免&lt;a href=&quot;http://blog.csdn.net/bichenggui/article/details/4690175&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;不必要的重新分配&lt;/a&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;vector&lt;/code&gt;需要更多空间，以类似&lt;code&gt;realloc&lt;/code&gt;的思想来增长大小。分配，回收，拷贝和析构，这些步骤都很昂贵。并且每次这些步骤发生时，所有指向&lt;code&gt;vector&lt;/code&gt;或&lt;code&gt;string&lt;/code&gt;中的迭代器、指针和引用都会失效。&lt;/li&gt;
&lt;li&gt;据博客中所说，vector重新分配时容量翻倍。我在VS2012，WIN32编译器下结果如下，容量是翻&lt;em&gt;1.5&lt;/em&gt;倍的。因此在1000次&lt;code&gt;push_back&lt;/code&gt;中导致了18次重新分配。&lt;img src=&quot;http://i.imgur.com/ooqb6by.png&quot; alt=&quot;reverse()&quot;&gt;&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;容器被构造之后&lt;/strong&gt;进行&lt;strong&gt;&lt;code&gt;reserve&lt;/code&gt;设置容器容量&lt;/strong&gt;可以避免不必要的重新分配。&lt;code&gt;a.reserve(1000)&lt;/code&gt;即把a的容量设置为1000。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;判断两个值a-b是否相等&quot;&gt;&lt;a href=&quot;#判断两个值a-b是否相等&quot; class=&quot;headerlink&quot; title=&quot;判断两个值a,b是否相等&quot;&gt;&lt;/a&gt;判断两个值a,b是否相等&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;若为整型，应该为&lt;code&gt;a==b&lt;/code
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>类的构造函数与析构函数初探</title>
    <link href="http://yoursite.com/2016/04/07/%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%88%9D%E6%8E%A2/"/>
    <id>http://yoursite.com/2016/04/07/类的构造函数与析构函数初探/</id>
    <published>2016-04-07T11:03:11.000Z</published>
    <updated>2016-04-15T01:35:53.665Z</updated>
    
    <content type="html">&lt;h2 id=&quot;类的简介&quot;&gt;&lt;a href=&quot;#类的简介&quot; class=&quot;headerlink&quot; title=&quot;类的简介&quot;&gt;&lt;/a&gt;类的简介&lt;/h2&gt;&lt;h3 id=&quot;类的规范由两部分组成：&quot;&gt;&lt;a href=&quot;#类的规范由两部分组成：&quot; class=&quot;headerlink&quot; title=&quot;类的规范由两部分组成：&quot;&gt;&lt;/a&gt;类的规范由两部分组成：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;类声明（declaration） – 类的蓝图&lt;ul&gt;
&lt;li&gt;以数据成员的方式描述数据，以成员函数的方式描述公有接口；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据&lt;/strong&gt;通常放在私有部分，组成类接口的&lt;strong&gt;成员函数&lt;/strong&gt;放在公有部分，另外&lt;strong&gt;私有成员函数&lt;/strong&gt;用来处理不属于公有接口的实现细节。&lt;/li&gt;
&lt;li&gt;定义位于声明中的函数都将自动成为内联函数，若定义位于声明之外，使用&lt;code&gt;inline&lt;/code&gt;关键字成为内联函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;类方法定义 – 类的实现细节&lt;ul&gt;
&lt;li&gt;C++通常把接口（类声明）放在头文件中，并将实现（类方法代码）放在源代码中；&lt;/li&gt;
&lt;li&gt;定义成员函数时，使用作用域解析符（&lt;code&gt;::&lt;/code&gt;）来表示函数所属的类；&lt;/li&gt;
&lt;li&gt;类方法可以访问类的&lt;code&gt;private&lt;/code&gt;组件。&lt;/li&gt;
&lt;li&gt;只要类方法不修改调用对象，就应将其声明为&lt;code&gt;const&lt;/code&gt;，如&lt;code&gt;void Stock::show() const&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;类所创建的每个新对象都有自己的存储空间，用于存储其内部变量和类成员；但同一个类的所有对象&lt;strong&gt;共享同一组类方法&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;类成员的访问控制（封装）&quot;&gt;&lt;a href=&quot;#类成员的访问控制（封装）&quot; class=&quot;headerlink&quot; title=&quot;类成员的访问控制（封装）&quot;&gt;&lt;/a&gt;类成员的访问控制（封装）&lt;/h3&gt;&lt;p&gt;数据隐藏：防止程序直接访问数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如&lt;code&gt;int a&lt;/code&gt;是类的私有数据成员，&lt;code&gt;cout&amp;lt;&amp;lt;a&lt;/code&gt;是不对的，只有公有成员函数或友元函数才能访问。可以定义一个&lt;code&gt;show()&lt;/code&gt;方法访问a用来输出。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据封装：实现细节放在一起并与抽象分开。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据隐藏（数据放在类的私有部分）&lt;/li&gt;
&lt;li&gt;私有成员函数（实现细节隐藏在私有部分）&lt;/li&gt;
&lt;li&gt;类函数定义和类声明放在不同的文件中。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;类的构造函数与析构函数&quot;&gt;&lt;a href=&quot;#类的构造函数与析构函数&quot; class=&quot;headerlink&quot; title=&quot;类的构造函数与析构函数&quot;&gt;&lt;/a&gt;类的构造函数与析构函数&lt;/h2&gt;&lt;h3 id=&quot;类的构造函数&quot;&gt;&lt;a href=&quot;#类的构造函数&quot; class=&quot;headerlink&quot; title=&quot;类的构造函数&quot;&gt;&lt;/a&gt;类的构造函数&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;如果没有提供任何构造函数，C++自动提供默认构造函数，他不做任何工作；但是如果定义了构造函数，程序员必须为他提供默认构造函数，用户定义的默认构造函数通常给所有成员提供隐式初始值（已知合理值）。&lt;/li&gt;
&lt;li&gt;构造函数被用来创造对象，而不能通过对象来调用。（因为在通过构造函数构造出对象之前，对象是不存在的）。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;类的析构函数&quot;&gt;&lt;a href=&quot;#类的析构函数&quot; class=&quot;headerlink&quot; title=&quot;类的析构函数&quot;&gt;&lt;/a&gt;类的析构函数&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;对象过期时，程序自动调用析构函数；如果程序员没有声明，编译器隐式声明一个默认析构函数。&lt;/li&gt;
&lt;li&gt;注意窗口环境中，窗口关闭之前的代码包含在同一个代码块中，才能保证析构函数在窗口关闭之前执行。&lt;/li&gt;
&lt;li&gt;若构造函数中有&lt;code&gt;new&lt;/code&gt;，则析构函数必须&lt;code&gt;delete&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;构造函数的语法&quot;&gt;&lt;a href=&quot;#构造函数的语法&quot; class=&quot;headerlink&quot; title=&quot;构造函数的语法&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/applefishsky009/Leetcode/tree/master/2.1.1%20-%20Remove%20Duplicates%20from%20Sorted%20Array&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;构造函数的语法&lt;/a&gt;&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1. Num nums(initVector);
2. nums = Num(initVector)。
3. Num();
4. Num nums = Num();
5. Num nums = Num(initVector)；
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;1一定不会创建一个临时对象并析构；&lt;/li&gt;
&lt;li&gt;2是赋值语句一定会创建临时对象并析构(虽然有匿名对象但作用域限制)；&lt;/li&gt;
&lt;li&gt;3也会创建一个临时对象并析构(因为没有匿名对象的载体)；&lt;/li&gt;
&lt;li&gt;4不会(因为有匿名对象载体)；&lt;/li&gt;
&lt;li&gt;5会。但是对于5这种创建&lt;strong&gt;有指定值的对象&lt;/strong&gt;，是否有临时对象是不确定的(取决于具体的实现)。&lt;/li&gt;
&lt;li&gt;总之，1的效率最高。&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类的简介&quot;&gt;&lt;a href=&quot;#类的简介&quot; class=&quot;headerlink&quot; title=&quot;类的简介&quot;&gt;&lt;/a&gt;类的简介&lt;/h2&gt;&lt;h3 id=&quot;类的规范由两部分组成：&quot;&gt;&lt;a href=&quot;#类的规范由两部分组成：&quot; class=&quot;headerlink&quot; ti
    
    </summary>
    
      <category term="类" scheme="http://yoursite.com/categories/%E7%B1%BB/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++五种变量存储方式与external关键字</title>
    <link href="http://yoursite.com/2016/04/06/C++%E4%BA%94%E7%A7%8D%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E4%B8%8Eexternal%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2016/04/06/C++五种变量存储方式与external关键字/</id>
    <published>2016-04-06T09:15:14.000Z</published>
    <updated>2016-04-15T01:49:06.028Z</updated>
    
    <content type="html">&lt;h2 id=&quot;五种变量存储方式&quot;&gt;&lt;a href=&quot;#五种变量存储方式&quot; class=&quot;headerlink&quot; title=&quot;五种变量存储方式&quot;&gt;&lt;/a&gt;五种变量存储方式&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;存储描述&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;持续性&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;作用域&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;链接性&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;如何声明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;自动&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;自动&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;代码块&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;无&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;代码块中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;寄存器&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;自动&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;代码块&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;无&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;代码块中，&lt;code&gt;register&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;静态，无链接性&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;静态&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;代码块&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;无&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;代码块中，&lt;code&gt;static&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;静态，外部连接性&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;静态&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;文件&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;外部&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;不在任何代码块中，无关键字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;静态，内部链接性&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;静态&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;文件&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;内部&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;不在任何代码块中，&lt;code&gt;static&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;register&lt;/code&gt;用于显示指出自动变量，没什么用处，C++11保留的目的是向下兼容；&lt;/li&gt;
&lt;li&gt;静态无链接性变量与自动变量的异同：&lt;ul&gt;
&lt;li&gt;静态无链接性变量在编译器&lt;strong&gt;编译&lt;/strong&gt;时，编译器在&lt;strong&gt;静态/全局存储区&lt;/strong&gt;分配内存；&lt;/li&gt;
&lt;li&gt;自动变量在代码块&lt;strong&gt;运行&lt;/strong&gt;时，编译器在&lt;strong&gt;栈&lt;/strong&gt;中分配内存；&lt;/li&gt;
&lt;li&gt;二者均只能在代码块中运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;external关键字&quot;&gt;&lt;a href=&quot;#external关键字&quot; class=&quot;headerlink&quot; title=&quot;external关键字&quot;&gt;&lt;/a&gt;external关键字&lt;/h2&gt;&lt;p&gt;变量的声明有两种：定义声明（简称为定义）与引用声明（简称为声明）。如果要在一个文件中使用另一个文件中定义声明的变量，仅仅将这个变量储存为外部链接性的静态变量是不够的，还要在引用的文件中使用&lt;code&gt;external&lt;/code&gt;关键字做&lt;strong&gt;引用声明&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;外部变量在&lt;code&gt;main()&lt;/code&gt;前面或头文件中定义它，在文件中定义之后的任何位置使用它；&lt;/li&gt;
&lt;li&gt;单定义规则：变量只能定义声明一次；&lt;/li&gt;
&lt;li&gt;局部变量隐藏同名的全局变量。如果要访问全局变量，可用作用域解析符&lt;code&gt;：：&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;静态变量将隐藏常规外部变量（使用&lt;code&gt;external&lt;/code&gt;关键字引用）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关于&lt;code&gt;external&lt;/code&gt;关键字的测试是很简单的，这里不给出代码。另外提到单定义规则，有一点需要注意。任何一个包含头文件的cpp都要重新编译这个头文件，因此头文件绝对不能包含函数体与变量。不然，两个或两个以上cpp包含它会出现重定义错误。&lt;/p&gt;
&lt;hr&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;五种变量存储方式&quot;&gt;&lt;a href=&quot;#五种变量存储方式&quot; class=&quot;headerlink&quot; title=&quot;五种变量存储方式&quot;&gt;&lt;/a&gt;五种变量存储方式&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center
    
    </summary>
    
      <category term="存储" scheme="http://yoursite.com/categories/%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++内存存储区</title>
    <link href="http://yoursite.com/2016/04/05/C++%E5%86%85%E5%AD%98%E5%AD%98%E5%82%A8%E5%8C%BA/"/>
    <id>http://yoursite.com/2016/04/05/C++内存存储区/</id>
    <published>2016-04-05T02:17:33.000Z</published>
    <updated>2016-04-15T01:49:19.732Z</updated>
    
    <content type="html">&lt;h2 id=&quot;C-内存分配方式有五种：&quot;&gt;&lt;a href=&quot;#C-内存分配方式有五种：&quot; class=&quot;headerlink&quot; title=&quot;C++内存分配方式有五种：&quot;&gt;&lt;/a&gt;C++内存分配方式有五种：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;栈：局部变量、函数参数等&lt;ul&gt;
&lt;li&gt;可以实现函数调用；&lt;/li&gt;
&lt;li&gt;动态扩展、收缩；&lt;/li&gt;
&lt;li&gt;位于用户虚拟地址空间顶部。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;堆：&lt;code&gt;new&lt;/code&gt;分配的内存块，&lt;code&gt;delete&lt;/code&gt;释放。&lt;/li&gt;
&lt;li&gt;自由存储区：&lt;code&gt;malloc&lt;/code&gt;分配，&lt;code&gt;free&lt;/code&gt;释放。&lt;/li&gt;
&lt;li&gt;全局/静态存储区：全局变量与静态变量&lt;/li&gt;
&lt;li&gt;常量存储区：存放常量&lt;ul&gt;
&lt;li&gt;如 &lt;code&gt;string s1 = “abcd”&lt;/code&gt;；&lt;code&gt;s1&lt;/code&gt;是代码块中的指针，在栈中；&lt;code&gt;“abcd”&lt;/code&gt;是常量，在常量存储区。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;new和malloc的区别：&quot;&gt;&lt;a href=&quot;#new和malloc的区别：&quot; class=&quot;headerlink&quot; title=&quot;new和malloc的区别：&quot;&gt;&lt;/a&gt;new和malloc的区别：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;new&lt;/code&gt;可以认为是&lt;code&gt;malloc&lt;/code&gt;加构造函数的执行；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;new&lt;/code&gt;出来的指针是直接带类型信息的，&lt;code&gt;malloc&lt;/code&gt;返回&lt;code&gt;void&lt;/code&gt;指针；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;delete&lt;/code&gt;会相应调用对象的析构函数。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;堆和栈的区别：&quot;&gt;&lt;a href=&quot;#堆和栈的区别：&quot; class=&quot;headerlink&quot; title=&quot;堆和栈的区别：&quot;&gt;&lt;/a&gt;堆和栈的区别：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;管理方式：栈是编译器自助管理；堆是程序员控制，容易内存泄漏；&lt;ul&gt;
&lt;li&gt;内存泄漏：申请指针，指针指向内存，作用域或生命周期到了，指针释 放，但内存并没有释放，也无法访问，变成“死内存”。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;空间大小：堆内存几乎没有限制；栈一般有一定大小（编译器有默认值，可修改）&lt;/li&gt;
&lt;li&gt;碎片问题：堆频繁&lt;code&gt;new/delete&lt;/code&gt;会产生大量碎片（&lt;code&gt;delete&lt;/code&gt;出来的空间几乎不可能恰好等于&lt;code&gt;new&lt;/code&gt;的空间）；栈不会；&lt;/li&gt;
&lt;li&gt;生长方向：堆向上；栈向下。&lt;/li&gt;
&lt;li&gt;分配方式：堆动态；栈动态（&lt;code&gt;alloca&lt;/code&gt;，但他不需人工释放）或静态（编译器完成）&lt;/li&gt;
&lt;li&gt;分配效率：栈高于堆（栈：计算机系统提供，有底层支持；堆：C/C++库提供）&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;以上内容主要来自于&lt;a href=&quot;http://www.cnblogs.com/daocaoren/archive/2011/06/29/2092957.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;C-内存分配方式有五种：&quot;&gt;&lt;a href=&quot;#C-内存分配方式有五种：&quot; class=&quot;headerlink&quot; title=&quot;C++内存分配方式有五种：&quot;&gt;&lt;/a&gt;C++内存分配方式有五种：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;栈：局部变量、函数参数等&lt;ul&gt;
&lt;li&gt;可
    
    </summary>
    
      <category term="存储" scheme="http://yoursite.com/categories/%E5%AD%98%E5%82%A8/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
</feed>
