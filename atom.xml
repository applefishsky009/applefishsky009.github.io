<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孤云两角，去天一握</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://rylcode.cn/"/>
  <updated>2020-05-13T12:18:58.437Z</updated>
  <id>http://rylcode.cn/</id>
  
  <author>
    <name>ryl</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>The Skyline Problem</title>
    <link href="http://rylcode.cn/2017/04/14/The-Skyline-Problem/"/>
    <id>http://rylcode.cn/2017/04/14/The-Skyline-Problem/</id>
    <published>2017-04-14T01:54:01.000Z</published>
    <updated>2020-05-13T12:18:58.437Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/the-skyline-problem/#/description" target="_blank" rel="noopener">218. The Skyline Problem</a>这个问题非常有意思，与<a href="https://github.com/applefishsky009/FunnyIssues/blob/master/6-SJF/6-SJF.cpp" target="_blank" rel="noopener">SJF(短作业优先算法)</a>极为相似，使用<code>priority_queue</code>配合<code>pair</code>来解题非常方便。由此延伸到<code>utility</code>和<code>tuple</code>头文件的理解与关联。</p><hr><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>关于这个题的理解<a href="https://briangordon.github.io/2014/08/the-skyline-problem.html" target="_blank" rel="noopener">The skyline problem</a>阐述的较为清楚。解题的重点在于高权值在存活时间内覆盖低权值的“活动”，而所要求的<code>keyPoint</code>就是每当权值发生变化时的横坐标-权值对。</p><h3 id="普通解法"><a href="#普通解法" class="headerlink" title="普通解法"></a>普通解法</h3><p>在简单的解法中，每有一个活动开始，更新它存活时间内的权值最大值，由此就得到所谓天际线，得到<code>keyPoint</code>。但在这个解法中，时间复杂度和空间复杂度都与这个活动可能的持续总时间相关，而与活动个数<code>n</code>没有直接关系，也就是说，极可能出现<code>kn</code>的时间复杂度，<code>k</code>值非常大，<code>k</code>的空间复杂度，这里的<code>k</code>甚至会引起<code>bad_alloc</code>。</p><p>普通解法代码，仅供理解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;pair&lt;int, int&gt;&gt; getSkyline(const vector&lt;vector&lt;int&gt;&gt; &amp;buildings)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; keyPoint;</span><br><span class="line">        <span class="keyword">if</span> (!buildings.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> keyPoint;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = buildings[buildings.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">segTree</span><span class="params">(n + <span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : buildings)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = x[<span class="number">0</span>]; i &lt; x[<span class="number">1</span>]; i++)</span><br><span class="line">                segTree[i] = <span class="built_in">max</span>(x[<span class="number">2</span>], segTree[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">2</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (segTree[i] != segTree[i - <span class="number">1</span>])</span><br><span class="line">                keyPoint.push_back(make_pair(i, segTree[i]));</span><br><span class="line">        <span class="keyword">return</span> keyPoint;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p>之前提到解题的重点在于高权值在权值时间内覆盖低权值的“活动”，显然，一个以权值为<code>key</code>的优先级队列可以满足需要，同时需要携带<code>Y</code>值信息来判断活动是否结束，由于活动按照<code>X</code>值排好序，那么沿<code>X</code>轴进行扫描(只在活动开始或者结束时检查)，可能的操作有：</p><ol><li>在当前时间点开始的所有活动入队列，检查权值是否发生变化，如果变化则产生一个关键点。</li><li>随着<code>X</code>的扫描，所有超过存活时间的活动出队列，同时检查权值是否发生变化，如果变化则产生一个关键点。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;pair&lt;int, int&gt;&gt; getSkyline(vector&lt;vector&lt;int&gt;&gt; &amp;buildings)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>, cur_X = <span class="number">0</span>, cur_H = <span class="number">-1</span>, len = buildings.<span class="built_in">size</span>();</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; liveBlg;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt; len || !liveBlg.empty())</span><br><span class="line">        &#123;                                     </span><br><span class="line">            cur_X = liveBlg.empty() ? buildings[cur][<span class="number">0</span>] : liveBlg.top().second;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cur &gt;= len || buildings[cur][<span class="number">0</span>] &gt; cur_X)</span><br><span class="line">            &#123; </span><br><span class="line">                <span class="keyword">while</span> (!liveBlg.empty() &amp;&amp; (liveBlg.top().second &lt;= cur_X))</span><br><span class="line">                    liveBlg.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur_X = buildings[cur][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">while</span> (cur &lt; len &amp;&amp; buildings[cur][<span class="number">0</span>] == cur_X)</span><br><span class="line">                &#123;</span><br><span class="line">                    liveBlg.push(make_pair(buildings[cur][<span class="number">2</span>], buildings[cur][<span class="number">1</span>]));</span><br><span class="line">                    cur++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur_H = liveBlg.empty() ? <span class="number">0</span> : liveBlg.top().first;</span><br><span class="line">            <span class="keyword">if</span> (res.empty() || (res.back().second != cur_H))</span><br><span class="line">                res.push_back(make_pair(cur_X, cur_H));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="http://blog.csdn.net/xiajun07061225/article/details/8556786" target="_blank" rel="noopener">【STL学习】优先级队列Priority Queue详解与C++编程实现</a></p><blockquote><p>优先级队列内部的元素并不是按照添加的顺序排列，而是自动依照元素的<strong>权值</strong>排列。权值最高者排在最前面。缺省情况下，优先级队列利用一个<font color="red"><strong>大顶堆</strong></font>完成。</p></blockquote><p><a href="https://zh.wikipedia.org/wiki/%E5%84%AA%E5%85%88%E4%BD%87%E5%88%97" target="_blank" rel="noopener">优先队列</a></p><blockquote><p>标准模板库（STL）以及1998年的C++标准确定优先队列是标准模板库的容器适配器模板。其实现了一个需要三个参数的最大优先队列：比较函数（缺省情况是小于函数less<t>）、存储数据所用的容器类型（缺省情况是向量vector<t>）以及指向序列开始和结束位置的两个迭代器。和标准模板库中其他的真实容器不同，优先队列不允许使用其元素类型的迭代器，而必须使用优先队列抽象数据类型的迭代器。标准模板库还实现了支持随机访问数据容器的优先队列–二叉最大堆。Boost C++库也在其中实现了堆结构。</t></t></p></blockquote><hr><h2 id="从utillity到tuple"><a href="#从utillity到tuple" class="headerlink" title="从utillity到tuple"></a>从utillity到tuple</h2><p>在优先级队列中发现了一个很有意思的现象，没有重写<code>pair</code>类型的比较函数就能构造一个默认的<code>grater</code>优先级队列，这是如何进行的？</p><h3 id="utility"><a href="#utility" class="headerlink" title="utility"></a>utility</h3><p><a href="https://en.wikipedia.org/wiki/Utility_(C%2B%2B)" target="_blank" rel="noopener">utility (C++)</a>头文件包括两个关键部分：</p><ol><li><code>rel_ops</code>(relational operators)是一个命名空间，它包含一组模板，这些模板定义了同类型的关系运算符(<code>！=</code>,<code>&gt;</code>,<code>&lt;=</code>,<code>&gt;=</code>)的默认行为。这些默认行为是基于用户定义的<code>==</code>,<code>&lt;</code>两个行为的(也就是说这两个关系<font color="red">必须被定义</font>)。</li><li><code>pair</code>是一个容器模板，他可以包含任意类型的两个成员对象。通过(<code>first</code>和<code>second</code>来访问成员)，值得注意的是，头文件定义了他<font color="red"><strong>所有的</strong></font>关系运算符。从这里<a href="http://www.cplusplus.com/reference/utility/pair/operators/" target="_blank" rel="noopener">relational operators (pair)</a>也能看到。<ul><li><code>pair</code>使用默认的构造函数对数据成员进行值初始化。</li><li><code>pair</code>的数据成员是<code>public</code>的，两个成员啊分别命名为<code>first</code>和<code>second</code>。</li><li>新标准下，我们可以对返回值进行列表初始化，就像<code>python</code>中那样，但旧的标准中必须显式构造返回值。另外还可以用<code>mnake_pair</code>来生成<code>pair</code>对象。</li></ul></li></ol><p>这就就容易解释<code>pair</code>在优先级队列中并不需要重写比较函数这一现象。另外，在<a href="http://www.cplusplus.com/reference/utility/pair/" target="_blank" rel="noopener">pair</a>中可以看到以下描述，而<code>tuple</code>这个结构不能不让人想到<code>Python</code>中的<code>tuple</code>。</p><blockquote><p>Pairs are a particular case of tuple.</p></blockquote><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>上节提到<code>pair</code>是<code>tuple</code>的特例，其实他是类似<code>pair</code>的模板，</p><ol><li><code>tuple</code>的默认构造函数会对每个成员进行值初始化。</li><li><code>tuple</code>的成员都是未命名的，可以使用<code>get&lt;i&gt;(t)</code>来访问成员。</li><li>可以使用辅助类模板<code>tuple_size&lt;tupleType&gt;::value</code>和<code>tuple_element&lt;i,tupleType&gt;::type</code>来查询<code>tuple</code>成员的数量和类型。<code>tupleType</code>可以通过<code>typedef decltype(t) tupleType</code>来推断。</li><li>同类型的<code>tuple</code>才可以进行比较。</li><li><code>tuple</code>常用来从一个函数返回多个值。</li></ol><hr><p>一个简单的tips:<br>关于出栈顺序的题目，以1,2,3,4,5,6元素为例，如果当前位出现了6,之后小于6的元素肯定是<font color="red"><strong>逆序</strong></font>，从思维上来说，不必使用DFS的思路来找正确答案，类似于一个DP问题，当前当前位是否合理与他之后的元素顺序有关。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/the-skyline-problem/#/description&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;218. The Skyline Problem&lt;/a&gt;这个问题
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://rylcode.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Algorithm" scheme="http://rylcode.cn/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>再解KMP</title>
    <link href="http://rylcode.cn/2017/04/06/%E5%86%8D%E8%A7%A3KMP/"/>
    <id>http://rylcode.cn/2017/04/06/再解KMP/</id>
    <published>2017-04-06T02:21:03.000Z</published>
    <updated>2020-05-13T12:18:58.447Z</updated>
    
    <content type="html"><![CDATA[<p>之前在<a href="http://rylcode.cn/2016/05/03/BP%E3%80%81KMP%E3%80%81%E6%94%B9%E8%BF%9B%E7%9A%84KMP/">BP、KMP、改进的KMP</a>博文中介绍了计算KMP的方式以及程序理解，经过一段时间的沉淀，现在从算法角度和编程两个角度结合其他算法探求沉思KMP算法的本质。</p><hr><h2 id="算法角度"><a href="#算法角度" class="headerlink" title="算法角度"></a>算法角度</h2><p>结合DP思维，记录了前后缀匹配长度。<br>DP的思想体现首先在于<font color="red"><strong>无后效性</strong></font>，<code>next[j]</code>代表<code>j</code>位以前字符串中真前后缀的最大公共元素长度，即不包含<code>j</code>自身。<code>j</code>位以前的记录和<code>j</code>位以后无关，这就是无后效性。但注意在之前博文中改进的KMP算法使用到了<code>j</code>位的字符比较。<br>其次体现在状态转移上，<code>j</code>位的记录仅由<code>j-1</code>位和当前字符和前缀指针是否匹配来共同决定，这就引出了编程使用双指针fail pointer的决策实现。</p><hr><h2 id="编程角度"><a href="#编程角度" class="headerlink" title="编程角度"></a>编程角度</h2><p>fail pointer问题。在编程实现中，可以用失配指针来解决，双指针一个指向真前缀，失配则回溯，一个指向真后缀，由前一状态和当前是否匹配来共同决定。<br>值得注意的是，在<code>nextTemp[j]</code>的计算中，如果<code>i</code>的值代表了后缀指针，那么<code>nextTemp[i-1]</code>的值就代表了前缀指针，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(l.<span class="built_in">size</span>(), <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; l.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> j = next[i - <span class="number">1</span>];    <span class="comment">// 前一状态，同时这个值也是相同的真前缀长度</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; l[i] != l[j])   <span class="comment">//失配</span></span><br><span class="line">        j = next[j - <span class="number">1</span>];    <span class="comment">//  回溯，因为next[j]记录了匹配位置</span></span><br><span class="line">    next[i] = (j += l[i] == l[j]);<span class="comment">//回溯后再判断是否匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<a href="http://www.rudy-yuan.net/archives/182/" target="_blank" rel="noopener">一幅图让你彻底理解KMP算法</a>这个博文中对回溯的过程解释的比较清楚，即在回溯到的子字符串中，其实也经过了前缀后缀的匹配过程，因此需要多次回溯，回溯的跳出条件为回溯到底或者完全匹配为止。因此从<code>nextTemp[j]</code>到<code>next[j]</code>到<code>nextVal[j]</code>的算法优化过程如下：</p><p><code>nextTemp[j]</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(l.<span class="built_in">size</span>(), <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; l.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> j = next[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; l[i] != l[j])</span><br><span class="line">        j = next[j - <span class="number">1</span>];</span><br><span class="line">    next[i] = (j += l[i] == l[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>next[j]</code>，在这里做了两件事情，将i,j初始值减一，j作为前缀指针进行了更强有力的控制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>; </span><br><span class="line"><span class="keyword">while</span>(i &lt; l.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; l[i] != l[j])</span><br><span class="line">j = next[j];</span><br><span class="line">j++;</span><br><span class="line">i++;</span><br><span class="line">next[i] = j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再写<code>next[j]</code>，这里做了两件事情，去掉内层循环仅有外层循环控制，转换判断逻辑。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>; </span><br><span class="line"><span class="keyword">while</span> (i &lt; s2.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">-1</span> || s2[i]==s2[j])</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">next[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">j = next[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化至<code>nextVal[j]</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &lt; needle.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="comment">//注意i少一个值</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">-1</span> || needle[i] == needle[j]) <span class="comment">//前一次失配 或 当前匹配，真前后缀长度加1</span></span><br><span class="line">&#123;</span><br><span class="line">j++;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span> (needle[i] != needle[j])</span><br><span class="line">nextVal[i] = j;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">nextVal[i] = nextVal[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">j = nextVal[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考题目：<br><a href="https://leetcode.com/problems/shortest-palindrome/#/description" target="_blank" rel="noopener">214. Shortest Palindrome</a><br><a href="https://leetcode.com/problems/implement-strstr/" target="_blank" rel="noopener">28. Implement strStr()</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前在&lt;a href=&quot;http://rylcode.cn/2016/05/03/BP%E3%80%81KMP%E3%80%81%E6%94%B9%E8%BF%9B%E7%9A%84KMP/&quot;&gt;BP、KMP、改进的KMP&lt;/a&gt;博文中介绍了计算KMP的方式以及程序理解，经过
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://rylcode.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Algorithm" scheme="http://rylcode.cn/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>前缀树的实现</title>
    <link href="http://rylcode.cn/2017/03/30/%E5%89%8D%E7%BC%80%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://rylcode.cn/2017/03/30/前缀树的实现/</id>
    <published>2017-03-30T02:42:08.000Z</published>
    <updated>2020-05-13T12:18:58.448Z</updated>
    
    <content type="html"><![CDATA[<p>前缀树也叫字典树或Trie树，可以查询某个单词或者前缀在所有单词中出现的次数(假设单词中只包含字符’a’-‘z’)，查询和插入的时间复杂度都是O(n)，是一种以时间换空间的方法。<br>在下述实现中，根结点不对应空字符，而是首字符(这样保证了数据结构的一致性)，每个结点包含上一结点的<strong>超尾</strong>。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>创建一个结构体或类，其中包含一个26大小的指针数组(指向本数据类型，用是否空指针判断字符是否存在)，一个endFlag或nCount用来标识是否字符尾(判断前缀使用)或统计字符个数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> endFlag;</span><br><span class="line">    <span class="built_in">vector</span>&lt;node *&gt; pre;</span><br><span class="line">    node() : endFlag(<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pre = <span class="built_in">vector</span>&lt;node *&gt;(<span class="number">26</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>前缀树的实现除构造函数外需要四种基本操作，插入，辅助操作<strong>寻找指针</strong>用来<strong>查找</strong>或<strong>判断是否前缀</strong>。</p><p>构造函数即创建根节点，注意在出现空字符后<code>endflag</code>才会为真，符合逻辑。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Trie()</span><br><span class="line">&#123;</span><br><span class="line">    trie = <span class="keyword">new</span> node();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入。按单词顺序往前缀树中插入单词，可以将单词看做数据结构之间的“线”。即路径。注意在叶子节点中除<code>endFlag</code>为<code>True</code>外，指针数组中的指针全是空指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node *p = trie;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">word</span>.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!p-&gt;pre[<span class="keyword">word</span>[i] - <span class="string">'a'</span>])</span><br><span class="line">            p-&gt;pre[<span class="keyword">word</span>[i] - <span class="string">'a'</span>] = <span class="keyword">new</span> node();</span><br><span class="line">        p = p-&gt;pre[<span class="keyword">word</span>[i] - <span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;endFlag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>寻找指针。沿单词顺序在前缀树中查找，有三种可能。</p><ol><li>该单词恰好在前缀树中，返回超尾指针，超尾指针的<code>endFlag</code>为<code>True</code>，指针数组中的值由其他单词决定。</li><li>若该单词是一个前缀(单词是前缀)，而不是作为单词插入前缀树，不需要检查<code>endFlag</code>，只需要返回非空指针即可。</li><li>若单词不在前缀树中，在查找中间过程失配的时候就返回了空指针(因为前缀树中没有初始化过对应的数据结构)。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node *<span class="title">find</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node *p = trie;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">word</span>.<span class="built_in">size</span>() &amp;&amp; p; i++)</span><br><span class="line">        p = p-&gt;pre[<span class="keyword">word</span>[i] - <span class="string">'a'</span>];</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找。返回非空指针且<code>endFlag</code>为<code>True</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node *p = <span class="built_in">find</span>(<span class="keyword">word</span>);</span><br><span class="line">    <span class="keyword">return</span> p &amp;&amp; p-&gt;endFlag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是否前缀。返回非空指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(prefix);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考资料：<br><a href="http://blog.csdn.net/pirage/article/details/6977730" target="_blank" rel="noopener">字典树（前缀树）的应用</a><br><a href="https://zh.wikipedia.org/wiki/Trie" target="_blank" rel="noopener">Trie</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前缀树也叫字典树或Trie树，可以查询某个单词或者前缀在所有单词中出现的次数(假设单词中只包含字符’a’-‘z’)，查询和插入的时间复杂度都是O(n)，是一种以时间换空间的方法。&lt;br&gt;在下述实现中，根结点不对应空字符，而是首字符(这样保证了数据结构的一致性)，每个结点包含
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://rylcode.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Algorithm" scheme="http://rylcode.cn/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>基本图算法和拓扑排序</title>
    <link href="http://rylcode.cn/2017/02/10/%E5%9F%BA%E6%9C%AC%E5%9B%BE%E7%AE%97%E6%B3%95%E5%92%8C%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <id>http://rylcode.cn/2017/02/10/基本图算法和拓扑排序/</id>
    <published>2017-02-10T06:24:17.000Z</published>
    <updated>2020-05-13T12:18:58.450Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h2><p>对于图G(graph) = (V(vertex),E(edge))，有两种标准表示方法。</p><ol><li>邻接链表，一般用于表示稀疏图(边的条数|E|远远小于|V|*|V|)时非常紧凑。<ul><li>对于有向图，邻接链表长度之和是|E|；对于无向图，邻接链表长度之和是2*|E|。</li><li>邻接链表表示法的储存空间需求是O(V+E)，他的一个潜在缺陷是无法在O(1)时间判断边(u,v)是否在图中，需要在邻接链表Adj[u]中搜索结点v。</li><li>可以将边(u,v)∈E的权重值w(u,v)存放在结点u的邻接链表里。</li></ul></li><li>邻接矩阵，在稠密图(边的条数|E|接近|V|*|V|)时通常选择这种表示。<ul><li>无向图的邻接矩阵是一个对称矩阵。</li><li>邻接矩阵的空间需求为O(V*V)，付出更大的储存空间消耗，可以进行快速边搜索。</li><li>直接将边(u,v)∈E的权重值w(u,v)存放在邻接矩阵第u行第v列。</li></ul></li></ol><p>图规模较小时，倾向于使用邻接矩阵表示法，他每个记录项只需要一位空间。另外，结点和边的属性，可以通过数组或者子类实例变量来表示。</p><hr><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>图搜索算法分为广度优先算法(BFS)(Prim最小生成树，Dijkstra单元最短路径)和深度优先算法(DFS)，他们也是很多重要图算法的原型。在搜索的过程中，对结点进行涂色来指明结点的状态。</p><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>一般用于解决路径问题。所有结点初始颜色都是白色，凡是黑色和灰色结点都是已被发现的结点。所有与黑色结点邻接的点都已被发现，灰色结点所代表的就是已知和未知两个集合的边界(即白色结点还未入队列，灰色结点都在队列中，黑色结点已经出队列)。</p><ol><li><code>u.color</code>存放结点u的颜色属性。</li><li><code>u.π</code>存放结点u的前驱结点。</li><li><code>u.d</code>记录广度优先算法所计算出的从源节点s到结点u之间的距离。</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">BFS(G,s)</span><br><span class="line">  for each vertex u ∈ G.V - &#123;s&#125;</span><br><span class="line">    u.color = WHITE</span><br><span class="line">    u.d = ∞</span><br><span class="line">    u.π = NIL</span><br><span class="line">  s.color = GRAY</span><br><span class="line">  s.d = 0</span><br><span class="line">  s.π = NIL</span><br><span class="line">  Q = ∅</span><br><span class="line">  ENQUEUE(Q, s)</span><br><span class="line">  while Q ≠ ∅</span><br><span class="line">    u = DEQUEUE(Q)</span><br><span class="line">    for each v ∈ G.Adj[u]</span><br><span class="line">      if v.color == WHITE</span><br><span class="line">        v.color = GRAY</span><br><span class="line">        v.d = u.d + 1</span><br><span class="line">        v.π = u</span><br><span class="line">        ENQUEUE(Q, v)</span><br><span class="line">    u.color = BLACK</span><br></pre></td></tr></table></figure><h4 id="聚合分析"><a href="#聚合分析" class="headerlink" title="聚合分析"></a>聚合分析</h4><ol><li>初始化操作结束后，广度优先搜索不会再给任何结点涂上白色，因此每个结点入队最多为一次，那么出队最多也为一次，即队列操作的总时间阿伟O(V)。</li><li>队列只在结点出队时对该结点的邻接链表进行扫描，即每个邻接链表最多扫描一次，所有邻接链表的长度之和是O(E)，那么扫描邻接链表总时间是O(E)。</li><li>初始化操作的时间成本是O(V)，因此广度优先搜索的运行总时间是O(E+V)。</li></ol><p>另外可以证明，<code>v.d</code>即为源结点s到结点v的最短路径。</p><h4 id="广度优先树"><a href="#广度优先树" class="headerlink" title="广度优先树"></a>广度优先树</h4><p>BFS算法搜索过程中创建一颗广度优先树，对应π属性。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PRINT-PATH(G,s,v)</span><br><span class="line">  if v == s</span><br><span class="line">    print s</span><br><span class="line">  elseif v.π == NIL</span><br><span class="line">    print "no path from s to v exists"</span><br><span class="line">  else PRINT-PATH(G,s,v.π)</span><br><span class="line">    print v</span><br></pre></td></tr></table></figure><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>一般用于解决拓扑排序问题。每个结点初始颜色都是白色，在结点被发现后变为灰色，在其邻接链表被扫描完成后变为黑色。</p><ol><li><code>v.color</code>存放结点v颜色属性。</li><li><code>v.π</code>存放结点v的前驱结点。</li><li>第一个时间戳<code>v.d</code>记录结点v第一次被发现的时间(涂上灰色的时候)。</li><li>第二个时间戳<code>v.f</code>记录的是搜索完成对v的邻接链表扫描的时间(涂上黑色的时候)。</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">DFS(G)</span><br><span class="line">  for each vertex u ∈ G.V</span><br><span class="line">    u.color = WHITE</span><br><span class="line">    u.π = NIL</span><br><span class="line">  time = 0</span><br><span class="line">  for each vertex u ∈ G.V</span><br><span class="line">    if u.color == WHITE</span><br><span class="line">      DFS-VISIT(G,u)</span><br><span class="line"></span><br><span class="line">DFS-VISIT(G,u)</span><br><span class="line">  time = time + 1</span><br><span class="line">  u.d = time</span><br><span class="line">  u.color = GRAY</span><br><span class="line">  for each v ∈ G:Adj[u]</span><br><span class="line">    if v.color == WHITE</span><br><span class="line">      v.π = u</span><br><span class="line">      DFS-VISIT(G,v)</span><br><span class="line">  u.color = BLACK</span><br><span class="line">  time = time + 1</span><br><span class="line">  u.f = time</span><br></pre></td></tr></table></figure><h4 id="聚合分析-1"><a href="#聚合分析-1" class="headerlink" title="聚合分析"></a>聚合分析</h4><ol><li>排除调用DFS-VISIT(G,u)的时间，DFS(G)中两个循环的时间复杂度都是O(V)。</li><li>只有结点u是白色时才能调用DFS-VISIT(G,u)，而他所做的第一件事情是将结点涂灰，而在初始化之后结点不会被涂白，因此对每个结点来说，刚好调用了一次DFS-VISIT(G,v)。</li><li>每个结点调用DFS-VISIT(G,v)时扫描邻接矩阵，由于∑|Adj[v]| = O(E)，因此总的算法运行时间是O(V+E)。</li></ol><hr><h2 id="无环图"><a href="#无环图" class="headerlink" title="无环图"></a>无环图</h2><h3 id="kahn算法"><a href="#kahn算法" class="headerlink" title="kahn算法"></a>kahn算法</h3><ol><li>计算图中所有点的入度，把入度为0的点加入栈。</li><li>如果栈非空：<ul><li>取出栈顶顶点a，输出该顶点值，删除该顶点。</li><li>从图中删除所有以a为起始点的边，如果删除的边的另一个顶点入度为0，则把它入栈。</li></ul></li><li>如果图中还存在顶点，则表示图中存在环；否则输出的顶点就是一个拓扑排序序列。</li></ol><p>以上算法可以判断是否有环，但是并不是所有最后剩余的点都是环中的顶点。<br>参考资料：<a href="http://www.cnblogs.com/TenosDoIt/p/3644225.html" target="_blank" rel="noopener">判断一个图是否有环</a></p><h3 id="有向无环图的拓扑排序"><a href="#有向无环图的拓扑排序" class="headerlink" title="有向无环图的拓扑排序"></a>有向无环图的拓扑排序</h3><p>经过拓扑排序后的结点次序，和结点的完成时间刚好相反。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TOPOLOGICAL-SORT(G)</span><br><span class="line">  call DFS(G) to compute finishing times v.f for each vertex v.</span><br><span class="line">  as each vertex is finished, insert it onto the front of a linked list.</span><br><span class="line">  return the linked list of vertices.</span><br></pre></td></tr></table></figure><p><a href="https://github.com/applefishsky009/LeetCode/blob/master/207-CourseSchedule/207-CourseSchedule.cpp" target="_blank" rel="noopener">CourseSchedule</a></p><hr><h2 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h2><p>有向图的强连通分量是一个最大结点集合C⊆V，对于该集合中的任意一对结点u和v来说，可以互相到达。<br>在O(E+V)时间使用两次DFS来计算有向图G = (V,E)的强连通分量，Kosaraju算法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">STRONGLY-CONNECTED</span><br><span class="line">  call DFS(G) to compute finishing times u.f for each vertex u.</span><br><span class="line">  compute G^T.</span><br><span class="line">  call DFS(G^T), but in main loop of DFS, consider the vertices in order of decreasing u.f.</span><br><span class="line">  output the vertices of each tree in the depth-first forest formed in last step as a separate strongly connected component.</span><br></pre></td></tr></table></figure><p>参考资料：<a href="http://www.cnblogs.com/bamboo-talking/archive/2011/08/25/2153740.html#!comments" target="_blank" rel="noopener">算法导论 拓扑排序、强连通分量（备忘）</a></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;图的表示&quot;&gt;&lt;a href=&quot;#图的表示&quot; class=&quot;headerlink&quot; title=&quot;图的表示&quot;&gt;&lt;/a&gt;图的表示&lt;/h2&gt;&lt;p&gt;对于图G(graph) = (V(vertex),E(edge))，有两种标准表示方法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;邻接链表
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://rylcode.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Algorithm" scheme="http://rylcode.cn/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>VSCode配置Python环境</title>
    <link href="http://rylcode.cn/2017/01/19/VSCode%E9%85%8D%E7%BD%AEPython%E7%8E%AF%E5%A2%83/"/>
    <id>http://rylcode.cn/2017/01/19/VSCode配置Python环境/</id>
    <published>2017-01-19T09:11:03.000Z</published>
    <updated>2020-05-13T12:18:58.438Z</updated>
    
    <content type="html"><![CDATA[<h2 id="VSCode与插件"><a href="#VSCode与插件" class="headerlink" title="VSCode与插件"></a>VSCode与插件</h2><ol><li>VSCode安装省略。</li><li>插件选择<code>Python</code>，作者是Don Jayamanne，下载量最多的那个。</li></ol><hr><h2 id="Python环境"><a href="#Python环境" class="headerlink" title="Python环境"></a>Python环境</h2><p>安装环境时注意重启VSCode，powershell，计算机。</p><ol><li>安装Python，注意安装的时候<a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001374738150500472fd5785c194ebea336061163a8a974000" target="_blank" rel="noopener">Add python.exe to Path</a>，<a href="https://www.zhihu.com/question/22621185" target="_blank" rel="noopener">一招搞定windows安装路径配置</a>，如果安装的时候没有选择，手动添加<code>Python.exe</code>到环境变量即可。</li><li>配好环境变量在cmd中输入<code>python</code>，可以看到版本信息。因为我用的是powershell，在cmd中可以看到版本信息而在powershell中看不到，解决方案是<a href="http://stackoverflow.com/questions/19676403/running-python-in-powershell" target="_blank" rel="noopener">Running Python in powershell?</a></li><li>参数配置：</li></ol><p>launch.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="attr">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Python"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"python"</span>,</span><br><span class="line">            <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="attr">"stopOnEntry"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">"program"</span>: <span class="string">"$&#123;file&#125;"</span>,</span><br><span class="line">            <span class="attr">"debugOptions"</span>: [</span><br><span class="line">                <span class="string">"WaitOnAbnormalExit"</span>,</span><br><span class="line">                <span class="string">"WaitOnNormalExit"</span>,</span><br><span class="line">                <span class="string">"RedirectOutput"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Python Console App"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"python"</span>,</span><br><span class="line">            <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="attr">"stopOnEntry"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">"program"</span>: <span class="string">"$&#123;file&#125;"</span>,</span><br><span class="line">            <span class="attr">"externalConsole"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">"debugOptions"</span>: [</span><br><span class="line">                <span class="string">"WaitOnAbnormalExit"</span>,</span><br><span class="line">                <span class="string">"WaitOnNormalExit"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Django"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"python"</span>,</span><br><span class="line">            <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="attr">"stopOnEntry"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">"program"</span>: <span class="string">"$&#123;workspaceRoot&#125;/manage.py"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [</span><br><span class="line">                <span class="string">"runserver"</span>,</span><br><span class="line">                <span class="string">"--noreload"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"debugOptions"</span>: [</span><br><span class="line">                <span class="string">"WaitOnAbnormalExit"</span>,</span><br><span class="line">                <span class="string">"WaitOnNormalExit"</span>,</span><br><span class="line">                <span class="string">"RedirectOutput"</span>,</span><br><span class="line">                <span class="string">"DjangoDebugging"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Watson"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"python"</span>,</span><br><span class="line">            <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="attr">"stopOnEntry"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">"program"</span>: <span class="string">"$&#123;workspaceRoot&#125;/console.py"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [</span><br><span class="line">                <span class="string">"dev"</span>,</span><br><span class="line">                <span class="string">"runserver"</span>,</span><br><span class="line">                <span class="string">"--noreload=True"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"debugOptions"</span>: [</span><br><span class="line">                <span class="string">"WaitOnAbnormalExit"</span>,</span><br><span class="line">                <span class="string">"WaitOnNormalExit"</span>,</span><br><span class="line">                <span class="string">"RedirectOutput"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tasks.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"0.1.0"</span>,</span><br><span class="line">    <span class="attr">"command"</span>: <span class="string">"python"</span>,</span><br><span class="line">    <span class="attr">"isShellCommand"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"args"</span>: [<span class="string">"$&#123;file&#125;"</span>],</span><br><span class="line">    <span class="attr">"showOutput"</span>: <span class="string">"always"</span>,</span><br><span class="line">    <span class="attr">"options"</span>: &#123;</span><br><span class="line">        <span class="attr">"env"</span>: &#123;</span><br><span class="line">            <span class="attr">"PYTHONIOENCODING"</span>: <span class="string">"UTF-8"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Run-Build-Task-中文乱码-BUG"><a href="#Run-Build-Task-中文乱码-BUG" class="headerlink" title="Run Build Task 中文乱码 BUG"></a>Run Build Task 中文乱码 BUG</h2><p>安装好之后F5运行，在dubug窗口显示的输出格式并不正确，按<code>ctrl + shift + B</code>运行(tasks指令)，安装好其他两个插件之后<code>Configure Task Runner</code>，即写好tasks配置文件，运行后可能出现乱码。<br>解决方案：<br><a href="https://segmentfault.com/a/1190000005986197" target="_blank" rel="noopener">VSCode Python 配置</a><br>我采用在tasks.json中配置options参数来解决。</p><hr><h2 id="task配置"><a href="#task配置" class="headerlink" title="task配置"></a>task配置</h2><p>详细信息查看官网。<br><a href="http://code.visualstudio.com/docs/editor/tasks" target="_blank" rel="noopener">Integrate with External Tools via Tasks</a></p><blockquote><p>The final command line is constructed as follows:</p></blockquote><blockquote><p>If suppressTaskName is true, the command line is <font color="red">command ‘global args’ ‘task args’</font>.<br>If suppressTaskName is false, it is <font color="red">command ‘global args’ taskName ‘task args’</font>.</p></blockquote><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;VSCode与插件&quot;&gt;&lt;a href=&quot;#VSCode与插件&quot; class=&quot;headerlink&quot; title=&quot;VSCode与插件&quot;&gt;&lt;/a&gt;VSCode与插件&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;VSCode安装省略。&lt;/li&gt;
&lt;li&gt;插件选择&lt;code&gt;Pytho
      
    
    </summary>
    
      <category term="VSCode" scheme="http://rylcode.cn/categories/VSCode/"/>
    
    
      <category term="VSCode" scheme="http://rylcode.cn/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>并查集-不相交集合算法</title>
    <link href="http://rylcode.cn/2017/01/18/%E5%B9%B6%E6%9F%A5%E9%9B%86-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E9%9B%86%E5%90%88%E7%AE%97%E6%B3%95/"/>
    <id>http://rylcode.cn/2017/01/18/并查集-不相交集合算法/</id>
    <published>2017-01-18T08:33:53.000Z</published>
    <updated>2020-05-13T12:18:58.452Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>资料：<br><a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure" target="_blank" rel="noopener">Disjoint-set data structure</a><br>算法导论第21章</p><p>联合-查找算法（union-find algorithm）定义了两个操作用于此数据结构：</p><ol><li>Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。</li><li>Union：将两个子集合并成同一个集合。</li></ol><p>实际使用：</p><ol><li>无向图的连通分量个数。</li><li>最近公共祖先(LCA)。</li><li>带限制的作业排序。</li><li>实现Kruskar算法求最小生成树。</li><li>求二值图像连通域个数。</li></ol><hr><h2 id="代码实现和优化"><a href="#代码实现和优化" class="headerlink" title="代码实现和优化"></a>代码实现和优化</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 13 <span class="comment">//总结点数</span></span></span><br><span class="line"><span class="comment">// 先搞一个充分大的数组模拟树</span></span><br><span class="line"><span class="keyword">int</span> parent[N + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> nRank[N + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//按秩合并</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化时， 将自己初始化为集合代表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeSet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        parent[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Find-AND-Union"><a href="#Find-AND-Union" class="headerlink" title="Find AND Union"></a>Find AND Union</h3><p>采用迭代的方式求集合代表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找集合代表， 看看究竟是谁(实际上， 还可以进行路径压缩优化)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = n;</span><br><span class="line">    <span class="keyword">while</span> (parent[r] != r)</span><br><span class="line">        r = parent[r]; <span class="comment">// 没找到的话， 一直往上找</span></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将parentX和parentY所在的集合融合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union1</span><span class="params">(<span class="keyword">int</span> parentX, <span class="keyword">int</span> parentY)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    parent[parentX] = parentY; <span class="comment">// parent[parentY] = parentX;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这样创建的树可能严重不平衡，树深度会影响查找效率。</p><h3 id="路径压缩优化-path-compression"><a href="#路径压缩优化-path-compression" class="headerlink" title="路径压缩优化(path compression)"></a>路径压缩优化(path compression)</h3><p>采用递归的方式进行路径压缩优化，在<font color="red">执行“查找”操作</font>时，扁平化树结构的方法，将路径上的每个节点都都直接连在根上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//路径压缩,O(n)查找-&gt;O(1)查找，沿叶子往上找的时候将叶子和根全连在一起</span></span><br><span class="line"><span class="comment">//无论什么时候只要搜索发生就可能产生优化。初始化或者测试的时候。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[n] != n)</span><br><span class="line">        <span class="comment">//等式右边第一趟沿着查找路径向上直到找到根，等式左边递归回溯沿着搜索树向下更新每个节点</span></span><br><span class="line">        parent[n] = find1(parent[n]);</span><br><span class="line">    <span class="keyword">return</span> parent[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="按秩合并-union-by-rank"><a href="#按秩合并-union-by-rank" class="headerlink" title="按秩合并(union by rank)"></a>按秩合并(union by rank)</h3><p>使具有较少结点的树的根指向具有较多结点的树的根，来控制树的深度，只使用这个方法将使最坏运行时间(Union，Find)为log(n)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union2</span><span class="params">(<span class="keyword">int</span> parentX, <span class="keyword">int</span> parentY)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nRank[parentX] &gt; nRank[parentY])</span><br><span class="line">        parent[parentY] = parentX;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        parent[parentX] = parentY;</span><br><span class="line">        <span class="keyword">if</span> (nRank[parentX] == nRank[parentY])</span><br><span class="line">            ++nRank[parentY];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时采用两种方法优势互补，将每个操作的平均时间仅为O(a(n))，这是渐进最优算法。</p><hr><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><p>对于集合中的非数字元素，可以建立Hash Map将元素与数字进行编码，然后采用上述方式(数组)模拟树结构求解。<br><a href="https://github.com/applefishsky009/DataStructuresAndAlgorithms/blob/master/UnionSet/UnionSet.cpp" target="_blank" rel="noopener">ryl的并查集</a><br><a href="https://github.com/applefishsky009/LeetCode/blob/master/200-NumberOfIslands/200-NumberOfIslands.cpp" target="_blank" rel="noopener">NumberOfIslands</a><br>为什么叫并查集？因为核心的两个功能(API)就是合并(Union)和查找(Find)。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;资料：&lt;br&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Disjoint-set_data_struct
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://rylcode.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Algorithm" scheme="http://rylcode.cn/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Python入门12-执行环境</title>
    <link href="http://rylcode.cn/2017/01/17/Python%E5%85%A5%E9%97%A812-%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/"/>
    <id>http://rylcode.cn/2017/01/17/Python入门12-执行环境/</id>
    <published>2017-01-17T10:10:32.000Z</published>
    <updated>2020-05-13T12:18:58.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h2><p>函数，方法，类，类的实例。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ol><li>内建函数(BIF:Built-in Function)，C/C++所写，可以用<code>dir()</code>列出所有内建函数的属性。<ul><li><code>type(BIF) -&gt; type &#39;builtin_funciotn_or_method&#39;</code>，但不用于工厂函数，工厂函数会返回类型<code>type</code>。</li></ul></li><li>用户自定义函数(UDF:User-Defind Function)，Python所写，用户自定义函数是函数类型的。<ul><li><code>type(UDF) -&gt; &lt;type &#39;function&#39;&gt;</code>。</li></ul></li><li><code>lambda</code>表达式，创建匿名函数，通过别名来引用，享有和UDF相同的属性。</li></ol><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol><li>内建方法(BIM:built-in Method)，只有内建类型(BIT:built-in type)有内建方法，通过内建对象来访问内建方法。<ul><li>BIF和BIM有相同的属性，不同的是BIM的<code>__self__</code>属性指向一个Python对象，而BIF指向<code>None</code>。</li></ul></li><li>用户定义的方法(UDM:User-Defined Method)，与类对象关联/非绑定，通过类的实例来调用(绑定的)。<ul><li>访问对象本身会揭示你正在引用一个绑定方法还是非绑定方法。</li></ul></li></ol><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ol><li>利用类的可调用性来创建实例。</li></ol><h3 id="类的实例"><a href="#类的实例" class="headerlink" title="类的实例"></a>类的实例</h3><ol><li>类有一个特别方法<code>__call__()</code>，该方法允许程序员创建可调用的实例。默认情况下，这个方法是没有被实现的，即大部分实例是不可调用的。</li></ol><hr><h2 id="代码对象"><a href="#代码对象" class="headerlink" title="代码对象"></a>代码对象</h2><p>函数对象仅是代码对象的包装，方法则是给函数对象的包装。</p><ol><li><code>callable(object)</code>判断一个对象是否可调用。</li><li><code>compile(source,filename,mode,flag=0,dont_inherit=False,optimize=-1)</code>编译source为code或AST对象 code可以通过调用<code>exec()</code>和<code>eval()</code>执行。<ul><li>source可以为字符串或AST对象，第二个参数是代码所有文件，通常设置为<code>None</code>。</li></ul></li><li><code>eval(expression,globals=None,locals=None)</code>执行一个表达式，可以是字符串或内建函数<code>compile()</code>创建的预编译代码对象。</li><li><code>exec(obj)</code>执行代码对象或字符串形式的Python代码。<ul><li>注意使用这个执行文件操作时，依然要<code>tell()</code>，<code>seek()</code>，<code>close()</code>，<code>getsize()</code>。</li></ul></li><li><code>input(prompt)</code>输出提示符，读取用户输入。把输入作为Python对象来求值并返回表达式的结果。</li><li>模块导入：<code>__name__</code>系统变量可以在运行时检测该模块是被导入还是被直接执行。<ul><li>如果模块是被导入，<code>__name__</code>的值为模块名字。</li><li>如果模块是被直接执行，<code>__name__</code>的值是<code>__main__</code>。</li><li>利用这个特性在主程序中书写测试代码。</li></ul></li><li>使用命令行从工作目录直接调用脚本。(如果是标准库的一部分会比较复杂)</li><li><code>os.system()</code>通常不会和产生输出的命令一起使用，他通过退出状态显示成功或失败而不是通过输入和/或输出通信。通常的约定是利用退出状态，0表示成功，非0表示其他类型的错误。</li><li><code>os.popen()</code>建立一个指向程序的单向链接，然后像访问文件一样访问程序。</li><li><code>os.fork(), os.exec*(), os.wait*()</code>，进程控制函数，各种<code>os.exec*()</code>函数接受加载到新进程的参数列表。<ul><li>子进程返回的pid是0，父进程返回的pid是子进程的进程号。</li></ul></li><li><code>os.spawn*()</code>在新进程中执行命令。</li><li><code>subprocess</code>模块，允许生成新进程，连接到输入/输出/错误管道，并获取返回码。此模块旨在替换多个旧模块和功能。</li></ol><hr><h2 id="终止执行的方法"><a href="#终止执行的方法" class="headerlink" title="终止执行的方法"></a>终止执行的方法</h2><ol><li><code>sys.exit()</code> 调用时，引发<code>systemExit</code>异常，这是唯一不看做错误的异常，如果没有给出状态参数，默认为0。</li><li><code>os._exit()</code> 不执行任何清理便立即退出Python，不应该在一般应用中使用，因为他是平台相关的。</li><li><code>os.kill(pid,sig)</code> 发给pid你想要发送的信号sig。 </li></ol><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;可调用对象&quot;&gt;&lt;a href=&quot;#可调用对象&quot; class=&quot;headerlink&quot; title=&quot;可调用对象&quot;&gt;&lt;/a&gt;可调用对象&lt;/h2&gt;&lt;p&gt;函数，方法，类，类的实例。&lt;/p&gt;
&lt;h3 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="Python" scheme="http://rylcode.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://rylcode.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python入门11-类的高级特性</title>
    <link href="http://rylcode.cn/2017/01/15/Python%E5%85%A5%E9%97%A811-%E7%B1%BB%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
    <id>http://rylcode.cn/2017/01/15/Python入门11-类的高级特性/</id>
    <published>2017-01-15T02:07:53.000Z</published>
    <updated>2020-05-13T12:18:58.429Z</updated>
    
    <content type="html"><![CDATA[<h2 id="通用特性"><a href="#通用特性" class="headerlink" title="通用特性"></a>通用特性</h2><ol><li>类和类型统一，所有Python内建转换函数都是工厂函数。类名以及工厂函数可以创建类的新对象，还可以作为基类去子类化类型，还可以用于<code>instance()</code>内建函数。    </li><li>注意<code>instance(obj,OBJ)</code>内建函数不是严格比较的，如果obj是一个给定类型的实例或其子类的实例，都会返回<code>TRUE</code>。</li><li>严格比较使用<code>is</code>操作符。</li></ol><hr><h2 id="slots类属性"><a href="#slots类属性" class="headerlink" title="slots类属性"></a><strong>slots</strong>类属性</h2><p><a href="http://stackoverflow.com/questions/472000/usage-of-slots" target="_blank" rel="noopener">Usage of <strong>slots</strong>?</a></p><ol><li>字典对实例很重要，<code>__dict__</code>属性跟踪所有实例属性。使用<code>inst.foo</code>和<code>inst.__dict__[&#39;foo&#39;]</code>访问属性是一样的。</li><li>字典会占用大量内存，如果有一个属性数量很少的类，但有很多实例，基于内存上的考虑，可以使用<code>__slots__</code>属性来代替<code>__dict__</code>属性。</li><li><code>__slots__</code>属性是一个类变量，由一序列型对象组成，由所有合法标识构成的实例属性的集合来表示，可以是列表，元组，可迭代对象，甚至在实例属性唯一时他可以是字符串。</li><li><code>__slots__</code>属性是“类型安全”的，不允许用户动态增加实例属性。带<code>__slots__</code>属性的类定义不会存在<code>__dict__</code>了。</li><li><code>__slots__</code>属性主要有两个优势，节约内存，访问属性速度更快。</li></ol><hr><h2 id="getattribute-特殊方法"><a href="#getattribute-特殊方法" class="headerlink" title="getattribute()特殊方法"></a><strong>getattribute</strong>()特殊方法</h2><ol><li>回忆<code>__getattr__()</code>特殊方法，当属性不能在实例或他的类或他的祖先类中的<code>__dict__</code>找到时，调用这个方法(在授权中，调用这个方法后调用<code>getattr()</code>内建函数来实现授权)。</li><li>使用一个函数来执行每一个函数的访问，不光是属性不能找到的情况。如果类同时定义了<code>__getattribute__()</code>及<code>__getattr__()</code>方法，除非明确从<code>__getattribute__()</code>调用<code>__getattr__()</code>或者引发<code>AttributeError</code>(<code>__getattr__()</code>捕获这个异常并执行)，否则后者不会被调用。</li><li>如果在<code>__getattribute__()</code>中不知何故再次调用了<code>__getattribute__()</code>，会引起无穷递归调用。因此总应该先调用祖先类的同名方法。</li></ol><hr><h2 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>描述符是表示对象属性的一个代理。</p><ol><li>描述符可以是任何类，至少实现了<code>__get__()</code>,<code>__set__()</code>,<code>__del__()</code>三个方法中的一个，这三个方法充当描述符协议的作用。实现方法不同具有不同的读写权限。</li><li>非数据描述符实现<code>__get__()</code>方法，是只读数据，也叫做方法描述符。数据描述符具有读写权限，实现了<code>__set__()</code>和<code>__get__()</code>方法。</li><li>如果想为一个属性写个代理，必须把他作为一个类的属性，让这个代理来完成所有的工作。考虑到上一节中每个属性实例都会调用的特殊方法<code>__getattribute__()</code>，他是描述符的核心。</li><li>如果<code>super()</code>被调用了，它会沿着<code>obj.__class__.__mro__</code>紧接着的继承树来查找属性。</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def __get__(self, obj, type=None) =&gt; value</span><br><span class="line">类X的实例x  x.foo    equals    type(x).__dict__[<span class="string">'foo'</span>].__get__(x,type(x))</span><br><span class="line">类X        X.foo    equals    X.__dict__[<span class="string">'foo'</span>].__get__(<span class="literal">None</span>,X)</span><br><span class="line">类X的子类Y  super(Y,obj).foo   X.__dict__[<span class="string">'foo'</span>].__get__(obj,X)</span><br><span class="line"></span><br><span class="line">def __set__(self, obj, val) =&gt; None</span><br><span class="line">def __delete__(self, obj) =&gt; None</span><br></pre></td></tr></table></figure><h3 id="优先级别"><a href="#优先级别" class="headerlink" title="优先级别"></a>优先级别</h3><ol><li>类属性 &gt; 数据描述符 &gt; 实例属性 &gt; 非数据描述符 &gt; 默认为<code>__getattr__()</code>。</li><li>非数据描述符的目的只是当实例属性值不存在时，提供的一个值而已。当没有找到非数据描述符，<code>__getattribute__()</code>将会抛出一个<code>AttributeError</code>异常，接着会调用<code>__getattr__()</code>作为最后一个操作。</li><li>优先级高的可以隐藏优先级低的属性。</li><li>函数是非数据描述符，实例属性有更高的优先级，可以遮蔽任何一个非数据描述符。只要把(另)一个(非数据描述符)对象赋给实例(属性)就行了。</li><li>静态方法、类方法、属性，甚至所有的函数都是描述符，描述符会根据函数的类型确定如何“封装”这个函数和函数被绑定的对象，然后返回调用对象。</li></ol><hr><h2 id="属性和property内建函数"><a href="#属性和property内建函数" class="headerlink" title="属性和property内建函数"></a>属性和property内建函数</h2><p><a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143186781871161bc8d6497004764b398401a401d4cce000" target="_blank" rel="noopener">使用@property</a><br><a href="http://www.howsoftworks.net/python/function/property.html" target="_blank" rel="noopener">property</a></p><ol><li>可以使用<code>property()</code>方法来处理实例属性的获取(<code>x.getter</code>)、赋值(<code>x.setter</code>)、删除(<code>x.deleter</code>)操作，在操作中可以对属性做一些合法值判断等功能。</li><li><code>property()</code>方法是他所在类被创建时调用的，实际上是将函数作为参数传递进去，这些方法(其实就是函数)是非绑定的。</li></ol><hr><h2 id="元类-metaclass"><a href="#元类-metaclass" class="headerlink" title="元类(metaclass)"></a>元类(metaclass)</h2><p><a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319106919344c4ef8b1e04c48778bb45796e0335839000" target="_blank" rel="noopener">使用元类</a><br><a href="http://blog.jobbole.com/21351/" target="_blank" rel="noopener">深刻理解Python中的元类(metaclass)</a><br><a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python" target="_blank" rel="noopener">What is a metaclass in Python?</a></p><ol><li>元类是类的类，即由元类创建类，由类创建实例，关键是元类中的<code>__new__()</code>方法和<code>type()</code>内建函数(唯一可以创建类的东西)。</li><li>元类一般用于创建类，解释器首先会查找类的关键字参数<code>metaclass</code>，如果没有传入，他会继续查找父类的关键字参数<code>metaclass</code>，直到<code>object</code>，<code>type(object)</code>即<code>type</code>类型，可以看到一个令人震惊的事实，<code>object</code>是<code>type</code>创建的。</li><li>元类用于改变类的默认行为和创建方式。</li></ol><p>运行以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime</span><br><span class="line"></span><br><span class="line">print(<span class="string">'1'</span>)</span><br><span class="line">print(<span class="string">'2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MetaA</span><span class="params">(type)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls,name,bases,attrd)</span>:</span></span><br><span class="line">        super(MetaA,cls).__init__(name,bases,attrd)</span><br><span class="line">        print(<span class="string">'4'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'3'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object,metaclass=MetaA)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'6'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'5'</span>)</span><br><span class="line">c = C()</span><br><span class="line">print(<span class="string">'7'</span>)</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;通用特性&quot;&gt;&lt;a href=&quot;#通用特性&quot; class=&quot;headerlink&quot; title=&quot;通用特性&quot;&gt;&lt;/a&gt;通用特性&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;类和类型统一，所有Python内建转换函数都是工厂函数。类名以及工厂函数可以创建类的新对象，还可以作为基类去子类
      
    
    </summary>
    
      <category term="Python" scheme="http://rylcode.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://rylcode.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python入门11-继承和授权</title>
    <link href="http://rylcode.cn/2017/01/13/Python%E5%85%A5%E9%97%A811-%E7%BB%A7%E6%89%BF%E5%92%8C%E6%8E%88%E6%9D%83/"/>
    <id>http://rylcode.cn/2017/01/13/Python入门11-继承和授权/</id>
    <published>2017-01-13T03:48:46.000Z</published>
    <updated>2020-05-13T12:18:58.429Z</updated>
    
    <content type="html"><![CDATA[<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>描述基类的属性遗传给派生类。</p><ol><li><code>__doc___</code>类属性不会从基类中遗传过来。</li><li><code>__bases__</code>类属性是包含父类集合的元组。</li><li>可以在子类中定义同名函数覆盖父类的函数方法(多态)。可以在子类中显式地(需要知道父类名)或通过<code>super()</code>内建方法(默认传递<code>self</code>)调用父类方法。</li><li>需要注意如果覆盖构造器<code>__init__()</code>方法，子类实例化时并不会自动调用父类的构造器，应该在子类中明确地调用父类的构造器。<ul><li><code>super(obj, ins)</code>传入两个参数，类和类的实例，Python3中参数默认值是当前类和<code>self</code>(当前类的实例)。</li></ul></li></ol><h3 id="派生标准类型"><a href="#派生标准类型" class="headerlink" title="派生标准类型"></a>派生标准类型</h3><p>正如元类调用<code>type()</code>，是类的类一样，标准类型也可以看做是类型的类，来派生出新的类型。</p><h4 id="不可变类型的派生"><a href="#不可变类型的派生" class="headerlink" title="不可变类型的派生"></a>不可变类型的派生</h4><ol><li>应该覆盖<code>__new__()</code>特殊方法来定制我们的对象，因为这个方法在<code>__init__(self)</code>执行之前执行并返回一个对象传入初始化方法<code>__init__(self)</code>(即这里的<code>self</code>)。</li><li><a href="https://zhuanlan.zhihu.com/p/21379984" target="_blank" rel="noopener">python 类中<strong>new</strong> 和 <strong>init</strong>方法区别</a></li></ol><h4 id="可变类型的派生"><a href="#可变类型的派生" class="headerlink" title="可变类型的派生"></a>可变类型的派生</h4><p>一般情况下，对可变类型继承到的类型的默认行为就是你想要的。</p><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>多重继承一般有两个问题，第一，找到合适的属性；第二，如何调用父类的方法以发挥他们的作用。</p><ol><li>方法解释顺序MRO(<code>Method Resolution Order</code>)，新式类出现之前是深度优先，之后是广度优先，新式类的<code>__mro__</code>属性会返回查找顺序。<ul><li><a href="http://www.cnblogs.com/lovemo1314/archive/2011/05/03/2035005.html" target="_blank" rel="noopener">python super()</a></li></ul></li><li>菱形效应引起的MRO问题，因为新式类都会从<code>object</code>中派生，如果采用深度优先，会多次回溯到<code>object</code>。这是不期望的。<ul><li>1中的链接很好的说明了这个问题，F的mro顺序FEBCDAob，E的MRO顺序EBCAob，C的MRO顺序CAob。、</li></ul></li></ol><h3 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h3><ol><li><code>subclass(sub,sup)</code>判断一个类是不是另一个类的子类或者子孙类。</li><li><code>isinstance(obj,OBJ)</code>判定一个对象是不是另一个给定类的实例。<ul><li>第二个参数是类。</li><li>他不会有性能上的问题，因为他只用来搜索类族集成结构，而且它是用C写的。</li></ul></li><li><code>hasattr(ins,attr)</code> 判断一个对象是否有特定的属性。</li><li><code>getattr(ins,attr)</code> 取得对象的属性。</li><li><code>setattr(ins,attr)</code> 赋值给对象的属性。</li><li><code>delattr(ins,attr)</code> 从一个对象中删除属性。</li><li><code>dir()</code><ul><li>作用于实例上，显示实例变量，还有实例所在类及所有他的基类中定义的方法和类。</li><li>作用于类上，显示类以及他的所有基类的<code>__dict__</code>中的内容。但他不会显示定义在元类(<code>metaclass</code>)中的类属性。</li><li>作用在模块上，显示模块的<code>__dict__</code>内容。</li><li>不带参数时，显示调用者的局部变量。</li></ul></li><li><code>super()</code> 帮助程序员找出相应的父类，然后方便调用相应的属性。<ul><li>使用<code>super()</code>来简化搜索一个合适祖先的任务，其主要是用来查找父类的属性。</li><li>实际上，<code>super()</code>是一个工厂函数，他创造了一个<code>super object</code>，为一个给定的类使用<code>__mro__</code>去查找相应的父类。</li></ul></li><li><code>var()</code> 内建函数与<code>dir()</code>相似，只是给定的对象参数必须有一个<code>__dict__</code>属性。返回一个字典，包含对象存储于其<code>__dict__</code>中的属性(键)和值。<ul><li>如果没有提供参数，他将显示一个包含本地名字空间的属性(键)及其值的字典，也就是<code>locals()</code>。</li></ul></li></ol><h3 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h3><p>之前的<code>__init__()</code>和<code>__del__()</code>也是自定义特殊方法的一部分，另外，Python的类定制包含：模拟标准类型，重载操作符。</p><ol><li>可以定制的方法有，属性方法，二进制操作符，一元操作符，数值转换，基本表示法，序列类型，映射类型。<ul><li>Python中有两个除法，<code>/</code>真除法<code>__truediv__()</code>是准确的浮点除法，<code>//</code>是<code>__floordiv__()</code>C++中的整型除法。</li><li><a href="http://stackoverflow.com/questions/1436703/difference-between-str-and-repr-in-python" target="_blank" rel="noopener">Difference between <strong>str</strong> and <strong>repr</strong> in Python</a>，<strong>unambiguous v.s. readable</strong>，从编译器角度和从读者角度，另外，如果<code>__repr__()</code>定义了，但<code>__str__()</code>没有定义，默认会有<code>__str__=__repr__</code>。</li><li><code>__str__()</code>只返回一个字符串(这是<code>print()</code>的重载)，如果想要打印多个字符串，请自定义其他类型的打印函数。</li></ul></li><li>重载<code>__iter__</code>和<code>next()</code>方法可以定制迭代器，无穷迭代可以通过随机选择<code>choice()</code>或者处理异常来实现。<ul><li><strong>所谓的安全模式</strong>：只是一个标识flag，在抓取到异常时，采用不同的决策。</li></ul></li><li><code>__nonzeros__()</code>可以为<code>object</code>定义<code>FALSE</code>值。</li><li><code>__cmp__</code>对象比较。</li></ol><hr><h2 id="私有化"><a href="#私有化" class="headerlink" title="私有化"></a>私有化</h2><h3 id="类的访问控制"><a href="#类的访问控制" class="headerlink" title="类的访问控制"></a>类的访问控制</h3><ol><li>在类的属性和方法名字前面加上<strong>双下划线</strong>提供了初步的类的私有化，不允许直接访问。在访问时，要在名字前边加上<strong>单下划线和类名</strong>来指定访问的是哪一个类的变量(<code>self._OBJ__attr</code>)。<ul><li>保证<code>__XXX</code>变量不与父类的名称空间冲突。</li></ul></li></ol><h3 id="模块级访问控制"><a href="#模块级访问控制" class="headerlink" title="模块级访问控制"></a>模块级访问控制</h3><ol><li>之前提到过模块级的私有化，在属性(或方法，因为这是严格基于作用域的)名称前加<strong>单下划线</strong>，这样不会被<code>from XXX import *</code>加载，但是可以显式载入。</li></ol><hr><h2 id="授权-enabling"><a href="#授权-enabling" class="headerlink" title="授权(enabling)"></a>授权(enabling)</h2><p>授权是包装的一个特性，包装一个类型通常是对已存在的类型的一些定制，可以新建、修改、删除原有产品的功能。其他保持原样或保留已存功能或行为。授权的过程，即所有更新的功能都是由新类的某部分来处理，但已存的功能就授权给对象的默认属性。</p><ol><li>关键：<font color="red">覆盖<code>__getattr__()</code></font>方法，代码中包含对<code>getattr()</code>内建函数的访问。<ul><li>引用一个属性时，Python解释器会依次在局部名称空间，类名称空间中搜索，如果都没有找到，搜索对原对象开始授权申请，<code>__getattr__()</code>会被调用。</li><li>对这些属性的访问，是通过<code>getattr(obj,atrr)</code>方法，授权给对象。而且只有已存在的属性是在此代码中授权的。</li><li>在包装中实现<code>get()</code>方法返回一个对象，因为有时需要访问实际对象和他的切片能力。</li></ul></li><li>时间戳。<a href="http://www.cnblogs.com/SRL-Southern/archive/2015/09/30/4848590.html" target="_blank" rel="noopener">2015/9/29 Python基础(20)：类的授权</a></li></ol><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;描述基
      
    
    </summary>
    
      <category term="Python" scheme="http://rylcode.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://rylcode.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python的实例方法，类方法，静态方法</title>
    <link href="http://rylcode.cn/2017/01/11/Python%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%8C%E7%B1%BB%E6%96%B9%E6%B3%95%EF%BC%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"/>
    <id>http://rylcode.cn/2017/01/11/Python的实例方法，类方法，静态方法/</id>
    <published>2017-01-11T07:14:06.000Z</published>
    <updated>2020-05-13T12:18:58.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="静态方法和类方法"><a href="#静态方法和类方法" class="headerlink" title="静态方法和类方法"></a>静态方法和类方法</h2><p>参考资料：</p><ol><li><a href="http://www.jianshu.com/p/212b6fdb2c50" target="_blank" rel="noopener">python类的静态方法和类方法区别</a>强调使用场景和继承。</li><li><a href="http://stackoverflow.com/questions/12179271/python-classmethod-and-staticmethod-for-beginner" target="_blank" rel="noopener">Python @classmethod and @staticmethod for beginner?</a>最高赞答案强调了重载，次高赞答案强调了继承。</li><li><a href="https://www.zhihu.com/question/20021164" target="_blank" rel="noopener">Python 中的 classmethod 和 staticmethod 有什么具体用途</a>最高赞答案强调了封装和使用场景。来自于<a href="https://link.zhihu.com/?target=http%3A//www.pythoncentral.io/difference-between-staticmethod-and-classmethod-in-python/" target="_blank" rel="noopener">Difference between @staticmethod and @classmethod in Python</a></li></ol><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ol><li>实例方法提供与类的实例对象进行交互的方法(针对实例特有的数据)，因此第一个参数必须传入实例对象，<code>一般习惯用self</code>。</li><li>类方法提供与类本身(类也是对象)交互的方法()，我们可以在类外定义一个简单方法将类作为参数传入来交互。这个参数如果传入实例对象，需要通过实例对象的<code>__class__</code>属性来访问类，如果是类对象，可以直接访问。但是这样就会将类代码关系扩散到类定义的外部，违背了OOP封装的特性。因此采用<code>@classmethod</code>装饰器来创建类方法与类交互，注意要与类交互，因此类方法的第一个参数必须传入类对象。</li><li>有一些与类有关系的功能但不需要类对象或者实例对象，这就需要静态对象，比如更改环境变量(控制一部分类功能)或者修改其他类的属性。用外部函数依然可以解决，但同样会扩散类内部代码，造成维护困难。因此采用<code>@staticmethod</code>装饰器，因为这些功能不需要类对象与实例对象，因此默认不需要传入任何参数。</li></ol><p>代码参见参考资料3，但代码对齐有一些问题。</p><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><ol><li>考虑C++中类构造函数的多样化可以通过函数重载(<code>overloading</code>)来实现，但Python中没有这个概念，如果只能有一个构造函数，对于不同的初始化参数，只能在类外做一些重复性的工作后传入唯一的构造函数来初始化。因此类方法<code>@classmethod</code>,通过给不同的类方法传入不同的初始化参数来实现多样化的初始化。<ul><li>可重复利用(reusable)，针对构造函数外部重复性的处理。</li><li>封装(Encapsulation)，将类代码关系封装在类内。</li><li>继承(inherit)，类方法与类关联，因此继承后依然存在于子类，但其属于子类。</li></ul></li><li>静态方法与类方法非常相似，但其不需要强制参数，因此可以做一些与类控制相关的环境变量或其他类属性的判断或更改。</li></ol><p>代码见参考资料2,3。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>如果子类继承父类方法，子类覆盖了父类的静态方法；</p><ol><li>子类实例继承父类的静态方法，调用该方法，还是调用父类的方法和类属性。其实可以认为是提供了一个子类访问父类属性的接口(就算子类重载了任何函数，这个静态函数的搜索也是从父类开始向上的，即屏蔽了子类的名称空间)。</li><li>子类实例继承父类的类方法，调用该方法，调用子类的方法和类属性。可以通过继承来覆盖类方法。</li></ol><p>代码参见资料1,2。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li>实例方法，只能被实例对象调用，第一个参数必须要传实例对象，一般习惯用<code>self</code>；</li><li>类方法(在类中由<code>@classmethod</code>装饰)，可以被实例对象和类调用，第一个参数必须要传类，一般习惯用<code>cls</code>；</li><li>静态方法(在类中由<code>@staticmethod</code>装饰)，可以被实例对象和类调用，参数没有要求。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_my1</span><span class="params">(self)</span>:</span>    </span><br><span class="line">        print(<span class="string">'实例方法&#123;&#125;'</span>.format(self.__class__))</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_my2</span><span class="params">(cls)</span>:</span> <span class="comment">#所属的类名</span></span><br><span class="line">        print(<span class="string">'类方法&#123;&#125;'</span>.format(cls.__name__))</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_my3</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'静态方法'</span>)</span><br><span class="line"></span><br><span class="line">x = foo()</span><br><span class="line"><span class="comment">#实例初始化只有两个属性__dict__(包含可用的属性名-属性字典)和__class__(指出该实例属于哪一类)</span></span><br><span class="line"><span class="comment">#foo.print_my1() 类不能调用实例方法</span></span><br><span class="line">foo.print_my2()</span><br><span class="line">foo.print_my3()</span><br><span class="line">x.print_my1()</span><br><span class="line">x.print_my2()</span><br><span class="line">x.print_my3()</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#error</span></span><br><span class="line">类方法foo</span><br><span class="line">静态方法</span><br><span class="line">实例方法&lt;<span class="class"><span class="keyword">class</span> '<span class="title">__main__</span>.<span class="title">foo</span>'&gt;</span></span><br><span class="line"><span class="class">类方法<span class="title">foo</span></span></span><br><span class="line"><span class="class">静态方法</span></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;静态方法和类方法&quot;&gt;&lt;a href=&quot;#静态方法和类方法&quot; class=&quot;headerlink&quot; title=&quot;静态方法和类方法&quot;&gt;&lt;/a&gt;静态方法和类方法&lt;/h2&gt;&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu
      
    
    </summary>
    
      <category term="Python" scheme="http://rylcode.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://rylcode.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python入门11-面向对象编程</title>
    <link href="http://rylcode.cn/2017/01/10/Python%E5%85%A5%E9%97%A811-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <id>http://rylcode.cn/2017/01/10/Python入门11-面向对象编程/</id>
    <published>2017-01-10T12:22:02.000Z</published>
    <updated>2020-05-13T12:18:58.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类简介"><a href="#类简介" class="headerlink" title="类简介"></a>类简介</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ol><li>类是对象的定义(蓝图)，而实例是真正的实物。<ul><li>类的定义：<code>class A(object):</code>，类就像一个Python类型容器；</li><li>通过继承来创建子类，子类继承基类的属性和方法，每个子类最好定义它自己的构造器，不然基类的构造器就会被调用(<code>__init__()</code>没有被覆盖)。</li><li>标准惯例：类名通常大写大头。</li><li>尽管类是对象，但正被定义时他还不是对象的实现(实例化才是)。</li></ul></li><li>所有的新式类必须继承至少一个类，<code>object</code>是所有类之母，如果一个类没有继承任何其他类，<code>object</code>将作为默认的父类，他位于所有类结构的最上层。一定在类名称后边加上<code>(object)</code>！<ul><li><code>__doc__</code>属性是类的文档字符串，他必须紧跟头行，并且不能被派生类继承，默认情况下派生类的这个属性为<code>None</code>。</li></ul></li><li>创建一个实例的过程称为实例化，通过函数操作符，以<strong>函数调用</strong>的形式出现。<ul><li>实例化认为是对<code>__init__()</code>的一种隐式的调用；</li><li>函数有下划线表示一般情况下这个函数不是直接供调用的。</li></ul></li><li>最简单的类可以仅作为容器来共享容器空间。</li><li>实例的属性是动态的，不需要在任何地方预先声明或者赋值。<ul><li>通过句点标识符访问类的属性。</li></ul></li></ol><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>通常的实例方法调用：定义类；创建实例；通过实例调用方法。</p><ol><li>实例方法传<code>self</code>(约定俗成，相当于<code>this指针)，类方法传</code>cls`(约定俗成)，静态方法不需要强制传任何参数。</li><li>类方法和类属性不能重名。</li></ol><p><a href="http://rylcode.cn/2017/01/11/Python%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%8C%E7%B1%BB%E6%96%B9%E6%B3%95%EF%BC%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/">Python的实例方法，类方法，静态方法</a></p><hr><h2 id="面对对象"><a href="#面对对象" class="headerlink" title="面对对象"></a>面对对象</h2><p><a href="http://rylcode.cn/2016/05/21/%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E4%B8%8E%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0/">OOP特性</a></p><ol><li>抽象：对现实世界和实体的本质表现、行为和特征建模。<ul><li>对模型接口以及抽象数据的现实化(<code>realization</code>)</li></ul></li><li>封装/接口：对数据/信息进行隐藏，对数据属性提供接口和访问函数。<ul><li>限制不规范的操作对数据属性的访问。</li></ul></li><li>合成：扩充了对类的描述，使得多个不同类合成为一个大的类，来解决现实问题。</li><li>派生/继承/继承结构：子类保存父类中所有需要的数据和类型，但允许修改或定义其他的自定义操作，但不会修改父类的定义。</li><li>泛化/特化：子类与其父类以及祖先类有一样的特点，即<code>is-a</code>关系。</li><li>多态：对象通过共同的属性或动作来操作访问，不需要考虑具体的类。即动态(运行时)绑定，允许重载以及运行时类型确定和验证。</li><li>自省/反射：对象在运行时取得自身信息。即Java中的反射，C++中的运行阶段类型推断RTTI。<ul><li><code>type()</code>判断类型。</li><li><code>dir()</code>返回对象的属性列表。</li><li><code>var(obj)</code>返回实例属性构成的字典，即<code>__dict__</code>特殊属性。</li></ul></li></ol><hr><h2 id="类属性，实例，实例属性"><a href="#类属性，实例，实例属性" class="headerlink" title="类属性，实例，实例属性"></a>类属性，实例，实例属性</h2><h3 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h3><ol><li>属性就是属于一个对象的数据或者函数元素，属性同时也是一个对象，他拥有自己的属性，因此会有属性链这一现象。</li><li>主要使用的属性是实例属性，当且仅当需要更加静态的数据时才会使用类数据属性，即静态变量，静态数据。</li><li>通常的方法必须绑定(<code>binding</code>)才能被直接调用，非绑定方法可以被调用，但实例对象一定要明确给出，才能确保调用成功(派生类构造函数通过基类调用基类的构造函数)。</li><li>使用<code>dir()</code>和特殊类属性<code>__dict__</code>来查看类的属性。<ul><li><code>dir()</code>内建函数可接受模块，类，实例对象。如果不传入参数，和<code>locals()</code>一样。</li></ul></li><li><code>type()</code>被调用对象的类型，他的类型是<code>type</code>，被调用对象的类型<code>type().__name__</code>来访问。</li><li><code>__doc__</code>特殊属性，不能被派生类继承。</li><li><code>__bases__</code>用来处理继承，包含由所有父类组成的元组。</li><li><code>__module__</code>返回类所有模块的字符串表示。</li></ol><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ol><li>类是一种数据结构定义类型，实例则声明了一个这种类型的变量。当你定义了一个类后，已经创建了一个新的类型。</li><li>定义或覆盖<code>__init__()</code>方法。缺省时不进行任何操作，注意对于不可变类型的类属性，同名的实例属性会覆盖他，但对于可变类型的类属性，二者是同一个对象，这样类、所有实例都可以修改这个属性。</li><li><code>__new__()</code>方法来继承不可变数据类型(<code>int</code>,<code>str</code>,<code>tuple</code>等)来定制数据类型；或者用在元类，定制创建类对象。<ul><li><code>__new__()</code>方法是一个静态方法，他在<code>__init__(self)</code>执行之前执行并返回一个对象传入初始化方法<code>__init__(self)</code>(即这里的<code>self</code>)</li><li><a href="https://zhuanlan.zhihu.com/p/21379984" target="_blank" rel="noopener">python 类中<strong>new</strong> 和 <strong>init</strong>方法区别</a></li><li><a href="http://blog.jobbole.com/21351/" target="_blank" rel="noopener">深刻理解Python中的元类(metaclass)</a></li><li><a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python" target="_blank" rel="noopener">What is a metaclass in Python?</a></li></ul></li><li><code>__del__()</code>解构器方法，由于Python的垃圾回收机制是靠引用计数的，这个函数要直到该实例对象所有的引用计数都被清除掉后才会执行。<ul><li>也就是说这个函数只会被调用一次(引用计数为0的时候)；</li><li>在子类<code>__del__()</code>中不要忘记调用父类的<code>__del__()</code>;</li><li><code>del x</code>表示引用计数减1，不表示结构器方法被调用。</li></ul></li></ol><h3 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h3><ol><li>实例属性是与实例相关联的数据值，构造器<code>__init__()</code>是设置这些属性的关键点。</li><li>可以使用默认参数来设置默认的实例属性(注意默认参数应该是不变的对象)。</li><li><code>__init__()</code>应该返回<code>None</code>，因为实例对象是在实例化调用后返回的，如果返回其他值会产生冲突。</li><li><code>dir()</code>内建函数和<code>__dict__</code>属性可以查看所有的属性。<ul><li>不要修改<code>__dict__</code>字典，使用句点标识符来修改属性；</li><li>内建类型也是类，他可以<code>dir()</code>，但不存在<code>__dict__</code>属性(因为这个属性只有通过类工厂<code>type()</code>产生的类才有)。</li></ul></li></ol><h3 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h3><ol><li>类属性可通过类或实例来访问，但是任何对实例属性的赋值都会创建一个实例属性(如果不存在)并且对其赋值(这里指不可变对象，因为不可变对象在赋值时会创建一个新的对象)。</li><li>但是在类属性是可变类型的情况下会不同，可变对象在赋值过程中并没有必要产生新的对象，这样会造成实例和类的数据污染。</li><li>类属性是静态成员，当一个实例被修改后才创建，那么更新的值就将生效，类属性的修改会影响到所有的实例。</li></ol><hr><h2 id="绑定，组合"><a href="#绑定，组合" class="headerlink" title="绑定，组合"></a>绑定，组合</h2><h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><ol><li>实例方法是绑定在实例上的，只有通过实例才能调用这种绑定方法。没有实例时方法就是未绑定的。<code>self</code>变量用于在实例中引用方法所绑定的实例。</li><li>没有实例调用非绑定方法，例如在子类中覆盖父类的构造方法，这时没有父类实例，需要将子类中的<code>self</code>传入父类的构造方法，因为这时子类对象没有进行任何定制，可用来代替父类对象，构造后再进行定制。</li></ol><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><ol><li>通过组合(<code>composition</code>)让不同的类混合并加入到其他类中，来增加功能和可重用性。这是<code>has-a</code>关系(这在C++中通过包含或者私有/保护继承来体现)，因为这些类都不相同，每一个类管理他们自己的名字空间和行为。</li><li>另一种方法通过派生(<code>derived</code>)，它们具有更接近的关系，强调<code>is-a</code>关系，用于当你需要一些相似的对象，但却有少许不同不同功能的时候。</li></ol><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;类简介&quot;&gt;&lt;a href=&quot;#类简介&quot; class=&quot;headerlink&quot; title=&quot;类简介&quot;&gt;&lt;/a&gt;类简介&lt;/h2&gt;&lt;h3 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;headerlink&quot; title=&quot;类&quot;&gt;&lt;/a&gt;类&lt;/h3&gt;&lt;ol&gt;
&lt;
      
    
    </summary>
    
      <category term="Python" scheme="http://rylcode.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://rylcode.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python入门10-模块</title>
    <link href="http://rylcode.cn/2017/01/09/Python%E5%85%A5%E9%97%A810-%E6%A8%A1%E5%9D%97/"/>
    <id>http://rylcode.cn/2017/01/09/Python入门10-模块/</id>
    <published>2017-01-09T11:38:23.000Z</published>
    <updated>2020-05-13T12:18:58.429Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模块基础"><a href="#模块基础" class="headerlink" title="模块基础"></a>模块基础</h2><ol><li>自我包含并且有组织的代码片段就是模块。把其他模块中属性附件到你的模块中的操作叫做导入。</li><li>模块按照逻辑来组织Python代码方法，文件是物理层组织模块的方法。<ul><li>一个文件被看作一个独立模块，一个模块也被看作是一个文件。</li><li>模块的文件名就是模块的名字加上扩展名.py。</li></ul></li><li>一个名称空间就是一个从名称到对象的关系集合映射。所以每个模块都定义了自己的唯一的名称空间。<ul><li>即使属性之间有名称冲突，但他们的完整授权名称——据点属性标识指定了各自的名称空间(防止名称冲突)。</li></ul></li><li>默认搜索路径是在编译时或者安装时指定的。他可以在一个或者两个地方修改。路径模块<code>import sys</code>。<ul><li><code>sys.path</code>包含每个独立路径的列表，那么显然<code>sys.path.append()</code>可以添加搜索的路径，<code>sys.path.insert(pos, val)</code>可以指定插入位置。</li><li><code>sys.modules</code>可以找到当前导入了哪些模块以及他们来自哪里，返回值是一个字典，模块名是<code>key</code>，对应物理地址是<code>val</code>。</li></ul></li><li>名称空间是名称到对象的映射，改变一个名字叫做重新绑定，删除一个名字叫做解除绑定。<ul><li>局部名称空间，全局名称空间，内建名称空间(<code>__buildins__</code>模块中的名字)，从前往后搜索名称，从后往前加载。</li><li><code>globals()</code>和<code>locals()</code>内建函数得到全局/当前符号表字典。可以用于判断某一名字属于哪个名称空间。</li></ul></li><li><code>__name__</code>系统变量可以在运行时检测该模块是被导入还是被直接执行。<ul><li>如果模块是被导入，<code>__name__</code>的值为模块名字。</li><li>如果模块是被直接执行，<code>__name__</code>的值是<code>__main__</code>。</li><li>利用这个特性在主程序中书写测试代码。</li></ul></li><li>明白名称查询的规则，就很容易理解遮蔽效应。名称查询首先从局部名称空间开始，然后查找全局名称空间，然后在内建名称空间里查找。</li><li>可以在任何需要防止数据的地方获得一个名称空间，比如可以在任何时候给函数添加属性。 </li></ol><hr><h2 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h2><ol><li>建议按顺序导入模块，Python标准库模块-&gt;Python第三方模块库-&gt;应用程序自定义模块。</li><li>可以在模块中导入指定属性。即吧指定名称导入当前作用域。</li><li>多行导入，使用逗号分隔属性，使用<code>\</code>来自动换行，建议使用Python标准分组机制(圆括号)来创建更合理的多行导入语句。</li><li>在<code>import</code>语句之后使用<code>as</code>在导入的同时指定局部绑定名称。</li><li>一个模块只能被加载一次，加载只在第一次导入时发生。<ul><li>限制使用<code>from module import *</code>，因为会污染名称空间。</li><li>在交互解释器或者目标模块属性非常多时可以全部导入。</li></ul></li><li>属性名称可能冲突时，建议使用<code>import</code>和完整的标识符名称(句点属性标识)。</li><li><code>__future__</code>导入新的特性。</li><li>警告框架，警告用户不要使用一个即将改变或不支持的操作，包含几个部分：<ul><li>API：调用API发布警告，使用warnings模块。</li><li>一些警告异常类的集合：Warning，UserWarning，DeprecationWarning,SyntaxWarning和RunningWarning等。</li><li>警告过滤器：不仅仅收集关于警告的信息(如信号，警告原因等)，控制是否忽略警告，是否显示警告(可以自定义格式)，或者转化为错误生成一个异常等。</li></ul></li><li>从zip文件中导入模块。</li><li>编写可调用的<code>import</code>类来重新实现整个导入机制，需要实现查找器和载入器。<ul><li><code>import</code>语句调用<code>__import()__</code>函数完成工作，提供这个函数是为了让有特殊需求的用户覆盖他，实现自定义的导入算法。</li></ul></li></ol><hr><h2 id="包和其他特性"><a href="#包和其他特性" class="headerlink" title="包和其他特性"></a>包和其他特性</h2><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><ol><li>包是一个有层次的文件目录结构，他定义了一个由模块和子包组成的Python应用程序执行环境。</li><li>可以通过<code>最顶层的包.子包.模块</code>来导入；也可以通过<code>from 最顶层的包 import 子包</code>然后使用 属性/点 操作符向下引用子包树；也可以<code>from 最顶层的包.子包 import 模块</code>来导入模块；甚至可以沿着子包的树状结构导入子包中模块的名称空间<code>from 最顶层的包.子包.子包中模块 import something</code>。</li><li>绝对导入是指导入的包通过Python路径(<code>sys.path</code>或者<code>PYTHONPATH</code>)，<code>.</code>表示导入同目录下的模块，<code>..</code>表示导入不同目录下的模块(他们都包含在同一个最顶层的包中)。<ul><li><a href="http://python3-cookbook.readthedocs.io/zh_CN/latest/c10/p03_import_submodules_by_relative_names.html" target="_blank" rel="noopener">使用相对路径名导入包中子模块</a></li></ul></li></ol><h3 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h3><ol><li>自动载入的模块：内建模块，在Python2.x中命名是<code>__builtin__</code>，在Python3.x中命名是<code>builtins</code>。而不论是2还是3中，<code>__builtins__</code>都是对内建模块的引用。不同的是，在主模块<code>__main()__</code>中，其是对内建模块本身的引用；而在非<code>__main()__</code>中，其仅仅是对<code>__buildin__/builtins.__dict__</code>的引用，他的类型是字典。<ul><li><a href="http://www.52ij.com/jishu/665.html" target="_blank" rel="noopener">Python中的内建模块</a></li></ul></li><li>阻止属性导入：如果不想让某个模块被<code>from module import *</code>导入，可以在模块中给不想导入的属性名称加下划线(<code>_</code>，例如<code>bar</code>-&gt;<code>_bar</code>)，但是加上下划线之后怎么导入模块？可以导入整个模块(<code>import foo</code>)或者显式导入这个属性(<code>import foo._bar</code>)。</li><li>不区分大小写的导入，必须指定一个<code>PYTHONCASEOK</code>的变量。</li><li>源代码编译，<a href="http://www.crifan.com/python_head_meaning_for_usr_bin_python_coding_utf-8/" target="_blank" rel="noopener">关于Python脚本开头两行的：#!/usr/bin/python和# -<em>- coding: utf-8 -</em>-的作用 – 指定文件编码类型</a></li><li>导入循环，循环引用的问题。删除导入语句；或者将导入语句移到最后；或者将导入语句放在函数内部，只在调用函数的时候导入这个模块。</li><li>模块执行：通过命令行，shell，execfile()，模块导入，解释器的<code>-m</code>选项等。</li></ol><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;模块基础&quot;&gt;&lt;a href=&quot;#模块基础&quot; class=&quot;headerlink&quot; title=&quot;模块基础&quot;&gt;&lt;/a&gt;模块基础&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;自我包含并且有组织的代码片段就是模块。把其他模块中属性附件到你的模块中的操作叫做导入。&lt;/li&gt;
&lt;li&gt;模块按
      
    
    </summary>
    
      <category term="Python" scheme="http://rylcode.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://rylcode.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python入门9-函数和函数式编程</title>
    <link href="http://rylcode.cn/2017/01/06/Python%E5%85%A5%E9%97%A89-%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://rylcode.cn/2017/01/06/Python入门9-函数和函数式编程/</id>
    <published>2017-01-06T03:09:07.000Z</published>
    <updated>2020-05-13T12:18:58.435Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol><li>python的过程就是函数，因此解释器会隐式返回默认值<code>None</code>。即如果保存一个没有返回值的函数的返回值，该值就为<code>None</code>。</li><li>Python里的函数可以返回一个值或者对象。由于元组语法上不一定需要圆括号，会让人以为可以返回多个对象，实际上是一个元组。<ul><li>元组的保存方式也有三种，整个元组变量，单一变量，带圆括号的单一变量。</li></ul></li></ol><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><ol><li>函数操作符<code>()</code>相当于类的实例化。</li><li>允许参数缺失或者不按顺序，解释器能通过给出的关键字来匹配参数的值。关键字参数结合默认参数可以跳过缺失参数。</li><li>默认参数，给参数赋予默认值，和C++中一样。</li><li>使用<code>*</code>和<code>**</code>指定元组和字典作为非关键字参数和关键字参数组。完整语法为(所有参数都是可选的)：<br> <code>func(positional_args,keyword_args,*tuple_grp_nonkw_args,**dict_grp_kw_args)</code></li></ol><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ol><li><code>def</code>关键字，函数的名字，参数集合。建议添加文档字串和函数体。</li><li>定义和声明有区别的语言，往往是因为函数的定义可能和其声明放在不同的文件中。Python将二者视为一体，函数由声明的标题和随后的定义体组成。</li><li>在a函数定义中的b函数调用不会出现前向引用问题，除非在a函数调用的时候b函数依然没有被定义。</li><li>句点属性标识，意味着不同的命名空间。函数声明中不能访问属性，因为此时函数体还没有被创建。定义后通过<font color="red">函数名</font>(而不是实例名)和句点属性标识来访问修改属性值。</li><li>内部/内嵌函数：整个函数体在外部函数的作用域，或者lambda表达式。<ul><li>如果内部函数定义包含了外部函数内定义的对象的引用，内部函数会成为<strong>闭包</strong>(传递了作用域)。</li></ul></li><li>装饰器：以<code>@</code>开头，需要返回<font color="red">函数对象</font>，实际上是把要装饰的函数参数传递给装饰器。其返回的函数对象是一个包装了的函数。并将其重新赋值为原来的标识符，并永久失去对原始函数对象的访问。<ul><li><a href="http://coolshell.cn/articles/11265.html" target="_blank" rel="noopener">PYTHON修饰器的函数式编程</a></li><li>下边是类式的装饰器。</li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myDecorator</span><span class="params">(object)</span>:</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fn)</span>:</span><span class="comment">#装饰时调用</span></span><br><span class="line">        print(<span class="string">"inside myDecorator.__init__()"</span>)</span><br><span class="line">        self.fn = fn</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span><span class="comment">#调用时调用</span></span><br><span class="line">        self.fn()</span><br><span class="line">        print(<span class="string">"inside myDecorator.__call__()"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="meta">@myDecorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aFunction</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"inside aFunction()"</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Finished decorating aFunction()"</span>)</span><br><span class="line"> </span><br><span class="line">aFunction()</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inside myDecorator.__init__()</span><br><span class="line">Finished decorating aFunction()</span><br><span class="line">inside aFunction()</span><br><span class="line">inside myDecorator.__call__()</span><br></pre></td></tr></table></figure><h3 id="函数传递"><a href="#函数传递" class="headerlink" title="函数传递"></a>函数传递</h3><ol><li>所有对象都是通过引用传递的，函数也不例外。因此可以将函数作为参数传入其他函数来调用。函数内部通过函数操作符<code>()</code>来调用函数。</li></ol><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><ol><li>按照被调用函数中定义的顺序来准确传递参数(就像C++一样)</li><li>默认参数：和C++一样，在函数声明中使用赋值运算符。<ul><li>所有的必需的参数都必须在默认参数之前。否则编译器无法确定匹配方式。</li><li>使用关键字参数可以不按顺序提供参数，也可以用于跳过缺失参数。 </li><li>默认参数<font color="red">一定要是不可变对象</font>，否则不同的实例会操作同一个对象，实例之间会有数据污染。参考<a href="http://cenalulu.github.io/python/default-mutable-arguments/" target="_blank" rel="noopener">Python函数参数默认值的陷阱和原理深究</a>。</li></ul></li></ol><h3 id="可变长度参数"><a href="#可变长度参数" class="headerlink" title="可变长度参数"></a>可变长度参数</h3><ol><li>函数调用时，形参将值赋给函数声明中相对应的局部变量。剩下的非关键字参数按顺序插入到一个元组中便于访问，关键字参数按顺序插入到一个字典中便于访问。</li><li>使用星号操作符<code>*</code>和双星号操作符<code>**</code>之后标识的形参将参数传递给函数。<ul><li><code>**</code>是被重载的，因为他也可以表达幂运算。</li><li>函数声明中所有的形参必须位于非正式的参数之前。</li><li>关键字字典必须是最后一个参数且非关键字参数在他之前。</li></ul></li><li>如果在函数调用之外创建传入的字典和元祖，函数内部最终接受的元组和字典是被调函数的超集。</li></ol><hr><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><ol><li>这种语句的目的是由于性能的原因，在调用时绕过函数的栈分配。</li><li>默认参数和可变参数是允许的。</li></ol><h3 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h3><ol><li><code>filter(function, iterable)</code>-&gt;<code>function</code>重构为<code>labmda</code>-&gt;<code>filter</code>重构为列表解析式(<code>filter</code>相当于列表解析中的<code>if</code>)-&gt;重构为嵌套的列表解析。</li><li><code>map(function, iterable, ...)</code>映射函数-&gt;<code>function</code>重构为<code>labmda</code>-&gt;(在处理单个序列时)重构为列表解析(<code>for...in...</code>迭代循环)。<ul><li><code>...</code>表示多个序列传入<code>function</code>。</li><li><code>map</code>函数在<code>function</code>为<code>None</code>时可以将不相关的序列归并在一起，相当于<code>zip</code>。</li><li><code>map</code>独特的优势在于处理多个序列的映射。</li></ul></li><li><code>functools.reduce(function, iterable,initializer)</code>将列表元素减少为单一的值，如果给定初始化器，那么一开始的迭代会用初始化器和一个序列的元素进行，接着会正常进行。<ul><li><a href="https://docs.python.org/3/library/functools.html" target="_blank" rel="noopener">functools.reduce(function, iterable[, initializer]</a>可以看到代码逻辑。</li><li><code>reduce((labmda:x,y:x+y),range(5))</code> = <code>((((0 + 1) + 2) + 3) + 4)</code></li></ul></li></ol><h3 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h3><p>PFA:<a href="https://docs.python.org/3/library/functools.html" target="_blank" rel="noopener">Partial Function Apply</a></p><ol><li><code>functools.partial(func, *args, **keywords)</code>创建PFA。</li><li>参数顺序传入<code>func</code>，可以使用关键字参数且其总是出现在形参之后。</li></ol><hr><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><ol><li>全局变量的一个特征是除非被删除掉，否则他们会存活到脚本运行结束。</li><li>Python会先从局部作用域开始搜索，如果在局部作用域内没有找到，那么会在全局作用域或者内建作用域中找到这个变量，否则就会抛出<code>NameError</code>异常(LGB原则)。</li><li>由2的规则可知，通过创建一个局部变量来隐藏全局变量是有可能的。</li><li><code>if</code>,<code>try</code>,<code>for</code>不会产生新的作用域，<code>def</code>,<code>class</code>,<code>lambda</code>等才会产生。</li></ol><h3 id="global语句"><a href="#global语句" class="headerlink" title="global语句"></a>global语句</h3><ol><li>在局部作用域中通过<code>global</code>语句来明确引用一个已命名的全局变量。</li><li>如果不明确引用，只要不定义同名变量局部编译器依然会搜索到全局变量。</li></ol><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ol><li>如果在一个函数内，对外部作用域(但不是全局作用域)的变量进行引用，那么内部函数就被认为是闭包。这是函数式编程中一个很重要的概念。</li><li>闭包仅仅是带了额外特征的函数—另外的作用域。</li></ol><h3 id="lambda-1"><a href="#lambda-1" class="headerlink" title="lambda"></a>lambda</h3><ol><li><code>lambda</code>表达式定义了新的作用域。</li></ol><h3 id="变量作用域和名称空间"><a href="#变量作用域和名称空间" class="headerlink" title="变量作用域和名称空间"></a>变量作用域和名称空间</h3><ol><li>从函数内部，局部作用域包围了局部名称空间，第一个搜寻名字的地方。如果名字存在的话，那么将跳过检查全局作用域。</li></ol><hr><h2 id="递归与生成器"><a href="#递归与生成器" class="headerlink" title="递归与生成器"></a>递归与生成器</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ol><li>函数内部包含对函数自身的调用，和C++一样。</li></ol><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><h4 id="生成器的动机"><a href="#生成器的动机" class="headerlink" title="生成器的动机"></a>生成器的动机</h4><ol><li>函数可以在迭代中以某种方式生成下一个值并且返回和<code>next()</code>调用一样。</li><li>协同程序：函数可以暂停或者挂起，并从程序离开的地方继续或者开始。</li><li>挂起返回出中间值并多次继续的协同程序被成为生成器。</li></ol><h4 id="生成器的定义"><a href="#生成器的定义" class="headerlink" title="生成器的定义"></a>生成器的定义</h4><ol><li>函数中使用<code>yield</code>关键字，当到达一个真正的返回或者函数结束没有更多的值返回，会抛出一个<code>StopIteration</code>异常。</li><li>获得和保存一个生成器对象之后，使用<code>next(obj)</code>或者<code>obj.__next__()</code>来生成下一个值。</li><li>生成器不停的挂起或者继续，其状态是保留的，那么当在生成的过程中如何动态调整生成的值？这就需要介绍<code>send()</code>函数。<ul><li><code>yield val</code>这个表达式是有返回值的，<code>next(obj)</code>其实相当于<code>send(None)</code>，默认情况下返回的是<code>None</code>，可以通过<code>send(val)</code>将值传入生成器。用参数接收表达式的值。</li><li><code>send(val)</code>让生成器继续，将表达式的值赋给变量(必须要有接受输入的参数)，然后调用<code>next(obj)</code>。</li></ul></li></ol><p>输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counter</span><span class="params">(start_at = <span class="number">0</span>)</span>:</span></span><br><span class="line">count = start_at</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">val = (<span class="keyword">yield</span> count)</span><br><span class="line"><span class="keyword">if</span> val <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">count = val</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">cnt = counter(<span class="number">5</span>)</span><br><span class="line">next(cnt)</span><br><span class="line">next(cnt)</span><br><span class="line">cnt.send(<span class="number">9</span>)</span><br><span class="line">next(cnt)</span><br><span class="line">cnt.close()</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;函数基础&quot;&gt;&lt;a href=&quot;#函数基础&quot; class=&quot;headerlink&quot; title=&quot;函数基础&quot;&gt;&lt;/a&gt;函数基础&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h
      
    
    </summary>
    
      <category term="Python" scheme="http://rylcode.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://rylcode.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python入门8-错误和异常</title>
    <link href="http://rylcode.cn/2017/01/04/Python%E5%85%A5%E9%97%A88-%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8/"/>
    <id>http://rylcode.cn/2017/01/04/Python入门8-错误和异常/</id>
    <published>2017-01-04T06:24:53.000Z</published>
    <updated>2020-05-13T12:18:58.434Z</updated>
    
    <content type="html"><![CDATA[<p>错误是语法和逻辑上的，当Python检测到一个错误时，解释器就会指出当前流已经无法继续执行下去了，这时候就出现了异常。</p><hr><h2 id="Python中的异常"><a href="#Python中的异常" class="headerlink" title="Python中的异常"></a>Python中的异常</h2><p><a href="https://docs.python.org/3/library/exceptions.html" target="_blank" rel="noopener">Exception hierarchy</a>，所有的标准/内建异常都是从根异常派生的。目前的Python3有4个直接从BaseException派生的异常子类：</p><ol><li>SystemExit</li><li>KeyboardInterrupt</li><li>GeneratorExit</li><li>Exception</li></ol><p>其他所有的内建异常都是Exception的子类。</p><hr><h2 id="检测和处理异常"><a href="#检测和处理异常" class="headerlink" title="检测和处理异常"></a>检测和处理异常</h2><h3 id="try…except…"><a href="#try…except…" class="headerlink" title="try…except…"></a>try…except…</h3><ol><li>使用<font color="red"><code>as</code></font>关键字将错误捕获为异常参数。</li><li>为用户可能遇到的返回错误写文档。比如显式的返回None或者负数(如果可以表征无效值)，来规范代码。</li><li>带有多个<code>except</code>的<code>try</code>语句，匹配不同的异常来执行对应的动作。</li><li>处理多个异常的<code>except</code>语句，可以在一个<code>except</code>语句中处理多个异常，但使用<code>as</code>捕获异常参数时，被赋值的是所触发的特定异常。</li><li>不指定任何异常，可以捕获所有异常。</li><li>不要捕获并忽略(<code>pass</code>)所有错误，可以捕获并忽略特定错误。</li><li>异常参数是导致异常的代码的诊断信息的类实例。</li></ol><h3 id="try…finally…"><a href="#try…finally…" class="headerlink" title="try…finally…"></a>try…finally…</h3><ol><li>这个语句不用来捕捉异常，无论<code>try</code>是否有异常被触发，<code>finally</code>代码段都会被执行。</li><li>当<code>try</code>范围中产生一个异常时，会立即跳转到<code>finally</code>语句段。当<code>finally</code>中的所有代码都执行完毕后，会继续向上一层引发异常。</li><li>如果<code>finally</code>中的代码引发了另一个由于<code>return</code>,<code>break</code>,<code>continue</code>语法而终止，原来的异常将丢失且无法重新引发。</li></ol><h3 id="try…except…finally…"><a href="#try…except…finally…" class="headerlink" title="try…except…finally…"></a>try…except…finally…</h3><ol><li>无论异常是否发生，是否捕捉都会执行的一段代码。</li></ol><h3 id="try…except…else…"><a href="#try…except…else…" class="headerlink" title="try…except…else…"></a>try…except…else…</h3><ol><li>在<code>try</code>范围内没有异常被检测到时，执行<code>else</code>子句。</li></ol><h3 id="try…except…else…finally…"><a href="#try…except…else…finally…" class="headerlink" title="try…except…else…finally…"></a>try…except…else…finally…</h3><ol><li>无论选择什么语法，至少需要一个<code>except</code>，<code>else</code>和<code>finally</code>都是可选的。</li></ol><p>所有的异常处理语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">doSomething</span><br><span class="line"><span class="keyword">except</span> Exception1:</span><br><span class="line">doSomethingForE1</span><br><span class="line"><span class="keyword">except</span> (Exception2,Exception3,Exception4):</span><br><span class="line">doSomethingForE2||E3||E4</span><br><span class="line"><span class="keyword">except</span> Exception5 <span class="keyword">as</span> e5:</span><br><span class="line">doSomethingForE5</span><br><span class="line"><span class="keyword">except</span> (Exception6,Exception7,Exception8) <span class="keyword">as</span> e6||e7||e8</span><br><span class="line">doSomethingForE6||E7||E8</span><br><span class="line">note that e6||e7||e8 <span class="keyword">is</span> only the one Exception that cause error.</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">catch all the other exceptions</span><br><span class="line"><span class="keyword">else</span>:</span><br></pre></td></tr></table></figure><hr><h2 id="上下文管理"><a href="#上下文管理" class="headerlink" title="上下文管理"></a>上下文管理</h2><p><code>with</code>语句的目的在于从流程图中把<code>try</code>,<code>except</code>,<code>finally</code>关键字和资源分配释放相关代码统统去掉。<br>支持上下文管理协议的成员：</p><ol><li>file</li><li>decimal.Context</li><li>thread.LockType</li><li>threading.Lock</li><li>threading.RLock</li><li>threading.Condition</li><li>threading.Semaphore</li><li>threading.BoundedSemaphore</li></ol><p>file是最常见且最易于演示的(通常见到<code>with</code>用于打开文件)。</p><hr><h2 id="触发异常"><a href="#触发异常" class="headerlink" title="触发异常"></a>触发异常</h2><p>异常除了由解释器引发，还可以由程序员明确触发：<code>raise</code>语句。<br><code>raise SomeException args traceback</code></p><ol><li><code>SomeException</code>:触发异常的名字。</li><li><code>args</code>:异常参数，可以是一个单独对象，或者是一个元组。</li><li><code>traceback</code>:跟踪记录对象，用于重新引发异常。</li></ol><hr><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p><code>assert</code>和C++中用法基本相同，只不过不需要括号需要空格分隔关键字和表达式。</p><hr><h2 id="sys模块和异常"><a href="#sys模块和异常" class="headerlink" title="sys模块和异常"></a>sys模块和异常</h2><p><code>sys</code>模块中的<code>exc._info()</code>函数返回一个三元组来提供关于异常更多的消息。</p><ol><li><code>exc_type</code>:异常类；</li><li><code>exc_value</code>:异常类的实例；</li><li><code>exc_traceback</code>:跟踪记录对象。</li></ol><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;错误是语法和逻辑上的，当Python检测到一个错误时，解释器就会指出当前流已经无法继续执行下去了，这时候就出现了异常。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Python中的异常&quot;&gt;&lt;a href=&quot;#Python中的异常&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="Python" scheme="http://rylcode.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://rylcode.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>缺月挂疏桐，漏断人初静</title>
    <link href="http://rylcode.cn/2017/01/03/%E7%BC%BA%E6%9C%88%E6%8C%82%E7%96%8F%E6%A1%90%EF%BC%8C%E6%BC%8F%E6%96%AD%E4%BA%BA%E5%88%9D%E9%9D%99/"/>
    <id>http://rylcode.cn/2017/01/03/缺月挂疏桐，漏断人初静/</id>
    <published>2017-01-03T02:05:38.000Z</published>
    <updated>2020-05-13T12:18:58.460Z</updated>
    
    <content type="html"><![CDATA[<p>本来打算在元旦附近写年终总结，关于学习生活，思考回忆。可后来越回忆内容越多越发散，思维无法集中。只有勉强扩充好的一个章节和一些关键字。</p><h2 id="关于思考"><a href="#关于思考" class="headerlink" title="关于思考"></a>关于思考</h2><p>这一节都与所谓情商有关，<a href="https://zh.wikipedia.org/wiki/%E6%83%85%E7%B7%92%E5%95%86%E6%95%B8#.E7.A4.BE.E6.9C.83.E6.8A.80.E5.B7.A7" target="_blank" rel="noopener">WIKI - 情绪商数</a>有五个向度：</p><ol><li>自我察觉 认识自身的情绪</li><li>自我规范 妥善管理情绪</li><li>自我激励 激发个人潜力</li><li>同理心 感同他人的情绪</li><li>社会技巧 人际关系的管理</li></ol><h3 id="感情动物"><a href="#感情动物" class="headerlink" title="感情动物"></a>感情动物</h3><p>很久之前，在我开始思考的时候，就意识到这个世界上最难改变的就是一个人的思想，因为有太多的画地为牢，我们做好自己就好。</p><p>MacTalk在年终总结中说，人的一生兜兜转转，要么是找到自己的阈值，要么去突破某种界限，要么走得远，要么原地打转，莫不如是。恰好最近在生活中遇到几个在感情上画地为牢的人，“我不能失去她所以怎么挽回？”，“为什么我这么‘厉害’，他们还是不愿意理我？”，很可怕的是不自知或者拒绝承认(“我不会这么差的，一定是别人的问题”)，我习惯称这种人为直男癌。</p><p>《暗时间》&lt;逃出你的肖申克(3)&gt;-遇见20万年前的自己，节中提出一个非常有趣的说法。我们大脑中同时存在着远古的自我和现代的自我，远古自我代表原始的情绪系统和条件反射模块，在千万年的进化长河中忠实的保护着我们在自然环境生存下来并努力繁衍后代。这个天性使得我们在决策方面倾向于立即获得愉悦，而且不会导致立即的损失。现代的自我代表更先进生产力的高级认知模块。他偏好于能够积累知识和技的长远计划。而我们都只是生活在信息社会的远古人。一般来说决策的目光短浅是由于未来的惩罚和收益估计不足产生的。</p><p>巧合的是，采铜在《精进-如何成为一个很厉害的人》&lt;对五年后的自己提问&gt;中也提到如何解决“远期未来和近期未来的冲突”，文中指出研究时间的心理学家按照五年的长度把未来分为“近期未来”和“远期未来”，两者视角的来回切换有助于我们决策。如果二者之间有冲突，可以采取的策略有，通过增强远期未来，抑制近期未来(增加近期未来“非期望行为的成本”)。<br>在&lt;我们总是在重复的抓沙子-把时间花在值得做的事情上&gt;根据收益和半衰期组合成四类事件：</p><ol><li>高收益值，长半衰期；</li><li>高收益值，短半衰期；</li><li>低收益值，短半衰期；</li><li>低收益值，长半衰期；</li></ol><p>这是多么相似！前者更为理性而有说服力，后者充满人情味。</p><p>简而言之，这一小节主要是关于自我察觉。</p><h3 id="换位思考"><a href="#换位思考" class="headerlink" title="换位思考"></a>换位思考</h3><p>如果说一个人情商低智商高，虽然在长期可能会有收益(非自己可控因素，风险很大)，但在近期的相处过程中可能不仅不会获得立即的愉悦，反而会导致立即的损失(情感)，那么不管是别人有意识或是本能反应，他所处的环境就显而易见了。在这种情况下，他就会急于开拓新的圈子新的领域，陷入新的循环。</p><p>12年底在我极度迷茫的时候，受到过来自师兄的指点。12年除夕在西区图书馆自习，恰好碰到当年社会实践带队，保研本校，当时就读研一，算起来刚好入学半年的师兄。他笑了笑说，别人看起来他无比光鲜，多厉害多厉害，但保研之后别人玩的时候，他读论文做实验，更加努力，可能他们都没有看到吧。虽然家就在当地城市，但在这个时间点还在图书馆看论文已经很能说明问题了。不过和他不同的是，我是三观尽碎挂科之后去还债的= =。师兄提及当年社会实践正值他的人生低谷，和我们一起度过一段时间也挺开心。当时收获颇多，然后傻傻的问了一句“你为什么(愿意)对我说这些？”，可见三观崩溃到什么程度了。师兄感到比较奇怪，回答：”你是我师弟啊，能帮则帮”，这句话我能记一辈子，永远的USTCer~。</p><p>历史总是惊人的相似，在研究生二年级的时候碰到国君，非科班出身的计算机大牛。偶尔聊天说过一句别人都看他现在这么牛逼(正值找工作)，但其实一年多是死磕过来的。当时就想起来那年寒假的那个师兄~，虽然没多说，但真的能理解。</p><p>换个角度来想，“别人为什么那么厉害”，还是站在自己的角度去看别人，这只有一个维度。如果这么想：“他收获这么多一定付出了不少”。这就有两个维度。是不是会好很多？</p><p>要真诚，真挚诚恳。不要站在道德高地。往往越是满口仁爱的人越是面目可疑。站在别人的角度来看看，没有人是傻瓜。</p><p>Note0：关于我的大学生活，虽然是学渣。但最大的收获是见到了一些人一些事，各种闪闪发光的地方。在不经意的时候总能想起。</p><p>Note1：我个人不愿意称为牛人，语言中的大腿，大牛其实更多的是一种打趣。这个称呼在我看来是偏颇的，他只聚焦于一个人光鲜的一面而忽略了背后的付出。</p><p>Note2：女生尤其是感情动物，在当下的情感愉悦和<strong>可能</strong>的长期收益之间往往会选择前者。如果懂得换位思考，相信总会有收获。比如说，“我不能失去她”(一元思维)为什么不是唤起美好的记忆调动曾经美好的情绪让她觉得“她也需要我”(另一元思维，二者结合并突出这一点是不是会杀伤力很大？)？比如一加一就说过他感觉女生总是“笨笨”的，喜欢钻牛角尖。如果让她直接做什么不做什么十有八九都会让自己无可奈何。但如果换个说法，表达这次就这样，但我们说好下次怎样怎样~并表达出这样的做法对她的好处(包括自己的担心blabla)，那就基本没问题了。我只能说他情商很高(他一直是我学习的对象)。这不仅仅照顾到长期收益，最重要的是照顾到女生的当下感情(立即获得的愉悦)。经常可以看到知乎不少人说男生和女生不同，男生注重结果，女生注重当下感受而不是解决方法，就是这个道理。</p><p>Note3:</p><blockquote><p>People will forget what you did.<br>People will forget what you said.<br>But people will not forget what you made them feel.</p></blockquote><p>这一节是在与他人交往中最重要的一部分，同理心。</p><h3 id="画地为牢"><a href="#画地为牢" class="headerlink" title="画地为牢"></a>画地为牢</h3><p>那我们如何保证自己目前不是在画地为牢或者未来不要画地为牢？</p><p>要谦虚谨慎，本科时期有幸在邱本胜教授和李斌教授实验室短暂学习过，说的俗气一点就是见识到了“大牛的风采”。时隔已久，邱老师说过的话我依然记不清了，只记得他给我的feeling(做人就该这样子！)，并时时刻刻影响着我。李老师改毕业论文的时候咬文嚼字，精确到标点符号，但和他相处发现他是一个无比温和的人。他们闪光的品质对我产生深远的影响。那么如何保持谦虚谨慎？在我看来要明白<font color="red">反馈</font>调节的重要性，负反馈这一概念的出现在电子领域甚至是革命性的。学习的过程从来都是需要不断输入(降低偏差bias)不断输出(降低方差var)来反馈调节的，而不是一蹴而就。没有绝对正确的东西，学无止境，在不断的反馈调节中才能无限接触真实。</p><p>要往远看，《一代宗师》里有说，人要往远看，过了山，眼界就阔了。大昊神说站在身边的是伙伴，未知的才是敌人。过来人告诫我们，学习成长，干活拿钱，年轻人格局要大。有人说，真正的棱角是过人的才华，是坚定的志向，是对理想孜孜不倦的追求，是与生俱来的强大的意志力。这种棱角只会被社会越磨越锋利，最终成就一代大神。甚至大成若缺都是一个道理。</p><p>简而言之，自我规范，自我激励。</p><h3 id="交流的陷阱"><a href="#交流的陷阱" class="headerlink" title="交流的陷阱"></a>交流的陷阱</h3><p>讲故事，谈感受，少评论，就事论事。这里写的很好，就不献丑了。<a href="https://zhuanlan.zhihu.com/p/24656107" target="_blank" rel="noopener">交流时，我们为什么总在人身攻击</a></p><p>这是关于社会技巧。</p><hr><h2 id="2016关键字"><a href="#2016关键字" class="headerlink" title="2016关键字"></a>2016关键字</h2><h3 id="克己-克制"><a href="#克己-克制" class="headerlink" title="克己(克制)"></a>克己(克制)</h3><p>觉知，自制。</p><h3 id="靠谱"><a href="#靠谱" class="headerlink" title="靠谱"></a>靠谱</h3><p>解决问题的能力。<br>坦坦荡荡。人生如棋，落子无悔。</p><hr><h2 id="2017关键字"><a href="#2017关键字" class="headerlink" title="2017关键字"></a>2017关键字</h2><h3 id="make-love-not-commit-OR-push"><a href="#make-love-not-commit-OR-push" class="headerlink" title="make love, not commit OR push"></a>make love, not commit OR push</h3><p>如果不知道怎么做，那么就开始做并持续做。<br>2016 for push/commit 培养习惯。<br>2017 for love。</p><h3 id="专注"><a href="#专注" class="headerlink" title="专注"></a>专注</h3><p>长时间保持专注的能力。</p><h3 id="写作与思考"><a href="#写作与思考" class="headerlink" title="写作与思考"></a>写作与思考</h3><p>多读书，读书与书写是为了更好的思考。<br>如《暗时间》所说，如果没有写作，思维过程就像黑暗中的手电筒，总是在原地打转。</p><hr><blockquote><p>缺月挂疏桐，漏断人初静。<br>谁见幽人独往来？<br>缥缈孤鸿影。<br>惊起却回头，有恨无人省。<br>拣尽寒枝不肯栖，<br>寂寞沙洲冷。<br>宋 苏轼 《卜算子》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本来打算在元旦附近写年终总结，关于学习生活，思考回忆。可后来越回忆内容越多越发散，思维无法集中。只有勉强扩充好的一个章节和一些关键字。&lt;/p&gt;
&lt;h2 id=&quot;关于思考&quot;&gt;&lt;a href=&quot;#关于思考&quot; class=&quot;headerlink&quot; title=&quot;关于思考&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="ryl" scheme="http://rylcode.cn/categories/ryl/"/>
    
    
      <category term="ryl" scheme="http://rylcode.cn/tags/ryl/"/>
    
  </entry>
  
  <entry>
    <title>Python入门7-文件</title>
    <link href="http://rylcode.cn/2016/12/24/Python%E5%85%A5%E9%97%A87-%E6%96%87%E4%BB%B6/"/>
    <id>http://rylcode.cn/2016/12/24/Python入门7-文件/</id>
    <published>2016-12-24T02:51:18.000Z</published>
    <updated>2020-05-13T12:18:58.434Z</updated>
    
    <content type="html"><![CDATA[<p>首先介绍一个keyword:<code>with</code>，Python引入了<code>with</code>关键字来自动帮助我们调用<code>close()</code>方法。另外<code>as</code>关键字可以作为shorthands。<br>其次介绍一个内建函数<code>help()</code>：</p><ol><li><code>help(object)</code> 显示帮助信息，一般用于交互环境查询帮助信息。</li><li>参数<code>object</code>是对象。<ul><li>内建(工厂)函数直接输入函数名即可，例如<code>help(help)</code>;</li><li>对象的方法，首先实例化一个对象(基本数据类型可以用关键字来代替)，然后通过对象和方法名来调用帮助。</li><li>在很多文档中方法或属性不全面或者版本误差，可以这样来查看最全面的帮助文档。例如打开一个文件f，<code>help(f)</code>。</li></ul></li></ol><hr><h1 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h1><h2 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h2><p><code>open(file, mode=&#39;r&#39;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True)</code><br>返回文件对象，如果是文本文件，返回TextIOWrapper。如果是二进制文件，读时返回BufferedReader，写时返回BufferedWriter。访问模式：<code>r/w/a/r+/w+/a+</code> <code>rb/wb/ab/rb+/wb+/ab+</code><br>参考资料：<br><a href="https://docs.python.org/3/library/io.html" target="_blank" rel="noopener">io — Core tools for working with streams</a><br>Zeal<br><a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431917715991ef1ebc19d15a4afdace1169a464eecc2000" target="_blank" rel="noopener">廖雪峰的博客</a><br><a href="http://www.w3cschool.cn/python3/python3-file-methods.html" target="_blank" rel="noopener">Python3 File 方法</a></p><h2 id="Iteration"><a href="#Iteration" class="headerlink" title="Iteration"></a>Iteration</h2><p>打开文件之后，文件迭代(一行一行访问)很简单，使用<code>for each in f</code>比<code>for each in f.readline()</code>更高效。</p><hr><h1 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h1><ol><li>file.read([size]) 从文件读取指定的字节数，如果未给定或为负则读取所有。</li><li>file.readline([size]) 读取整行，包括 “\n” 字符。</li><li>file.readlines([size int]) 读取所有行并返回列表，若给定size int &gt; 0，返回总和<font color="red">大约</font>为size int字节的行, 实际读取值可能比size int较大, 因为需要填充缓冲区。<ul><li>注意read相关方法都不会删除行结束符，这个工作要通过<code>str.strip()</code>(默认情况下删除空白字符，<code>\t\ \n</code>)来完成。</li></ul></li><li>file.write(str) 将字符串写入文件，没有返回值。</li><li>file.writelines(sequence) 向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。</li><li>file.seek(offset, whence) 设置文件当前位置。</li><li>file.tell() 返回文件当前位置。</li><li>file.next() 返回文件下一行。</li><li>file.truncate([size]) 截取文件，截取的字节通过size指定，默认为当前文件位置。<ul><li>注意这个和<code>file.seek()</code>配合时，截断后返回文件开头。</li></ul></li><li>file.flush() 刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。</li><li>file.close() 关闭文件。关闭后文件不能再进行读写操作。</li><li>file.fileno() 返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。</li><li>file.isatty() 如果文件连接到一个终端设备返回 True，否则返回 False。</li></ol><h1 id="Attributes"><a href="#Attributes" class="headerlink" title="Attributes"></a>Attributes</h1><ol><li>file.closed 表示文件已经被关闭，否则为<code>false</code>。</li><li>file.encoding 返回文件所使用的编码。</li><li>file.mode 文件打开时所使用的模式。</li><li>file.name 文件名。</li><li>file.error</li><li>file.newlines</li><li>file.buffer</li></ol><hr><h1 id="Standard-File"><a href="#Standard-File" class="headerlink" title="Standard File"></a>Standard File</h1><h2 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h2><p>Python中通过sys模块来访问文件句柄。</p><ol><li><code>print()</code>通常输出到<code>sys.stdout</code>。</li><li><code>input()</code>通常从<code>sys.stdin</code>接受输入。</li><li><code>sys.*</code>是文件，所以必须自己处理好换行符。<br>sys模块有argv属性，<code>sys.argv</code>返回一个列表，列表长度<code>len(sys.argv)</code>即参数个数(C中的argc，即argument count)，列表本身就是参数向量(C中的argv，即argument vector)。</li><li><code>sys.argv</code>是命令行参数列表。</li><li><code>len(sys.argv)</code>是命令行参数个数。</li></ol><h2 id="os"><a href="#os" class="headerlink" title="os"></a>os</h2><p>Python中通过这个模块访问文件系统。</p><h2 id="os-path"><a href="#os-path" class="headerlink" title="os.path"></a>os.path</h2><p>完成一些针对路径名的操作。</p><h2 id="pickle-cPickle"><a href="#pickle-cPickle" class="headerlink" title="pickle/cPickle"></a>pickle/cPickle</h2><p>保存Python对象到文件中，而不需要转换成字符串。两个主要函数<code>dump()</code>，<code>load()</code>。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先介绍一个keyword:&lt;code&gt;with&lt;/code&gt;，Python引入了&lt;code&gt;with&lt;/code&gt;关键字来自动帮助我们调用&lt;code&gt;close()&lt;/code&gt;方法。另外&lt;code&gt;as&lt;/code&gt;关键字可以作为shorthands。&lt;br&gt;其次介绍一
      
    
    </summary>
    
      <category term="Python" scheme="http://rylcode.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://rylcode.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python入门6-条件和循环</title>
    <link href="http://rylcode.cn/2016/12/21/Python%E5%85%A5%E9%97%A86-%E6%9D%A1%E4%BB%B6%E5%92%8C%E5%BE%AA%E7%8E%AF/"/>
    <id>http://rylcode.cn/2016/12/21/Python入门6-条件和循环/</id>
    <published>2016-12-21T06:04:04.000Z</published>
    <updated>2020-05-13T12:18:58.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h1><ol><li><code>if</code>子句<ul><li>单一语句的代码块可以放在<code>if</code>同一行上，但建议使用合理的缩进。</li></ul></li><li><code>else</code>子句<ul><li>Python使用缩进在避免<font color="red">悬挂<code>else</code></font>时非常有用，因为C/C++中else与最近的if搭配，这在他本想与内部if搭配时发生错误。不要忘记花括号可以避免这个问题。</li></ul></li><li><code>elif</code>子句，即<code>else if</code>语句</li><li>Conditional expression. Python很长一段时间内都没有条件表达式<code>C ? X : Y</code>，P2.5加入并确定语法为<ul><li><code>X if C else Y</code>.</li></ul></li></ol><hr><h1 id="Loop"><a href="#Loop" class="headerlink" title="Loop"></a>Loop</h1><h2 id="Conditional-Loop-while"><a href="#Conditional-Loop-while" class="headerlink" title="Conditional Loop(while)"></a>Conditional Loop(while)</h2><p><code>while</code>是条件循环语句，常用在计数循环(配合自增或自减语句)、无限循环中。</p><h2 id="Iterative-Loop-for"><a href="#Iterative-Loop-for" class="headerlink" title="Iterative Loop(for)"></a>Iterative Loop(for)</h2><p><code>for</code>是Python中最强大的循环结构，他是迭代循环语句，可用于列表解析和生成器表达式中，自动调用<code>next(iter)</code>工厂函数(Python2是迭代器方法)，最终捕获StopIterator异常并结束循环。</p><ol><li>可用于序列类型，包括字符串，列表以及元组等。<ul><li>通过序列项迭代。</li><li>配合<code>range(len())</code>通过序列索引迭代，但显然效率不如序列迭代高，这是由迭代器的特性决定的。</li><li>使用索引和项迭代，这就是<code>enumerate()</code>的威力。</li></ul></li><li>用于迭代器类型，因为可以调用<code>next(iter)</code>函数，调用后返回下一条目所有条目迭代完毕后迭代器引发一个StopIteration异常告诉程序循环结束，这都是<code>for</code>语句内部发生的。</li><li>内建函数<code>range()</code>可以将原本类似于<code>foreach</code>的语句变成更熟悉的语句。<ul><li><code>range(start, end, step = 1)</code> step要求start。</li><li><code>range(end)</code></li><li><code>range(start, end)</code></li><li>注意不能将<code>range()</code>简略成一种语法<code>range(start = 0, end, step = 1)</code>，这是因为这个语法的两个参数调用版本有歧义。</li></ul></li><li>相关内建函数，<code>sorted()</code>(返回list),<code>zip()</code>(返回tuple指针)是序列相关，<code>enumerate()</code>,<code>reversed()</code>返回迭代器。</li></ol><h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><p>用于<code>while</code>和<code>for</code>循环中打断列表的迭代。</p><h2 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h2><p>终止当前循环并验证条件表达式(<code>while</code>)或验证是否有元素可以迭代(<code>for</code>)，验证成功的情况下开始下一次循环。</p><h2 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h2><p>提供<code>pass</code>语句表示不做任何事，在Python中如果在需要有语句块的地方不写任何语句，会提示语法错误。<code>pass</code>也可以作为调试中的小技巧，标记你后来要完成的代码。</p><h2 id="else"><a href="#else" class="headerlink" title="else"></a>else</h2><p>Python中可以在<code>while</code>和<code>for</code>循环中使用<code>else</code>语句做循环后处理(post-processing)，相当于设置了一个完整执行循环的flag，即<code>break</code>语句也会跳过<code>else</code>块，因为循环并没有被完整执行。</p><hr><h1 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h1><p>迭代器从根本上来说就是一个有<code>next()</code>方法的对象，因此他能无缝支持序列对象。(next()方法迭代和StopIteration异常告诉外部调用者迭代结束)，内建函数<code>reversed()</code>,<code>enumerate()</code>,<code>any()</code>,<code>all()</code>都返回迭代器。</p><ol><li>序列 内建函数iter()和next()；</li><li>字典 for迭代，方法缺省时迭代键；</li><li>文件 for，行迭代。</li></ol><p>不要在迭代不可变对象时改变值，比如字典的key，但是使用<code>dict.key()</code>方法是可以的，因为这个方法返回独立于字典的列表。一个实现了<code>__iter__()</code>和<code>__next__()</code>方法的类可以作为迭代器使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#for的工作原理</span></span><br><span class="line">fetch = iter(seq)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">i = next(fetch)</span><br><span class="line"><span class="keyword">except</span> StopIteration:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">do_something_to(i)</span><br></pre></td></tr></table></figure><hr><h1 id="List-Comprehensions"><a href="#List-Comprehensions" class="headerlink" title="List Comprehensions"></a>List Comprehensions</h1><h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><p>定义匿名函数，这个语句作为function传入其它函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> x: doSomethingAboutX</span><br><span class="line">f = <span class="keyword">lambda</span> x:x+<span class="number">1</span></span><br><span class="line">print(f(<span class="number">2</span>))</span><br></pre></td></tr></table></figure><h2 id="List-Comprehensions-1"><a href="#List-Comprehensions-1" class="headerlink" title="List Comprehensions"></a>List Comprehensions</h2><p>Python独有的语法，比lambda更具优势，两个表达式及例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[expr <span class="keyword">for</span> iter_var <span class="keyword">in</span> iterable]</span><br><span class="line">[expr <span class="keyword">for</span> iter_var <span class="keyword">in</span> iterable <span class="keyword">if</span> condexpr]</span><br><span class="line"></span><br><span class="line">[(x + <span class="number">1</span>, y + <span class="number">1</span>) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>) <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line">len([word <span class="keyword">for</span> line <span class="keyword">in</span> f <span class="keyword">for</span> word <span class="keyword">in</span> line.split()])</span><br><span class="line">sum([len(word) <span class="keyword">for</span> line <span class="keyword">in</span> f <span class="keyword">for</span> word <span class="keyword">in</span> line.split()])</span><br></pre></td></tr></table></figure><p>那么列表如何解析？</p><ol><li>对嵌套循环，for语句的顺序是与原顺序相同的；</li><li>条件表达式的作用域是前一个语句(for或者其他表达式)；</li><li>循环和条件之前的表达式是列表元素(核心部分)，如果还原回来这个语句应该在循环和条件的最内层。</li></ol><hr><h1 id="Generator-Expression"><a href="#Generator-Expression" class="headerlink" title="Generator Expression"></a>Generator Expression</h1><p>列表解析的一个缺点就是要生成所有数据用于创建整个列表。生成器表达式是列表解析的一个扩展。它使用了对内存使用更友好的结构。几他不创建真正的列表，而是返回一个生成器，这个生成器每次计算出一个条目之后，把这个条目“产生(<code>yield</code>)出来”，使用“延迟计算”(lazy evaluation)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(expr <span class="keyword">for</span> iter_var <span class="keyword">in</span> iterable <span class="keyword">if</span> cond_expr)</span><br><span class="line"></span><br><span class="line">((i, j) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>) <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">5</span>))</span><br><span class="line"><span class="keyword">return</span> max([len(x.strip()) <span class="keyword">for</span> x <span class="keyword">in</span> open(<span class="string">'ect/motd'</span>)])<span class="comment">#List Comprehensions</span></span><br><span class="line"><span class="keyword">return</span> max(len(x.strip()) <span class="keyword">for</span> x <span class="keyword">in</span> open(<span class="string">'/ect/motd'</span>))<span class="comment">#Generator Expression</span></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Condition&quot;&gt;&lt;a href=&quot;#Condition&quot; class=&quot;headerlink&quot; title=&quot;Condition&quot;&gt;&lt;/a&gt;Condition&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;if&lt;/code&gt;子句&lt;ul&gt;
&lt;li&gt;单一语句的代码块可以
      
    
    </summary>
    
      <category term="Python" scheme="http://rylcode.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://rylcode.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python入门5-字典和集合</title>
    <link href="http://rylcode.cn/2016/12/19/Python%E5%85%A5%E9%97%A85-%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/"/>
    <id>http://rylcode.cn/2016/12/19/Python入门5-字典和集合/</id>
    <published>2016-12-19T01:49:03.000Z</published>
    <updated>2020-05-13T12:18:58.433Z</updated>
    
    <content type="html"><![CDATA[<p>映射类型：字典(dict)<br>集合类型：集合(set) 可变集合/不可变集合</p><hr><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h2 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h2><h3 id="Assignment"><a href="#Assignment" class="headerlink" title="Assignment"></a>Assignment</h3><ol><li>赋值运算符<code>=</code>和花括号<code>{}</code>，键值之间的对应用冒号<code>:</code>。</li><li>工厂方法dict(),键值之间可以用赋值运算符<code>=</code>。</li><li>使用内建方法dict.fromkeys(seq,value),创建一个默认的字典，字典中的元素具有相同的值。</li></ol><h3 id="Access"><a href="#Access" class="headerlink" title="Access"></a>Access</h3><ol><li>键值访问 dict[key]返回value</li><li>迭代器访问 for key in dict</li></ol><h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><ol><li>方括号和赋值运算符新建/更新字典，dict[key] = newValue;<ul><li>如果没有key,则新建，如果有则更新；</li></ul></li><li>使用内建方法dict.update(dict)将整个字典的内容添加到另一个字典。</li></ol><h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><ol><li>del dict[key] 删除键为key的条目。</li><li>dict.clear() 删除dict中所有的条目。</li><li>dict.pop(key) 删除并返回键为key的条目的值。</li></ol><h3 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h3><ol><li>赋值运算符<code>=</code>，Python3中取消了关系运算符<code>&gt;</code>,<code>&lt;</code>，等相关的运算符，但是<code>==</code>依然可用。</li><li>Python3中取消了<code>cmp()</code>内建函数。</li><li>字典的键查找操作符<code>[]</code>，给某元素赋值或者查询字典中某元素的值。</li><li>键成员关系操作<code>in/not in</code>。</li></ol><h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><ol><li>type() 返回对象的类型或创建一个新的类型对象。</li><li>str() 得到对象的str()版本。</li><li>len() 返回对象长度或者集合个数。</li><li>dict() 创建字典。<ul><li>如果参数是可迭代的，必须成对出现才能创建字典，zip或者列表，列表解析等；</li><li>如果输入参数是一个映射对象，此函数会返回该映射对象的浅拷贝版本，但是效率没有dict.copy()高。</li></ul></li><li>hash() 得到对象的哈希值。<ul><li>一般用来判断对象是否是可哈希的，如果可哈希返回哈希值；</li><li>如果不可哈希，返回错误。</li></ul></li></ol><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><ol><li>dict.clear() 删除dictionary中的所有键值对，字典变为空。</li><li>dict.copy() 浅拷贝dictionary。</li><li>dict.fromkeys(iterater, value=None) 新建一个dictionary，键由可迭代对象组成，所有的值都是value。</li><li>dict.get(key, d) 返回dictionary中键为key的值，如果不存在key，则返回d(默认为None)，这可以判断键key是否存在。</li><li>dict.items() 返回dictionary中所有键值对，类型为dict_items，可以使用迭代器访问。</li><li>dict.keys() 返回dictionary中所有的键集合，类型为dict_keys，可以使用迭代器访问。</li><li>dict.values() 返回dictionary中所有的值集合，类型为dict_values，可以使用迭代器访问。</li><li>dict.pop(key) 删除dictionary中指定key，并返回key的值。如果没有key，会抛出KeyError。</li><li>dict.popitem() 删除dictionary中key-value对，类型是tuple()，如果dict是空，抛出异常。</li><li>dict.setdefault(k,d) 如果dictionary中不存在k,设置dict[k] = d,并返回d；如果k存在，则返回原有键k的值。</li><li>dict.update(dict/iterable) 使用一个字典或者可迭代容器(比如zip)更新字典(添加内容)。</li></ol><h2 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h2><ol><li>不允许一个键对应多个值，以最后一次的赋值/更新为准。</li><li>键必须是可哈希的<ul><li>所有的不可变类型都是可哈希的，因为字典中的键用来计算数据存储位置，如果可变，存取数据就变得不可靠了。</li><li>数字和字符串都可以作为键，但对元组来说，元组只包括数字和字符串这样的不可变参数，才能作为字典中有效的值。</li></ul></li></ol><hr><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>分为可变集合和不可变集合，可变集合可以添加删除元素，不可哈希。不可变集合刚好相反。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="Assignment-1"><a href="#Assignment-1" class="headerlink" title="Assignment"></a>Assignment</h3><p>只能通过工厂方法来创建，集合具有无序性，确定性，互异性。</p><ol><li>set() 可变集合。</li><li>frozenset() 不可变集合。</li></ol><h3 id="Access-1"><a href="#Access-1" class="headerlink" title="Access"></a>Access</h3><ol><li><code>in/not in</code>。</li></ol><h3 id="Update-1"><a href="#Update-1" class="headerlink" title="Update"></a>Update</h3><ol><li>set.add() 往set中添加一个元素。</li><li>set.remove() 从set中删除一个元素，这个操作和set.add()相对应。</li><li>set.update(set) 往set中添加一个set的所有元素。</li><li>set <code>-=</code> set() 从set中删去一个set的所有元素，这个操作与set.update()相对应。</li></ol><h3 id="Delete-1"><a href="#Delete-1" class="headerlink" title="Delete"></a>Delete</h3><ol><li><code>del set</code>清除出当前的名称空间，如果引用计数为0，会被垃圾回收。</li></ol><h3 id="Operator-1"><a href="#Operator-1" class="headerlink" title="Operator"></a>Operator</h3><p>注意<code>+</code>不是集合类型操作符，最接近<code>+</code>的逻辑是或(OR<code>|</code>)。</p><ol><li><code>in/not in</code> 成员关系操作符。</li><li><code>==/!=</code> 等价/不等价。</li><li><code>&lt;/&lt;=,&gt;/&gt;=</code> 严格子集/非严格子集(<code>&lt;=</code>相当于set.issubset())，严格超集/非严格超集(<code>&gt;=</code>相当于set.issuperset())。</li><li><code>|</code> 联合，相当于OR,等价方法set.union()。</li><li><code>&amp;</code> 交集，相当于ADD，等价方法set.intersection()。</li><li><code>-</code> 差补/相对补集，等价方法set.difference()。</li><li><code>^</code> 对称差分,即异或，等价方法set.symmetric_difference()。</li></ol><p>以下仅适用于可变集合：</p><ol><li><code>|=</code> 从已存在的集合中添加多个成员，此方法和update()等价。</li><li><code>&amp;=</code> 保留(交集更新)，保留与其他集合的共有成员，此方法和intersection_update()等价。</li><li><code>-=</code> 差更新，返回除去右集合后剩余元素组成的集合，此方法和difference_update()等价。</li><li><code>^=</code> 差分更新，返回仅是左集合或者仅是右集合的元素组成的集合。</li></ol><h2 id="Functions-1"><a href="#Functions-1" class="headerlink" title="Functions"></a>Functions</h2><ol><li>len() 返回集合基数。</li><li>set()/frozenset() 生成可变/不可变集合。<ul><li>默认生成空集合；</li><li>如果有一个参数，该参数必须是可迭代的。</li></ul></li></ol><h2 id="Methods-1"><a href="#Methods-1" class="headerlink" title="Methods"></a>Methods</h2><ol><li>set.add() 往set中添加一个元素。</li><li>set.clear() 从set中移除所有元素。</li><li>set.copy() 返回set的浅拷贝。</li><li>set.difference() 返回两个或多个set中不同的元素组成的set，差分。</li><li>set.difference_update() 从当前set中移除其他set中所有元素。</li><li>set.discard() 从set中删除一个元素，如果该元素存在。无论该元素存在与否，返回值都是None。</li><li>set.intersection() 返回两个或多个set的交集。</li><li>set.intersection_update() 更新当前set，只保留所有set中都存在的元素、</li><li>set.isdisjoint() 判断两个set有没有交集。</li><li>set.issubset()/set.issuperset() 判断是否非严格子集/非严格超集。 </li></ol><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;映射类型：字典(dict)&lt;br&gt;集合类型：集合(set) 可变集合/不可变集合&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;字典&quot;&gt;&lt;a href=&quot;#字典&quot; class=&quot;headerlink&quot; title=&quot;字典&quot;&gt;&lt;/a&gt;字典&lt;/h1&gt;&lt;h2 id=&quot;dict&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="Python" scheme="http://rylcode.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://rylcode.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>VSCode配置Go环境</title>
    <link href="http://rylcode.cn/2016/12/16/VSCode%E9%85%8D%E7%BD%AEGo%E7%8E%AF%E5%A2%83/"/>
    <id>http://rylcode.cn/2016/12/16/VSCode配置Go环境/</id>
    <published>2016-12-16T03:20:12.000Z</published>
    <updated>2020-05-13T12:18:58.438Z</updated>
    
    <content type="html"><![CDATA[<p>安装VSCode以及VSCode中Go扩展，git的过程省略</p><hr><h2 id="配置git环境"><a href="#配置git环境" class="headerlink" title="配置git环境"></a>配置git环境</h2><p>安装Go插件需要git指令因此首先要配置git环境,由于之前使用的是github桌面版，要在cmd下使用还需要配置环境变量。</p><ol><li>gitshell使用powershell启动是由于gitshell的原因，并不是powershell可以使用git指令；</li><li>因此在将VSCode shell改成powershell之后会无法识别git指令；</li><li>将git的bin目录添加在环境变量PATH中，但github安装时是不能选择安装目录的，一般情况下是安装在<code>C:\Users\***\AppData\Local\GitHub</code>目录下，然后有些英文不知道什么意思的文件夹，进去之后只看有没有bin目录。有的话就说明进对了。注意不一定是一级目录，也不一定只有一个bin目录，比如我有两个bin目录<code>PortableGit_d7effa1a4a322478cd29c826b52a0c118ad3db11\mingw32\bin</code>和<code>PortableGit_d7effa1a4a322478cd29c826b52a0c118ad3db11\usr\bin</code>,其中前一个是有效的。</li><li>如果安装的是git for windows，可以选择安装目录，这个问题比较容易解决。</li></ol><p>参考资料：<a href="http://blog.csdn.net/bugmeout/article/details/21335609" target="_blank" rel="noopener">GitHub cmd下环境变量设置</a></p><p>–</p><h2 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h2><h3 id="插件配置选项"><a href="#插件配置选项" class="headerlink" title="插件配置选项"></a>插件配置选项</h3><p>Preferrence-&gt;WorkSpaces Settings中设置插件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"files.autoSave"</span>: <span class="string">"onFocusChange"</span>,</span><br><span class="line">    <span class="attr">"go.buildOnSave"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"go.lintOnSave"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"go.vetOnSave"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"go.buildFlags"</span>: [],</span><br><span class="line">    <span class="attr">"go.lintFlags"</span>: [],</span><br><span class="line">    <span class="attr">"go.vetFlags"</span>: [],</span><br><span class="line">    <span class="attr">"go.useCodeSnippetsOnFunctionSuggest"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"go.formatOnSave"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"go.formatTool"</span>: <span class="string">"goreturns"</span>,</span><br><span class="line">    <span class="attr">"go.goroot"</span>: <span class="string">"D:\\Go"</span>,</span><br><span class="line">    <span class="attr">"go.gopath"</span>: <span class="string">"D:\\GoWorks"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="安装这些插件"><a href="#安装这些插件" class="headerlink" title="安装这些插件"></a>安装这些插件</h3><p>这些工具默认的安装方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">go get -u -v github.com/nsf/gocode</span><br><span class="line">go get -u -v github.com/rogpeppe/godef</span><br><span class="line">go get -u -v github.com/golang/lint/golint</span><br><span class="line">go get -u -v github.com/lukehoban/go-outline</span><br><span class="line">go get -u -v sourcegraph.com/sqs/goreturns</span><br><span class="line">go get -u -v golang.org/x/tools/cmd/gorename</span><br><span class="line">go get -u -v github.com/tpng/gopkgs</span><br><span class="line">go get -u -v github.com/newhook/go-symbols</span><br><span class="line">go get -u -v golang.org/x/tools/cmd/guru</span><br><span class="line">go get -u -v github.com/lukehoban/go-find-references</span><br><span class="line">go get -v -u github.com/peterh/liner github.com/derekparker/delve/cmd/dlv//调试工具</span><br></pre></td></tr></table></figure><p>最终目的是在gopath中bin文件夹生成一些exe文件，如果以上命令运行成功，会自动编译生成，但我运行时有5个安装失败，因此在网上找到已经生成好的exe包。</p><p>不过<font color="red">最终我还是通过命令安装成功了</font>，个人觉得终端提示的所有错误都可以无视，因为我开了两个VSCode换着一直输入指令，然后突然就全都好了，个人猜测是长城的原因。终端提示有以下几种：</p><ol><li>is not using a known version control system.</li><li>git remote error.</li><li>timeout 这是正确原因，由于长城的存在导致的。</li></ol><p>参考资料:<br><font color="red">特别重要</font><a href="https://marketplace.visualstudio.com/items?itemName=lukehoban.Go" target="_blank" rel="noopener">Go for Visual Studio Code</a><br><a href="http://www.cnblogs.com/JerryNo1/p/5412864.html" target="_blank" rel="noopener">windows下visual studio code搭建golang开发环境</a><br><a href="https://duosoftware.com/blog/how-to-setup-visual-studio-code-to-debug-golang-with-delve/" target="_blank" rel="noopener">HOW TO SETUP VISUAL STUDIO CODE TO DEBUG GOLANG WITH DELVE</a></p><h2 id="launch和settings"><a href="#launch和settings" class="headerlink" title="launch和settings"></a>launch和settings</h2><p>以下是simple项目的配置，复杂项目的配置以后慢慢研究。</p><p>launch.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="attr">"configurations"</span>: [</span><br><span class="line">        </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Launch"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"go"</span>,</span><br><span class="line">            <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="attr">"mode"</span>: <span class="string">"debug"</span>,</span><br><span class="line">            <span class="attr">"remotePath"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="attr">"port"</span>: <span class="number">2345</span>,</span><br><span class="line">            <span class="attr">"host"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">            <span class="attr">"program"</span>: <span class="string">"$&#123;workspaceRoot&#125;"</span>,</span><br><span class="line">            <span class="attr">"env"</span>: &#123;&#125;,</span><br><span class="line">            <span class="attr">"args"</span>: [],</span><br><span class="line">            <span class="attr">"showLog"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>settings.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"files.autoSave"</span>: <span class="string">"onFocusChange"</span>,</span><br><span class="line">    <span class="attr">"go.buildOnSave"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"go.lintOnSave"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"go.vetOnSave"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"go.buildFlags"</span>: [],</span><br><span class="line">    <span class="attr">"go.lintFlags"</span>: [],</span><br><span class="line">    <span class="attr">"go.vetFlags"</span>: [],</span><br><span class="line">    <span class="attr">"go.useCodeSnippetsOnFunctionSuggest"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"go.formatOnSave"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"go.formatTool"</span>: <span class="string">"goreturns"</span>,</span><br><span class="line">    <span class="attr">"go.goroot"</span>: <span class="string">"D:\\Go"</span>,</span><br><span class="line">    <span class="attr">"go.gopath"</span>: <span class="string">"D:\\GoWorks"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;安装VSCode以及VSCode中Go扩展，git的过程省略&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;配置git环境&quot;&gt;&lt;a href=&quot;#配置git环境&quot; class=&quot;headerlink&quot; title=&quot;配置git环境&quot;&gt;&lt;/a&gt;配置git环境&lt;/h2&gt;&lt;p&gt;安装Go插件需
      
    
    </summary>
    
      <category term="VSCode" scheme="http://rylcode.cn/categories/VSCode/"/>
    
    
      <category term="VSCode" scheme="http://rylcode.cn/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>Python入门4-列表和元组</title>
    <link href="http://rylcode.cn/2016/12/14/Python%E5%85%A5%E9%97%A84-%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/"/>
    <id>http://rylcode.cn/2016/12/14/Python入门4-列表和元组/</id>
    <published>2016-12-14T07:45:47.000Z</published>
    <updated>2020-05-13T12:18:58.433Z</updated>
    
    <content type="html"><![CDATA[<p>序列容器之列表和元组<br>列表，可变类型。<br>元组，不可变类型。</p><hr><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h3><ol><li><code>=</code>,<code>==</code>,<code>&gt;</code>,<code>&lt;</code>。列表的比较逻辑：两个列表元素分别比较，直到有一方的元素胜出。如果某两个元素相互之间不能比较会抛出一个TypeError。注意他的比较只是比较值，不会比较<code>id()</code>。</li><li><code>in/not in</code> 成员关系操作</li><li><code>+</code> 连接操作符，<code>extend()</code>方法可以代替连接操作符吧一个列表内容添加到另一个中去，而不是新建一个列表。<ul><li><code>+=</code> 替换连接操作也支持；</li><li>注意连接操作符不能新建一个元素到列表，只能连接两个列表。</li></ul></li><li><code>*</code> 重复操作符</li></ol><h3 id="Assignment"><a href="#Assignment" class="headerlink" title="Assignment"></a>Assignment</h3><p>使用赋值运算符和方括号<code>[]</code>，或者内建的构造函数list(iterable)，可以从参数看到，传入可迭代对象，即可以从tuple,list,range,str创建list对象。</p><h3 id="Access"><a href="#Access" class="headerlink" title="Access"></a>Access</h3><p>可以使用索引，或者切片操作符来访问列表值，并且类似于多维数组，可以在切片的结果上再次切片。</p><h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><p>通过索引或者索引范围来更新列表，因为列表是可变的。</p><h3 id="List-Comprehension"><a href="#List-Comprehension" class="headerlink" title="List Comprehension"></a>List Comprehension</h3><p>结合列表的方括弧和for循环，在逻辑上描述要创建的列表.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[i*<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">8</span>, <span class="number">-2</span>, <span class="number">5</span>]] = [<span class="number">16</span>, <span class="number">-4</span>, <span class="number">10</span>]</span><br><span class="line">[i <span class="keyword">for</span> i <span class="keyword">in</span> range[<span class="number">8</span>] <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>] = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure><h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><ol><li>len() 列表大小</li><li>max()/min() 最大最小值</li><li>sorted()/reversed() 字典序排序(排序后是另外一个对象)，反转(注意反转返回的是迭代器，需要list()转化，但这是另外一个对象了)</li><li>enumerate()/zip() 枚举，打包为元组</li><li>sum() 求和</li></ol><h2 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h2><ol><li>list.append() 附件一个对象到list</li><li>list.clear() 删除list中的所有元素</li><li>list.copy() 浅拷贝list<ul><li><a href="http://www.cnblogs.com/wilber2013/p/4645353.html" target="_blank" rel="noopener">图解Python深拷贝和浅拷贝</a>,简单来说，深拷贝会对每一个对象创造一个副本，而浅拷贝在能使用引用的时候绝对不用拷贝。</li></ul></li><li>list.count() 指定参数在list中出现的次数</li><li>list.extend() 附加指定的元素到迭代器</li><li>list.index() 返回指定值在list中第一次出现的位置，如果不存在指定值则抛出错误</li><li>list.insert() 在list指定位置插入对象</li><li>list.pop() 删除并返回指定位置的对象，默认为最后位置，如果越界或者列表为空则抛出异常</li><li>list.remove() 从list中删除第一次出现的指定值，如果指定值不存在，抛出异常</li><li>list.reverse() 原地反转list中的元素</li><li>list.sort() 对列表排序(原地)</li></ol><hr><h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><h2 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h2><p>元组和列表一个重要的区别：不可变类型，因此可以做一些列表不能做的事情，比如做字典的key.</p><h3 id="Assignment-1"><a href="#Assignment-1" class="headerlink" title="Assignment"></a>Assignment</h3><p>使用赋值运算符和圆括号，值得注意的是<font color="red">只有一个元素时需要添加一个逗号<code>,</code></font>，来区分工厂方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type((<span class="number">1</span>)) = <span class="string">'int'</span></span><br><span class="line">type((<span class="number">1</span>,)) = <span class="string">'tuple'</span></span><br></pre></td></tr></table></figure><h3 id="Acess"><a href="#Acess" class="headerlink" title="Acess"></a>Acess</h3><p>与列表切片操作一样，用方括号作为切片操作符，里边写上索引值或索引范围。</p><h3 id="Update-1"><a href="#Update-1" class="headerlink" title="Update"></a>Update</h3><p>因为元组是不可变的，因此不能更新或者改变元组的值，字符串必须通过现有字符串片段再构造一个新的字符串的方式来解决，对元组也必须这样。</p><h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><p>因为元组不可变，删除一个单独的元素是不可能的，只有通过<code>del</code>来减少对象的引用计数。引用计数为0时会析构对象。Python中大部分时候并不需要显式析构。</p><h3 id="Operator-1"><a href="#Operator-1" class="headerlink" title="Operator"></a>Operator</h3><ol><li><code>=</code>,<code>*</code>,<code>+</code> 创建，重复和连接</li><li><code>in/not in</code>,<code>[]</code>成员关系操作符，切片操作</li><li><code>&lt;</code>,<code>&gt;</code>,<code>==</code> 运算符</li></ol><h2 id="Functions-1"><a href="#Functions-1" class="headerlink" title="Functions"></a>Functions</h2><p>元组没有自己专用的内建函数，列表中描述的一些函数与其可变性有关，不适用于元祖。除此之外的一些适用于不可变迭代器的内建函数就可以用于元组。</p><h2 id="Methods-1"><a href="#Methods-1" class="headerlink" title="Methods"></a>Methods</h2><ol><li>tuple.count() 指定参数在tuple中出现的次数</li><li>tuple.index() 指定参数在tuple中第一次出现的次数，如果没有出现抛出错误。</li></ol><h2 id="元组的不可变性"><a href="#元组的不可变性" class="headerlink" title="元组的不可变性"></a>元组的不可变性</h2><ol><li>不可变不完全是坏事，比如将数据传入一个不了解的API，不可变可以保证数据不被修改。而如果要修改函数返回的元组，可以用list()内建函数来转化。</li><li>元组的不可变也没有那么可怕，通过连接，复制我们依然可以得到新的元组(尽管id不同了)，另外我们可以改变元组内部的一个可变对象来达到修改元组的目的(比如修改元组内部的列表元素)。</li><li>所有的逗号分隔的没有明确符号定义的集合，默认类型都是元组，但最好是显式定义类型。</li></ol><h2 id="list-amp-amp-tuple"><a href="#list-amp-amp-tuple" class="headerlink" title="list &amp;&amp; tuple"></a>list &amp;&amp; tuple</h2><ol><li>维护敏感数据-&gt;tuple</li><li>管理动态数据集合-&gt;list</li></ol><hr><h2 id="Python浅拷贝和深拷贝"><a href="#Python浅拷贝和深拷贝" class="headerlink" title="Python浅拷贝和深拷贝"></a>Python浅拷贝和深拷贝</h2><p>浅拷贝：</p><ol><li>完全切片操作</li><li>利用工厂函数</li><li>使用copy模块的copy函数<br>深拷贝：</li><li>使用copy.decopy()函数</li></ol><p>Waring:赋值运算符<code>=</code>并不会拷贝，这是类似于原引用的别名的东西(是同一个引用)。</p><ol><li>浅拷贝实际上是原对象的引用(新建的)，现在如果要改变其中的一个可变对象，那这两个对象访问的结果都会发生变化，如果这是一个联合账户(C++类中的静态对象)，那么这是期望的结果。但如果希望是相互独立的，这就导致了不期望的结果，此时需要深拷贝。</li><li>但如果改变的对象是不可变对象(比如字符串)，由于这是不同的引用，这会导致在这个改变的操作中这个不可变对象被显式拷贝，因此改变前后的对象元素已经是不同的了。</li><li>结合C++中的引用和类中的静态变量，以及Python中的引用计数机制，很容易理解。</li></ol><hr><p>参考资料：</p><ol><li><a href="http://www.howsoftworks.net/python.api/builtins/" target="_blank" rel="noopener">howsoftworks-builtins</a></li><li><a href="http://www.howsoftworks.net/python/function/" target="_blank" rel="noopener">howsoftworks-Builtin Function</a></li></ol><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;序列容器之列表和元组&lt;br&gt;列表，可变类型。&lt;br&gt;元组，不可变类型。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;列表&quot;&gt;&lt;a href=&quot;#列表&quot; class=&quot;headerlink&quot; title=&quot;列表&quot;&gt;&lt;/a&gt;列表&lt;/h1&gt;&lt;h2 id=&quot;List&quot;&gt;&lt;a href=&quot;#L
      
    
    </summary>
    
      <category term="Python" scheme="http://rylcode.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://rylcode.cn/tags/Python/"/>
    
  </entry>
  
</feed>
