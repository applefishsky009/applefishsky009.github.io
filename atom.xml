<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孤云两角，去天一握</title>
  <subtitle>山在地下，地山谦</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-05-19T01:37:30.831Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ryl</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>模九同余与各位数字之和</title>
    <link href="http://yoursite.com/2016/05/18/%E6%A8%A1%E4%B9%9D%E5%90%8C%E4%BD%99%E4%B8%8E%E5%90%84%E4%BD%8D%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/2016/05/18/模九同余与各位数字之和/</id>
    <published>2016-05-18T10:48:20.000Z</published>
    <updated>2016-05-19T01:37:30.831Z</updated>
    
    <content type="html">&lt;p&gt;$$ a\equiv b\quad(mod\ n) $$&lt;br&gt;此式即\( a \)与\( b \)同余于\( n \)；简称\( a \)与\( b \)模\( n \)同余。&lt;br&gt;同余运算见&lt;a href=&quot;https://en.wikipedia.org/wiki/Modular_arithmetic&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;维基百科&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;模九同余&quot;&gt;&lt;a href=&quot;#模九同余&quot; class=&quot;headerlink&quot; title=&quot;模九同余&quot;&gt;&lt;/a&gt;模九同余&lt;/h2&gt;&lt;p&gt;结论：任何一个整数模9同余于它的各数位上数字之和。&lt;br&gt;题目：设自然数\( N=a[n]a[n-1]\ldots a[0] \)，其中\( a[0],a[1],\ldots,a[n] \)分别是个位、十位、…上的数字，再设\( M=a[0]+a[1]+\ldots+a[n] \)&lt;br&gt;求证：\( N\equiv M\quad(mod\ 9) \)&lt;br&gt;证明：&lt;/p&gt;
&lt;p&gt;$$ \because N=a[n]a[n-1]…a[0]=a[n]\times10^n+a[n-1]\times10^{n-1}+\cdots+a[1]\times10+a[0] $$&lt;br&gt;又&lt;br&gt;$$ \because 1\equiv 1\quad(mod\ 9) $$&lt;br&gt;$$ 10\equiv 1\quad(mod\ 9) $$&lt;br&gt;$$ 10^2\equiv 1\quad(mod\ 9) $$&lt;br&gt;$$ \cdots $$&lt;br&gt;$$ 10^n\equiv 1\quad(mod\ 9) $$&lt;/p&gt;
&lt;p&gt;上面这些同余式两边分别同乘以\( a[0],a[1],a[2],\ldots,a[n] \)&lt;br&gt;再相加得：&lt;/p&gt;
&lt;p&gt;$$ a[n]\times10^n+a[n-1]\times10^{n-1}+\cdots+a[1]\times10+a[0]\equiv (a[0]+a[1]+…+a[n])\quad(mod\ 9) $$&lt;br&gt;即&lt;br&gt;$$ N\equiv M\quad(mod\ 9) $$&lt;br&gt;得证。&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;http://www.cnblogs.com/Rinyo/archive/2012/12/20/2826755.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;找规律&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;LeetCode&quot;&gt;&lt;a href=&quot;#LeetCode&quot; class=&quot;headerlink&quot; title=&quot;LeetCode&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/258%20-%20Add%20Digits/258%20-%20Add%20Digits.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;LeetCode&lt;/a&gt;&lt;/h2&gt;&lt;hr&gt;
&lt;h2 id=&quot;2012-2012&quot;&gt;&lt;a href=&quot;#2012-2012&quot; class=&quot;headerlink&quot; title=&quot;\( 2012^{2012} \)&quot;&gt;&lt;/a&gt;\( 2012^{2012} \)&lt;/h2&gt;&lt;p&gt;题目：记\( 2012^{2012} \)的各位数字之和为\( A \),\( A \)的各位数字之和是\( B \)，\( B \)的各位数字之和是\( C \)，求\( C \)的值。&lt;/p&gt;
&lt;h3 id=&quot;2012-2012-的余数&quot;&gt;&lt;a href=&quot;#2012-2012-的余数&quot; class=&quot;headerlink&quot; title=&quot;\( 2012^{2012} \)的余数&quot;&gt;&lt;/a&gt;\( 2012^{2012} \)的余数&lt;/h3&gt;&lt;p&gt;$$ \because 2012 \equiv 5\quad(mod\ 9) $$&lt;br&gt;$$ \therefore 2012^{2012} \equiv 5^{2012}\quad(mod\ 9) \equiv 25^{1006}\quad(mod\ 9) \equiv (-2)^{1006}\quad(mod\ 9) \equiv 2^{1006}\quad(mod\ 9) \equiv 2\times8^{335}\quad(mod\ 9) \equiv 2\times(-1)^{335}\quad(mod\ 9) \equiv -2\quad(mod\ 9)=7$$&lt;br&gt;又&lt;br&gt;$$ \because 2012^{2012}&amp;lt;10000^{2012}-1 $$&lt;br&gt;$$ \Rightarrow A&amp;lt;2012\times4\times9=72504 $$&lt;br&gt;$$ \Rightarrow B&amp;lt;6+4\times9=42 $$&lt;br&gt;$$ \Rightarrow C&amp;lt;3+9=12 $$&lt;br&gt;$$ \therefore C=7 $$&lt;/p&gt;
&lt;p&gt;思路：&lt;strong&gt;算出最大位数&lt;/strong&gt;，每一位给9算出\( A,B,C \)的最大值。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;$$ a\equiv b\quad(mod\ n) $$&lt;br&gt;此式即\( a \)与\( b \)同余于\( n \)；简称\( a \)与\( b \)模\( n \)同余。&lt;br&gt;同余运算见&lt;a href=&quot;https://en.wikipedia.org/wiki/
    
    </summary>
    
      <category term="Math" scheme="http://yoursite.com/categories/Math/"/>
    
    
      <category term="Modular Arithmetic" scheme="http://yoursite.com/tags/Modular-Arithmetic/"/>
    
  </entry>
  
  <entry>
    <title>伯努利级数</title>
    <link href="http://yoursite.com/2016/05/18/%E4%BC%AF%E5%8A%AA%E5%88%A9%E7%BA%A7%E6%95%B0/"/>
    <id>http://yoursite.com/2016/05/18/伯努利级数/</id>
    <published>2016-05-18T06:26:36.000Z</published>
    <updated>2016-05-18T08:47:34.112Z</updated>
    
    <content type="html">&lt;p&gt;先来彩蛋，在&lt;a href=&quot;http://www.wolframalpha.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;wolframalpha&lt;/a&gt;使用Latex格式输入数学公式，可以快速得到结果。&lt;/p&gt;
&lt;p&gt;考虑以下四种无穷级数：&lt;br&gt;$$ \sum_n\frac{1}{n^2\pm\omega^2}\qquad(1) $$&lt;/p&gt;
&lt;p&gt;$$ \prod_n(1\pm\frac{\omega^2}{n^2})\qquad(2) $$&lt;/p&gt;
&lt;p&gt;在式\( (1) \)中当\( \omega=0 \)时，公式变为伯努利级数：&lt;br&gt;$$ \sum_n\frac{1}{n^2}\qquad(3) $$&lt;/p&gt;
&lt;p&gt;式\( (3) \)中是一个非常有意思的题目，下面考虑来解决他，式\( (1) \)和式\( (2) \)并不会经常用到，具体解答见&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5ODUxOTA5Mg==&amp;amp;mid=404226908&amp;amp;idx=1&amp;amp;sn=93aa43ffa9157af03ad82543493cfe51&amp;amp;scene=23&amp;amp;srcid=042515FZI3kzNY54U1YJaKv8#rd&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;算法与数学之美&lt;/a&gt;的这篇文章。&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B7%B4%E5%A1%9E%E5%B0%94%E9%97%AE%E9%A2%98&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;维基百科上的解答&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;与式\( (3) \)相似的一个题目:&lt;br&gt;$$ \sum_nn^2 = \frac{1}{6}n(n+1)(2n+1)\qquad(4)$$&lt;br&gt;这个题目可以用数学归纳法简单求得。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;伯努利级数&quot;&gt;&lt;a href=&quot;#伯努利级数&quot; class=&quot;headerlink&quot; title=&quot;伯努利级数&quot;&gt;&lt;/a&gt;伯努利级数&lt;/h2&gt;&lt;p&gt;$$ \sum_n\frac{1}{n^2}=1+\frac{1}{4}+\frac{1}{9}+\frac{1}{16}+\cdots\qquad(5) $$&lt;/p&gt;
&lt;h3 id=&quot;泰勒展开&quot;&gt;&lt;a href=&quot;#泰勒展开&quot; class=&quot;headerlink&quot; title=&quot;泰勒展开&quot;&gt;&lt;/a&gt;泰勒展开&lt;/h3&gt;&lt;p&gt;首先，我们考虑式\( \frac{sin\sqrt{x}}{\sqrt{x}}=0 \)的根为\( n^2\pi^2,n=1,2,3,\ldots \)&lt;br&gt;左侧泰勒展开式为&lt;br&gt;$$ \frac{sin\sqrt{x}}{\sqrt{x}}=1-\frac{x}{6}+\frac{x^2}{120}-\frac{x^3}{5040}+\cdots\qquad(6) $$&lt;/p&gt;
&lt;h3 id=&quot;韦达定理&quot;&gt;&lt;a href=&quot;#韦达定理&quot; class=&quot;headerlink&quot; title=&quot;韦达定理&quot;&gt;&lt;/a&gt;韦达定理&lt;/h3&gt;&lt;p&gt;其次，考虑一元n次方程的韦达定理：&lt;br&gt;$$ 1+a_1x+a_2x^2+\cdots+a_nx^n=0\qquad(7) $$&lt;/p&gt;
&lt;p&gt;假设他有\( n \)个非零根\( x_1,x_2,\ldots,x_n \),将它转化为关于\( \frac{1}{x} \)的方程：&lt;br&gt;$$ (\frac{1}{x})^n+a_1(\frac{1}{x})^{n-1}+\cdots+a_n=0\qquad(8) $$&lt;br&gt;对应根变成\( 1/x_1,1/x_2,\ldots,1/x_n \)，由韦达定理得到：&lt;br&gt;$$ \frac{1}{x_1}+\frac{1}{x_2}+\cdots+\frac{1}{x_n}=-a_1\qquad(9) $$&lt;/p&gt;
&lt;h3 id=&quot;欧拉的大胆推广&quot;&gt;&lt;a href=&quot;#欧拉的大胆推广&quot; class=&quot;headerlink&quot; title=&quot;欧拉的大胆推广&quot;&gt;&lt;/a&gt;欧拉的大胆推广&lt;/h3&gt;&lt;p&gt;将式\( (9) \)推广在式\( (6) \)为0的根中：&lt;/p&gt;
&lt;p&gt;$$ \frac{1}{\pi^2}+\frac{1}{2^2\pi^2}+\frac{1}{3^2\pi^2}+\cdots=-a_1=\frac{1}{6}\qquad(10) $$&lt;br&gt;那么：&lt;br&gt;$$ 1+\frac{1}{2^2}+\frac{1}{3^2}+\cdots=\frac{\pi^2}{6}\qquad(11) $$&lt;/p&gt;
&lt;p&gt;如算法与数学之美中所说，其启发性创造性远远掩盖其不严格性。&lt;/p&gt;
&lt;h3 id=&quot;注解&quot;&gt;&lt;a href=&quot;#注解&quot; class=&quot;headerlink&quot; title=&quot;注解&quot;&gt;&lt;/a&gt;注解&lt;/h3&gt;&lt;p&gt;如果直接在式\( (7) \)中使用韦达定理，得到&lt;br&gt;$$ -\frac{a_{n-1}}{a_n}=\pi^2\sum_nn^2=\frac{\pi^2}{6}n(n+1)(2n+1)\qquad(12) $$&lt;br&gt;但是这个只有在\( n\rightarrow\infty \)才是有意义的，例如不能取\( n=3 \)(一个特定数值)来使等式成立。就如式\( (11) \)中取级数前\( n=3 \)部分使之成立。因此对无穷级数的未知项用韦达定理是没有意义的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;先来彩蛋，在&lt;a href=&quot;http://www.wolframalpha.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;wolframalpha&lt;/a&gt;使用Latex格式输入数学公式，可以快速得到结果。&lt;/p&gt;
&lt;p&gt;考虑以下四种无穷级数：&lt;
    
    </summary>
    
      <category term="Math" scheme="http://yoursite.com/categories/Math/"/>
    
    
      <category term="Bernoulli Series" scheme="http://yoursite.com/tags/Bernoulli-Series/"/>
    
  </entry>
  
  <entry>
    <title>牛顿迭代法</title>
    <link href="http://yoursite.com/2016/05/17/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95/"/>
    <id>http://yoursite.com/2016/05/17/牛顿迭代法/</id>
    <published>2016-05-17T04:29:01.000Z</published>
    <updated>2016-05-18T05:09:18.020Z</updated>
    
    <content type="html">&lt;p&gt;牛顿迭代法是一种巧妙地(切线)逼近方法，它是一种在实数域和复数域上近似求解方程的方法。&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E6%B3%95&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;维基百科的介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面的图(来源于wiki)巧妙的解释了牛顿迭代法的过程：&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/2y9UyHF.gif&quot; alt=&quot;牛顿迭代法&quot;&gt;&lt;/p&gt;
&lt;p&gt;公式如下：&lt;br&gt;$$ x_{n+1} = x_n-\frac{f(x_n)}{f’(x_n)} $$&lt;/p&gt;
&lt;p&gt;Markdownpad2不支持Latex有点烦，使用atom编辑器和markdowm pas plus插件可以解决这个问题，在HEXO博客上部署数学公式需要给HEXO安装&lt;a href=&quot;http://catx.me/2014/03/09/hexo-mathjax-plugin/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hexo-mathjax插件&lt;/a&gt;,注意在本机中使用时不需要修改_config.yml配置文件，否则会生成错误。&lt;br&gt;参考：&lt;a href=&quot;http://www.jeyzhang.com/how-to-insert-equations-in-markdown.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MarkdownPad 2的MathJax插件&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;牛顿迭代法在开方中的应用&quot;&gt;&lt;a href=&quot;#牛顿迭代法在开方中的应用&quot; class=&quot;headerlink&quot; title=&quot;牛顿迭代法在开方中的应用&quot;&gt;&lt;/a&gt;牛顿迭代法在开方中的应用&lt;/h2&gt;&lt;p&gt;开方的迭代式：&lt;br&gt;$$ x_{k+1} = \frac{1}{2}(x_k+\frac{n}{x_k}) $$&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/69%20-%20Sqrt(x)/69%20-%20Sqrt(int%20x).cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;int&lt;/code&gt;开方&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/69%20-%20Sqrt(x)/69%20-%20Sqrt(int%20x).cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;float&lt;/code&gt;开方&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Magic Number(只针对&lt;code&gt;float&lt;/code&gt;，链接同2)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;在开方的计算中，二分查找和牛顿迭代法时间复杂度都是O(logn)，但是牛顿迭代法优于二分查找。&lt;/li&gt;
&lt;li&gt;基于牛顿迭代法的&lt;code&gt;float&lt;/code&gt;开方中使用Magic Number，可以看到使用3次牛顿迭代法就可以得到较高的精确度(相同的迭代次数，要开放的数字越大，精度越低)，其原理与浮点数的存储相关，因此只用于浮点数。&lt;/li&gt;
&lt;li&gt;直观来看，开方(凹型曲线)时牛顿迭代法只从右侧逼近，二分查找从右侧左侧同时逼近,因此显然牛顿迭代法优于二分查找法，尤其对高阶的f(x),牛顿迭代法的逼近速度更快。&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;牛顿迭代法是一种巧妙地(切线)逼近方法，它是一种在实数域和复数域上近似求解方程的方法。&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E6%B3%95&quot; target=&quot;_blank&quot; rel=&quot;exter
    
    </summary>
    
      <category term="Math" scheme="http://yoursite.com/categories/Math/"/>
    
    
      <category term="Newton iterative method" scheme="http://yoursite.com/tags/Newton-iterative-method/"/>
    
  </entry>
  
  <entry>
    <title>multimap简介</title>
    <link href="http://yoursite.com/2016/05/16/multimap%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2016/05/16/multimap简介/</id>
    <published>2016-05-16T04:42:19.000Z</published>
    <updated>2016-05-16T06:31:48.006Z</updated>
    
    <content type="html">&lt;h2 id=&quot;multimap简介&quot;&gt;&lt;a href=&quot;#multimap简介&quot; class=&quot;headerlink&quot; title=&quot;multimap简介&quot;&gt;&lt;/a&gt;multimap简介&lt;/h2&gt;&lt;p&gt;multimap是一种Hash Table。首先使用&lt;code&gt;multimap&lt;/code&gt;必须使用宏语句&lt;code&gt;#include &amp;lt;map&amp;gt;&lt;/code&gt;。MSDN上对multimap的解释已经比较清楚&lt;a href=&quot;http://blog.csdn.net/chenyujing1234/article/details/8193172&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;multimap基础&lt;/a&gt;，&lt;a href=&quot;http://blog.csdn.net/xz_rabbit/article/details/43907311&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;multimap与map，unorderedmap的对比&lt;/a&gt;&lt;br&gt;主要有以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;multimap多重映照容器:容器的数据结构采用红黑树进行管理(还没有深入理解)；&lt;/li&gt;
&lt;li&gt;multimap的所有元素都是pair:第一元素为键值(key),不能修改;第二元素为实值(value),可被修改 &lt;/li&gt;
&lt;li&gt;multimap特性以及用法与map完全相同，唯一的差别在于: 允许重复键值的元素插入容器(每一个都是用一个&lt;strong&gt;链表&lt;/strong&gt;来链接的)，参考&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/126%20-%20Word%20Ladder%20II/126%20-%20Word%20Ladder%20II.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里的github&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unordered_multimap&lt;/code&gt;(目前还没有用到过)的无序存储特点，这是其与&lt;code&gt;multimap&lt;/code&gt;最大的区别。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;multimap的使用&quot;&gt;&lt;a href=&quot;#multimap的使用&quot; class=&quot;headerlink&quot; title=&quot;multimap的使用&quot;&gt;&lt;/a&gt;multimap的使用&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;初始化:&lt;code&gt;multimap&amp;lt;string, string&amp;gt; father;&lt;/code&gt;，第一个是key类型，第二个是映照类型；&lt;/li&gt;
&lt;li&gt;插入数据:&lt;code&gt;father.insert(make_pair(string1, string2);&lt;/code&gt;，&lt;a href=&quot;http://www.cnblogs.com/Nimeux/archive/2010/10/05/1844191.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;pair&lt;/code&gt;与&lt;code&gt;make_pair&lt;/code&gt;介绍&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;寻找某个键值:&lt;code&gt;pair&amp;lt;multimap&amp;lt;string, string&amp;gt;::iterator, multimap&amp;lt;string, string&amp;gt;::iterator&amp;gt; pos = father.equal_range(string1)&lt;/code&gt;;&lt;code&gt;equal_range(string1);&lt;/code&gt;注意其返回的是&lt;code&gt;pair&lt;/code&gt;对象，&lt;code&gt;first&lt;/code&gt;和&lt;code&gt;second&lt;/code&gt;都是迭代器类型，他返回键值为&lt;code&gt;string1&lt;/code&gt;的左指针和超尾(右)指针(最后一个键值为&lt;code&gt;string1&lt;/code&gt;的下一个指针)，源码如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;typedef pair&amp;lt;iterator, iterator&amp;gt; _Pairii;

_Pairii equal_range(const key_type&amp;amp; _Keyval)
{    // find range equivalent to _Keyval in mutable tree
    return (_Eqrange(_Keyval));
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;multimap简介&quot;&gt;&lt;a href=&quot;#multimap简介&quot; class=&quot;headerlink&quot; title=&quot;multimap简介&quot;&gt;&lt;/a&gt;multimap简介&lt;/h2&gt;&lt;p&gt;multimap是一种Hash Table。首先使用&lt;code&gt;multim
    
    </summary>
    
      <category term="STL" scheme="http://yoursite.com/categories/STL/"/>
    
    
      <category term="multimap" scheme="http://yoursite.com/tags/multimap/"/>
    
  </entry>
  
  <entry>
    <title>i++与++i的区别</title>
    <link href="http://yoursite.com/2016/05/06/i++%E4%B8%8E++i%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2016/05/06/i++与++i的区别/</id>
    <published>2016-05-06T06:22:46.000Z</published>
    <updated>2016-05-06T07:08:58.310Z</updated>
    
    <content type="html">&lt;p&gt;一直以来对&lt;code&gt;++i&lt;/code&gt;与&lt;code&gt;i++&lt;/code&gt;，知道前者效率更高，但是不知道为什么。有人说与寄存器有关，实际上寄存器都执行了一次加法，是一样的。看了&lt;a href=&quot;http://falldog7.blogspot.jp/2007/10/programmer-i-i.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里的博客&lt;/a&gt;才恍然大悟，原来是其实现的机制不同。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;++i&lt;/code&gt;先加再用，其对i类型(假设为INT)的++运算符重载如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//++i&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;INT operator ++()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	this-&amp;gt;_value++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return *this;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;i++&lt;/code&gt;先用再加，创建临时变量保存原有值用来返回，后调用++i语句，重载如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//i++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;INT operator ++(int t)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	INT temp(_value);//!!! 必須create出一個temp的變數!!!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	this-&amp;gt;_value++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在这个函数中参数n是没有任何意义的，它的存在只是为了区分是前置形式还是后置形式。&lt;/p&gt;
&lt;p&gt;可以看到&lt;code&gt;i++&lt;/code&gt;所必须付出的代价，就是多create出一个temp的变量，以及temp变量的的constructor()。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;一直以来对&lt;code&gt;++i&lt;/code&gt;与&lt;code&gt;i++&lt;/code&gt;，知道前者效率更高，但是不知道为什么。有人说与寄存器有关，实际上寄存器都执行了一次加法，是一样的。看了&lt;a href=&quot;http://falldog7.blogspot.jp/2007/10/pro
    
    </summary>
    
      <category term="C++的类" scheme="http://yoursite.com/categories/C-%E7%9A%84%E7%B1%BB/"/>
    
    
      <category term="自增减运算符重载" scheme="http://yoursite.com/tags/%E8%87%AA%E5%A2%9E%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的递归遍历与栈遍历</title>
    <link href="http://yoursite.com/2016/05/06/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E4%B8%8E%E6%A0%88%E9%81%8D%E5%8E%86/"/>
    <id>http://yoursite.com/2016/05/06/二叉树的递归遍历与栈遍历/</id>
    <published>2016-05-06T02:43:22.000Z</published>
    <updated>2016-05-06T04:44:10.888Z</updated>
    
    <content type="html">&lt;p&gt;二叉树的遍历算法有三种，最简单的递归遍历，还有两种非递归遍历，分别是使用栈的遍历和Morris遍历。每一种遍历根据访问根节点的时机又分为前序，中序，后序三种。&lt;br&gt;二叉树节点的定义如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;struct TreeNode &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	TreeNode *left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	TreeNode *right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	TreeNode(int x) : val(x), left(nullptr), right(nullptr) &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;二叉树的递归遍历&quot;&gt;&lt;a href=&quot;#二叉树的递归遍历&quot; class=&quot;headerlink&quot; title=&quot;二叉树的递归遍历&quot;&gt;&lt;/a&gt;二叉树的递归遍历&lt;/h2&gt;&lt;p&gt;没什么技巧，方式如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class Solution &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	void Traversal(TreeNode* root,vector&amp;lt;int&amp;gt; &amp;amp;result) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if (!root)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		//result.push(root-&amp;gt;val);	//preorderTraversal&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Traversal(root-&amp;gt;left,result);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		//result.push(root-&amp;gt;val);	//inorderTraversal&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Traversal(root-&amp;gt;right,result);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		//result.push(root-&amp;gt;val);	//postorderTraversal&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;二叉树的栈遍历&quot;&gt;&lt;a href=&quot;#二叉树的栈遍历&quot; class=&quot;headerlink&quot; title=&quot;二叉树的栈遍历&quot;&gt;&lt;/a&gt;二叉树的栈遍历&lt;/h2&gt;&lt;p&gt;前序和中序可以用同一段代码来实现(用栈记忆所有左子树(while)，回溯一位(if)访问右子树)：&lt;br&gt;&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/144%20-%20Binary%20Tree%20Preorder%20Traversal/144%20-%20Binary%20Tree%20Preorder%20Traversal.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前序遍历&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/94%20-%20Binary%20Tree%20Inorder%20Traversal/94%20-%20Binary%20Tree%20Inorder%20Traversal.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;中序遍历&lt;/a&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class Solution &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	vector&amp;lt;int&amp;gt; inorderTraversal(TreeNode* root) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		vector&amp;lt;int&amp;gt; result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		stack&amp;lt;TreeNode*&amp;gt; sS1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		while (root||!sS1.empty())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			while (root)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				//result.push_back(root-&amp;gt;val);	//先序遍历的位置&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				sS1.push(root);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				root = root-&amp;gt;left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			if (!sS1.empty())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				root = sS1.top();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				sS1.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				result.push_back(root-&amp;gt;val);	//中序遍历的位置&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				root = root-&amp;gt;right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		return result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;后序遍历稍微复杂一点，有两种思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;左子树-&amp;gt;右子树-&amp;gt;节点(后序)    转化为    节点-&amp;gt;右子树-&amp;gt;左子树(前序) 的翻转(栈)&lt;/li&gt;
&lt;li&gt;对于任一结点P，先将其入栈。如果P不存在左孩子和右孩子，则可以直接访问它。或者P存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。若非上述两种情况，则将P的右孩子和左孩子依次入栈。这样就保证了每次取栈顶元素的时候，左孩子和右孩子都在根结点前面被访问。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/145%20-%20Binary%20Tree%20Postorder%20Traversal/145%20-%20Binary%20Tree%20Postorder%20Traversal.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;后序遍历&lt;/a&gt;&lt;br&gt;第一种(变异的前序)：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class Solution1 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	vector&amp;lt;int&amp;gt; postorderTraversal(TreeNode* root) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		vector&amp;lt;int&amp;gt; outTreeNode;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		stack&amp;lt;TreeNode*&amp;gt; sTreeNode;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		stack&amp;lt;int&amp;gt; sInt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		while (root||!sTreeNode.empty())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			while (root)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				sInt.push(root-&amp;gt;val);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				sTreeNode.push(root);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				root=root-&amp;gt;right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			if (!sTreeNode.empty())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				root=sTreeNode.top();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				sTreeNode.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				root=root-&amp;gt;left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		while (!sInt.empty())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			outTreeNode.push_back(sInt.top());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			sInt.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		return outTreeNode;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;第二种(利用pre指针的后序)：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class Solution &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	vector&amp;lt;int&amp;gt; postorderTraversal(TreeNode* root) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		vector&amp;lt;int&amp;gt; outTreeNode;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		stack&amp;lt;TreeNode*&amp;gt; sTreeNode;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		TreeNode* pre=nullptr;	//指向之前访问的节点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if (root)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			sTreeNode.push(root);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		while (!sTreeNode.empty())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			root=sTreeNode.top();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			if ((root-&amp;gt;left==nullptr&amp;amp;&amp;amp;root-&amp;gt;right==nullptr)||(pre!=nullptr&amp;amp;&amp;amp;(pre==root-&amp;gt;left||pre==root-&amp;gt;right)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				outTreeNode.push_back(root-&amp;gt;val);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				pre=root;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				sTreeNode.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				if (root-&amp;gt;right)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					sTreeNode.push(root-&amp;gt;right);//右孩子先入栈，后访问&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				if (root-&amp;gt;left)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					sTreeNode.push(root-&amp;gt;left);//左孩子后入栈，先访问&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		return outTreeNode;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;二叉树的遍历算法有三种，最简单的递归遍历，还有两种非递归遍历，分别是使用栈的遍历和Morris遍历。每一种遍历根据访问根节点的时机又分为前序，中序，后序三种。&lt;br&gt;二叉树节点的定义如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="非递归遍历" scheme="http://yoursite.com/tags/%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>BP、KMP、改进的KMP</title>
    <link href="http://yoursite.com/2016/05/03/BP%E3%80%81KMP%E3%80%81%E6%94%B9%E8%BF%9B%E7%9A%84KMP/"/>
    <id>http://yoursite.com/2016/05/03/BP、KMP、改进的KMP/</id>
    <published>2016-05-03T06:57:41.000Z</published>
    <updated>2016-05-06T04:44:53.510Z</updated>
    
    <content type="html">&lt;p&gt;在主串S中，自low位置开始，查找与模式串T相等的子串。如果这样的子串存在，返回其第一次出现的位置。本文详细介绍三种字符串匹配算法:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;BF(Brute-Force)算法(暴力破解);&lt;/li&gt;
&lt;li&gt;KMP算法;&lt;/li&gt;
&lt;li&gt;改进的KMP算法。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这三种算法的代码&lt;a href=&quot;https://github.com/applefishsky009/Interface/blob/master/BF%E5%92%8CKMP/BF%E5%92%8CKMP.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在这里&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;BF算法&quot;&gt;&lt;a href=&quot;#BF算法&quot; class=&quot;headerlink&quot; title=&quot;BF算法&quot;&gt;&lt;/a&gt;BF算法&lt;/h2&gt;&lt;p&gt;设主串从i位开始与子串(从0开始)判断是否匹配;到子串的j位置，对应主串的i+j位置失配;将主串左移一位(&lt;code&gt;i++&lt;/code&gt;),j回到0位继续匹配。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;KMP算法&quot;&gt;&lt;a href=&quot;#KMP算法&quot; class=&quot;headerlink&quot; title=&quot;KMP算法&quot;&gt;&lt;/a&gt;KMP算法&lt;/h2&gt;&lt;h3 id=&quot;为什么是next-j&quot;&gt;&lt;a href=&quot;#为什么是next-j&quot; class=&quot;headerlink&quot; title=&quot;为什么是next[j]&quot;&gt;&lt;/a&gt;为什么是next[j]&lt;/h3&gt;&lt;p&gt;每次失配将i右移一位显然是低效的。&lt;strong&gt;主观上来考虑，如果在失配之前子串有相等的真后缀，那么就可以右移更多的位。&lt;/strong&gt;考虑在i+j位失配时将主串左移k位(子串右移k位)，而不是一位。容易得到，这个k只与子串的性质有关。&lt;br&gt;我们使用next[j]来标识当j位失配时子串应向右移j-next[j]位。示例:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;code&gt;abcdefg&lt;/code&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;0 1 2 3 4 5 6&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;next[j]&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-1 0 0 0 0 0 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;offset&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1 1 2 3 4 5 6&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;code&gt;abcabcabc&lt;/code&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;0 1 2 3 4 5 6 7 8&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;next[j]&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-1 0 0 0 1 2 3 4 5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;offset&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1 1 2 3 3 3 3 3 3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;如何求得next-j&quot;&gt;&lt;a href=&quot;#如何求得next-j&quot; class=&quot;headerlink&quot; title=&quot;如何求得next[j]&quot;&gt;&lt;/a&gt;如何求得next[j]&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/qc2eynB.png&quot; alt=&quot;这里&quot;&gt;&lt;/p&gt;
&lt;p&gt;在计算公式中第二行指的是:j位&lt;strong&gt;以前&lt;/strong&gt;字串中真前后缀的最大&lt;strong&gt;公共&lt;/strong&gt;元素长度。真前缀、真后缀指的不包含串本身的子串。那么我们可以这样来计算j:&lt;br&gt;tempNext[j]表示j位及以前子串真前缀最大公共元素长度。将tempNext[j]右移一位，初值赋为-1,得到next[j]&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;code&gt;xyxyyxxyx&lt;/code&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;0 1 2 3 4 5 6 7 8&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;tempNext[j]&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0 0 1 2 0 1 1 2 3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;next[j]&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-1 0 0 1 2 0 1 1 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;offset&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1 1 2 2 2 5 5 6 6&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;tempNext[j]的计算:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//计算j位及之前真前缀以及真后缀的最大公共元素长度&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void calTempNext(vector&amp;lt;int&amp;gt;&amp;amp;next)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if (s2.size() == 1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	next[0] = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int k = 0;//前缀指针,j就是后缀指针&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	for (int j = 1;j &amp;lt; s2.size();j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		while(k &amp;gt; 0 &amp;amp;&amp;amp; s2[j] != s2[k])//k位失配，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			k = next[k-1];//k-1是可靠匹配，next[k-1]记录了上一个真后缀出现的地方&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if (s2[j] == s2[k])//匹配，k++,j++，next[j]赋值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			k++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		next[j] = k;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;如何在编程中求得next-j&quot;&gt;&lt;a href=&quot;#如何在编程中求得next-j&quot; class=&quot;headerlink&quot; title=&quot;如何在编程中求得next[j]&quot;&gt;&lt;/a&gt;如何在编程中求得next[j]&lt;/h3&gt;&lt;p&gt;如果使用上述计算过程，先计算tempNext[j]再计算next[j]，需要两次遍历。将tempNext[j]右移初值赋-1的过程可以直接融入程序中，使用一次遍历就可以得到next[j]，&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//直接计算next(时间复杂度O(n))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void cal2Next(vector&amp;lt;int&amp;gt;&amp;amp;next)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int j = -1;		//j,偏移指针&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int i = 0;		//i,next下标（实际上是要计算的next下标-1,因为是先加后赋值）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	next[0] = -1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	while (i &amp;lt; s2.size()-1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if (j == -1 || s2[i]==s2[j])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			i++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			j++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			next[i] = j;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			j = next[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;改进的KMP算法&quot;&gt;&lt;a href=&quot;#改进的KMP算法&quot; class=&quot;headerlink&quot; title=&quot;改进的KMP算法&quot;&gt;&lt;/a&gt;改进的KMP算法&lt;/h2&gt;&lt;p&gt;next[j]值越小，模式匹配所需比较次数越少。next[j]的计算中先判断匹配，i,j自加再赋值。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若自加之后失配，这时候i失配并不代表j失配，因此留给下次循环回溯后来判断。&lt;/li&gt;
&lt;li&gt;若自加之后匹配，说明i与j位置完全等效，i失配，j一定失配。，而朴素的KMP算法在失配之后要一次一次回溯。因此可以&lt;font color=&quot;red&quot;&gt;一次回溯到底&lt;/font&gt;节约比较次数。&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;code&gt;abcaabbabcaac&lt;/code&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;0 1 2  3 4 5 6  7 8 9 10 11 12&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;next[j]&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-1 0 0  0 1 1 2  0 1 2  3  4  5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;offset1&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1 1 2  3 3 4 4  7 7 7  7  7  7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;nextVal[j]&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-1 0 0 -1 1 0 2 -1 0 0 -1  1  5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;offset2&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1 1 2  4 3 5 4  8 8 9 11 10  7&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/28%20-%20Implement%20strStr()/28%20-%20Implement%20strStr().cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;LeetCode代码&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在主串S中，自low位置开始，查找与模式串T相等的子串。如果这样的子串存在，返回其第一次出现的位置。本文详细介绍三种字符串匹配算法:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;BF(Brute-Force)算法(暴力破解);&lt;/li&gt;
&lt;li&gt;KMP算法;&lt;/li&gt;
&lt;li&gt;改进的KMP算
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="字符串匹配" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    
      <category term="KMP" scheme="http://yoursite.com/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>野指针与内存泄漏</title>
    <link href="http://yoursite.com/2016/04/25/%E9%87%8E%E6%8C%87%E9%92%88%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>http://yoursite.com/2016/04/25/野指针与内存泄漏/</id>
    <published>2016-04-25T01:36:10.000Z</published>
    <updated>2016-05-06T04:55:02.316Z</updated>
    
    <content type="html">&lt;p&gt;野指针和内存泄漏是两个相联系的概念，一般来讲指针&amp;lt;-&amp;gt;内存相互对应，如果有一个指针但没有指向任何内存，就是野指针；如果有一块未释放的内存，但没有指针指向他，就是内存泄露。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;野指针&quot;&gt;&lt;a href=&quot;#野指针&quot; class=&quot;headerlink&quot; title=&quot;野指针&quot;&gt;&lt;/a&gt;野指针&lt;/h2&gt;&lt;p&gt;野指针指向一个已删除对象或未申请访问受限内存区域的指针，一般来说野指针有三个成因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;指针变量未初始化；&lt;/li&gt;
&lt;li&gt;指针释放后未置空；&lt;/li&gt;
&lt;li&gt;指针操作超越变量作用域。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;值得注意的是，如果有多个指针指向同一块内存，释放其中一个指针后，应将包含这个指针在内的指向这一块内存的所有指针都置空，否则都会成为野指针。&lt;/p&gt;
&lt;h2 id=&quot;内存泄漏&quot;&gt;&lt;a href=&quot;#内存泄漏&quot; class=&quot;headerlink&quot; title=&quot;内存泄漏&quot;&gt;&lt;/a&gt;内存泄漏&lt;/h2&gt;&lt;p&gt;在某一块内存的生命周期内，指向它的指针全部指向别处时，用户无法访问，也无法申请到这一块内存。这就是内存泄露。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;野指针和内存泄漏是两个相联系的概念，一般来讲指针&amp;lt;-&amp;gt;内存相互对应，如果有一个指针但没有指向任何内存，就是野指针；如果有一块未释放的内存，但没有指针指向他，就是内存泄露。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;野指针&quot;&gt;&lt;a href=&quot;#野指针&quot; class=&quot;h
    
    </summary>
    
      <category term="C++基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="野指针" scheme="http://yoursite.com/tags/%E9%87%8E%E6%8C%87%E9%92%88/"/>
    
      <category term="内存泄漏" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Git命令</title>
    <link href="http://yoursite.com/2016/04/23/Git%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2016/04/23/Git命令/</id>
    <published>2016-04-23T06:27:10.000Z</published>
    <updated>2016-05-12T08:52:46.756Z</updated>
    
    <content type="html">&lt;p&gt;初学git，记录当时的一些解决方法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/22132675&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;删除不想要的git历史&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/q/1010000000115900&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;删除版本库中的提交&lt;/a&gt;注意，他将HEAD指向某一个commit，之后的commit和文件都被擦除了，删除前做好备份……&lt;/li&gt;
&lt;li&gt;博客中常用的命令：hexo clean(删除一些没有用的缓存，比如删掉的tag等);hexo generate(生成一个commit?);hexo deploy(提交到远程)&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;初学git，记录当时的一些解决方法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/22132675&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;删除不想要的git历史&lt;/a&gt;&lt;/li&gt;
&lt;li
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://yoursite.com/2016/04/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2016/04/22/动态规划/</id>
    <published>2016-04-22T09:07:05.000Z</published>
    <updated>2016-05-16T07:57:05.637Z</updated>
    
    <content type="html">&lt;p&gt;持续更新，记录在编程过程中关于动态规划(DP)的心得体会。算法分析以算法导论为主。主要是用于求解最优化问题，不同于递归用于解决互不相交的子问题，动态规划应用于子问题重叠的情况。在实际应用中发现他有两个关键点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;子问题的&lt;strong&gt;状态转移方程&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;保存子问题的解用于递归(自顶向下);&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;它有两种等价的实现方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;带备忘的自顶向下；&lt;/li&gt;
&lt;li&gt;自底向上。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般来说自底向上更容易实现。实际中哪一种更容易编程取决于具体问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/120%20-%20Triangle/120%20-%20Triangle.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;triangle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/tree/master/62%20-%20Unique%20Paths&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Unique Paths&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;持续更新，记录在编程过程中关于动态规划(DP)的心得体会。算法分析以算法导论为主。主要是用于求解最优化问题，不同于递归用于解决互不相交的子问题，动态规划应用于子问题重叠的情况。在实际应用中发现他有两个关键点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;子问题的&lt;strong&gt;状态转移方程&lt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法</title>
    <link href="http://yoursite.com/2016/04/22/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2016/04/22/贪心算法/</id>
    <published>2016-04-22T07:54:31.000Z</published>
    <updated>2016-05-18T02:02:07.495Z</updated>
    
    <content type="html">&lt;p&gt;持续更新，记录在编程过程中关于贪心算法的心得体会。算法分析以算法导论为主。求解最优化问题比动态规划更为简洁高效。其思想核心是&lt;font color=&quot;red&quot;&gt;选择当前最优解&lt;/font&gt;，虽然不一定是全局最优解。贪心算法主要应用有&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;活动选择问题&lt;/li&gt;
&lt;li&gt;霍夫曼编码&lt;/li&gt;
&lt;li&gt;最小生成树&lt;/li&gt;
&lt;li&gt;单元最短路径的Dijkstra算法&lt;/li&gt;
&lt;li&gt;集合覆盖问题的贪心启发式算法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;贪心算法的形式一般有&lt;strong&gt;递归贪心算法&lt;/strong&gt;，&lt;strong&gt;迭代贪心算法&lt;/strong&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;活动选择问题&quot;&gt;&lt;a href=&quot;#活动选择问题&quot; class=&quot;headerlink&quot; title=&quot;活动选择问题&quot;&gt;&lt;/a&gt;活动选择问题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;调度竞争共享资源的多个活动问题，选出最大的互相兼容的活动集合；&lt;ul&gt;
&lt;li&gt;选择一个活动，选出他后剩下的资源能尽量多的被其他任务所用(算法导论16.1)；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Jump Game；&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/55%20-%20Jump%20Game/55%20-%20Jump%20Game%20%20.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Jump Game&lt;/a&gt;,每个节点选择更新当前最优解。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/45%20-%20Jump%20Game%20II/45%20-%20Jump%20Game%20II.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Jump GameⅡ&lt;/a&gt;, 每一步选择当前最优解(层数，是一层一一层映射的关系，怎么感觉是在广搜？!)。&lt;/li&gt;
&lt;li&gt;Jump GameⅡ比Jump Game多出统计步数，在这个映射范围内选择最优解&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;持续更新，记录在编程过程中关于贪心算法的心得体会。算法分析以算法导论为主。求解最优化问题比动态规划更为简洁高效。其思想核心是&lt;font color=&quot;red&quot;&gt;选择当前最优解&lt;/font&gt;，虽然不一定是全局最优解。贪心算法主要应用有&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;活动选择问题&lt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="贪心" scheme="http://yoursite.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>函数参数的传递</title>
    <link href="http://yoursite.com/2016/04/22/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92/"/>
    <id>http://yoursite.com/2016/04/22/函数参数的传递/</id>
    <published>2016-04-22T01:42:40.000Z</published>
    <updated>2016-05-06T06:20:28.808Z</updated>
    
    <content type="html">&lt;p&gt;函数参数的传递有三种，按值传递，按址传递，按引用传递(C++新增)。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h2&gt;&lt;h3 id=&quot;引用的本质&quot;&gt;&lt;a href=&quot;#引用的本质&quot; class=&quot;headerlink&quot; title=&quot;引用的本质&quot;&gt;&lt;/a&gt;引用的本质&lt;/h3&gt;&lt;p&gt;C++将&lt;code&gt;&amp;amp;&lt;/code&gt;符号赋予了另一个含义，用来声明引用。引用是已定义变量的别名(同一块内存)。引用的主要作用是用作函数形参。&lt;br&gt;引用的本质是&lt;font color=&quot;red&quot;&gt;指针常量&lt;/font&gt;，例如&lt;code&gt;int &amp;amp;pr = rats;&lt;/code&gt;是&lt;code&gt;int* const pr = &amp;amp;rats;&lt;/code&gt;的伪装。它的含义是他是一个指针，指向一个常量地址。因此他有以下特性也就很好理解了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;必须在声明引用是将其初始化；(因为指向常量地址)&lt;/li&gt;
&lt;li&gt;初始化时，省略了取地址符的操作&lt;code&gt;&amp;amp;&lt;/code&gt;,给我们感觉是别名；&lt;/li&gt;
&lt;li&gt;声明引用时，隐藏了对指针常量的自动间接引用，让我们看不到指针。&lt;/li&gt;
&lt;li&gt;使用引用时，隐藏了解除引用&lt;code&gt;*&lt;/code&gt;,让我们觉得是在直接修改(别名)变量。&lt;br&gt;如下：&lt;img src=&quot;http://i.imgur.com/idRXQZy.png&quot; alt=&quot;这里&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;返回引用&quot;&gt;&lt;a href=&quot;#返回引用&quot; class=&quot;headerlink&quot; title=&quot;返回引用&quot;&gt;&lt;/a&gt;返回引用&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;返回引用比传统返回机制烧了拷贝复制，效率更高。&lt;/li&gt;
&lt;li&gt;返回引用本质是返回“别名”,因此要注意保证返回后这个内存依然存在。(变量持续性)&lt;/li&gt;
&lt;li&gt;返回类型&lt;strong&gt;一般&lt;/strong&gt;用&lt;font color=&quot;red&quot;&gt;&lt;code&gt;const&lt;/code&gt;标识&lt;/font&gt;，将其设置为不可修改的左值，避免数据损失。&lt;ul&gt;
&lt;li&gt;赋值语句，左边必须是可修改的左值；&lt;/li&gt;
&lt;li&gt;常规返回类型是右值(因为其位于临时内存单元)-&amp;gt;不能通过地址访问。(可以出现在表达式右边，但不能出现在左边，如字面值&lt;code&gt;10.0&lt;/code&gt;,表达式&lt;code&gt;x+y&lt;/code&gt;) &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果返回局部变量(运算符重载中)，不能返回引用。&lt;/p&gt;
&lt;h3 id=&quot;C-C-中的左值和右值&quot;&gt;&lt;a href=&quot;#C-C-中的左值和右值&quot; class=&quot;headerlink&quot; title=&quot;C/C++中的左值和右值&quot;&gt;&lt;/a&gt;C/C++中的左值和右值&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;左值是一个引用到对象的表达式，因此可以取址(可以赋值)；&lt;/li&gt;
&lt;li&gt;右值强调的不是表达式本身，而是该表达式运算后的结果。这个结果往往并不引用到某一对象，可以看成计算的中间结果(临时内存单元)；（当然它也可能引用到某一对象，但是通过该右值表达式我们不能直接修改该对象—）。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;按值传递&quot;&gt;&lt;a href=&quot;#按值传递&quot; class=&quot;headerlink&quot; title=&quot;按值传递&quot;&gt;&lt;/a&gt;按值传递&lt;/h2&gt;&lt;p&gt;C++将数值参数传递给函数，函数将其赋给一个新的变量，新变量与旧变量在赋值之后没有任何关系。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;按址传递&quot;&gt;&lt;a href=&quot;#按址传递&quot; class=&quot;headerlink&quot; title=&quot;按址传递&quot;&gt;&lt;/a&gt;按址传递&lt;/h2&gt;&lt;p&gt;C++将参数地址传递给函数，函数原型用指针(一般用&lt;code&gt;const&lt;/code&gt;修饰表示指针不会乱指)指向这个地址&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;数组传递&quot;&gt;&lt;a href=&quot;#数组传递&quot; class=&quot;headerlink&quot; title=&quot;数组传递&quot;&gt;&lt;/a&gt;数组传递&lt;/h2&gt;&lt;p&gt;数组在传递时，编译器将数组名解释为第一个元素的地址，因此传递实参为数组时，形参应该是一个指针指向这个地址。&lt;br&gt;在用多维数组名作为形参时，可以指定所有维数的大小，也可以省略第一位的大小(高维大小必须指定)，这与编译器寻址有关，比如&lt;code&gt;int p[m][n]&lt;/code&gt;如果要取&lt;code&gt;p[i][j]&lt;/code&gt;的值，编译器会计算地址为&lt;code&gt;p+i*n+j;&lt;/code&gt;，因此编译器可以不知道m的值，但必须知道n的值。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;函数参数的传递有三种，按值传递，按址传递，按引用传递(C++新增)。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h2&gt;&lt;h3 id=&quot;引用的本质&quot;&gt;&lt;a href=&quot;#引
    
    </summary>
    
      <category term="C++基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="引用" scheme="http://yoursite.com/tags/%E5%BC%95%E7%94%A8/"/>
    
      <category term="参数传递" scheme="http://yoursite.com/tags/%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"/>
    
      <category term="左值和右值" scheme="http://yoursite.com/tags/%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>BFS和DFS</title>
    <link href="http://yoursite.com/2016/04/21/BFS%E5%92%8CDFS/"/>
    <id>http://yoursite.com/2016/04/21/BFS和DFS/</id>
    <published>2016-04-21T07:28:51.000Z</published>
    <updated>2016-05-16T08:00:17.518Z</updated>
    
    <content type="html">&lt;p&gt;持续更新,该贴记录一些BFS和DFS在使用过程中的心得体会，以加深对BFS与DFS的理解。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;BFS-广度优先搜索&quot;&gt;&lt;a href=&quot;#BFS-广度优先搜索&quot; class=&quot;headerlink&quot; title=&quot;BFS(广度优先搜索)&quot;&gt;&lt;/a&gt;BFS(广度优先搜索)&lt;/h2&gt;&lt;p&gt;BFS需要借助一个队列来记录遍历的”层数”；每遍历目标集合一次，&lt;strong&gt;步长&lt;/strong&gt;加一；队列为空，结束搜寻。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/127%20-%20World%20Ladder/127%20-%20World%20Ladder.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Word Ladder&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/126%20-%20Word%20Ladder%20II/126%20-%20Word%20Ladder%20II.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Word Ladder II&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;DFS-深度优先搜索&quot;&gt;&lt;a href=&quot;#DFS-深度优先搜索&quot; class=&quot;headerlink&quot; title=&quot;DFS(深度优先搜索)&quot;&gt;&lt;/a&gt;DFS(深度优先搜索)&lt;/h2&gt;&lt;p&gt;DFS需要用递归或者借助栈来&lt;strong&gt;记录&lt;/strong&gt;走过的路径；每遍历完这条分支，便要&lt;strong&gt;回溯&lt;/strong&gt;到上一层；在递归之前可以记录深度。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/131%20-%20Palindrome%20Partitioning/131%20-%20Palindrome%20Partitioning.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Palindrome Partitioning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/126%20-%20Word%20Ladder%20II/126%20-%20Word%20Ladder%20II.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Word Ladder II&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;持续更新,该贴记录一些BFS和DFS在使用过程中的心得体会，以加深对BFS与DFS的理解。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;BFS-广度优先搜索&quot;&gt;&lt;a href=&quot;#BFS-广度优先搜索&quot; class=&quot;headerlink&quot; title=&quot;BFS(广度优先搜索)&quot;&gt;&lt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>共用体、枚举和浮点数存储</title>
    <link href="http://yoursite.com/2016/04/21/%E5%85%B1%E7%94%A8%E4%BD%93%E3%80%81%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B5%AE%E7%82%B9%E6%95%B0%E5%AD%98%E5%82%A8/"/>
    <id>http://yoursite.com/2016/04/21/共用体、枚举和浮点数存储/</id>
    <published>2016-04-21T02:38:14.000Z</published>
    <updated>2016-05-06T04:58:24.186Z</updated>
    
    <content type="html">&lt;h2 id=&quot;共用体&quot;&gt;&lt;a href=&quot;#共用体&quot; class=&quot;headerlink&quot; title=&quot;共用体&quot;&gt;&lt;/a&gt;共用体&lt;/h2&gt;&lt;p&gt;是一种数据格式，简单来说，在同一块内存地址，可以同时起不同数据类型的名字，用这些名字来取值时，名字所对应的数据类型告诉编译器怎么去解释内存中的数据。他的特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它的长度是最大数据类型长度，可以节省空间；&lt;/li&gt;
&lt;li&gt;数据不共存；&lt;/li&gt;
&lt;li&gt;关键字&lt;code&gt;union&lt;/code&gt;，声明方式与结构体相同；&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;枚举&quot;&gt;&lt;a href=&quot;#枚举&quot; class=&quot;headerlink&quot; title=&quot;枚举&quot;&gt;&lt;/a&gt;枚举&lt;/h2&gt;&lt;p&gt;创建符号常量的方式，简单来说就是将一个“标签”与枚举量对应起来。特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以提升(常到&lt;code&gt;int&lt;/code&gt;)，但&lt;code&gt;int&lt;/code&gt;不能缩窄到它；&lt;/li&gt;
&lt;li&gt;可以显式设置枚举量，枚举范围内即使没有枚举量，也合法；&lt;/li&gt;
&lt;li&gt;关键词&lt;code&gt;enum&lt;/code&gt;，声明方式与结构体相似；&lt;/li&gt;
&lt;li&gt;他没有算术运算，一般常用于&lt;code&gt;swith&lt;/code&gt;语句中的标签。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;浮点数存储方式&quot;&gt;&lt;a href=&quot;#浮点数存储方式&quot; class=&quot;headerlink&quot; title=&quot;浮点数存储方式&quot;&gt;&lt;/a&gt;浮点数存储方式&lt;/h2&gt;&lt;p&gt;不管是什么数据类型，在内存中的表示方式都是一样的(0或者1)，数据类型的作用只是告诉编译器如何去解释内存中的数据，那么编译器是如何解释浮点型的？&lt;br&gt;首先，二进制科学法表示中，一个浮点型S = M*2^N，内存会存储三部分：符号位+阶码(N)+尾数(M)；&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;数据&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;符号位&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;阶码&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;尾数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1位&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;8位&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;23位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;内存位&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;31&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;30-23&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;22-0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;double&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1位&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;11位&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;52位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;内存位&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;63&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;62-52&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;51-0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;其次，阶码使用中间偏置(固定量为2^N-1)的移码表示的,M的整数部分为1,不存储，只存储尾数即可。&lt;br&gt;例如，125.5f = &lt;code&gt;1111101.1&lt;/code&gt; = 1.1111011*2^6 =&amp;gt;移码127+6 = 133 = &lt;code&gt;10000101&lt;/code&gt; =&amp;gt;正数符号位是0，尾数补0到够23位,那么计算机中：&lt;code&gt;01000010 10000000 00000000 01111011&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;补充&quot;&gt;&lt;a href=&quot;#补充&quot; class=&quot;headerlink&quot; title=&quot;补充&quot;&gt;&lt;/a&gt;补充&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;整型常量默认情况下是int型,浮点常量在默认情况下是&lt;code&gt;double&lt;/code&gt;型,如果需要&lt;code&gt;float&lt;/code&gt;型，需要这样表示：&lt;code&gt;3.25f&lt;/code&gt;；&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;共用体&quot;&gt;&lt;a href=&quot;#共用体&quot; class=&quot;headerlink&quot; title=&quot;共用体&quot;&gt;&lt;/a&gt;共用体&lt;/h2&gt;&lt;p&gt;是一种数据格式，简单来说，在同一块内存地址，可以同时起不同数据类型的名字，用这些名字来取值时，名字所对应的数据类型告诉编译器怎么去解
    
    </summary>
    
      <category term="C++基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="共用体" scheme="http://yoursite.com/tags/%E5%85%B1%E7%94%A8%E4%BD%93/"/>
    
      <category term="枚举" scheme="http://yoursite.com/tags/%E6%9E%9A%E4%B8%BE/"/>
    
      <category term="浮点数存储" scheme="http://yoursite.com/tags/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>string类与结构体</title>
    <link href="http://yoursite.com/2016/04/21/string%E7%B1%BB%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>http://yoursite.com/2016/04/21/string类与结构体/</id>
    <published>2016-04-21T02:36:21.000Z</published>
    <updated>2016-05-06T04:59:55.241Z</updated>
    
    <content type="html">&lt;h2 id=&quot;string类&quot;&gt;&lt;a href=&quot;#string类&quot; class=&quot;headerlink&quot; title=&quot;string类&quot;&gt;&lt;/a&gt;string类&lt;/h2&gt;&lt;h3 id=&quot;string运算符&quot;&gt;&lt;a href=&quot;#string运算符&quot; class=&quot;headerlink&quot; title=&quot;string运算符&quot;&gt;&lt;/a&gt;string运算符&lt;/h3&gt;&lt;p&gt;&lt;code&gt;string&lt;/code&gt;类的运算符重载在头文件&lt;code&gt;string&lt;/code&gt;里,如&lt;code&gt;+&lt;/code&gt;,&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;。注意&lt;code&gt;&amp;quot;a&amp;quot;+&amp;quot;b&amp;quot; = &amp;quot;ab&amp;quot;&lt;/code&gt;,&lt;code&gt;&amp;#39;a&amp;#39;+&amp;#39;b&amp;#39; = 195&lt;/code&gt;,前者是字符串拼接，后者是字符常量相加。但是&lt;code&gt;cout&amp;lt;&amp;lt;&amp;quot;a&amp;quot;+&amp;quot;b&amp;quot;;&lt;/code&gt;这个语句是错误的，必须至少声明两个&lt;code&gt;string&lt;/code&gt;类型。&lt;/p&gt;
&lt;h3 id=&quot;string-find&quot;&gt;&lt;a href=&quot;#string-find&quot; class=&quot;headerlink&quot; title=&quot;string.find()&quot;&gt;&lt;/a&gt;string.find()&lt;/h3&gt;&lt;p&gt;&lt;code&gt;string&lt;/code&gt;类的&lt;code&gt;find()&lt;/code&gt;方法，可以用于找子串，返回子串在原串出现的下标。&lt;a href=&quot;http://www.cnblogs.com/web100/archive/2012/12/02/cpp-string-find-npos.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;和&lt;a href=&quot;http://www.cplusplus.com/reference/string/string/find/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;有详细解释，使用时注意以下三点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接受三个参数，第一个是子串，第二个是开始寻找的下标，第三个参数是匹配字串的字符数。可以用于找全部的匹配子串；&lt;/li&gt;
&lt;li&gt;如果没有找到，返回值是&lt;code&gt;string::npos&lt;/code&gt;，他是一个很大的正数；&lt;/li&gt;
&lt;li&gt;返回值是&lt;code&gt;size_t&lt;/code&gt;，一般可用&lt;code&gt;auto&lt;/code&gt;来代替。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下代码可以输出全部的匹配位置：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;string s1 = &amp;quot;abcdbcgbcdbjjkklbcdbcdbcdghjbcd&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;string s2 = &amp;quot;bcd&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;auto k  = s1.find(s2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;while (k != string::npos)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	cout&amp;lt;&amp;lt;k&amp;lt;&amp;lt;endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	k = s1.find(s2,k+1);	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;string-substr&quot;&gt;&lt;a href=&quot;#string-substr&quot; class=&quot;headerlink&quot; title=&quot;string.substr()&quot;&gt;&lt;/a&gt;string.substr()&lt;/h3&gt;&lt;p&gt;函数声明如下：&lt;code&gt;_Myt substr(size_type _Off = 0, size_type _Count = npos) const&lt;/code&gt;，返回从指定位置(_Off)开始的长度为(_Count)的子字符串。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;结构体&quot;&gt;&lt;a href=&quot;#结构体&quot; class=&quot;headerlink&quot; title=&quot;结构体&quot;&gt;&lt;/a&gt;结构体&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;基本项，可以列表化，提倡外部结构声明，可以使用赋值运算符,列表初始化不允许缩窄转换。&lt;/li&gt;
&lt;li&gt;结构体对准：&lt;ul&gt;
&lt;li&gt;结构体首地址能被其最宽基本类型成员的大小所整除；&lt;/li&gt;
&lt;li&gt;结构体每个成员相对于结构体首地址的偏移量(offset)都是成员大小整数倍；&lt;/li&gt;
&lt;li&gt;结构体的总大小是结构体最宽基本类型成员大小的整数倍。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;与此相关还有栈对准，某些编译器(x64?)按大小对准，&lt;code&gt;char&lt;/code&gt;位于栈底，&lt;code&gt;double&lt;/code&gt;位于栈顶排列。找不到相关资料了，需要深入了解。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;示例：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//Definition for a binary tree node.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct TreeNode &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	TreeNode *left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	TreeNode *right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	TreeNode(int x) : val(x), left(NULL), right(NULL) &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;string类&quot;&gt;&lt;a href=&quot;#string类&quot; class=&quot;headerlink&quot; title=&quot;string类&quot;&gt;&lt;/a&gt;string类&lt;/h2&gt;&lt;h3 id=&quot;string运算符&quot;&gt;&lt;a href=&quot;#string运算符&quot; class=&quot;header
    
    </summary>
    
      <category term="C++基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="string.find()" scheme="http://yoursite.com/tags/string-find/"/>
    
      <category term="结构体" scheme="http://yoursite.com/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>cctype与进制数转化</title>
    <link href="http://yoursite.com/2016/04/21/cctype%E4%B8%8E%E8%BF%9B%E5%88%B6%E6%95%B0%E8%BD%AC%E5%8C%96/"/>
    <id>http://yoursite.com/2016/04/21/cctype与进制数转化/</id>
    <published>2016-04-21T01:16:59.000Z</published>
    <updated>2016-05-06T04:55:45.555Z</updated>
    
    <content type="html">&lt;h2 id=&quot;进制转化&quot;&gt;&lt;a href=&quot;#进制转化&quot; class=&quot;headerlink&quot; title=&quot;进制转化&quot;&gt;&lt;/a&gt;进制转化&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;控制符dec，hex，oct用于设置整数显式的进制数，分别对应十进制，16进制，八进制，语法：&lt;code&gt;cout&amp;lt;&amp;lt;dec;&lt;/code&gt;,&lt;code&gt;cout&amp;lt;&amp;lt;hex;&lt;/code&gt;,&lt;code&gt;cout&amp;lt;&amp;lt;oct&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;头文件&lt;code&gt;cstdlib&lt;/code&gt;中的&lt;code&gt;char *_itoa(int value,char string,int radix)&lt;/code&gt;可以设置任一进制的输出。&lt;ul&gt;
&lt;li&gt;参数一：要转换的数据；&lt;/li&gt;
&lt;li&gt;参数二：存放结果的字符串地址；&lt;/li&gt;
&lt;li&gt;参数三：进制数；&lt;/li&gt;
&lt;li&gt;返回值：指向结果字符串的指针。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;cctype&quot;&gt;&lt;a href=&quot;#cctype&quot; class=&quot;headerlink&quot; title=&quot;cctype&quot;&gt;&lt;/a&gt;cctype&lt;/h2&gt;&lt;p&gt;主要是&lt;code&gt;cctype&lt;/code&gt;头文件中的字符函数在编程过程中可以带来很多便利，常用的总结如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;isalpha()&lt;/code&gt;,&lt;code&gt;isdigit()&lt;/code&gt;,&lt;code&gt;isalnum()&lt;/code&gt;可以用于判断是字符、数字、字母或数字。返回&lt;code&gt;true&lt;/code&gt;或&lt;code&gt;false&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;islower()&lt;/code&gt;,&lt;code&gt;isupper()&lt;/code&gt;,&lt;code&gt;isprint()&lt;/code&gt;可以用于判断是小写字母、大写字符、可显示字符。返回&lt;code&gt;true&lt;/code&gt;或&lt;code&gt;false&lt;/code&gt;。&lt;a href=&quot;https://zh.wikipedia.org/wiki/ASCII#.E5.8F.AF.E6.98.BE.E7.A4.BA.E5.AD.97.E7.AC.A6&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;可显示字符&lt;/a&gt;从32到126一共95个。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tolower()&lt;/code&gt;,&lt;code&gt;toupper()&lt;/code&gt;用于大小写字母的转换，如果不需要转换，字符不变。&lt;/li&gt;
&lt;li&gt;另外一些不常用的字符函数,&lt;code&gt;isgraph()&lt;/code&gt;(除空格之外的打印字符),&lt;code&gt;ispunct()&lt;/code&gt;(标点符号),&lt;code&gt;isspace()&lt;/code&gt;(标准空白字符),&lt;code&gt;iscntrl()&lt;/code&gt;(控制字符),&lt;code&gt;isxdigit()&lt;/code&gt;(16进制,即1-9,a-f,A-F)。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进制转化&quot;&gt;&lt;a href=&quot;#进制转化&quot; class=&quot;headerlink&quot; title=&quot;进制转化&quot;&gt;&lt;/a&gt;进制转化&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;控制符dec，hex，oct用于设置整数显式的进制数，分别对应十进制，16进制，八进制，语法：&lt;code&gt;cou
    
    </summary>
    
      <category term="C++基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="进制转化" scheme="http://yoursite.com/tags/%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8C%96/"/>
    
      <category term="cctype" scheme="http://yoursite.com/tags/cctype/"/>
    
  </entry>
  
  <entry>
    <title>类型转换</title>
    <link href="http://yoursite.com/2016/04/20/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2016/04/20/类型转换/</id>
    <published>2016-04-20T02:53:34.000Z</published>
    <updated>2016-05-06T05:00:51.097Z</updated>
    
    <content type="html">&lt;p&gt;C++自动执行以下类型转换：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不同算术类型的赋值；&lt;/li&gt;
&lt;li&gt;包含不同类型的表达式；&lt;/li&gt;
&lt;li&gt;函数调用&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;初始化和赋值进行的转换&quot;&gt;&lt;a href=&quot;#初始化和赋值进行的转换&quot; class=&quot;headerlink&quot; title=&quot;初始化和赋值进行的转换&quot;&gt;&lt;/a&gt;初始化和赋值进行的转换&lt;/h2&gt;&lt;p&gt;扩展没有问题；缩窄可能会有一些问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;精度降低(double-&amp;gt;float等);&lt;/li&gt;
&lt;li&gt;数字截短(float-&amp;gt;int等);&lt;/li&gt;
&lt;li&gt;数据丢失(long-&amp;gt;short等)。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;列表初始化时的转换&quot;&gt;&lt;a href=&quot;#列表初始化时的转换&quot; class=&quot;headerlink&quot; title=&quot;列表初始化时的转换&quot;&gt;&lt;/a&gt;列表初始化时的转换&lt;/h2&gt;&lt;p&gt;不允许缩窄。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;表达式的转换&quot;&gt;&lt;a href=&quot;#表达式的转换&quot; class=&quot;headerlink&quot; title=&quot;表达式的转换&quot;&gt;&lt;/a&gt;表达式的转换&lt;/h2&gt;&lt;h3 id=&quot;自动转化&quot;&gt;&lt;a href=&quot;#自动转化&quot; class=&quot;headerlink&quot; title=&quot;自动转化&quot;&gt;&lt;/a&gt;自动转化&lt;/h3&gt;&lt;p&gt;&lt;code&gt;int&lt;/code&gt;型是计算机最自然的语言，运算速度最快。整型提升(integral promotion)规则如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算表达式时，C++将&lt;code&gt;bool&lt;/code&gt;，&lt;code&gt;char&lt;/code&gt;，&lt;code&gt;unsigned char&lt;/code&gt;，&lt;code&gt;signed char&lt;/code&gt;，&lt;code&gt;short&lt;/code&gt;都转换为&lt;code&gt;int&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;short&lt;/code&gt;和&lt;code&gt;int&lt;/code&gt;一样长，&lt;code&gt;unsigned short&lt;/code&gt;转换为&lt;code&gt;unsigned int&lt;/code&gt;，如果&lt;code&gt;short&lt;/code&gt;比&lt;code&gt;int&lt;/code&gt;短，&lt;code&gt;unsigned short&lt;/code&gt;转换为&lt;code&gt;int&lt;/code&gt;。总之，以不损失数据为原则。&lt;/li&gt;
&lt;li&gt;在不损失数据的原则下，同级别有符号数比无符号数优先。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;算术运算的转化&quot;&gt;&lt;a href=&quot;#算术运算的转化&quot; class=&quot;headerlink&quot; title=&quot;算术运算的转化&quot;&gt;&lt;/a&gt;算术运算的转化&lt;/h3&gt;&lt;p&gt;将较小的类型转换成较大的类型。依次判断long double?-&amp;gt;double?-&amp;gt;float?-&amp;gt;integral promotion!可以看到浮点型优先于整型。具体过程可以查看C++11版本的效验表。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;传递参数时的转换&quot;&gt;&lt;a href=&quot;#传递参数时的转换&quot; class=&quot;headerlink&quot; title=&quot;传递参数时的转换&quot;&gt;&lt;/a&gt;传递参数时的转换&lt;/h2&gt;&lt;p&gt;由C++函数原型控制，若取消函数原型的控制:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将对&lt;code&gt;char&lt;/code&gt;和&lt;code&gt;short&lt;/code&gt;整型提升;&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;float&lt;/code&gt;参数提升为&lt;code&gt;double&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;强制类型转换&quot;&gt;&lt;a href=&quot;#强制类型转换&quot; class=&quot;headerlink&quot; title=&quot;强制类型转换&quot;&gt;&lt;/a&gt;强制类型转换&lt;/h2&gt;&lt;p&gt;C++设计新格式，让强制类型转换像函数一样调用:&lt;code&gt;typename (value)&lt;/code&gt;更严格的限制允许的类型转换，以下4个类型转换符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dynamic_cast&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_cast&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static_cast&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reinterpret_cast&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相关：因为指针大小固定(指针的本质是一个存放地址的内存，32位编译器是4字节),任意指针之间可以进行强制转化。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;C++自动执行以下类型转换：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不同算术类型的赋值；&lt;/li&gt;
&lt;li&gt;包含不同类型的表达式；&lt;/li&gt;
&lt;li&gt;函数调用&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;初始化和赋值进行的转换&quot;&gt;&lt;a href=&quot;#初始化和赋值进行的转换&quot; cla
    
    </summary>
    
      <category term="C++基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="类型转换" scheme="http://yoursite.com/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
      <category term="整型提升" scheme="http://yoursite.com/tags/%E6%95%B4%E5%9E%8B%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>栈与字符型变量的地址</title>
    <link href="http://yoursite.com/2016/04/20/%E6%A0%88%E4%B8%8E%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%9C%B0%E5%9D%80/"/>
    <id>http://yoursite.com/2016/04/20/栈与字符型变量的地址/</id>
    <published>2016-04-20T01:15:59.000Z</published>
    <updated>2016-05-06T05:02:50.434Z</updated>
    
    <content type="html">&lt;h2 id=&quot;栈的存储机制&quot;&gt;&lt;a href=&quot;#栈的存储机制&quot; class=&quot;headerlink&quot; title=&quot;栈的存储机制&quot;&gt;&lt;/a&gt;栈的存储机制&lt;/h2&gt;&lt;p&gt;在之前的内存存储区之中讲过栈，他大概有以下特点：编译器自助管理；空间大小指定；不会产生碎片；向下生长；静态(主要)或动态(不需要人工释放)分配；效率高。这里以下边的语句为例说明栈的存储：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int main()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int a[4] = &amp;#123;1,2,3,4&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int b[4] = &amp;#123;5,6,7,8&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int c[4] = &amp;#123;9,10,11,12&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/r0E1t24.jpg&quot; alt=&quot;栈&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数组名称是一个指针，指向数组的第一个元素；&lt;/li&gt;
&lt;li&gt;a[-2]指的是a指针向栈的地址低位移动2个数据元素大小(例子中是int型)，即访问到b[2]，&lt;strong&gt;但是&lt;/strong&gt;实际情况与编译器相关，他会做一些对准或者优化，明白访问原理即可；&lt;/li&gt;
&lt;li&gt;每一个元素在栈中的字节序是Little Endian，即低位字节排放在地址的低地址端，高位字节排放在地址的高地址端。与之对应的还有Big Endian，排放次序相反。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;字符型变量的地址&quot;&gt;&lt;a href=&quot;#字符型变量的地址&quot; class=&quot;headerlink&quot; title=&quot;字符型变量的地址&quot;&gt;&lt;/a&gt;字符型变量的地址&lt;/h2&gt;&lt;p&gt;字符型变量&lt;code&gt;char c&lt;/code&gt;的地址不能用&lt;code&gt;cout&amp;lt;&amp;lt;&amp;amp;c；&lt;/code&gt;来表示，因为&lt;code&gt;&amp;amp;c&lt;/code&gt;实际上是一个&lt;code&gt;char *&lt;/code&gt;型的变量，它输出字符串的值，而字符串只有在内存中读到&lt;code&gt;\0&lt;/code&gt;才会终止，因此会出现乱码。所以要输出字符变量的地址，应该用以下语句告诉编译器如何解释：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;(int *)&amp;amp;c&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(static_cast&amp;lt;void *&amp;gt;(&amp;amp;jc)&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上述的&lt;code&gt;static_cast&lt;/code&gt;用于显式类型转换。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;栈的存储机制&quot;&gt;&lt;a href=&quot;#栈的存储机制&quot; class=&quot;headerlink&quot; title=&quot;栈的存储机制&quot;&gt;&lt;/a&gt;栈的存储机制&lt;/h2&gt;&lt;p&gt;在之前的内存存储区之中讲过栈，他大概有以下特点：编译器自助管理；空间大小指定；不会产生碎片；向下生长；静态(
    
    </summary>
    
      <category term="C++基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="栈的存储" scheme="http://yoursite.com/tags/%E6%A0%88%E7%9A%84%E5%AD%98%E5%82%A8/"/>
    
      <category term="字符型变量输出" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%8F%98%E9%87%8F%E8%BE%93%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>unordered_set简介</title>
    <link href="http://yoursite.com/2016/04/19/unordered_set%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2016/04/19/unordered_set简介/</id>
    <published>2016-04-19T11:42:25.000Z</published>
    <updated>2016-05-16T04:51:57.172Z</updated>
    
    <content type="html">&lt;h2 id=&quot;unordered-set简介&quot;&gt;&lt;a href=&quot;#unordered-set简介&quot; class=&quot;headerlink&quot; title=&quot;unordered_set简介&quot;&gt;&lt;/a&gt;unordered_set简介&lt;/h2&gt;&lt;p&gt;首先使用&lt;code&gt;unordered_set&lt;/code&gt;必须使用宏语句&lt;code&gt;#include &amp;lt;unordered_set&amp;gt;&lt;/code&gt;。MSDN上有对&lt;a href=&quot;https://msdn.microsoft.com/zh-cn/library/bb982739.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;unordered_set&lt;/a&gt;描述，CSDN上有博客对&lt;a href=&quot;http://blog.csdn.net/oabid/article/details/4562577&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;unordered_set&lt;/a&gt;描述，这是一个哈希表。一般来说，一些简单功能可以当做STL里的容器来用：&lt;code&gt;insert()&lt;/code&gt;、&lt;font color=&quot;red&quot;&gt;&lt;code&gt;find()&lt;/code&gt;&lt;/font&gt;、&lt;code&gt;erase()&lt;/code&gt;、&lt;code&gt;size()&lt;/code&gt;、&lt;code&gt;empty()&lt;/code&gt;、&lt;code&gt;begin()&lt;/code&gt;、&lt;code&gt;end()&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;unordered-set-无序关联容器-与vector的异同&quot;&gt;&lt;a href=&quot;#unordered-set-无序关联容器-与vector的异同&quot; class=&quot;headerlink&quot; title=&quot;unordered_set(无序关联容器)与vector的异同&quot;&gt;&lt;/a&gt;unordered_set(无序关联容器)与vector的异同&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;_Pairib insert(const value_type&amp;amp; _Val);&lt;/code&gt;;基本与&lt;code&gt;vector&lt;/code&gt;用法相同，参数为要插入的值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iterator find(const key_type&amp;amp; _Keyval);&lt;/code&gt;;若找到该元素，返回的指针指向该元素，没找到返回的指针会指向超尾即&lt;code&gt;end()&lt;/code&gt;。与&lt;code&gt;size_type find(_Elem _Ch, size_type _Off = 0) const;&lt;/code&gt;有区别，后者会返回下标(&lt;code&gt;size_type&lt;/code&gt;可以看做一种足够大的&lt;code&gt;unsigned&lt;/code&gt;类型来表示下标)，如果没找到，返回&lt;code&gt;string::npos&lt;/code&gt;。而&lt;/li&gt;
&lt;li&gt;&lt;code&gt;size_type erase(const key_type&amp;amp; _Keyval);&lt;/code&gt;;擦除指定值，返回该指定值的位置。&lt;code&gt;iterator erase(const_iterator _Where);&lt;/code&gt;擦除指针指向的值，容器重排，指针不变。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;size_type count(const Key&amp;amp; keyval) const;&lt;/code&gt;返回unordered_set中指定键对应的元素个数，k-要查找的key值。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;unordered-set简介&quot;&gt;&lt;a href=&quot;#unordered-set简介&quot; class=&quot;headerlink&quot; title=&quot;unordered_set简介&quot;&gt;&lt;/a&gt;unordered_set简介&lt;/h2&gt;&lt;p&gt;首先使用&lt;code&gt;unordere
    
    </summary>
    
      <category term="STL" scheme="http://yoursite.com/categories/STL/"/>
    
    
      <category term="unordered_set" scheme="http://yoursite.com/tags/unordered-set/"/>
    
  </entry>
  
  <entry>
    <title>默认参数与内联函数</title>
    <link href="http://yoursite.com/2016/04/19/%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E4%B8%8E%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2016/04/19/默认参数与内联函数/</id>
    <published>2016-04-19T03:15:10.000Z</published>
    <updated>2016-05-06T06:20:28.812Z</updated>
    
    <content type="html">&lt;h2 id=&quot;默认参数&quot;&gt;&lt;a href=&quot;#默认参数&quot; class=&quot;headerlink&quot; title=&quot;默认参数&quot;&gt;&lt;/a&gt;默认参数&lt;/h2&gt;&lt;p&gt;省略实参时自动使用的值，必须通过函数原型(这是因为函数调用时通过函数原型将函数参数压入栈帧)，使用方法是将值赋给原型中的值(压入栈帧并初始化)。 &lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;内联函数&quot;&gt;&lt;a href=&quot;#内联函数&quot; class=&quot;headerlink&quot; title=&quot;内联函数&quot;&gt;&lt;/a&gt;内联函数&lt;/h2&gt;&lt;p&gt;常规函数和内联函数之间的主要区别是C++编译器如何将它们组合到程序中去。&lt;/p&gt;
&lt;h3 id=&quot;C语言的宏&quot;&gt;&lt;a href=&quot;#C语言的宏&quot; class=&quot;headerlink&quot; title=&quot;C语言的宏&quot;&gt;&lt;/a&gt;C语言的宏&lt;/h3&gt;&lt;p&gt;宏是内联代码的原始实现，它的本质是&lt;strong&gt;文本替换&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;普通宏定义中，预处理器将空格解释成分段标志；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;##&lt;/code&gt;是一种分隔连接方式，作用是先分隔后强制连接；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#&lt;/code&gt;表示变量替换后加双引号括起来。&lt;/li&gt;
&lt;li&gt;另外一些分隔符、操作符如&lt;code&gt;+&lt;/code&gt;、&lt;code&gt;-&lt;/code&gt;、&lt;code&gt;*&lt;/code&gt;、&lt;code&gt;/&lt;/code&gt;、&lt;code&gt;[&lt;/code&gt;、&lt;code&gt;]&lt;/code&gt;依然有意义。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#define A1(name,type) type name_##type##_type&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	A1(a1,int) &amp;lt;=&amp;gt; int name_int_type&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define A1(name,type) type name##_##type##_type&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	A1(a1,int) &amp;lt;=&amp;gt; int a1_int_type&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define stringify(x) #x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	stringify(linux) &amp;lt;=&amp;gt; &amp;quot;linux&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;C-内联函数&quot;&gt;&lt;a href=&quot;#C-内联函数&quot; class=&quot;headerlink&quot; title=&quot;C++内联函数&quot;&gt;&lt;/a&gt;C++内联函数&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;编译器将使用相应的函数代码替换函数调用(省略了来回跳跃并记录跳跃位置的过程)；&lt;/li&gt;
&lt;li&gt;运行速度较快，但占用更多的内存(同一个内联函数调用多少次，就有多少次副本)；&lt;/li&gt;
&lt;li&gt;一般省略原型(但原型特性仍在起作用)，将整个定义放在原本该提供原型的地方(这是首次使用前的函数定义，充当原型)，并使用&lt;code&gt;inline&lt;/code&gt;关键字&lt;/li&gt;
&lt;li&gt;编译器并不一定满足程序员内联函数的请求，比如函数过大或者函数调用了自己(递归不能内联)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意类成员函数中的内联函数并不一定使用&lt;code&gt;inline&lt;/code&gt;关键字。定义位于类声明中自动成为内联函数；否则使用&lt;code&gt;inline&lt;/code&gt;关键字作为内联函数。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;默认参数&quot;&gt;&lt;a href=&quot;#默认参数&quot; class=&quot;headerlink&quot; title=&quot;默认参数&quot;&gt;&lt;/a&gt;默认参数&lt;/h2&gt;&lt;p&gt;省略实参时自动使用的值，必须通过函数原型(这是因为函数调用时通过函数原型将函数参数压入栈帧)，使用方法是将值赋给原型中的值(
    
    </summary>
    
      <category term="C++基础" scheme="http://yoursite.com/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="默认参数" scheme="http://yoursite.com/tags/%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0/"/>
    
      <category term="内联函数" scheme="http://yoursite.com/tags/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
</feed>
