<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孤云两角，去天一握</title>
  <subtitle>山在地下，地山谦</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://rylcode.cn/"/>
  <updated>2016-05-22T09:58:22.578Z</updated>
  <id>http://rylcode.cn/</id>
  
  <author>
    <name>ryl</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数字输入与atoi函数</title>
    <link href="http://rylcode.cn/2016/05/22/%E6%95%B0%E5%AD%97%E8%BE%93%E5%85%A5%E4%B8%8Eatoi%E5%87%BD%E6%95%B0/"/>
    <id>http://rylcode.cn/2016/05/22/数字输入与atoi函数/</id>
    <published>2016-05-22T08:14:08.000Z</published>
    <updated>2016-05-22T09:58:22.578Z</updated>
    
    <content type="html">&lt;p&gt;这篇博客来源于编程中的数字输入检查，最终选择&lt;code&gt;cingetline()&lt;/code&gt;加&lt;code&gt;atoi()&lt;/code&gt;函数进行输入检查转换。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;输入&quot;&gt;&lt;a href=&quot;#输入&quot; class=&quot;headerlink&quot; title=&quot;输入&quot;&gt;&lt;/a&gt;输入&lt;/h2&gt;&lt;h3 id=&quot;cin的学问&quot;&gt;&lt;a href=&quot;#cin的学问&quot; class=&quot;headerlink&quot; title=&quot;cin的学问&quot;&gt;&lt;/a&gt;cin的学问&lt;/h3&gt;&lt;p&gt;首先分析&lt;code&gt;cin&lt;/code&gt;,&lt;code&gt;cin.get()&lt;/code&gt;,&lt;code&gt;cin.getline()&lt;/code&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;cin&amp;lt;&amp;lt;&lt;/code&gt;会忽略&lt;strong&gt;有效字符前的&lt;/strong&gt;空格，换行符，制表符(开始有效输入之后非法就退出了)；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cin.get()&lt;/code&gt;读取每一个字符；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cin.getline()&lt;/code&gt;读取一行到字符串中，并把&lt;code&gt;\n&lt;/code&gt;替换为&lt;code&gt;\0&lt;/code&gt;存储。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;测试中发现更多的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;cin.getline(字符指针(char*),字符个数N(int),结束符(char));其只读取N-1个字符，因为最后一个字符要补&lt;code&gt;\0&lt;/code&gt;,如果&lt;font color=&quot;red&quot;&gt;输入超过N-1&lt;/font&gt;,会将状态位设置：&lt;code&gt;ios_base::failbit&lt;/code&gt;(表示轻微错误，可以挽回。查看&lt;code&gt;cin.getline()&lt;/code&gt;源码很明显)，注意剩下的字符依然在输入队列中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cin.getline()&lt;/code&gt;超过N-1输入状态位设置：&lt;code&gt;ios_base::failbit&lt;/code&gt;(可修复的)，这时候不能使&lt;code&gt;cin&amp;lt;&amp;lt;&lt;/code&gt;和&lt;code&gt;cin.get()&lt;/code&gt;和&lt;code&gt;cin.getline()&lt;/code&gt;，此时输入队列有值。应该用&lt;code&gt;cin.clear()&lt;/code&gt;设置状态位&lt;code&gt;ios_base::goodbit&lt;/code&gt;才能继续读取。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/40160488&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;cin.sync()&lt;/a&gt;亲自测试&lt;code&gt;cin.sync()&lt;/code&gt;并不是如网上所说的清空缓冲区(相信英语是对的…),&lt;code&gt;cin.ignore()&lt;/code&gt;才是。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在编写主界面时，经常会碰到如下语句：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int index = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;switch(index)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	case 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	case 2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	default：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上述语句没有对&lt;code&gt;index&lt;/code&gt;变量进行输入检查，显然不安全，那么如何进行输入检查？&lt;/p&gt;
&lt;h3 id=&quot;一般的错误处理机制&quot;&gt;&lt;a href=&quot;#一般的错误处理机制&quot; class=&quot;headerlink&quot; title=&quot;一般的错误处理机制&quot;&gt;&lt;/a&gt;一般的错误处理机制&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int index;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;while (!cin&amp;lt;&amp;lt;idex) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	cin.clear();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	while(cin.get()!=&amp;apos;\n&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		continue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	cout&amp;lt;&amp;lt;&amp;quot;请再次输入&amp;quot;&amp;lt;&amp;lt;endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里会解决错误输入的问题,但是有一个新的问题，如输入&lt;code&gt;5a&lt;/code&gt;，&lt;code&gt;cin&amp;lt;&amp;lt;&lt;/code&gt;只会让&lt;code&gt;index=5&lt;/code&gt;，&lt;code&gt;a&lt;/code&gt;留在输入队列中，会影响下一次的输入。&lt;/p&gt;
&lt;h3 id=&quot;atoi-引发的思考&quot;&gt;&lt;a href=&quot;#atoi-引发的思考&quot; class=&quot;headerlink&quot; title=&quot;atoi()引发的思考&quot;&gt;&lt;/a&gt;atoi()引发的思考&lt;/h3&gt;&lt;p&gt;原型：&lt;code&gt;int atoi(const char *nptr);&lt;/code&gt;;&lt;br&gt;头文件：&lt;code&gt;#include &amp;lt;cstdlib&amp;gt;&lt;/code&gt;;&lt;br&gt;&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/8%20-%20String%20to%20Integer%20(atoi)/8%20-%20String%20to%20Integer%20(atoi).cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;LeetCode&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里有一个非常重要的概念，不管是数字输入韩式字符串转数字，都是&lt;strong&gt;遇到有效输入开始读取，直到碰到无效输入退出&lt;/strong&gt;&lt;br&gt;也就是说其实&lt;code&gt;cin&amp;lt;&amp;lt;&lt;/code&gt;就是对输入缓存进行了一个atoi()。区别就是在&lt;code&gt;cin&amp;lt;&amp;lt;&lt;/code&gt;退出之后同行中的非法输入(如果有)还是留在输入队列中，影响后续读入。&lt;br&gt;因此可以使用&lt;code&gt;cingetline()&lt;/code&gt;加&lt;code&gt;atoi()&lt;/code&gt;函数进行输入检查转换是安全的。代码如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int k = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;char s1[20];	//注意分配空间和,很久没用char[]，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cin.getline(s1,20);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;k = atoi(s1);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博客来源于编程中的数字输入检查，最终选择&lt;code&gt;cingetline()&lt;/code&gt;加&lt;code&gt;atoi()&lt;/code&gt;函数进行输入检查转换。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;输入&quot;&gt;&lt;a href=&quot;#输入&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
      <category term="C++基础" scheme="http://rylcode.cn/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="输入" scheme="http://rylcode.cn/tags/%E8%BE%93%E5%85%A5/"/>
    
      <category term="atoi" scheme="http://rylcode.cn/tags/atoi/"/>
    
  </entry>
  
  <entry>
    <title>二元运算符重载与友元函数</title>
    <link href="http://rylcode.cn/2016/05/21/%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E4%B8%8E%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0/"/>
    <id>http://rylcode.cn/2016/05/21/二元运算符重载与友元函数/</id>
    <published>2016-05-21T08:21:54.000Z</published>
    <updated>2016-05-21T09:46:24.705Z</updated>
    
    <content type="html">&lt;p&gt;一般来说，在基础知识的介绍中不会提供代码，无论哪一本语法书中都会有大篇幅的代码和例子，而博客只是用作总结提纲复习之用，没有必要提供代码(STL等代码分析除外)，如果需要细致的分析，建议查看《C++ primer plus》和《C++ Primer》&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;OPP特性的分析&quot;&gt;&lt;a href=&quot;#OPP特性的分析&quot; class=&quot;headerlink&quot; title=&quot;OPP特性的分析&quot;&gt;&lt;/a&gt;OPP特性的分析&lt;/h2&gt;&lt;p&gt;首先分析OPP特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;抽象：指抽象接口的类设计；&lt;/li&gt;
&lt;li&gt;封装和数据隐藏：通过访问控制实现封装，数据隐藏是封装的一种&lt;ul&gt;
&lt;li&gt;数据隐藏(数据放在类的私有部分)&lt;/li&gt;
&lt;li&gt;私有成员函数(实现细节私有化)&lt;/li&gt;
&lt;li&gt;类函数定义和声明放在不同的文件中(类定义封装)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多态：通过重载(静态多态)和vtbl(虚函数表，动态多态)实现&lt;ul&gt;
&lt;li&gt;vtbl&lt;/li&gt;
&lt;li&gt;运算符重载(成员函数和友元函数)&lt;/li&gt;
&lt;li&gt;函数重载&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;继承：is-a关系，公有继承(常用，派生类可以使用基类方法)，保护继承，私有继承。&lt;/li&gt;
&lt;li&gt;代码可重用性：库，类库，类继承。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;运算符重载&quot;&gt;&lt;a href=&quot;#运算符重载&quot; class=&quot;headerlink&quot; title=&quot;运算符重载&quot;&gt;&lt;/a&gt;运算符重载&lt;/h2&gt;&lt;h3 id=&quot;规则&quot;&gt;&lt;a href=&quot;#规则&quot; class=&quot;headerlink&quot; title=&quot;规则&quot;&gt;&lt;/a&gt;规则&lt;/h3&gt;&lt;p&gt;先上接口：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;operator+();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;operator*();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;operator[]();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;注意在函数之前有返回类型和类的作用域声明。运算符重载有一定的限制：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;重载后的运算符必须至少有一个操作数是用户定义的类型(不然会引发已知类型的运算符冲突)；&lt;/li&gt;
&lt;li&gt;使用运算符不能违反运算符原来的句法规则(操作数数量和优先级不能改变，编译器无法解释)&lt;/li&gt;
&lt;li&gt;不能创建新的运算符，还有一些运算符不能重载(查看可重载运算符列表)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;=,(),[],-&amp;gt;&lt;/code&gt;只能通过成员函数重载。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;一般而言(下面的问题2的解决方案中就有例外)，单目运算符最好重载为类的成员函数，双目运算符最好重载为类的友元函数。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;疑问&quot;&gt;&lt;a href=&quot;#疑问&quot; class=&quot;headerlink&quot; title=&quot;疑问&quot;&gt;&lt;/a&gt;疑问&lt;/h3&gt;&lt;p&gt;在运算符传递的过程中，运算符左侧的对象是调用对象，右侧的对象是传递的对象。于是就会产生两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基本四则运算(&lt;code&gt;+，-，*，/&lt;/code&gt;)的交换律怎么满足?(如&lt;code&gt;a = b*2&lt;/code&gt;可以匹配，但&lt;code&gt;a = 2*b&lt;/code&gt;无法匹配)&lt;/li&gt;
&lt;li&gt;如何对自定义的类使用&lt;code&gt;ostream&lt;/code&gt;对象(&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;如何重载)?(&lt;code&gt;a&amp;lt;&amp;lt;cout&lt;/code&gt;太过奇怪)&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;友元函数&quot;&gt;&lt;a href=&quot;#友元函数&quot; class=&quot;headerlink&quot; title=&quot;友元函数&quot;&gt;&lt;/a&gt;友元函数&lt;/h2&gt;&lt;p&gt;先回答上面的问题,引入友元函数来解决,简单解释：&lt;/p&gt;
&lt;h3 id=&quot;什么是友元&quot;&gt;&lt;a href=&quot;#什么是友元&quot; class=&quot;headerlink&quot; title=&quot;什么是友元&quot;&gt;&lt;/a&gt;什么是友元&lt;/h3&gt;&lt;p&gt;特性：访问权限与成员函数相同的非成员函数;&lt;br&gt;创建：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在类声明中使用&lt;code&gt;friend&lt;/code&gt;关键字；&lt;/li&gt;
&lt;li&gt;在类定义中不要使用&lt;code&gt;friend&lt;/code&gt;和类限定符(因为不是成员函数);&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;如何解决问题&quot;&gt;&lt;a href=&quot;#如何解决问题&quot; class=&quot;headerlink&quot; title=&quot;如何解决问题&quot;&gt;&lt;/a&gt;如何解决问题&lt;/h3&gt;&lt;p&gt;问题的答案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;问题1中的不同类型运算使用 成员函数重载+友元函数(不同类型)重载 做到分别匹配；或者使用自动转换(特定类型的构造函数)+友元函数(相同类型，都是自定义的)来实现。前者运行速度快但程序长，后者程序简短但时间内存开销大。&lt;/li&gt;
&lt;li&gt;非成员函数重载&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;，并返回&lt;code&gt;ostream&amp;amp;&lt;/code&gt;来保证连续输出(必须返回引用，因为&lt;code&gt;ostream&lt;/code&gt;没有共有的复制构造函数)。&lt;code&gt;ostream&amp;amp; operator&amp;lt;&amp;lt;(ostream &amp;amp;os,const A &amp;amp;a)&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用友元函数要注意规避二义性错误。自动转换和转换函数会在下一篇中分析。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;一般来说，在基础知识的介绍中不会提供代码，无论哪一本语法书中都会有大篇幅的代码和例子，而博客只是用作总结提纲复习之用，没有必要提供代码(STL等代码分析除外)，如果需要细致的分析，建议查看《C++ primer plus》和《C++ Primer》&lt;/p&gt;
&lt;hr&gt;
&lt;h2
    
    </summary>
    
      <category term="C++的类" scheme="http://rylcode.cn/categories/C-%E7%9A%84%E7%B1%BB/"/>
    
    
      <category term="OPP" scheme="http://rylcode.cn/tags/OPP/"/>
    
      <category term="运算符重载" scheme="http://rylcode.cn/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
      <category term="友元函数" scheme="http://rylcode.cn/tags/%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>链表的精髓-持续更新</title>
    <link href="http://rylcode.cn/2016/05/21/%E9%93%BE%E8%A1%A8%E7%9A%84%E7%B2%BE%E9%AB%93/"/>
    <id>http://rylcode.cn/2016/05/21/链表的精髓/</id>
    <published>2016-05-21T06:56:57.000Z</published>
    <updated>2016-05-21T07:26:13.070Z</updated>
    
    <content type="html">&lt;p&gt;术有穷而道无穷。一些简单的方法在实践过程中往往知易行难。在这里我会持续记录一些链表操作中值得注意的事情以及一些小小的有趣的事情。希望大家可以会心一笑。在链表操作中，发现最重要的一个概念就是&lt;font color=&quot;red&quot;&gt;前驱&lt;/font&gt;(后继同样重要，但是链表的后继太容易得到)。对于链表的调整，包括插入，删除，转置等操作，都涉及到链表结构的重组，在重组中前驱就是串联各个节点的线。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;前驱和后继&quot;&gt;&lt;a href=&quot;#前驱和后继&quot; class=&quot;headerlink&quot; title=&quot;前驱和后继&quot;&gt;&lt;/a&gt;前驱和后继&lt;/h2&gt;&lt;p&gt;链表自带后继&lt;code&gt;-&amp;gt;next&lt;/code&gt;,最后一个节点的后继通常为&lt;code&gt;nullptr&lt;/code&gt;，可以看作超尾。而编程过程中往往喜欢创建一个头节点，这是由于链表头是最特殊的一个节点，他没有前驱，不能写入循环中，往往会有&lt;code&gt;if else&lt;/code&gt;之类的语句单独处理头节点(深受其害)。于是产生了这种方法，给链表建立一个虚拟的头节点，一切问题引刃而解。&lt;/p&gt;
&lt;h3 id=&quot;逆置部分链表&quot;&gt;&lt;a href=&quot;#逆置部分链表&quot; class=&quot;headerlink&quot; title=&quot;逆置部分链表&quot;&gt;&lt;/a&gt;逆置部分链表&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/92%20-%20Reverse%20Linked%20List%20II/92%20-%20Reverse%20Linked%20List%20II.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;LeetCode链表的部分转置&lt;/a&gt;&lt;br&gt;头指针L永远是前驱,q是当前要处理的节点，p是pre指针，指向最前的节点(&lt;code&gt;q = p;p = p-&amp;gt;next;&lt;/code&gt;)。而转置的核心代码只有两行(&lt;code&gt;q-&amp;gt;next = l;l = q;&lt;/code&gt;)。&lt;/p&gt;
&lt;h3 id=&quot;删除当前节点&quot;&gt;&lt;a href=&quot;#删除当前节点&quot; class=&quot;headerlink&quot; title=&quot;删除当前节点&quot;&gt;&lt;/a&gt;删除当前节点&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/applefishsky009/BeautyOfProgramming/blob/master/3.4%20-%20%E4%BB%8E%E6%97%A0%E5%A4%B4%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9/3.4.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;狸猫换太子&lt;/a&gt;&lt;br&gt;这个没见过很难想到，见过绝对就回了……&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;术有穷而道无穷。一些简单的方法在实践过程中往往知易行难。在这里我会持续记录一些链表操作中值得注意的事情以及一些小小的有趣的事情。希望大家可以会心一笑。在链表操作中，发现最重要的一个概念就是&lt;font color=&quot;red&quot;&gt;前驱&lt;/font&gt;(后继同样重要，但是链表的后继太
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://rylcode.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Linked List" scheme="http://rylcode.cn/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search的陷阱</title>
    <link href="http://rylcode.cn/2016/05/20/Binary-Search%E7%9A%84%E9%99%B7%E9%98%B1/"/>
    <id>http://rylcode.cn/2016/05/20/Binary-Search的陷阱/</id>
    <published>2016-05-20T09:03:16.000Z</published>
    <updated>2016-05-20T10:39:36.096Z</updated>
    
    <content type="html">&lt;p&gt;先上&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;二分搜索算法wiki&lt;/a&gt;，再上&lt;a href=&quot;http://www.cppblog.com/converse/archive/2009/09/21/96893.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;二分查找写正确的方法&lt;/a&gt;。简单说说二分搜索：&lt;/p&gt;
&lt;p&gt;主要用于&lt;font color=&quot;red&quot;&gt;有序数组&lt;/font&gt;的遍历，时间复杂度O(log(n))，比之顺序遍历的时间复杂度O(n)更优，空间复杂度为O(1)。如用在插入排序中。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;三点原则&quot;&gt;&lt;a href=&quot;#三点原则&quot; class=&quot;headerlink&quot; title=&quot;三点原则&quot;&gt;&lt;/a&gt;三点原则&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;为了防止溢出折半时应该这么写&lt;code&gt;mid = start + (end - start) / 2;&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;因为大部分情况不是大于就是小于，因此一般在最后检测相等(如下例，检测条件过于复杂，因此放在开始检测相等少写一个检测条件，写全条件容易出错，一般用于debug)。&lt;/li&gt;
&lt;li&gt;传入的一定是左闭右闭区间，因此递归入口为&lt;code&gt;low &amp;lt;= high&lt;/code&gt;，由原则2可知递归出口判断写在入口之后。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;陷阱&quot;&gt;&lt;a href=&quot;#陷阱&quot; class=&quot;headerlink&quot; title=&quot;陷阱&quot;&gt;&lt;/a&gt;陷阱&lt;/h2&gt;&lt;p&gt;二分法，顾名思义，就是将区间一分为二传入递归函数，但是注意区间有开闭之分，因此在过程中一定要注意，例&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/33%20-%20Search%20in%20Rotated%20Sorted%20Array/33%20-%20Search%20in%20Rotated%20Sorted%20Array.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;LeetCode - 33&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不建议传入左开右开区间，增加判断次数，但是这样写极为简单，不得已可以使用，如例子中的&lt;code&gt;Solution&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;传入左闭右闭区间，递归入口一定是&lt;code&gt;low &amp;lt;= high&lt;/code&gt;,不能少等号;&lt;/li&gt;
&lt;li&gt;如例子中的&lt;code&gt;Solution1&lt;/code&gt;所警示，在另外有区间判断的条件时注意&lt;code&gt;int&lt;/code&gt;向下取整的特性，可能会有&lt;code&gt;low == mid;&lt;/code&gt;需要特殊分析。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;先上&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;二分搜索算法wik
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://rylcode.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Binary Search" scheme="http://rylcode.cn/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>模九同余与各位数字之和</title>
    <link href="http://rylcode.cn/2016/05/18/%E6%A8%A1%E4%B9%9D%E5%90%8C%E4%BD%99%E4%B8%8E%E5%90%84%E4%BD%8D%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/"/>
    <id>http://rylcode.cn/2016/05/18/模九同余与各位数字之和/</id>
    <published>2016-05-18T10:48:20.000Z</published>
    <updated>2016-05-19T02:13:25.162Z</updated>
    
    <content type="html">&lt;p&gt;$$ a\equiv b\quad(mod\ n) $$&lt;br&gt;此式即\( a \)与\( b \)同余于\( n \)；简称\( a \)与\( b \)模\( n \)同余。&lt;br&gt;同余运算见&lt;a href=&quot;https://en.wikipedia.org/wiki/Modular_arithmetic&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;维基百科&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;模九同余&quot;&gt;&lt;a href=&quot;#模九同余&quot; class=&quot;headerlink&quot; title=&quot;模九同余&quot;&gt;&lt;/a&gt;模九同余&lt;/h2&gt;&lt;p&gt;结论：任何一个整数模9同余于它的各数位上数字之和。&lt;br&gt;题目：设自然数\( N=a[n]a[n-1]\ldots a[0] \)，其中\( a[0],a[1],\ldots,a[n] \)分别是个位、十位、…上的数字，再设\( M=a[0]+a[1]+\ldots+a[n] \)&lt;br&gt;求证：\( N\equiv M\quad(mod\ 9) \)&lt;br&gt;证明：&lt;/p&gt;
&lt;p&gt;$$ \because N=a[n]a[n-1]…a[0]=a[n]\times10^n+a[n-1]\times10^{n-1}+\cdots+a[1]\times10+a[0] $$&lt;br&gt;又&lt;br&gt;$$ \because 1\equiv 1\quad(mod\ 9) $$&lt;br&gt;$$ 10\equiv 1\quad(mod\ 9) $$&lt;br&gt;$$ 10^2\equiv 1\quad(mod\ 9) $$&lt;br&gt;$$ \cdots $$&lt;br&gt;$$ 10^n\equiv 1\quad(mod\ 9) $$&lt;/p&gt;
&lt;p&gt;上面这些同余式两边分别同乘以\( a[0],a[1],a[2],\ldots,a[n] \)&lt;br&gt;再相加得：&lt;/p&gt;
&lt;p&gt;$$ a[n]\times10^n+a[n-1]\times10^{n-1}+\cdots+a[1]\times10+a[0]\equiv (a[0]+a[1]+…+a[n])\quad(mod\ 9) $$&lt;br&gt;即&lt;br&gt;$$ N\equiv M\quad(mod\ 9) $$&lt;br&gt;得证。&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;http://www.cnblogs.com/Rinyo/archive/2012/12/20/2826755.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;找规律&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;LeetCode&quot;&gt;&lt;a href=&quot;#LeetCode&quot; class=&quot;headerlink&quot; title=&quot;LeetCode&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/258%20-%20Add%20Digits/258%20-%20Add%20Digits.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;LeetCode&lt;/a&gt;&lt;/h2&gt;&lt;hr&gt;
&lt;h2 id=&quot;2012-2012&quot;&gt;&lt;a href=&quot;#2012-2012&quot; class=&quot;headerlink&quot; title=&quot;\( 2012^{2012} \)&quot;&gt;&lt;/a&gt;\( 2012^{2012} \)&lt;/h2&gt;&lt;p&gt;题目：记\( 2012^{2012} \)的各位数字之和为\( A \),\( A \)的各位数字之和是\( B \)，\( B \)的各位数字之和是\( C \)，求\( C \)的值。&lt;/p&gt;
&lt;h3 id=&quot;2012-2012-的余数&quot;&gt;&lt;a href=&quot;#2012-2012-的余数&quot; class=&quot;headerlink&quot; title=&quot;\( 2012^{2012} \)的余数&quot;&gt;&lt;/a&gt;\( 2012^{2012} \)的余数&lt;/h3&gt;&lt;p&gt;$$ \because 2012 \equiv 5\quad(mod\ 9) $$&lt;br&gt;\begin{equation}&lt;br&gt;\begin{split}&lt;br&gt;\therefore 2012^{2012} &amp;amp; \equiv 5^{2012}\quad(mod\ 9) \\&lt;br&gt;&amp;amp; \equiv 25^{1006}\quad(mod\ 9) \\&lt;br&gt;&amp;amp; \equiv (-2)^{1006}\quad(mod\ 9) \\&lt;br&gt;&amp;amp; \equiv 2^{1006}\quad(mod\ 9) \\&lt;br&gt;&amp;amp; \equiv 2\times8^{335}\quad(mod\ 9) \\&lt;br&gt;&amp;amp; \equiv 2\times(-1)^{335}\quad(mod\ 9) \\&lt;br&gt;&amp;amp; \equiv -2\quad(mod\ 9) \\&lt;br&gt;&amp;amp; \equiv 7&lt;br&gt;\end{split}&lt;br&gt;\end{equation}&lt;/p&gt;
&lt;h3 id=&quot;C的最大值&quot;&gt;&lt;a href=&quot;#C的最大值&quot; class=&quot;headerlink&quot; title=&quot;C的最大值&quot;&gt;&lt;/a&gt;C的最大值&lt;/h3&gt;&lt;p&gt;$$ \because 2012^{2012}&amp;lt;10000^{2012}-1 $$&lt;br&gt;$$ \Rightarrow A&amp;lt;2012\times4\times9=72504 $$&lt;br&gt;$$ \Rightarrow B&amp;lt;6+4\times9=42 $$&lt;br&gt;$$ \Rightarrow C&amp;lt;3+9=12 $$&lt;br&gt;$$ \therefore C=7 $$&lt;/p&gt;
&lt;p&gt;思路：&lt;strong&gt;算出最大位数&lt;/strong&gt;，每一位给9算出\( A,B,C \)的最大值。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;$$ a\equiv b\quad(mod\ n) $$&lt;br&gt;此式即\( a \)与\( b \)同余于\( n \)；简称\( a \)与\( b \)模\( n \)同余。&lt;br&gt;同余运算见&lt;a href=&quot;https://en.wikipedia.org/wiki/
    
    </summary>
    
      <category term="Math" scheme="http://rylcode.cn/categories/Math/"/>
    
    
      <category term="Modular Arithmetic" scheme="http://rylcode.cn/tags/Modular-Arithmetic/"/>
    
  </entry>
  
  <entry>
    <title>伯努利级数</title>
    <link href="http://rylcode.cn/2016/05/18/%E4%BC%AF%E5%8A%AA%E5%88%A9%E7%BA%A7%E6%95%B0/"/>
    <id>http://rylcode.cn/2016/05/18/伯努利级数/</id>
    <published>2016-05-18T06:26:36.000Z</published>
    <updated>2016-05-18T08:47:34.112Z</updated>
    
    <content type="html">&lt;p&gt;先来彩蛋，在&lt;a href=&quot;http://www.wolframalpha.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;wolframalpha&lt;/a&gt;使用Latex格式输入数学公式，可以快速得到结果。&lt;/p&gt;
&lt;p&gt;考虑以下四种无穷级数：&lt;br&gt;$$ \sum_n\frac{1}{n^2\pm\omega^2}\qquad(1) $$&lt;/p&gt;
&lt;p&gt;$$ \prod_n(1\pm\frac{\omega^2}{n^2})\qquad(2) $$&lt;/p&gt;
&lt;p&gt;在式\( (1) \)中当\( \omega=0 \)时，公式变为伯努利级数：&lt;br&gt;$$ \sum_n\frac{1}{n^2}\qquad(3) $$&lt;/p&gt;
&lt;p&gt;式\( (3) \)中是一个非常有意思的题目，下面考虑来解决他，式\( (1) \)和式\( (2) \)并不会经常用到，具体解答见&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5ODUxOTA5Mg==&amp;amp;mid=404226908&amp;amp;idx=1&amp;amp;sn=93aa43ffa9157af03ad82543493cfe51&amp;amp;scene=23&amp;amp;srcid=042515FZI3kzNY54U1YJaKv8#rd&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;算法与数学之美&lt;/a&gt;的这篇文章。&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%B7%B4%E5%A1%9E%E5%B0%94%E9%97%AE%E9%A2%98&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;维基百科上的解答&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;与式\( (3) \)相似的一个题目:&lt;br&gt;$$ \sum_nn^2 = \frac{1}{6}n(n+1)(2n+1)\qquad(4)$$&lt;br&gt;这个题目可以用数学归纳法简单求得。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;伯努利级数&quot;&gt;&lt;a href=&quot;#伯努利级数&quot; class=&quot;headerlink&quot; title=&quot;伯努利级数&quot;&gt;&lt;/a&gt;伯努利级数&lt;/h2&gt;&lt;p&gt;$$ \sum_n\frac{1}{n^2}=1+\frac{1}{4}+\frac{1}{9}+\frac{1}{16}+\cdots\qquad(5) $$&lt;/p&gt;
&lt;h3 id=&quot;泰勒展开&quot;&gt;&lt;a href=&quot;#泰勒展开&quot; class=&quot;headerlink&quot; title=&quot;泰勒展开&quot;&gt;&lt;/a&gt;泰勒展开&lt;/h3&gt;&lt;p&gt;首先，我们考虑式\( \frac{sin\sqrt{x}}{\sqrt{x}}=0 \)的根为\( n^2\pi^2,n=1,2,3,\ldots \)&lt;br&gt;左侧泰勒展开式为&lt;br&gt;$$ \frac{sin\sqrt{x}}{\sqrt{x}}=1-\frac{x}{6}+\frac{x^2}{120}-\frac{x^3}{5040}+\cdots\qquad(6) $$&lt;/p&gt;
&lt;h3 id=&quot;韦达定理&quot;&gt;&lt;a href=&quot;#韦达定理&quot; class=&quot;headerlink&quot; title=&quot;韦达定理&quot;&gt;&lt;/a&gt;韦达定理&lt;/h3&gt;&lt;p&gt;其次，考虑一元n次方程的韦达定理：&lt;br&gt;$$ 1+a_1x+a_2x^2+\cdots+a_nx^n=0\qquad(7) $$&lt;/p&gt;
&lt;p&gt;假设他有\( n \)个非零根\( x_1,x_2,\ldots,x_n \),将它转化为关于\( \frac{1}{x} \)的方程：&lt;br&gt;$$ (\frac{1}{x})^n+a_1(\frac{1}{x})^{n-1}+\cdots+a_n=0\qquad(8) $$&lt;br&gt;对应根变成\( 1/x_1,1/x_2,\ldots,1/x_n \)，由韦达定理得到：&lt;br&gt;$$ \frac{1}{x_1}+\frac{1}{x_2}+\cdots+\frac{1}{x_n}=-a_1\qquad(9) $$&lt;/p&gt;
&lt;h3 id=&quot;欧拉的大胆推广&quot;&gt;&lt;a href=&quot;#欧拉的大胆推广&quot; class=&quot;headerlink&quot; title=&quot;欧拉的大胆推广&quot;&gt;&lt;/a&gt;欧拉的大胆推广&lt;/h3&gt;&lt;p&gt;将式\( (9) \)推广在式\( (6) \)为0的根中：&lt;/p&gt;
&lt;p&gt;$$ \frac{1}{\pi^2}+\frac{1}{2^2\pi^2}+\frac{1}{3^2\pi^2}+\cdots=-a_1=\frac{1}{6}\qquad(10) $$&lt;br&gt;那么：&lt;br&gt;$$ 1+\frac{1}{2^2}+\frac{1}{3^2}+\cdots=\frac{\pi^2}{6}\qquad(11) $$&lt;/p&gt;
&lt;p&gt;如算法与数学之美中所说，其启发性创造性远远掩盖其不严格性。&lt;/p&gt;
&lt;h3 id=&quot;注解&quot;&gt;&lt;a href=&quot;#注解&quot; class=&quot;headerlink&quot; title=&quot;注解&quot;&gt;&lt;/a&gt;注解&lt;/h3&gt;&lt;p&gt;如果直接在式\( (7) \)中使用韦达定理，得到&lt;br&gt;$$ -\frac{a_{n-1}}{a_n}=\pi^2\sum_nn^2=\frac{\pi^2}{6}n(n+1)(2n+1)\qquad(12) $$&lt;br&gt;但是这个只有在\( n\rightarrow\infty \)才是有意义的，例如不能取\( n=3 \)(一个特定数值)来使等式成立。就如式\( (11) \)中取级数前\( n=3 \)部分使之成立。因此对无穷级数的未知项用韦达定理是没有意义的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;先来彩蛋，在&lt;a href=&quot;http://www.wolframalpha.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;wolframalpha&lt;/a&gt;使用Latex格式输入数学公式，可以快速得到结果。&lt;/p&gt;
&lt;p&gt;考虑以下四种无穷级数：&lt;
    
    </summary>
    
      <category term="Math" scheme="http://rylcode.cn/categories/Math/"/>
    
    
      <category term="Bernoulli Series" scheme="http://rylcode.cn/tags/Bernoulli-Series/"/>
    
  </entry>
  
  <entry>
    <title>牛顿迭代法</title>
    <link href="http://rylcode.cn/2016/05/17/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95/"/>
    <id>http://rylcode.cn/2016/05/17/牛顿迭代法/</id>
    <published>2016-05-17T04:29:01.000Z</published>
    <updated>2016-05-18T05:09:18.020Z</updated>
    
    <content type="html">&lt;p&gt;牛顿迭代法是一种巧妙地(切线)逼近方法，它是一种在实数域和复数域上近似求解方程的方法。&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E6%B3%95&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;维基百科的介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面的图(来源于wiki)巧妙的解释了牛顿迭代法的过程：&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/2y9UyHF.gif&quot; alt=&quot;牛顿迭代法&quot;&gt;&lt;/p&gt;
&lt;p&gt;公式如下：&lt;br&gt;$$ x_{n+1} = x_n-\frac{f(x_n)}{f’(x_n)} $$&lt;/p&gt;
&lt;p&gt;Markdownpad2不支持Latex有点烦，使用atom编辑器和markdowm pas plus插件可以解决这个问题，在HEXO博客上部署数学公式需要给HEXO安装&lt;a href=&quot;http://catx.me/2014/03/09/hexo-mathjax-plugin/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hexo-mathjax插件&lt;/a&gt;,注意在本机中使用时不需要修改_config.yml配置文件，否则会生成错误。&lt;br&gt;参考：&lt;a href=&quot;http://www.jeyzhang.com/how-to-insert-equations-in-markdown.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MarkdownPad 2的MathJax插件&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;牛顿迭代法在开方中的应用&quot;&gt;&lt;a href=&quot;#牛顿迭代法在开方中的应用&quot; class=&quot;headerlink&quot; title=&quot;牛顿迭代法在开方中的应用&quot;&gt;&lt;/a&gt;牛顿迭代法在开方中的应用&lt;/h2&gt;&lt;p&gt;开方的迭代式：&lt;br&gt;$$ x_{k+1} = \frac{1}{2}(x_k+\frac{n}{x_k}) $$&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/69%20-%20Sqrt(x)/69%20-%20Sqrt(int%20x).cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;int&lt;/code&gt;开方&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/69%20-%20Sqrt(x)/69%20-%20Sqrt(int%20x).cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;float&lt;/code&gt;开方&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Magic Number(只针对&lt;code&gt;float&lt;/code&gt;，链接同2)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;在开方的计算中，二分查找和牛顿迭代法时间复杂度都是O(logn)，但是牛顿迭代法优于二分查找。&lt;/li&gt;
&lt;li&gt;基于牛顿迭代法的&lt;code&gt;float&lt;/code&gt;开方中使用Magic Number，可以看到使用3次牛顿迭代法就可以得到较高的精确度(相同的迭代次数，要开放的数字越大，精度越低)，其原理与浮点数的存储相关，因此只用于浮点数。&lt;/li&gt;
&lt;li&gt;直观来看，开方(凹型曲线)时牛顿迭代法只从右侧逼近，二分查找从右侧左侧同时逼近,因此显然牛顿迭代法优于二分查找法，尤其对高阶的f(x),牛顿迭代法的逼近速度更快。&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;牛顿迭代法是一种巧妙地(切线)逼近方法，它是一种在实数域和复数域上近似求解方程的方法。&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E6%B3%95&quot; target=&quot;_blank&quot; rel=&quot;exter
    
    </summary>
    
      <category term="Math" scheme="http://rylcode.cn/categories/Math/"/>
    
    
      <category term="Newton iterative method" scheme="http://rylcode.cn/tags/Newton-iterative-method/"/>
    
  </entry>
  
  <entry>
    <title>multimap简介</title>
    <link href="http://rylcode.cn/2016/05/16/multimap%E7%AE%80%E4%BB%8B/"/>
    <id>http://rylcode.cn/2016/05/16/multimap简介/</id>
    <published>2016-05-16T04:42:19.000Z</published>
    <updated>2016-05-16T06:31:48.006Z</updated>
    
    <content type="html">&lt;h2 id=&quot;multimap简介&quot;&gt;&lt;a href=&quot;#multimap简介&quot; class=&quot;headerlink&quot; title=&quot;multimap简介&quot;&gt;&lt;/a&gt;multimap简介&lt;/h2&gt;&lt;p&gt;multimap是一种Hash Table。首先使用&lt;code&gt;multimap&lt;/code&gt;必须使用宏语句&lt;code&gt;#include &amp;lt;map&amp;gt;&lt;/code&gt;。MSDN上对multimap的解释已经比较清楚&lt;a href=&quot;http://blog.csdn.net/chenyujing1234/article/details/8193172&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;multimap基础&lt;/a&gt;，&lt;a href=&quot;http://blog.csdn.net/xz_rabbit/article/details/43907311&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;multimap与map，unorderedmap的对比&lt;/a&gt;&lt;br&gt;主要有以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;multimap多重映照容器:容器的数据结构采用红黑树进行管理(还没有深入理解)；&lt;/li&gt;
&lt;li&gt;multimap的所有元素都是pair:第一元素为键值(key),不能修改;第二元素为实值(value),可被修改 &lt;/li&gt;
&lt;li&gt;multimap特性以及用法与map完全相同，唯一的差别在于: 允许重复键值的元素插入容器(每一个都是用一个&lt;strong&gt;链表&lt;/strong&gt;来链接的)，参考&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/126%20-%20Word%20Ladder%20II/126%20-%20Word%20Ladder%20II.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里的github&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unordered_multimap&lt;/code&gt;(目前还没有用到过)的无序存储特点，这是其与&lt;code&gt;multimap&lt;/code&gt;最大的区别。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;multimap的使用&quot;&gt;&lt;a href=&quot;#multimap的使用&quot; class=&quot;headerlink&quot; title=&quot;multimap的使用&quot;&gt;&lt;/a&gt;multimap的使用&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;初始化:&lt;code&gt;multimap&amp;lt;string, string&amp;gt; father;&lt;/code&gt;，第一个是key类型，第二个是映照类型；&lt;/li&gt;
&lt;li&gt;插入数据:&lt;code&gt;father.insert(make_pair(string1, string2);&lt;/code&gt;，&lt;a href=&quot;http://www.cnblogs.com/Nimeux/archive/2010/10/05/1844191.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;pair&lt;/code&gt;与&lt;code&gt;make_pair&lt;/code&gt;介绍&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;寻找某个键值:&lt;code&gt;pair&amp;lt;multimap&amp;lt;string, string&amp;gt;::iterator, multimap&amp;lt;string, string&amp;gt;::iterator&amp;gt; pos = father.equal_range(string1)&lt;/code&gt;;&lt;code&gt;equal_range(string1);&lt;/code&gt;注意其返回的是&lt;code&gt;pair&lt;/code&gt;对象，&lt;code&gt;first&lt;/code&gt;和&lt;code&gt;second&lt;/code&gt;都是迭代器类型，他返回键值为&lt;code&gt;string1&lt;/code&gt;的左指针和超尾(右)指针(最后一个键值为&lt;code&gt;string1&lt;/code&gt;的下一个指针)，源码如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;typedef pair&amp;lt;iterator, iterator&amp;gt; _Pairii;

_Pairii equal_range(const key_type&amp;amp; _Keyval)
{    // find range equivalent to _Keyval in mutable tree
    return (_Eqrange(_Keyval));
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;multimap简介&quot;&gt;&lt;a href=&quot;#multimap简介&quot; class=&quot;headerlink&quot; title=&quot;multimap简介&quot;&gt;&lt;/a&gt;multimap简介&lt;/h2&gt;&lt;p&gt;multimap是一种Hash Table。首先使用&lt;code&gt;multim
    
    </summary>
    
      <category term="STL" scheme="http://rylcode.cn/categories/STL/"/>
    
    
      <category term="multimap" scheme="http://rylcode.cn/tags/multimap/"/>
    
  </entry>
  
  <entry>
    <title>i++与++i的区别</title>
    <link href="http://rylcode.cn/2016/05/06/i++%E4%B8%8E++i%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://rylcode.cn/2016/05/06/i++与++i的区别/</id>
    <published>2016-05-06T06:22:46.000Z</published>
    <updated>2016-05-06T07:08:58.310Z</updated>
    
    <content type="html">&lt;p&gt;一直以来对&lt;code&gt;++i&lt;/code&gt;与&lt;code&gt;i++&lt;/code&gt;，知道前者效率更高，但是不知道为什么。有人说与寄存器有关，实际上寄存器都执行了一次加法，是一样的。看了&lt;a href=&quot;http://falldog7.blogspot.jp/2007/10/programmer-i-i.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里的博客&lt;/a&gt;才恍然大悟，原来是其实现的机制不同。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;++i&lt;/code&gt;先加再用，其对i类型(假设为INT)的++运算符重载如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//++i&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;INT operator ++()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	this-&amp;gt;_value++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return *this;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;i++&lt;/code&gt;先用再加，创建临时变量保存原有值用来返回，后调用++i语句，重载如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//i++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;INT operator ++(int t)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	INT temp(_value);//!!! 必須create出一個temp的變數!!!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	this-&amp;gt;_value++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在这个函数中参数n是没有任何意义的，它的存在只是为了区分是前置形式还是后置形式。&lt;/p&gt;
&lt;p&gt;可以看到&lt;code&gt;i++&lt;/code&gt;所必须付出的代价，就是多create出一个temp的变量，以及temp变量的的constructor()。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;一直以来对&lt;code&gt;++i&lt;/code&gt;与&lt;code&gt;i++&lt;/code&gt;，知道前者效率更高，但是不知道为什么。有人说与寄存器有关，实际上寄存器都执行了一次加法，是一样的。看了&lt;a href=&quot;http://falldog7.blogspot.jp/2007/10/pro
    
    </summary>
    
      <category term="C++的类" scheme="http://rylcode.cn/categories/C-%E7%9A%84%E7%B1%BB/"/>
    
    
      <category term="自增减运算符重载" scheme="http://rylcode.cn/tags/%E8%87%AA%E5%A2%9E%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的递归遍历与栈遍历</title>
    <link href="http://rylcode.cn/2016/05/06/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E4%B8%8E%E6%A0%88%E9%81%8D%E5%8E%86/"/>
    <id>http://rylcode.cn/2016/05/06/二叉树的递归遍历与栈遍历/</id>
    <published>2016-05-06T02:43:22.000Z</published>
    <updated>2016-05-06T04:44:10.888Z</updated>
    
    <content type="html">&lt;p&gt;二叉树的遍历算法有三种，最简单的递归遍历，还有两种非递归遍历，分别是使用栈的遍历和Morris遍历。每一种遍历根据访问根节点的时机又分为前序，中序，后序三种。&lt;br&gt;二叉树节点的定义如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;struct TreeNode &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	TreeNode *left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	TreeNode *right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	TreeNode(int x) : val(x), left(nullptr), right(nullptr) &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;二叉树的递归遍历&quot;&gt;&lt;a href=&quot;#二叉树的递归遍历&quot; class=&quot;headerlink&quot; title=&quot;二叉树的递归遍历&quot;&gt;&lt;/a&gt;二叉树的递归遍历&lt;/h2&gt;&lt;p&gt;没什么技巧，方式如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class Solution &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	void Traversal(TreeNode* root,vector&amp;lt;int&amp;gt; &amp;amp;result) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if (!root)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		//result.push(root-&amp;gt;val);	//preorderTraversal&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Traversal(root-&amp;gt;left,result);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		//result.push(root-&amp;gt;val);	//inorderTraversal&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Traversal(root-&amp;gt;right,result);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		//result.push(root-&amp;gt;val);	//postorderTraversal&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;二叉树的栈遍历&quot;&gt;&lt;a href=&quot;#二叉树的栈遍历&quot; class=&quot;headerlink&quot; title=&quot;二叉树的栈遍历&quot;&gt;&lt;/a&gt;二叉树的栈遍历&lt;/h2&gt;&lt;p&gt;前序和中序可以用同一段代码来实现(用栈记忆所有左子树(while)，回溯一位(if)访问右子树)：&lt;br&gt;&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/144%20-%20Binary%20Tree%20Preorder%20Traversal/144%20-%20Binary%20Tree%20Preorder%20Traversal.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前序遍历&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/94%20-%20Binary%20Tree%20Inorder%20Traversal/94%20-%20Binary%20Tree%20Inorder%20Traversal.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;中序遍历&lt;/a&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class Solution &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	vector&amp;lt;int&amp;gt; inorderTraversal(TreeNode* root) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		vector&amp;lt;int&amp;gt; result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		stack&amp;lt;TreeNode*&amp;gt; sS1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		while (root||!sS1.empty())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			while (root)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				//result.push_back(root-&amp;gt;val);	//先序遍历的位置&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				sS1.push(root);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				root = root-&amp;gt;left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			if (!sS1.empty())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				root = sS1.top();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				sS1.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				result.push_back(root-&amp;gt;val);	//中序遍历的位置&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				root = root-&amp;gt;right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		return result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;后序遍历稍微复杂一点，有两种思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;左子树-&amp;gt;右子树-&amp;gt;节点(后序)    转化为    节点-&amp;gt;右子树-&amp;gt;左子树(前序) 的翻转(栈)&lt;/li&gt;
&lt;li&gt;对于任一结点P，先将其入栈。如果P不存在左孩子和右孩子，则可以直接访问它。或者P存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。若非上述两种情况，则将P的右孩子和左孩子依次入栈。这样就保证了每次取栈顶元素的时候，左孩子和右孩子都在根结点前面被访问。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/145%20-%20Binary%20Tree%20Postorder%20Traversal/145%20-%20Binary%20Tree%20Postorder%20Traversal.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;后序遍历&lt;/a&gt;&lt;br&gt;第一种(变异的前序)：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class Solution1 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	vector&amp;lt;int&amp;gt; postorderTraversal(TreeNode* root) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		vector&amp;lt;int&amp;gt; outTreeNode;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		stack&amp;lt;TreeNode*&amp;gt; sTreeNode;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		stack&amp;lt;int&amp;gt; sInt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		while (root||!sTreeNode.empty())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			while (root)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				sInt.push(root-&amp;gt;val);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				sTreeNode.push(root);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				root=root-&amp;gt;right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			if (!sTreeNode.empty())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				root=sTreeNode.top();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				sTreeNode.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				root=root-&amp;gt;left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		while (!sInt.empty())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			outTreeNode.push_back(sInt.top());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			sInt.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		return outTreeNode;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;第二种(利用pre指针的后序)：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class Solution &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	vector&amp;lt;int&amp;gt; postorderTraversal(TreeNode* root) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		vector&amp;lt;int&amp;gt; outTreeNode;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		stack&amp;lt;TreeNode*&amp;gt; sTreeNode;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		TreeNode* pre=nullptr;	//指向之前访问的节点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if (root)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			sTreeNode.push(root);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		while (!sTreeNode.empty())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			root=sTreeNode.top();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			if ((root-&amp;gt;left==nullptr&amp;amp;&amp;amp;root-&amp;gt;right==nullptr)||(pre!=nullptr&amp;amp;&amp;amp;(pre==root-&amp;gt;left||pre==root-&amp;gt;right)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				outTreeNode.push_back(root-&amp;gt;val);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				pre=root;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				sTreeNode.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				if (root-&amp;gt;right)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					sTreeNode.push(root-&amp;gt;right);//右孩子先入栈，后访问&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				if (root-&amp;gt;left)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					sTreeNode.push(root-&amp;gt;left);//左孩子后入栈，先访问&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		return outTreeNode;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;二叉树的遍历算法有三种，最简单的递归遍历，还有两种非递归遍历，分别是使用栈的遍历和Morris遍历。每一种遍历根据访问根节点的时机又分为前序，中序，后序三种。&lt;br&gt;二叉树节点的定义如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://rylcode.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="http://rylcode.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="非递归遍历" scheme="http://rylcode.cn/tags/%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>BP、KMP、改进的KMP</title>
    <link href="http://rylcode.cn/2016/05/03/BP%E3%80%81KMP%E3%80%81%E6%94%B9%E8%BF%9B%E7%9A%84KMP/"/>
    <id>http://rylcode.cn/2016/05/03/BP、KMP、改进的KMP/</id>
    <published>2016-05-03T06:57:41.000Z</published>
    <updated>2016-05-06T04:44:53.510Z</updated>
    
    <content type="html">&lt;p&gt;在主串S中，自low位置开始，查找与模式串T相等的子串。如果这样的子串存在，返回其第一次出现的位置。本文详细介绍三种字符串匹配算法:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;BF(Brute-Force)算法(暴力破解);&lt;/li&gt;
&lt;li&gt;KMP算法;&lt;/li&gt;
&lt;li&gt;改进的KMP算法。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这三种算法的代码&lt;a href=&quot;https://github.com/applefishsky009/Interface/blob/master/BF%E5%92%8CKMP/BF%E5%92%8CKMP.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在这里&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;BF算法&quot;&gt;&lt;a href=&quot;#BF算法&quot; class=&quot;headerlink&quot; title=&quot;BF算法&quot;&gt;&lt;/a&gt;BF算法&lt;/h2&gt;&lt;p&gt;设主串从i位开始与子串(从0开始)判断是否匹配;到子串的j位置，对应主串的i+j位置失配;将主串左移一位(&lt;code&gt;i++&lt;/code&gt;),j回到0位继续匹配。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;KMP算法&quot;&gt;&lt;a href=&quot;#KMP算法&quot; class=&quot;headerlink&quot; title=&quot;KMP算法&quot;&gt;&lt;/a&gt;KMP算法&lt;/h2&gt;&lt;h3 id=&quot;为什么是next-j&quot;&gt;&lt;a href=&quot;#为什么是next-j&quot; class=&quot;headerlink&quot; title=&quot;为什么是next[j]&quot;&gt;&lt;/a&gt;为什么是next[j]&lt;/h3&gt;&lt;p&gt;每次失配将i右移一位显然是低效的。&lt;strong&gt;主观上来考虑，如果在失配之前子串有相等的真后缀，那么就可以右移更多的位。&lt;/strong&gt;考虑在i+j位失配时将主串左移k位(子串右移k位)，而不是一位。容易得到，这个k只与子串的性质有关。&lt;br&gt;我们使用next[j]来标识当j位失配时子串应向右移j-next[j]位。示例:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;code&gt;abcdefg&lt;/code&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;0 1 2 3 4 5 6&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;next[j]&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-1 0 0 0 0 0 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;offset&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1 1 2 3 4 5 6&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;code&gt;abcabcabc&lt;/code&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;0 1 2 3 4 5 6 7 8&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;next[j]&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-1 0 0 0 1 2 3 4 5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;offset&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1 1 2 3 3 3 3 3 3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;如何求得next-j&quot;&gt;&lt;a href=&quot;#如何求得next-j&quot; class=&quot;headerlink&quot; title=&quot;如何求得next[j]&quot;&gt;&lt;/a&gt;如何求得next[j]&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/qc2eynB.png&quot; alt=&quot;这里&quot;&gt;&lt;/p&gt;
&lt;p&gt;在计算公式中第二行指的是:j位&lt;strong&gt;以前&lt;/strong&gt;字串中真前后缀的最大&lt;strong&gt;公共&lt;/strong&gt;元素长度。真前缀、真后缀指的不包含串本身的子串。那么我们可以这样来计算j:&lt;br&gt;tempNext[j]表示j位及以前子串真前缀最大公共元素长度。将tempNext[j]右移一位，初值赋为-1,得到next[j]&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;code&gt;xyxyyxxyx&lt;/code&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;0 1 2 3 4 5 6 7 8&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;tempNext[j]&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0 0 1 2 0 1 1 2 3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;next[j]&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-1 0 0 1 2 0 1 1 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;offset&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1 1 2 2 2 5 5 6 6&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;tempNext[j]的计算:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//计算j位及之前真前缀以及真后缀的最大公共元素长度&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void calTempNext(vector&amp;lt;int&amp;gt;&amp;amp;next)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if (s2.size() == 1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	next[0] = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int k = 0;//前缀指针,j就是后缀指针&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	for (int j = 1;j &amp;lt; s2.size();j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		while(k &amp;gt; 0 &amp;amp;&amp;amp; s2[j] != s2[k])//k位失配，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			k = next[k-1];//k-1是可靠匹配，next[k-1]记录了上一个真后缀出现的地方&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if (s2[j] == s2[k])//匹配，k++,j++，next[j]赋值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			k++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		next[j] = k;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;如何在编程中求得next-j&quot;&gt;&lt;a href=&quot;#如何在编程中求得next-j&quot; class=&quot;headerlink&quot; title=&quot;如何在编程中求得next[j]&quot;&gt;&lt;/a&gt;如何在编程中求得next[j]&lt;/h3&gt;&lt;p&gt;如果使用上述计算过程，先计算tempNext[j]再计算next[j]，需要两次遍历。将tempNext[j]右移初值赋-1的过程可以直接融入程序中，使用一次遍历就可以得到next[j]，&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//直接计算next(时间复杂度O(n))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void cal2Next(vector&amp;lt;int&amp;gt;&amp;amp;next)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int j = -1;		//j,偏移指针&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int i = 0;		//i,next下标（实际上是要计算的next下标-1,因为是先加后赋值）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	next[0] = -1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	while (i &amp;lt; s2.size()-1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if (j == -1 || s2[i]==s2[j])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			i++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			j++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			next[i] = j;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			j = next[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;改进的KMP算法&quot;&gt;&lt;a href=&quot;#改进的KMP算法&quot; class=&quot;headerlink&quot; title=&quot;改进的KMP算法&quot;&gt;&lt;/a&gt;改进的KMP算法&lt;/h2&gt;&lt;p&gt;next[j]值越小，模式匹配所需比较次数越少。next[j]的计算中先判断匹配，i,j自加再赋值。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若自加之后失配，这时候i失配并不代表j失配，因此留给下次循环回溯后来判断。&lt;/li&gt;
&lt;li&gt;若自加之后匹配，说明i与j位置完全等效，i失配，j一定失配。，而朴素的KMP算法在失配之后要一次一次回溯。因此可以&lt;font color=&quot;red&quot;&gt;一次回溯到底&lt;/font&gt;节约比较次数。&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;code&gt;abcaabbabcaac&lt;/code&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;0 1 2  3 4 5 6  7 8 9 10 11 12&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;next[j]&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-1 0 0  0 1 1 2  0 1 2  3  4  5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;offset1&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1 1 2  3 3 4 4  7 7 7  7  7  7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;nextVal[j]&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-1 0 0 -1 1 0 2 -1 0 0 -1  1  5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;offset2&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1 1 2  4 3 5 4  8 8 9 11 10  7&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/28%20-%20Implement%20strStr()/28%20-%20Implement%20strStr().cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;LeetCode代码&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在主串S中，自low位置开始，查找与模式串T相等的子串。如果这样的子串存在，返回其第一次出现的位置。本文详细介绍三种字符串匹配算法:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;BF(Brute-Force)算法(暴力破解);&lt;/li&gt;
&lt;li&gt;KMP算法;&lt;/li&gt;
&lt;li&gt;改进的KMP算
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://rylcode.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="字符串匹配" scheme="http://rylcode.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    
      <category term="KMP" scheme="http://rylcode.cn/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>野指针与内存泄漏</title>
    <link href="http://rylcode.cn/2016/04/25/%E9%87%8E%E6%8C%87%E9%92%88%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>http://rylcode.cn/2016/04/25/野指针与内存泄漏/</id>
    <published>2016-04-25T01:36:10.000Z</published>
    <updated>2016-05-06T04:55:02.316Z</updated>
    
    <content type="html">&lt;p&gt;野指针和内存泄漏是两个相联系的概念，一般来讲指针&amp;lt;-&amp;gt;内存相互对应，如果有一个指针但没有指向任何内存，就是野指针；如果有一块未释放的内存，但没有指针指向他，就是内存泄露。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;野指针&quot;&gt;&lt;a href=&quot;#野指针&quot; class=&quot;headerlink&quot; title=&quot;野指针&quot;&gt;&lt;/a&gt;野指针&lt;/h2&gt;&lt;p&gt;野指针指向一个已删除对象或未申请访问受限内存区域的指针，一般来说野指针有三个成因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;指针变量未初始化；&lt;/li&gt;
&lt;li&gt;指针释放后未置空；&lt;/li&gt;
&lt;li&gt;指针操作超越变量作用域。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;值得注意的是，如果有多个指针指向同一块内存，释放其中一个指针后，应将包含这个指针在内的指向这一块内存的所有指针都置空，否则都会成为野指针。&lt;/p&gt;
&lt;h2 id=&quot;内存泄漏&quot;&gt;&lt;a href=&quot;#内存泄漏&quot; class=&quot;headerlink&quot; title=&quot;内存泄漏&quot;&gt;&lt;/a&gt;内存泄漏&lt;/h2&gt;&lt;p&gt;在某一块内存的生命周期内，指向它的指针全部指向别处时，用户无法访问，也无法申请到这一块内存。这就是内存泄露。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;野指针和内存泄漏是两个相联系的概念，一般来讲指针&amp;lt;-&amp;gt;内存相互对应，如果有一个指针但没有指向任何内存，就是野指针；如果有一块未释放的内存，但没有指针指向他，就是内存泄露。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;野指针&quot;&gt;&lt;a href=&quot;#野指针&quot; class=&quot;h
    
    </summary>
    
      <category term="C++基础" scheme="http://rylcode.cn/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="野指针" scheme="http://rylcode.cn/tags/%E9%87%8E%E6%8C%87%E9%92%88/"/>
    
      <category term="内存泄漏" scheme="http://rylcode.cn/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Git命令</title>
    <link href="http://rylcode.cn/2016/04/23/Git%E5%91%BD%E4%BB%A4/"/>
    <id>http://rylcode.cn/2016/04/23/Git命令/</id>
    <published>2016-04-23T06:27:10.000Z</published>
    <updated>2016-05-21T12:28:56.846Z</updated>
    
    <content type="html">&lt;p&gt;初学git，记录当时的一些解决方法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/22132675&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;删除不想要的git历史&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/q/1010000000115900&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;删除版本库中的提交&lt;/a&gt;注意，他将HEAD指向某一个commit，之后的commit和文件都被擦除了，删除前做好备份……&lt;/li&gt;
&lt;li&gt;博客中常用的命令：hexo clean(删除一些没有用的缓存，比如删掉的tag等);hexo generate(生成一个commit?);hexo deploy(提交到远程)&lt;/li&gt;
&lt;li&gt;使用过程中碰到&lt;a href=&quot;http://stackoverflow.com/questions/9299651/git-says-warning-permanently-added-to-the-list-of-known-hosts&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Warning: Permanently added ‘github.com,192.30.252.120’ (RSA) to the list of known hosts&lt;/a&gt;.这个问题在linux下很好解决,但我用windows for github，困扰好久，方法如下：在C:/user/###(你的用户名)/.ssh/新建config文件(无后缀),添加UserKnownHostsFile ~/.ssh/known_hosts,下一次访问你还会看到，但是之后(可能要多几次，我的三次才可以，因为在这个文件夹下添加了三个ip)就没有了。&lt;/li&gt;
&lt;li&gt;windows下换行符&lt;a href=&quot;http://www.luckyonecn.com/blog/git-auto-crlf-problem/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;warning: LF will be replaced by CRLF&lt;/a&gt;，不知道为什么我的&lt;code&gt;git config --global autocrlf false&lt;/code&gt;没有用，因此直接在仓库中将config文件，core中修改autocrlf = false,没有则添加。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;初学git，记录当时的一些解决方法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/22132675&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;删除不想要的git历史&lt;/a&gt;&lt;/li&gt;
&lt;li
    
    </summary>
    
      <category term="Git" scheme="http://rylcode.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="http://rylcode.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://rylcode.cn/2016/04/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://rylcode.cn/2016/04/22/动态规划/</id>
    <published>2016-04-22T09:07:05.000Z</published>
    <updated>2016-05-19T03:23:15.666Z</updated>
    
    <content type="html">&lt;p&gt;持续更新，记录在编程过程中关于动态规划(DP)的心得体会。算法分析以算法导论为主。主要是用于求解最优化问题，不同于递归用于解决互不相交的子问题，动态规划应用于子问题重叠的情况。在实际应用中发现他有两个关键点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;子问题的&lt;strong&gt;状态转移方程&lt;/strong&gt;(递推关系式)；&lt;/li&gt;
&lt;li&gt;保存子问题的解用于递归(自顶向下);&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;它有两种等价的实现方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;带备忘的自顶向下；&lt;/li&gt;
&lt;li&gt;自底向上。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般来说自底向上更容易实现。实际中哪一种更容易编程取决于具体问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/120%20-%20Triangle/120%20-%20Triangle.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;triangle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/tree/master/62%20-%20Unique%20Paths&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Unique Paths&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/53%20-%20Maximum%20Subarray/53%20-%20Maximum%20Subarray.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;LeetCode:Maximum Subarray&lt;/a&gt;和&lt;a href=&quot;https://github.com/applefishsky009/BeautyOfProgramming/blob/master/2.14%20-%20%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/2.14.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BeautyOfProgramming:一维数组的最大子数组&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;注意递推关系式(未改进版)(主要是理清逻辑，需要一个\( nStart[i] \)的递推):&lt;/li&gt;
&lt;li&gt;\( nStart[i] = max(nStart[i-1]+A[i],nAll[i-1]) \);&lt;/li&gt;
&lt;li&gt;\( nAll[i] = max(nStart[i],nAll[i-1]) \) &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;持续更新，记录在编程过程中关于动态规划(DP)的心得体会。算法分析以算法导论为主。主要是用于求解最优化问题，不同于递归用于解决互不相交的子问题，动态规划应用于子问题重叠的情况。在实际应用中发现他有两个关键点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;子问题的&lt;strong&gt;状态转移方程&lt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://rylcode.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://rylcode.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法</title>
    <link href="http://rylcode.cn/2016/04/22/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <id>http://rylcode.cn/2016/04/22/贪心算法/</id>
    <published>2016-04-22T07:54:31.000Z</published>
    <updated>2016-05-18T02:02:07.495Z</updated>
    
    <content type="html">&lt;p&gt;持续更新，记录在编程过程中关于贪心算法的心得体会。算法分析以算法导论为主。求解最优化问题比动态规划更为简洁高效。其思想核心是&lt;font color=&quot;red&quot;&gt;选择当前最优解&lt;/font&gt;，虽然不一定是全局最优解。贪心算法主要应用有&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;活动选择问题&lt;/li&gt;
&lt;li&gt;霍夫曼编码&lt;/li&gt;
&lt;li&gt;最小生成树&lt;/li&gt;
&lt;li&gt;单元最短路径的Dijkstra算法&lt;/li&gt;
&lt;li&gt;集合覆盖问题的贪心启发式算法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;贪心算法的形式一般有&lt;strong&gt;递归贪心算法&lt;/strong&gt;，&lt;strong&gt;迭代贪心算法&lt;/strong&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;活动选择问题&quot;&gt;&lt;a href=&quot;#活动选择问题&quot; class=&quot;headerlink&quot; title=&quot;活动选择问题&quot;&gt;&lt;/a&gt;活动选择问题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;调度竞争共享资源的多个活动问题，选出最大的互相兼容的活动集合；&lt;ul&gt;
&lt;li&gt;选择一个活动，选出他后剩下的资源能尽量多的被其他任务所用(算法导论16.1)；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Jump Game；&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/55%20-%20Jump%20Game/55%20-%20Jump%20Game%20%20.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Jump Game&lt;/a&gt;,每个节点选择更新当前最优解。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/45%20-%20Jump%20Game%20II/45%20-%20Jump%20Game%20II.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Jump GameⅡ&lt;/a&gt;, 每一步选择当前最优解(层数，是一层一一层映射的关系，怎么感觉是在广搜？!)。&lt;/li&gt;
&lt;li&gt;Jump GameⅡ比Jump Game多出统计步数，在这个映射范围内选择最优解&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;持续更新，记录在编程过程中关于贪心算法的心得体会。算法分析以算法导论为主。求解最优化问题比动态规划更为简洁高效。其思想核心是&lt;font color=&quot;red&quot;&gt;选择当前最优解&lt;/font&gt;，虽然不一定是全局最优解。贪心算法主要应用有&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;活动选择问题&lt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://rylcode.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="贪心" scheme="http://rylcode.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>函数参数的传递</title>
    <link href="http://rylcode.cn/2016/04/22/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92/"/>
    <id>http://rylcode.cn/2016/04/22/函数参数的传递/</id>
    <published>2016-04-22T01:42:40.000Z</published>
    <updated>2016-05-06T06:20:28.808Z</updated>
    
    <content type="html">&lt;p&gt;函数参数的传递有三种，按值传递，按址传递，按引用传递(C++新增)。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h2&gt;&lt;h3 id=&quot;引用的本质&quot;&gt;&lt;a href=&quot;#引用的本质&quot; class=&quot;headerlink&quot; title=&quot;引用的本质&quot;&gt;&lt;/a&gt;引用的本质&lt;/h3&gt;&lt;p&gt;C++将&lt;code&gt;&amp;amp;&lt;/code&gt;符号赋予了另一个含义，用来声明引用。引用是已定义变量的别名(同一块内存)。引用的主要作用是用作函数形参。&lt;br&gt;引用的本质是&lt;font color=&quot;red&quot;&gt;指针常量&lt;/font&gt;，例如&lt;code&gt;int &amp;amp;pr = rats;&lt;/code&gt;是&lt;code&gt;int* const pr = &amp;amp;rats;&lt;/code&gt;的伪装。它的含义是他是一个指针，指向一个常量地址。因此他有以下特性也就很好理解了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;必须在声明引用是将其初始化；(因为指向常量地址)&lt;/li&gt;
&lt;li&gt;初始化时，省略了取地址符的操作&lt;code&gt;&amp;amp;&lt;/code&gt;,给我们感觉是别名；&lt;/li&gt;
&lt;li&gt;声明引用时，隐藏了对指针常量的自动间接引用，让我们看不到指针。&lt;/li&gt;
&lt;li&gt;使用引用时，隐藏了解除引用&lt;code&gt;*&lt;/code&gt;,让我们觉得是在直接修改(别名)变量。&lt;br&gt;如下：&lt;img src=&quot;http://i.imgur.com/idRXQZy.png&quot; alt=&quot;这里&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;返回引用&quot;&gt;&lt;a href=&quot;#返回引用&quot; class=&quot;headerlink&quot; title=&quot;返回引用&quot;&gt;&lt;/a&gt;返回引用&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;返回引用比传统返回机制烧了拷贝复制，效率更高。&lt;/li&gt;
&lt;li&gt;返回引用本质是返回“别名”,因此要注意保证返回后这个内存依然存在。(变量持续性)&lt;/li&gt;
&lt;li&gt;返回类型&lt;strong&gt;一般&lt;/strong&gt;用&lt;font color=&quot;red&quot;&gt;&lt;code&gt;const&lt;/code&gt;标识&lt;/font&gt;，将其设置为不可修改的左值，避免数据损失。&lt;ul&gt;
&lt;li&gt;赋值语句，左边必须是可修改的左值；&lt;/li&gt;
&lt;li&gt;常规返回类型是右值(因为其位于临时内存单元)-&amp;gt;不能通过地址访问。(可以出现在表达式右边，但不能出现在左边，如字面值&lt;code&gt;10.0&lt;/code&gt;,表达式&lt;code&gt;x+y&lt;/code&gt;) &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果返回局部变量(运算符重载中)，不能返回引用。&lt;/p&gt;
&lt;h3 id=&quot;C-C-中的左值和右值&quot;&gt;&lt;a href=&quot;#C-C-中的左值和右值&quot; class=&quot;headerlink&quot; title=&quot;C/C++中的左值和右值&quot;&gt;&lt;/a&gt;C/C++中的左值和右值&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;左值是一个引用到对象的表达式，因此可以取址(可以赋值)；&lt;/li&gt;
&lt;li&gt;右值强调的不是表达式本身，而是该表达式运算后的结果。这个结果往往并不引用到某一对象，可以看成计算的中间结果(临时内存单元)；（当然它也可能引用到某一对象，但是通过该右值表达式我们不能直接修改该对象—）。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;按值传递&quot;&gt;&lt;a href=&quot;#按值传递&quot; class=&quot;headerlink&quot; title=&quot;按值传递&quot;&gt;&lt;/a&gt;按值传递&lt;/h2&gt;&lt;p&gt;C++将数值参数传递给函数，函数将其赋给一个新的变量，新变量与旧变量在赋值之后没有任何关系。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;按址传递&quot;&gt;&lt;a href=&quot;#按址传递&quot; class=&quot;headerlink&quot; title=&quot;按址传递&quot;&gt;&lt;/a&gt;按址传递&lt;/h2&gt;&lt;p&gt;C++将参数地址传递给函数，函数原型用指针(一般用&lt;code&gt;const&lt;/code&gt;修饰表示指针不会乱指)指向这个地址&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;数组传递&quot;&gt;&lt;a href=&quot;#数组传递&quot; class=&quot;headerlink&quot; title=&quot;数组传递&quot;&gt;&lt;/a&gt;数组传递&lt;/h2&gt;&lt;p&gt;数组在传递时，编译器将数组名解释为第一个元素的地址，因此传递实参为数组时，形参应该是一个指针指向这个地址。&lt;br&gt;在用多维数组名作为形参时，可以指定所有维数的大小，也可以省略第一位的大小(高维大小必须指定)，这与编译器寻址有关，比如&lt;code&gt;int p[m][n]&lt;/code&gt;如果要取&lt;code&gt;p[i][j]&lt;/code&gt;的值，编译器会计算地址为&lt;code&gt;p+i*n+j;&lt;/code&gt;，因此编译器可以不知道m的值，但必须知道n的值。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;函数参数的传递有三种，按值传递，按址传递，按引用传递(C++新增)。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h2&gt;&lt;h3 id=&quot;引用的本质&quot;&gt;&lt;a href=&quot;#引
    
    </summary>
    
      <category term="C++基础" scheme="http://rylcode.cn/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="引用" scheme="http://rylcode.cn/tags/%E5%BC%95%E7%94%A8/"/>
    
      <category term="参数传递" scheme="http://rylcode.cn/tags/%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"/>
    
      <category term="左值和右值" scheme="http://rylcode.cn/tags/%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>BFS和DFS</title>
    <link href="http://rylcode.cn/2016/04/21/BFS%E5%92%8CDFS/"/>
    <id>http://rylcode.cn/2016/04/21/BFS和DFS/</id>
    <published>2016-04-21T07:28:51.000Z</published>
    <updated>2016-05-16T08:00:17.518Z</updated>
    
    <content type="html">&lt;p&gt;持续更新,该贴记录一些BFS和DFS在使用过程中的心得体会，以加深对BFS与DFS的理解。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;BFS-广度优先搜索&quot;&gt;&lt;a href=&quot;#BFS-广度优先搜索&quot; class=&quot;headerlink&quot; title=&quot;BFS(广度优先搜索)&quot;&gt;&lt;/a&gt;BFS(广度优先搜索)&lt;/h2&gt;&lt;p&gt;BFS需要借助一个队列来记录遍历的”层数”；每遍历目标集合一次，&lt;strong&gt;步长&lt;/strong&gt;加一；队列为空，结束搜寻。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/127%20-%20World%20Ladder/127%20-%20World%20Ladder.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Word Ladder&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/126%20-%20Word%20Ladder%20II/126%20-%20Word%20Ladder%20II.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Word Ladder II&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;DFS-深度优先搜索&quot;&gt;&lt;a href=&quot;#DFS-深度优先搜索&quot; class=&quot;headerlink&quot; title=&quot;DFS(深度优先搜索)&quot;&gt;&lt;/a&gt;DFS(深度优先搜索)&lt;/h2&gt;&lt;p&gt;DFS需要用递归或者借助栈来&lt;strong&gt;记录&lt;/strong&gt;走过的路径；每遍历完这条分支，便要&lt;strong&gt;回溯&lt;/strong&gt;到上一层；在递归之前可以记录深度。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/131%20-%20Palindrome%20Partitioning/131%20-%20Palindrome%20Partitioning.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Palindrome Partitioning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/126%20-%20Word%20Ladder%20II/126%20-%20Word%20Ladder%20II.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Word Ladder II&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;持续更新,该贴记录一些BFS和DFS在使用过程中的心得体会，以加深对BFS与DFS的理解。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;BFS-广度优先搜索&quot;&gt;&lt;a href=&quot;#BFS-广度优先搜索&quot; class=&quot;headerlink&quot; title=&quot;BFS(广度优先搜索)&quot;&gt;&lt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://rylcode.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="BFS" scheme="http://rylcode.cn/tags/BFS/"/>
    
      <category term="DFS" scheme="http://rylcode.cn/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>共用体、枚举和浮点数存储</title>
    <link href="http://rylcode.cn/2016/04/21/%E5%85%B1%E7%94%A8%E4%BD%93%E3%80%81%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B5%AE%E7%82%B9%E6%95%B0%E5%AD%98%E5%82%A8/"/>
    <id>http://rylcode.cn/2016/04/21/共用体、枚举和浮点数存储/</id>
    <published>2016-04-21T02:38:14.000Z</published>
    <updated>2016-05-06T04:58:24.186Z</updated>
    
    <content type="html">&lt;h2 id=&quot;共用体&quot;&gt;&lt;a href=&quot;#共用体&quot; class=&quot;headerlink&quot; title=&quot;共用体&quot;&gt;&lt;/a&gt;共用体&lt;/h2&gt;&lt;p&gt;是一种数据格式，简单来说，在同一块内存地址，可以同时起不同数据类型的名字，用这些名字来取值时，名字所对应的数据类型告诉编译器怎么去解释内存中的数据。他的特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它的长度是最大数据类型长度，可以节省空间；&lt;/li&gt;
&lt;li&gt;数据不共存；&lt;/li&gt;
&lt;li&gt;关键字&lt;code&gt;union&lt;/code&gt;，声明方式与结构体相同；&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;枚举&quot;&gt;&lt;a href=&quot;#枚举&quot; class=&quot;headerlink&quot; title=&quot;枚举&quot;&gt;&lt;/a&gt;枚举&lt;/h2&gt;&lt;p&gt;创建符号常量的方式，简单来说就是将一个“标签”与枚举量对应起来。特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以提升(常到&lt;code&gt;int&lt;/code&gt;)，但&lt;code&gt;int&lt;/code&gt;不能缩窄到它；&lt;/li&gt;
&lt;li&gt;可以显式设置枚举量，枚举范围内即使没有枚举量，也合法；&lt;/li&gt;
&lt;li&gt;关键词&lt;code&gt;enum&lt;/code&gt;，声明方式与结构体相似；&lt;/li&gt;
&lt;li&gt;他没有算术运算，一般常用于&lt;code&gt;swith&lt;/code&gt;语句中的标签。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;浮点数存储方式&quot;&gt;&lt;a href=&quot;#浮点数存储方式&quot; class=&quot;headerlink&quot; title=&quot;浮点数存储方式&quot;&gt;&lt;/a&gt;浮点数存储方式&lt;/h2&gt;&lt;p&gt;不管是什么数据类型，在内存中的表示方式都是一样的(0或者1)，数据类型的作用只是告诉编译器如何去解释内存中的数据，那么编译器是如何解释浮点型的？&lt;br&gt;首先，二进制科学法表示中，一个浮点型S = M*2^N，内存会存储三部分：符号位+阶码(N)+尾数(M)；&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;数据&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;符号位&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;阶码&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;尾数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1位&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;8位&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;23位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;内存位&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;31&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;30-23&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;22-0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;double&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1位&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;11位&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;52位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;内存位&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;63&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;62-52&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;51-0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;其次，阶码使用中间偏置(固定量为2^N-1)的移码表示的,M的整数部分为1,不存储，只存储尾数即可。&lt;br&gt;例如，125.5f = &lt;code&gt;1111101.1&lt;/code&gt; = 1.1111011*2^6 =&amp;gt;移码127+6 = 133 = &lt;code&gt;10000101&lt;/code&gt; =&amp;gt;正数符号位是0，尾数补0到够23位,那么计算机中：&lt;code&gt;01000010 10000000 00000000 01111011&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;补充&quot;&gt;&lt;a href=&quot;#补充&quot; class=&quot;headerlink&quot; title=&quot;补充&quot;&gt;&lt;/a&gt;补充&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;整型常量默认情况下是int型,浮点常量在默认情况下是&lt;code&gt;double&lt;/code&gt;型,如果需要&lt;code&gt;float&lt;/code&gt;型，需要这样表示：&lt;code&gt;3.25f&lt;/code&gt;；&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;共用体&quot;&gt;&lt;a href=&quot;#共用体&quot; class=&quot;headerlink&quot; title=&quot;共用体&quot;&gt;&lt;/a&gt;共用体&lt;/h2&gt;&lt;p&gt;是一种数据格式，简单来说，在同一块内存地址，可以同时起不同数据类型的名字，用这些名字来取值时，名字所对应的数据类型告诉编译器怎么去解
    
    </summary>
    
      <category term="C++基础" scheme="http://rylcode.cn/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="共用体" scheme="http://rylcode.cn/tags/%E5%85%B1%E7%94%A8%E4%BD%93/"/>
    
      <category term="枚举" scheme="http://rylcode.cn/tags/%E6%9E%9A%E4%B8%BE/"/>
    
      <category term="浮点数存储" scheme="http://rylcode.cn/tags/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>string类与结构体</title>
    <link href="http://rylcode.cn/2016/04/21/string%E7%B1%BB%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>http://rylcode.cn/2016/04/21/string类与结构体/</id>
    <published>2016-04-21T02:36:21.000Z</published>
    <updated>2016-05-06T04:59:55.241Z</updated>
    
    <content type="html">&lt;h2 id=&quot;string类&quot;&gt;&lt;a href=&quot;#string类&quot; class=&quot;headerlink&quot; title=&quot;string类&quot;&gt;&lt;/a&gt;string类&lt;/h2&gt;&lt;h3 id=&quot;string运算符&quot;&gt;&lt;a href=&quot;#string运算符&quot; class=&quot;headerlink&quot; title=&quot;string运算符&quot;&gt;&lt;/a&gt;string运算符&lt;/h3&gt;&lt;p&gt;&lt;code&gt;string&lt;/code&gt;类的运算符重载在头文件&lt;code&gt;string&lt;/code&gt;里,如&lt;code&gt;+&lt;/code&gt;,&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;。注意&lt;code&gt;&amp;quot;a&amp;quot;+&amp;quot;b&amp;quot; = &amp;quot;ab&amp;quot;&lt;/code&gt;,&lt;code&gt;&amp;#39;a&amp;#39;+&amp;#39;b&amp;#39; = 195&lt;/code&gt;,前者是字符串拼接，后者是字符常量相加。但是&lt;code&gt;cout&amp;lt;&amp;lt;&amp;quot;a&amp;quot;+&amp;quot;b&amp;quot;;&lt;/code&gt;这个语句是错误的，必须至少声明两个&lt;code&gt;string&lt;/code&gt;类型。&lt;/p&gt;
&lt;h3 id=&quot;string-find&quot;&gt;&lt;a href=&quot;#string-find&quot; class=&quot;headerlink&quot; title=&quot;string.find()&quot;&gt;&lt;/a&gt;string.find()&lt;/h3&gt;&lt;p&gt;&lt;code&gt;string&lt;/code&gt;类的&lt;code&gt;find()&lt;/code&gt;方法，可以用于找子串，返回子串在原串出现的下标。&lt;a href=&quot;http://www.cnblogs.com/web100/archive/2012/12/02/cpp-string-find-npos.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;和&lt;a href=&quot;http://www.cplusplus.com/reference/string/string/find/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;有详细解释，使用时注意以下三点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接受三个参数，第一个是子串，第二个是开始寻找的下标，第三个参数是匹配字串的字符数。可以用于找全部的匹配子串；&lt;/li&gt;
&lt;li&gt;如果没有找到，返回值是&lt;code&gt;string::npos&lt;/code&gt;，他是一个很大的正数；&lt;/li&gt;
&lt;li&gt;返回值是&lt;code&gt;size_t&lt;/code&gt;，一般可用&lt;code&gt;auto&lt;/code&gt;来代替。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下代码可以输出全部的匹配位置：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;string s1 = &amp;quot;abcdbcgbcdbjjkklbcdbcdbcdghjbcd&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;string s2 = &amp;quot;bcd&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;auto k  = s1.find(s2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;while (k != string::npos)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	cout&amp;lt;&amp;lt;k&amp;lt;&amp;lt;endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	k = s1.find(s2,k+1);	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;string-substr&quot;&gt;&lt;a href=&quot;#string-substr&quot; class=&quot;headerlink&quot; title=&quot;string.substr()&quot;&gt;&lt;/a&gt;string.substr()&lt;/h3&gt;&lt;p&gt;函数声明如下：&lt;code&gt;_Myt substr(size_type _Off = 0, size_type _Count = npos) const&lt;/code&gt;，返回从指定位置(_Off)开始的长度为(_Count)的子字符串。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;结构体&quot;&gt;&lt;a href=&quot;#结构体&quot; class=&quot;headerlink&quot; title=&quot;结构体&quot;&gt;&lt;/a&gt;结构体&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;基本项，可以列表化，提倡外部结构声明，可以使用赋值运算符,列表初始化不允许缩窄转换。&lt;/li&gt;
&lt;li&gt;结构体对准：&lt;ul&gt;
&lt;li&gt;结构体首地址能被其最宽基本类型成员的大小所整除；&lt;/li&gt;
&lt;li&gt;结构体每个成员相对于结构体首地址的偏移量(offset)都是成员大小整数倍；&lt;/li&gt;
&lt;li&gt;结构体的总大小是结构体最宽基本类型成员大小的整数倍。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;与此相关还有栈对准，某些编译器(x64?)按大小对准，&lt;code&gt;char&lt;/code&gt;位于栈底，&lt;code&gt;double&lt;/code&gt;位于栈顶排列。找不到相关资料了，需要深入了解。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;示例：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//Definition for a binary tree node.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct TreeNode &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	TreeNode *left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	TreeNode *right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	TreeNode(int x) : val(x), left(NULL), right(NULL) &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;string类&quot;&gt;&lt;a href=&quot;#string类&quot; class=&quot;headerlink&quot; title=&quot;string类&quot;&gt;&lt;/a&gt;string类&lt;/h2&gt;&lt;h3 id=&quot;string运算符&quot;&gt;&lt;a href=&quot;#string运算符&quot; class=&quot;header
    
    </summary>
    
      <category term="C++基础" scheme="http://rylcode.cn/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="string.find()" scheme="http://rylcode.cn/tags/string-find/"/>
    
      <category term="结构体" scheme="http://rylcode.cn/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>cctype与进制数转化</title>
    <link href="http://rylcode.cn/2016/04/21/cctype%E4%B8%8E%E8%BF%9B%E5%88%B6%E6%95%B0%E8%BD%AC%E5%8C%96/"/>
    <id>http://rylcode.cn/2016/04/21/cctype与进制数转化/</id>
    <published>2016-04-21T01:16:59.000Z</published>
    <updated>2016-05-06T04:55:45.555Z</updated>
    
    <content type="html">&lt;h2 id=&quot;进制转化&quot;&gt;&lt;a href=&quot;#进制转化&quot; class=&quot;headerlink&quot; title=&quot;进制转化&quot;&gt;&lt;/a&gt;进制转化&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;控制符dec，hex，oct用于设置整数显式的进制数，分别对应十进制，16进制，八进制，语法：&lt;code&gt;cout&amp;lt;&amp;lt;dec;&lt;/code&gt;,&lt;code&gt;cout&amp;lt;&amp;lt;hex;&lt;/code&gt;,&lt;code&gt;cout&amp;lt;&amp;lt;oct&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;头文件&lt;code&gt;cstdlib&lt;/code&gt;中的&lt;code&gt;char *_itoa(int value,char string,int radix)&lt;/code&gt;可以设置任一进制的输出。&lt;ul&gt;
&lt;li&gt;参数一：要转换的数据；&lt;/li&gt;
&lt;li&gt;参数二：存放结果的字符串地址；&lt;/li&gt;
&lt;li&gt;参数三：进制数；&lt;/li&gt;
&lt;li&gt;返回值：指向结果字符串的指针。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;cctype&quot;&gt;&lt;a href=&quot;#cctype&quot; class=&quot;headerlink&quot; title=&quot;cctype&quot;&gt;&lt;/a&gt;cctype&lt;/h2&gt;&lt;p&gt;主要是&lt;code&gt;cctype&lt;/code&gt;头文件中的字符函数在编程过程中可以带来很多便利，常用的总结如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;isalpha()&lt;/code&gt;,&lt;code&gt;isdigit()&lt;/code&gt;,&lt;code&gt;isalnum()&lt;/code&gt;可以用于判断是字符、数字、字母或数字。返回&lt;code&gt;true&lt;/code&gt;或&lt;code&gt;false&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;islower()&lt;/code&gt;,&lt;code&gt;isupper()&lt;/code&gt;,&lt;code&gt;isprint()&lt;/code&gt;可以用于判断是小写字母、大写字符、可显示字符。返回&lt;code&gt;true&lt;/code&gt;或&lt;code&gt;false&lt;/code&gt;。&lt;a href=&quot;https://zh.wikipedia.org/wiki/ASCII#.E5.8F.AF.E6.98.BE.E7.A4.BA.E5.AD.97.E7.AC.A6&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;可显示字符&lt;/a&gt;从32到126一共95个。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tolower()&lt;/code&gt;,&lt;code&gt;toupper()&lt;/code&gt;用于大小写字母的转换，如果不需要转换，字符不变。&lt;/li&gt;
&lt;li&gt;另外一些不常用的字符函数,&lt;code&gt;isgraph()&lt;/code&gt;(除空格之外的打印字符),&lt;code&gt;ispunct()&lt;/code&gt;(标点符号),&lt;code&gt;isspace()&lt;/code&gt;(标准空白字符),&lt;code&gt;iscntrl()&lt;/code&gt;(控制字符),&lt;code&gt;isxdigit()&lt;/code&gt;(16进制,即1-9,a-f,A-F)。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进制转化&quot;&gt;&lt;a href=&quot;#进制转化&quot; class=&quot;headerlink&quot; title=&quot;进制转化&quot;&gt;&lt;/a&gt;进制转化&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;控制符dec，hex，oct用于设置整数显式的进制数，分别对应十进制，16进制，八进制，语法：&lt;code&gt;cou
    
    </summary>
    
      <category term="C++基础" scheme="http://rylcode.cn/categories/C-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="进制转化" scheme="http://rylcode.cn/tags/%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8C%96/"/>
    
      <category term="cctype" scheme="http://rylcode.cn/tags/cctype/"/>
    
  </entry>
  
</feed>
