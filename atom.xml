<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孤云两角，去天一握</title>
  <subtitle>山在地下，地山谦</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-05-03T09:15:05.890Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ryl</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BP、KMP、改进的KMP</title>
    <link href="http://yoursite.com/2016/05/03/BP%E3%80%81KMP%E3%80%81%E6%94%B9%E8%BF%9B%E7%9A%84KMP/"/>
    <id>http://yoursite.com/2016/05/03/BP、KMP、改进的KMP/</id>
    <published>2016-05-03T06:57:41.000Z</published>
    <updated>2016-05-03T09:15:05.890Z</updated>
    
    <content type="html">&lt;p&gt;在主串S中，自low位置开始，查找与模式串T相等的子串。如果这样的子串存在，返回其第一次出现的位置。本文详细介绍三种字符串匹配算法:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;BF(Brute-Force)算法(暴力破解);&lt;/li&gt;
&lt;li&gt;KMP算法;&lt;/li&gt;
&lt;li&gt;改进的KMP算法。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这三种算法的代码&lt;a href=&quot;https://github.com/applefishsky009/Interface/blob/master/BF%E5%92%8CKMP/BF%E5%92%8CKMP.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在这里&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;BF算法&quot;&gt;&lt;a href=&quot;#BF算法&quot; class=&quot;headerlink&quot; title=&quot;BF算法&quot;&gt;&lt;/a&gt;BF算法&lt;/h2&gt;&lt;p&gt;设主串从i位开始与子串(从0开始)判断是否匹配;到子串的j位置，对应主串的i+j位置失配;将主串左移一位(&lt;code&gt;i++&lt;/code&gt;),j回到0位继续匹配。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;KMP算法&quot;&gt;&lt;a href=&quot;#KMP算法&quot; class=&quot;headerlink&quot; title=&quot;KMP算法&quot;&gt;&lt;/a&gt;KMP算法&lt;/h2&gt;&lt;h3 id=&quot;为什么是next-j&quot;&gt;&lt;a href=&quot;#为什么是next-j&quot; class=&quot;headerlink&quot; title=&quot;为什么是next[j]&quot;&gt;&lt;/a&gt;为什么是next[j]&lt;/h3&gt;&lt;p&gt;每次失配将i右移一位显然是低效的。&lt;strong&gt;主观上来考虑，如果在失配之前子串有相等的真后缀，那么就可以右移更多的位。&lt;/strong&gt;考虑在i+j位失配时将主串左移k位(子串右移k位)，而不是一位。容易得到，这个k只与子串的性质有关。&lt;br&gt;我们使用next[j]来标识当j位失配时子串应向右移j-next[j]位。示例:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;code&gt;abcdefg&lt;/code&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;0 1 2 3 4 5 6&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;next[j]&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-1 0 0 0 0 0 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;offset&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1 1 2 3 4 5 6&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;code&gt;abcabcabc&lt;/code&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;0 1 2 3 4 5 6 7 8&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;next[j]&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-1 0 0 0 1 2 3 4 5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;offset&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1 1 2 3 3 3 3 3 3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;如何求得next-j&quot;&gt;&lt;a href=&quot;#如何求得next-j&quot; class=&quot;headerlink&quot; title=&quot;如何求得next[j]&quot;&gt;&lt;/a&gt;如何求得next[j]&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/qc2eynB.png&quot; alt=&quot;这里&quot;&gt;&lt;/p&gt;
&lt;p&gt;在计算公式中第二行指的是:j位&lt;strong&gt;以前&lt;/strong&gt;字串中真前后缀的最大&lt;strong&gt;公共&lt;/strong&gt;元素长度。真前缀、真后缀指的不包含串本身的子串。那么我们可以这样来计算j:&lt;br&gt;tempNext[j]表示j位及以前子串真前缀最大公共元素长度。将tempNext[j]右移一位，初值赋为-1,得到next[j]&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;code&gt;xyxyyxxyx&lt;/code&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;0 1 2 3 4 5 6 7 8&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;tempNext[j]&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0 0 1 2 0 1 1 2 3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;next[j]&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-1 0 0 1 2 0 1 1 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;offset&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1 1 2 2 2 5 5 6 6&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;tempNext[j]的计算:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//计算j位及之前真前缀以及真后缀的最大公共元素长度&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void calTempNext(vector&amp;lt;int&amp;gt;&amp;amp;next)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if (s2.size() == 1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	next[0] = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int k = 0;//前缀指针,j就是后缀指针&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	for (int j = 1;j &amp;lt; s2.size();j++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		while(k &amp;gt; 0 &amp;amp;&amp;amp; s2[j] != s2[k])//k位失配，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			k = next[k-1];//k-1是可靠匹配，next[k-1]记录了上一个真后缀出现的地方&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if (s2[j] == s2[k])//匹配，k++,j++，next[j]赋值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			k++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		next[j] = k;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;如何在编程中求得next-j&quot;&gt;&lt;a href=&quot;#如何在编程中求得next-j&quot; class=&quot;headerlink&quot; title=&quot;如何在编程中求得next[j]&quot;&gt;&lt;/a&gt;如何在编程中求得next[j]&lt;/h3&gt;&lt;p&gt;如果使用上述计算过程，先计算tempNext[j]再计算next[j]，需要两次遍历。将tempNext[j]右移初值赋-1的过程可以直接融入程序中，使用一次遍历就可以得到next[j]，&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//直接计算next(时间复杂度O(n))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void cal2Next(vector&amp;lt;int&amp;gt;&amp;amp;next)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int j = -1;		//j,偏移指针&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int i = 0;		//i,next下标（实际上是要计算的next下标-1,因为是先加后赋值）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	next[0] = -1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	while (i &amp;lt; s2.size()-1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if (j == -1 || s2[i]==s2[j])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			i++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			j++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			next[i] = j;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			j = next[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;改进的KMP算法&quot;&gt;&lt;a href=&quot;#改进的KMP算法&quot; class=&quot;headerlink&quot; title=&quot;改进的KMP算法&quot;&gt;&lt;/a&gt;改进的KMP算法&lt;/h2&gt;&lt;p&gt;next[j]值越小，模式匹配所需比较次数越少。next[j]的计算中先判断匹配，i,j自加再赋值。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若自加之后失配，这时候i失配并不代表j失配，因此留给下次循环回溯后来判断。&lt;/li&gt;
&lt;li&gt;若自加之后匹配，说明i与j位置完全等效，i失配，j一定失配。，而朴素的KMP算法在失配之后要一次一次回溯。因此可以&lt;font color=&quot;red&quot;&gt;一次回溯到底&lt;/font&gt;节约比较次数。&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;code&gt;abcaabbabcaac&lt;/code&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;0 1 2  3 4 5 6  7 8 9 10 11 12&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;next[j]&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-1 0 0  0 1 1 2  0 1 2  3  4  5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;offset1&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1 1 2  3 3 4 4  7 7 7  7  7  7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;nextVal[j]&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;-1 0 0 -1 1 0 2 -1 0 0 -1  1  5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;offset2&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1 1 2  4 3 5 4  8 8 9 11 10  7&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/28%20-%20Implement%20strStr()/28%20-%20Implement%20strStr().cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;LeetCode代码&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在主串S中，自low位置开始，查找与模式串T相等的子串。如果这样的子串存在，返回其第一次出现的位置。本文详细介绍三种字符串匹配算法:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;BF(Brute-Force)算法(暴力破解);&lt;/li&gt;
&lt;li&gt;KMP算法;&lt;/li&gt;
&lt;li&gt;改进的KMP算
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="字符串匹配" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>野指针与内存泄漏</title>
    <link href="http://yoursite.com/2016/04/25/%E9%87%8E%E6%8C%87%E9%92%88%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>http://yoursite.com/2016/04/25/野指针与内存泄漏/</id>
    <published>2016-04-25T01:36:10.000Z</published>
    <updated>2016-04-25T01:49:05.831Z</updated>
    
    <content type="html">&lt;p&gt;野指针和内存泄漏是两个相联系的概念，一般来讲指针&amp;lt;-&amp;gt;内存相互对应，如果有一个指针但没有指向任何内存，就是野指针；如果有一块未释放的内存，但没有指针指向他，就是内存泄露。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;野指针&quot;&gt;&lt;a href=&quot;#野指针&quot; class=&quot;headerlink&quot; title=&quot;野指针&quot;&gt;&lt;/a&gt;野指针&lt;/h2&gt;&lt;p&gt;野指针指向一个已删除对象或未申请访问受限内存区域的指针，一般来说野指针有三个成因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;指针变量未初始化；&lt;/li&gt;
&lt;li&gt;指针释放后未置空；&lt;/li&gt;
&lt;li&gt;指针操作超越变量作用域。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;值得注意的是，如果有多个指针指向同一块内存，释放其中一个指针后，应将包含这个指针在内的指向这一块内存的所有指针都置空，否则都会成为野指针。&lt;/p&gt;
&lt;h2 id=&quot;内存泄漏&quot;&gt;&lt;a href=&quot;#内存泄漏&quot; class=&quot;headerlink&quot; title=&quot;内存泄漏&quot;&gt;&lt;/a&gt;内存泄漏&lt;/h2&gt;&lt;p&gt;在某一块内存的生命周期内，指向它的指针全部指向别处时，用户无法访问，也无法申请到这一块内存。这就是内存泄露。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;野指针和内存泄漏是两个相联系的概念，一般来讲指针&amp;lt;-&amp;gt;内存相互对应，如果有一个指针但没有指向任何内存，就是野指针；如果有一块未释放的内存，但没有指针指向他，就是内存泄露。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;野指针&quot;&gt;&lt;a href=&quot;#野指针&quot; class=&quot;h
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="基本概念" scheme="http://yoursite.com/tags/%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>Git命令</title>
    <link href="http://yoursite.com/2016/04/23/Git%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2016/04/23/Git命令/</id>
    <published>2016-04-23T06:27:10.000Z</published>
    <updated>2016-04-23T06:37:10.733Z</updated>
    
    <content type="html">&lt;p&gt;初学git，记录当时的一些解决方法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/22132675&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;删除不想要的git历史&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/q/1010000000115900&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;删除版本库中的提交&lt;/a&gt;注意，他将HEAD指向某一个commit，之后的commit和文件都被擦除了，删除前做好备份……&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;初学git，记录当时的一些解决方法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/22132675&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;删除不想要的git历史&lt;/a&gt;&lt;/li&gt;
&lt;li
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://yoursite.com/2016/04/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2016/04/22/动态规划/</id>
    <published>2016-04-22T09:07:05.000Z</published>
    <updated>2016-04-25T09:29:39.604Z</updated>
    
    <content type="html">&lt;p&gt;持续更新，记录在编程过程中关于动态规划的心得体会。算法分析以算法导论为主。主要是用于求解最优化问题，不同于递归用于解决互不相交的子问题，动态规划应用于子问题重叠的情况。在实际应用中发现他有两个关键点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;子问题的状态转移方程；&lt;/li&gt;
&lt;li&gt;保存子问题的解用于递归;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;它有两种等价的实现方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;带备忘的自顶向下；&lt;/li&gt;
&lt;li&gt;自底向上。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般来说自底向上更容易实现。实际中哪一种更容易编程取决于具体问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/120%20-%20Triangle/120%20-%20Triangle.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;triangle&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;持续更新，记录在编程过程中关于动态规划的心得体会。算法分析以算法导论为主。主要是用于求解最优化问题，不同于递归用于解决互不相交的子问题，动态规划应用于子问题重叠的情况。在实际应用中发现他有两个关键点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;子问题的状态转移方程；&lt;/li&gt;
&lt;li&gt;保存
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="动规" scheme="http://yoursite.com/tags/%E5%8A%A8%E8%A7%84/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法</title>
    <link href="http://yoursite.com/2016/04/22/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2016/04/22/贪心算法/</id>
    <published>2016-04-22T07:54:31.000Z</published>
    <updated>2016-04-25T09:19:56.952Z</updated>
    
    <content type="html">&lt;p&gt;持续更新，记录在编程过程中关于贪心算法的心得体会。算法分析以算法导论为主。求解最优化问题比动态规划更为简洁高效。其思想核心是&lt;font color=&quot;red&quot;&gt;选择当前最优解&lt;/font&gt;，虽然不一定是全局最优解。贪心算法主要应用有&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;活动选择问题&lt;/li&gt;
&lt;li&gt;霍夫曼编码&lt;/li&gt;
&lt;li&gt;最小生成树&lt;/li&gt;
&lt;li&gt;单元最短路径的Dijkstra算法&lt;/li&gt;
&lt;li&gt;集合覆盖问题的贪心启发式算法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;贪心算法的形式一般有&lt;strong&gt;递归贪心算法&lt;/strong&gt;，&lt;strong&gt;迭代贪心算法&lt;/strong&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;活动选择问题&quot;&gt;&lt;a href=&quot;#活动选择问题&quot; class=&quot;headerlink&quot; title=&quot;活动选择问题&quot;&gt;&lt;/a&gt;活动选择问题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;调度竞争共享资源的多个活动问题，选出最大的互相兼容的活动集合；&lt;ul&gt;
&lt;li&gt;选择一个活动，选出他后剩下的资源能尽量多的被其他任务所用(算法导论16.1)；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LeetCode跳跃游戏；&lt;ul&gt;
&lt;li&gt;Jump Game,选择当前最优解,更新当前最优解。&lt;/li&gt;
&lt;li&gt;Jump GameⅡ, 在选择当前最优解的时候统计步数(层数，是一层一一层映射的关系，怎么感觉是在广搜？!)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;持续更新，记录在编程过程中关于贪心算法的心得体会。算法分析以算法导论为主。求解最优化问题比动态规划更为简洁高效。其思想核心是&lt;font color=&quot;red&quot;&gt;选择当前最优解&lt;/font&gt;，虽然不一定是全局最优解。贪心算法主要应用有&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;活动选择问题&lt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="贪心" scheme="http://yoursite.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>函数参数的传递</title>
    <link href="http://yoursite.com/2016/04/22/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92/"/>
    <id>http://yoursite.com/2016/04/22/函数参数的传递/</id>
    <published>2016-04-22T01:42:40.000Z</published>
    <updated>2016-04-25T01:54:06.846Z</updated>
    
    <content type="html">&lt;p&gt;函数参数的传递有三种，按值传递，按址传递，按引用传递(C++新增)。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h2&gt;&lt;h3 id=&quot;引用的本质&quot;&gt;&lt;a href=&quot;#引用的本质&quot; class=&quot;headerlink&quot; title=&quot;引用的本质&quot;&gt;&lt;/a&gt;引用的本质&lt;/h3&gt;&lt;p&gt;C++将&lt;code&gt;&amp;amp;&lt;/code&gt;符号赋予了另一个含义，用来声明引用。引用是已定义变量的别名(同一块内存)。引用的主要作用是用作函数形参。&lt;br&gt;引用的本质是&lt;font color=&quot;red&quot;&gt;指针常量&lt;/font&gt;，例如&lt;code&gt;int &amp;amp;pr = rats;&lt;/code&gt;是&lt;code&gt;int* const pr = &amp;amp;rats;&lt;/code&gt;的伪装。它的含义是他是一个指针，指向一个常量地址。因此他有以下特性也就很好理解了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;必须在声明引用是将其初始化；(因为指向常量地址)&lt;/li&gt;
&lt;li&gt;初始化时，省略了取地址符的操作&lt;code&gt;&amp;amp;&lt;/code&gt;,给我们感觉是别名；&lt;/li&gt;
&lt;li&gt;声明引用时，隐藏了对指针常量的自动间接引用，让我们看不到指针。&lt;/li&gt;
&lt;li&gt;使用引用时，隐藏了解除引用&lt;code&gt;*&lt;/code&gt;,让我们觉得是在直接修改(别名)变量。&lt;br&gt;如下：&lt;img src=&quot;http://i.imgur.com/idRXQZy.png&quot; alt=&quot;这里&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;返回引用&quot;&gt;&lt;a href=&quot;#返回引用&quot; class=&quot;headerlink&quot; title=&quot;返回引用&quot;&gt;&lt;/a&gt;返回引用&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;返回引用比传统返回机制烧了拷贝复制，效率更高。&lt;/li&gt;
&lt;li&gt;返回引用本质是返回“别名”,因此要注意保证返回后这个内存依然存在。(变量持续性)&lt;/li&gt;
&lt;li&gt;返回类型&lt;strong&gt;一般&lt;/strong&gt;用&lt;font color=&quot;red&quot;&gt;&lt;code&gt;const&lt;/code&gt;标识&lt;/font&gt;，将其设置为不可修改的左值，避免数据损失。&lt;ul&gt;
&lt;li&gt;赋值语句，左边必须是可修改的左值；&lt;/li&gt;
&lt;li&gt;常规返回类型是右值(因为其位于临时内存单元)-&amp;gt;不能通过地址访问。(可以出现在表达式右边，但不能出现在左边，如字面值&lt;code&gt;10.0&lt;/code&gt;,表达式&lt;code&gt;x+y&lt;/code&gt;) &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果返回局部变量(运算符重载中)，不能返回引用。&lt;/p&gt;
&lt;h3 id=&quot;C-C-中的左值和右值&quot;&gt;&lt;a href=&quot;#C-C-中的左值和右值&quot; class=&quot;headerlink&quot; title=&quot;C/C++中的左值和右值&quot;&gt;&lt;/a&gt;C/C++中的左值和右值&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;左值是一个引用到对象的表达式，因此可以取址(可以赋值)；&lt;/li&gt;
&lt;li&gt;右值强调的不是表达式本身，而是该表达式运算后的结果。这个结果往往并不引用到某一对象，可以看成计算的中间结果(临时内存单元)；（当然它也可能引用到某一对象，但是通过该右值表达式我们不能直接修改该对象—）。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;按值传递&quot;&gt;&lt;a href=&quot;#按值传递&quot; class=&quot;headerlink&quot; title=&quot;按值传递&quot;&gt;&lt;/a&gt;按值传递&lt;/h2&gt;&lt;p&gt;C++将数值参数传递给函数，函数将其赋给一个新的变量，新变量与旧变量在赋值之后没有任何关系。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;按址传递&quot;&gt;&lt;a href=&quot;#按址传递&quot; class=&quot;headerlink&quot; title=&quot;按址传递&quot;&gt;&lt;/a&gt;按址传递&lt;/h2&gt;&lt;p&gt;C++将参数地址传递给函数，函数原型用指针(一般用&lt;code&gt;const&lt;/code&gt;修饰表示指针不会乱指)指向这个地址&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;数组传递&quot;&gt;&lt;a href=&quot;#数组传递&quot; class=&quot;headerlink&quot; title=&quot;数组传递&quot;&gt;&lt;/a&gt;数组传递&lt;/h2&gt;&lt;p&gt;数组在传递时，编译器将数组名解释为第一个元素的地址，因此传递实参为数组时，形参应该是一个指针指向这个地址。&lt;br&gt;在用多维数组名作为形参时，可以指定所有维数的大小，也可以省略第一位的大小(高维大小必须指定)，这与编译器寻址有关，比如&lt;code&gt;int p[m][n]&lt;/code&gt;如果要取&lt;code&gt;p[i][j]&lt;/code&gt;的值，编译器会计算地址为&lt;code&gt;p+i*n+j;&lt;/code&gt;，因此编译器可以不知道m的值，但必须知道n的值。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;函数参数的传递有三种，按值传递，按址传递，按引用传递(C++新增)。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h2&gt;&lt;h3 id=&quot;引用的本质&quot;&gt;&lt;a href=&quot;#引
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="函数" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>BFS和DFS</title>
    <link href="http://yoursite.com/2016/04/21/BFS%E5%92%8CDFS/"/>
    <id>http://yoursite.com/2016/04/21/BFS和DFS/</id>
    <published>2016-04-21T07:28:51.000Z</published>
    <updated>2016-04-22T09:04:32.439Z</updated>
    
    <content type="html">&lt;p&gt;持续更新,该贴记录一些BFS和DFS在使用过程中的心得体会，以加深对BFS与DFS的理解。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;BFS-广度优先搜索&quot;&gt;&lt;a href=&quot;#BFS-广度优先搜索&quot; class=&quot;headerlink&quot; title=&quot;BFS(广度优先搜索)&quot;&gt;&lt;/a&gt;BFS(广度优先搜索)&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;BFS需要借助一个队列来记录遍历的”层数”；每遍历目标集合一次，&lt;strong&gt;步长&lt;/strong&gt;加一；队列为空，结束搜寻。分析见&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/127%20-%20World%20Ladder/127%20-%20World%20Ladder.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;DFS-深度优先搜索&quot;&gt;&lt;a href=&quot;#DFS-深度优先搜索&quot; class=&quot;headerlink&quot; title=&quot;DFS(深度优先搜索)&quot;&gt;&lt;/a&gt;DFS(深度优先搜索)&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;DFS需要用递归或者借助栈来&lt;strong&gt;记录&lt;/strong&gt;走过的路径；每遍历完这条分支，便要回溯到上一层；在递归之前可以记录深度。分析见&lt;a href=&quot;https://github.com/applefishsky009/LeetCode/blob/master/131%20-%20Palindrome%20Partitioning/131%20-%20Palindrome%20Partitioning.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;持续更新,该贴记录一些BFS和DFS在使用过程中的心得体会，以加深对BFS与DFS的理解。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;BFS-广度优先搜索&quot;&gt;&lt;a href=&quot;#BFS-广度优先搜索&quot; class=&quot;headerlink&quot; title=&quot;BFS(广度优先搜索)&quot;&gt;&lt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://yoursite.com/categories/Algorithms/"/>
    
    
      <category term="搜索" scheme="http://yoursite.com/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>共用体、枚举和浮点数存储</title>
    <link href="http://yoursite.com/2016/04/21/%E5%85%B1%E7%94%A8%E4%BD%93%E3%80%81%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B5%AE%E7%82%B9%E6%95%B0%E5%AD%98%E5%82%A8/"/>
    <id>http://yoursite.com/2016/04/21/共用体、枚举和浮点数存储/</id>
    <published>2016-04-21T02:38:14.000Z</published>
    <updated>2016-04-21T09:48:36.335Z</updated>
    
    <content type="html">&lt;h2 id=&quot;共用体&quot;&gt;&lt;a href=&quot;#共用体&quot; class=&quot;headerlink&quot; title=&quot;共用体&quot;&gt;&lt;/a&gt;共用体&lt;/h2&gt;&lt;p&gt;是一种数据格式，简单来说，在同一块内存地址，可以同时起不同数据类型的名字，用这些名字来取值时，名字所对应的数据类型告诉编译器怎么去解释内存中的数据。他的特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它的长度是最大数据类型长度，可以节省空间；&lt;/li&gt;
&lt;li&gt;数据不共存；&lt;/li&gt;
&lt;li&gt;关键字&lt;code&gt;union&lt;/code&gt;，声明方式与结构体相同；&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;枚举&quot;&gt;&lt;a href=&quot;#枚举&quot; class=&quot;headerlink&quot; title=&quot;枚举&quot;&gt;&lt;/a&gt;枚举&lt;/h2&gt;&lt;p&gt;创建符号常量的方式，简单来说就是将一个“标签”与枚举量对应起来。特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以提升(常到&lt;code&gt;int&lt;/code&gt;)，但&lt;code&gt;int&lt;/code&gt;不能缩窄到它；&lt;/li&gt;
&lt;li&gt;可以显式设置枚举量，枚举范围内即使没有枚举量，也合法；&lt;/li&gt;
&lt;li&gt;关键词&lt;code&gt;enum&lt;/code&gt;，声明方式与结构体相似；&lt;/li&gt;
&lt;li&gt;他没有算术运算，一般常用于&lt;code&gt;swith&lt;/code&gt;语句中的标签。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;浮点数存储方式&quot;&gt;&lt;a href=&quot;#浮点数存储方式&quot; class=&quot;headerlink&quot; title=&quot;浮点数存储方式&quot;&gt;&lt;/a&gt;浮点数存储方式&lt;/h2&gt;&lt;p&gt;不管是什么数据类型，在内存中的表示方式都是一样的(0或者1)，数据类型的作用只是告诉编译器如何去解释内存中的数据，那么编译器是如何解释浮点型的？&lt;br&gt;首先，二进制科学法表示中，一个浮点型S = M*2^N，内存会存储三部分：符号位+阶码(N)+尾数(M)；&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;数据&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;符号位&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;阶码&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;尾数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1位&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;8位&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;23位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;内存位&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;31&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;30-23&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;22-0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;double&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1位&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;11位&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;52位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;内存位&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;63&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;62-52&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;51-0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;其次，阶码使用中间偏置(固定量为2^N-1)的移码表示的,M的整数部分为1,不存储，只存储尾数即可。&lt;br&gt;例如，125.5f = &lt;code&gt;1111101.1&lt;/code&gt; = 1.1111011*2^6 =&amp;gt;移码127+6 = 133 = &lt;code&gt;10000101&lt;/code&gt; =&amp;gt;正数符号位是0，尾数补0到够23位,那么计算机中：&lt;code&gt;01000010 10000000 00000000 01111011&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;补充&quot;&gt;&lt;a href=&quot;#补充&quot; class=&quot;headerlink&quot; title=&quot;补充&quot;&gt;&lt;/a&gt;补充&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;整型常量默认情况下是int型,浮点常量在默认情况下是&lt;code&gt;double&lt;/code&gt;型,如果需要&lt;code&gt;float&lt;/code&gt;型，需要这样表示：&lt;code&gt;3.25f&lt;/code&gt;；&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;共用体&quot;&gt;&lt;a href=&quot;#共用体&quot; class=&quot;headerlink&quot; title=&quot;共用体&quot;&gt;&lt;/a&gt;共用体&lt;/h2&gt;&lt;p&gt;是一种数据格式，简单来说，在同一块内存地址，可以同时起不同数据类型的名字，用这些名字来取值时，名字所对应的数据类型告诉编译器怎么去解
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="数据类型" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>string类与结构体</title>
    <link href="http://yoursite.com/2016/04/21/string%E7%B1%BB%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>http://yoursite.com/2016/04/21/string类与结构体/</id>
    <published>2016-04-21T02:36:21.000Z</published>
    <updated>2016-04-21T09:44:57.462Z</updated>
    
    <content type="html">&lt;h2 id=&quot;string类&quot;&gt;&lt;a href=&quot;#string类&quot; class=&quot;headerlink&quot; title=&quot;string类&quot;&gt;&lt;/a&gt;string类&lt;/h2&gt;&lt;h3 id=&quot;string运算符&quot;&gt;&lt;a href=&quot;#string运算符&quot; class=&quot;headerlink&quot; title=&quot;string运算符&quot;&gt;&lt;/a&gt;string运算符&lt;/h3&gt;&lt;p&gt;&lt;code&gt;string&lt;/code&gt;类的运算符重载在头文件&lt;code&gt;string&lt;/code&gt;里,如&lt;code&gt;+&lt;/code&gt;,&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;。注意&lt;code&gt;&amp;quot;a&amp;quot;+&amp;quot;b&amp;quot; = &amp;quot;ab&amp;quot;&lt;/code&gt;,&lt;code&gt;&amp;#39;a&amp;#39;+&amp;#39;b&amp;#39; = 195&lt;/code&gt;,前者是字符串拼接，后者是字符常量相加。但是&lt;code&gt;cout&amp;lt;&amp;lt;&amp;quot;a&amp;quot;+&amp;quot;b&amp;quot;;&lt;/code&gt;这个语句是错误的，必须至少声明两个&lt;code&gt;string&lt;/code&gt;类型。&lt;/p&gt;
&lt;h3 id=&quot;string-find&quot;&gt;&lt;a href=&quot;#string-find&quot; class=&quot;headerlink&quot; title=&quot;string.find()&quot;&gt;&lt;/a&gt;string.find()&lt;/h3&gt;&lt;p&gt;&lt;code&gt;string&lt;/code&gt;类的&lt;code&gt;find()&lt;/code&gt;方法，可以用于找子串，返回子串在原串出现的下标。&lt;a href=&quot;http://www.cnblogs.com/web100/archive/2012/12/02/cpp-string-find-npos.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;和&lt;a href=&quot;http://www.cplusplus.com/reference/string/string/find/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;有详细解释，使用时注意以下三点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接受三个参数，第一个是子串，第二个是开始寻找的下标，第三个参数是匹配字串的字符数。可以用于找全部的匹配子串；&lt;/li&gt;
&lt;li&gt;如果没有找到，返回值是&lt;code&gt;string::npos&lt;/code&gt;，他是一个很大的正数；&lt;/li&gt;
&lt;li&gt;返回值是&lt;code&gt;size_t&lt;/code&gt;，一般可用&lt;code&gt;auto&lt;/code&gt;来代替。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下代码可以输出全部的匹配位置：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;string s1 = &amp;quot;abcdbcgbcdbjjkklbcdbcdbcdghjbcd&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;string s2 = &amp;quot;bcd&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;auto k  = s1.find(s2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;while (k != string::npos)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	cout&amp;lt;&amp;lt;k&amp;lt;&amp;lt;endl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	k = s1.find(s2,k+1);	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;string-substr&quot;&gt;&lt;a href=&quot;#string-substr&quot; class=&quot;headerlink&quot; title=&quot;string.substr()&quot;&gt;&lt;/a&gt;string.substr()&lt;/h3&gt;&lt;p&gt;函数声明如下：&lt;code&gt;_Myt substr(size_type _Off = 0, size_type _Count = npos) const&lt;/code&gt;，返回从指定位置(_Off)开始的长度为(_Count)的子字符串。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;结构体&quot;&gt;&lt;a href=&quot;#结构体&quot; class=&quot;headerlink&quot; title=&quot;结构体&quot;&gt;&lt;/a&gt;结构体&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;基本项，可以列表化，提倡外部结构声明，可以使用赋值运算符。&lt;/li&gt;
&lt;li&gt;结构体对准：&lt;ul&gt;
&lt;li&gt;结构体首地址能被其最宽基本类型成员的大小所整除；&lt;/li&gt;
&lt;li&gt;结构体每个成员相对于结构体首地址的偏移量(offset)都是成员大小整数倍；&lt;/li&gt;
&lt;li&gt;结构体的总大小是结构体最宽基本类型成员大小的整数倍。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;与此相关还有栈对准，某些编译器(x64?)按大小对准，&lt;code&gt;char&lt;/code&gt;位于栈底，&lt;code&gt;double&lt;/code&gt;位于栈顶排列。找不到相关资料了，需要深入了解。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;string类&quot;&gt;&lt;a href=&quot;#string类&quot; class=&quot;headerlink&quot; title=&quot;string类&quot;&gt;&lt;/a&gt;string类&lt;/h2&gt;&lt;h3 id=&quot;string运算符&quot;&gt;&lt;a href=&quot;#string运算符&quot; class=&quot;header
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="数据类型" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="存储" scheme="http://yoursite.com/tags/%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>cctype与进制数转化</title>
    <link href="http://yoursite.com/2016/04/21/cctype%E4%B8%8E%E8%BF%9B%E5%88%B6%E6%95%B0%E8%BD%AC%E5%8C%96/"/>
    <id>http://yoursite.com/2016/04/21/cctype与进制数转化/</id>
    <published>2016-04-21T01:16:59.000Z</published>
    <updated>2016-04-25T01:34:12.549Z</updated>
    
    <content type="html">&lt;h2 id=&quot;进制转化&quot;&gt;&lt;a href=&quot;#进制转化&quot; class=&quot;headerlink&quot; title=&quot;进制转化&quot;&gt;&lt;/a&gt;进制转化&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;控制符dec，hex，oct用于设置整数显式的进制数，分别对应十进制，16进制，八进制，语法：&lt;code&gt;cout&amp;lt;&amp;lt;dec;&lt;/code&gt;,&lt;code&gt;cout&amp;lt;&amp;lt;hex;&lt;/code&gt;,&lt;code&gt;cout&amp;lt;&amp;lt;oct&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;头文件&lt;code&gt;cstdlib&lt;/code&gt;中的&lt;code&gt;char *_itoa(int value,char string,int radix)&lt;/code&gt;可以设置任一进制的输出。&lt;ul&gt;
&lt;li&gt;参数一：要转换的数据；&lt;/li&gt;
&lt;li&gt;参数二：存放结果的字符串地址；&lt;/li&gt;
&lt;li&gt;参数三：进制数；&lt;/li&gt;
&lt;li&gt;返回值：指向结果字符串的指针。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;cctype&quot;&gt;&lt;a href=&quot;#cctype&quot; class=&quot;headerlink&quot; title=&quot;cctype&quot;&gt;&lt;/a&gt;cctype&lt;/h2&gt;&lt;p&gt;主要是&lt;code&gt;cctype&lt;/code&gt;头文件中的字符函数在编程过程中可以带来很多便利，常用的总结如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;isalpha()&lt;/code&gt;,&lt;code&gt;isdigit()&lt;/code&gt;,&lt;code&gt;isalnum()&lt;/code&gt;可以用于判断是字符、数字、字母或数字。返回&lt;code&gt;true&lt;/code&gt;或&lt;code&gt;false&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;islower()&lt;/code&gt;,&lt;code&gt;isupper()&lt;/code&gt;,&lt;code&gt;isprint()&lt;/code&gt;可以用于判断是小写字母、大写字符、可显示字符。返回&lt;code&gt;true&lt;/code&gt;或&lt;code&gt;false&lt;/code&gt;。&lt;a href=&quot;https://zh.wikipedia.org/wiki/ASCII#.E5.8F.AF.E6.98.BE.E7.A4.BA.E5.AD.97.E7.AC.A6&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;可显示字符&lt;/a&gt;从32到126一共95个。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tolower()&lt;/code&gt;,&lt;code&gt;toupper()&lt;/code&gt;用于大小写字母的转换，如果不需要转换，字符不变。&lt;/li&gt;
&lt;li&gt;另外一些不常用的字符函数,&lt;code&gt;isgraph()&lt;/code&gt;(除空格之外的打印字符),&lt;code&gt;ispunct()&lt;/code&gt;(标点符号),&lt;code&gt;isspace()&lt;/code&gt;(标准空白字符),&lt;code&gt;iscntrl()&lt;/code&gt;(控制字符),&lt;code&gt;isxdigit()&lt;/code&gt;(16进制,即1-9,a-f,A-F)。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进制转化&quot;&gt;&lt;a href=&quot;#进制转化&quot; class=&quot;headerlink&quot; title=&quot;进制转化&quot;&gt;&lt;/a&gt;进制转化&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;控制符dec，hex，oct用于设置整数显式的进制数，分别对应十进制，16进制，八进制，语法：&lt;code&gt;cou
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="cctype" scheme="http://yoursite.com/tags/cctype/"/>
    
      <category term="进制" scheme="http://yoursite.com/tags/%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>类型转换</title>
    <link href="http://yoursite.com/2016/04/20/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2016/04/20/类型转换/</id>
    <published>2016-04-20T02:53:34.000Z</published>
    <updated>2016-04-21T04:24:52.513Z</updated>
    
    <content type="html">&lt;p&gt;C++自动执行以下类型转换：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不同算术类型的赋值；&lt;/li&gt;
&lt;li&gt;包含不同类型的表达式；&lt;/li&gt;
&lt;li&gt;函数调用&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;初始化和赋值进行的转换&quot;&gt;&lt;a href=&quot;#初始化和赋值进行的转换&quot; class=&quot;headerlink&quot; title=&quot;初始化和赋值进行的转换&quot;&gt;&lt;/a&gt;初始化和赋值进行的转换&lt;/h2&gt;&lt;p&gt;扩展没有问题；缩窄可能会有一些问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;精度降低(double-&amp;gt;float等);&lt;/li&gt;
&lt;li&gt;数字截短(float-&amp;gt;int等);&lt;/li&gt;
&lt;li&gt;数据丢失(long-&amp;gt;short等)。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;列表初始化时的转换&quot;&gt;&lt;a href=&quot;#列表初始化时的转换&quot; class=&quot;headerlink&quot; title=&quot;列表初始化时的转换&quot;&gt;&lt;/a&gt;列表初始化时的转换&lt;/h2&gt;&lt;p&gt;不允许缩窄。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;表达式的转换&quot;&gt;&lt;a href=&quot;#表达式的转换&quot; class=&quot;headerlink&quot; title=&quot;表达式的转换&quot;&gt;&lt;/a&gt;表达式的转换&lt;/h2&gt;&lt;h3 id=&quot;自动转化&quot;&gt;&lt;a href=&quot;#自动转化&quot; class=&quot;headerlink&quot; title=&quot;自动转化&quot;&gt;&lt;/a&gt;自动转化&lt;/h3&gt;&lt;p&gt;&lt;code&gt;int&lt;/code&gt;型是计算机最自然的语言，运算速度最快。整型提升(integral promotion)规则如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算表达式时，C++将&lt;code&gt;bool&lt;/code&gt;，&lt;code&gt;char&lt;/code&gt;，&lt;code&gt;unsigned char&lt;/code&gt;，&lt;code&gt;signed char&lt;/code&gt;，&lt;code&gt;short&lt;/code&gt;都转换为&lt;code&gt;int&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;short&lt;/code&gt;和&lt;code&gt;int&lt;/code&gt;一样长，&lt;code&gt;unsigned short&lt;/code&gt;转换为&lt;code&gt;unsigned int&lt;/code&gt;，如果&lt;code&gt;short&lt;/code&gt;比&lt;code&gt;int&lt;/code&gt;短，&lt;code&gt;unsigned short&lt;/code&gt;转换为&lt;code&gt;int&lt;/code&gt;。总之，以不损失数据为原则。&lt;/li&gt;
&lt;li&gt;在不损失数据的原则下，同级别有符号数比无符号数优先。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;算术运算的转化&quot;&gt;&lt;a href=&quot;#算术运算的转化&quot; class=&quot;headerlink&quot; title=&quot;算术运算的转化&quot;&gt;&lt;/a&gt;算术运算的转化&lt;/h3&gt;&lt;p&gt;将较小的类型转换成较大的类型。依次判断long double?-&amp;gt;double?-&amp;gt;float?-&amp;gt;integral promotion!可以看到浮点型优先于整型。具体过程可以查看C++11版本的效验表。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;传递参数时的转换&quot;&gt;&lt;a href=&quot;#传递参数时的转换&quot; class=&quot;headerlink&quot; title=&quot;传递参数时的转换&quot;&gt;&lt;/a&gt;传递参数时的转换&lt;/h2&gt;&lt;p&gt;由C++函数原型控制，若取消函数原型的控制:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将对&lt;code&gt;char&lt;/code&gt;和&lt;code&gt;short&lt;/code&gt;整型提升;&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;float&lt;/code&gt;参数提升为&lt;code&gt;double&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;强制类型转换&quot;&gt;&lt;a href=&quot;#强制类型转换&quot; class=&quot;headerlink&quot; title=&quot;强制类型转换&quot;&gt;&lt;/a&gt;强制类型转换&lt;/h2&gt;&lt;p&gt;C++设计新格式，让强制类型转换像函数一样调用:&lt;code&gt;typename (value)&lt;/code&gt;更严格的限制允许的类型转换，以下4个类型转换符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dynamic_cast&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const_cast&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static_cast&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reinterpret_cast&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相关：因为指针大小固定(指针的本质是一个存放地址的内存，32位编译器是4字节),任意指针之间可以进行强制转化。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;C++自动执行以下类型转换：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不同算术类型的赋值；&lt;/li&gt;
&lt;li&gt;包含不同类型的表达式；&lt;/li&gt;
&lt;li&gt;函数调用&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;初始化和赋值进行的转换&quot;&gt;&lt;a href=&quot;#初始化和赋值进行的转换&quot; cla
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="类型转换" scheme="http://yoursite.com/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>栈与字符型变量的地址</title>
    <link href="http://yoursite.com/2016/04/20/%E6%A0%88%E4%B8%8E%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%9C%B0%E5%9D%80/"/>
    <id>http://yoursite.com/2016/04/20/栈与字符型变量的地址/</id>
    <published>2016-04-20T01:15:59.000Z</published>
    <updated>2016-04-20T02:44:11.001Z</updated>
    
    <content type="html">&lt;h2 id=&quot;栈的存储机制&quot;&gt;&lt;a href=&quot;#栈的存储机制&quot; class=&quot;headerlink&quot; title=&quot;栈的存储机制&quot;&gt;&lt;/a&gt;栈的存储机制&lt;/h2&gt;&lt;p&gt;在之前的内存存储区之中讲过栈，他大概有以下特点：编译器自助管理；空间大小指定；不会产生碎片；向下生长；静态(主要)或动态(不需要人工释放)分配；效率高。这里以下边的语句为例说明栈的存储：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int main()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int a[4] = &amp;#123;1,2,3,4&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int b[4] = &amp;#123;5,6,7,8&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int c[4] = &amp;#123;9,10,11,12&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/r0E1t24.jpg&quot; alt=&quot;栈&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数组名称是一个指针，指向数组的第一个元素；&lt;/li&gt;
&lt;li&gt;a[-2]指的是a指针向栈的地址低位移动2个数据元素大小(例子中是int型)，即访问到b[2]，&lt;strong&gt;但是&lt;/strong&gt;实际情况与编译器相关，他会做一些对准或者优化，明白访问原理即可；&lt;/li&gt;
&lt;li&gt;每一个元素在栈中的字节序是Little Endian，即低位字节排放在地址的低地址端，高位字节排放在地址的高地址端。与之对应的还有Big Endian，排放次序相反。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;字符型变量的地址&quot;&gt;&lt;a href=&quot;#字符型变量的地址&quot; class=&quot;headerlink&quot; title=&quot;字符型变量的地址&quot;&gt;&lt;/a&gt;字符型变量的地址&lt;/h2&gt;&lt;p&gt;字符型变量&lt;code&gt;char c&lt;/code&gt;的地址不能用&lt;code&gt;cout&amp;lt;&amp;lt;&amp;amp;c；&lt;/code&gt;来表示，因为&lt;code&gt;&amp;amp;c&lt;/code&gt;实际上是一个&lt;code&gt;char *&lt;/code&gt;型的变量，它输出字符串的值，而字符串只有在内存中读到&lt;code&gt;\0&lt;/code&gt;才会终止，因此会出现乱码。所以要输出字符变量的地址，应该用以下语句告诉编译器如何解释：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;(int *)&amp;amp;c&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(static_cast&amp;lt;void *&amp;gt;(&amp;amp;jc)&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上述的&lt;code&gt;static_cast&lt;/code&gt;用于显式类型转换。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;栈的存储机制&quot;&gt;&lt;a href=&quot;#栈的存储机制&quot; class=&quot;headerlink&quot; title=&quot;栈的存储机制&quot;&gt;&lt;/a&gt;栈的存储机制&lt;/h2&gt;&lt;p&gt;在之前的内存存储区之中讲过栈，他大概有以下特点：编译器自助管理；空间大小指定；不会产生碎片；向下生长；静态(
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="存储" scheme="http://yoursite.com/tags/%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>unordered_set简介</title>
    <link href="http://yoursite.com/2016/04/19/unordered_set%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2016/04/19/unordered_set简介/</id>
    <published>2016-04-19T11:42:25.000Z</published>
    <updated>2016-04-19T12:54:21.229Z</updated>
    
    <content type="html">&lt;h2 id=&quot;unordered-set简介&quot;&gt;&lt;a href=&quot;#unordered-set简介&quot; class=&quot;headerlink&quot; title=&quot;unordered_set简介&quot;&gt;&lt;/a&gt;unordered_set简介&lt;/h2&gt;&lt;p&gt;MSDN上有对&lt;a href=&quot;https://msdn.microsoft.com/zh-cn/library/bb982739.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;unordered_set&lt;/a&gt;描述，CSDN上有博客对&lt;a href=&quot;http://blog.csdn.net/oabid/article/details/4562577&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;unordered_set&lt;/a&gt;描述，这是一个哈希表。一般来说，一些简单功能可以当做STL里的容器来用：&lt;code&gt;insert()&lt;/code&gt;、&lt;font color=&quot;red&quot;&gt;&lt;code&gt;find()&lt;/code&gt;&lt;/font&gt;、&lt;code&gt;erase()&lt;/code&gt;、&lt;code&gt;size()&lt;/code&gt;、&lt;code&gt;empty()&lt;/code&gt;、&lt;code&gt;begin()&lt;/code&gt;、&lt;code&gt;end()&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;unordered-set与STL的异同&quot;&gt;&lt;a href=&quot;#unordered-set与STL的异同&quot; class=&quot;headerlink&quot; title=&quot;unordered_set与STL的异同&quot;&gt;&lt;/a&gt;unordered_set与STL的异同&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;_Pairib insert(const value_type&amp;amp; _Val)&lt;/code&gt;;基本与&lt;code&gt;vector&lt;/code&gt;用法相同，参数为要插入的值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iterator find(const key_type&amp;amp; _Keyval)&lt;/code&gt;;若找到该元素，返回的指针指向该元素，没找到返回的指针会指向超尾即&lt;code&gt;end()&lt;/code&gt;。与&lt;code&gt;size_type find(_Elem _Ch, size_type _Off = 0) const&lt;/code&gt;有区别，后者会返回下标(&lt;code&gt;size_type&lt;/code&gt;可以看做一种足够大的&lt;code&gt;unsigned&lt;/code&gt;类型来表示下标)，如果没找到，返回&lt;code&gt;string::npos&lt;/code&gt;。而&lt;/li&gt;
&lt;li&gt;&lt;code&gt;size_type erase(const key_type&amp;amp; _Keyval)&lt;/code&gt;;擦除指定值，返回该指定值的位置。&lt;code&gt;iterator erase(const_iterator _Where)&lt;/code&gt;擦除指针指向的值，容器重排，指针不变。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;unordered-set简介&quot;&gt;&lt;a href=&quot;#unordered-set简介&quot; class=&quot;headerlink&quot; title=&quot;unordered_set简介&quot;&gt;&lt;/a&gt;unordered_set简介&lt;/h2&gt;&lt;p&gt;MSDN上有对&lt;a href=&quot;ht
    
    </summary>
    
    
      <category term="unordered_set" scheme="http://yoursite.com/tags/unordered-set/"/>
    
  </entry>
  
  <entry>
    <title>默认参数与内联函数</title>
    <link href="http://yoursite.com/2016/04/19/%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E4%B8%8E%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2016/04/19/默认参数与内联函数/</id>
    <published>2016-04-19T03:15:10.000Z</published>
    <updated>2016-04-25T02:46:46.728Z</updated>
    
    <content type="html">&lt;h2 id=&quot;默认参数&quot;&gt;&lt;a href=&quot;#默认参数&quot; class=&quot;headerlink&quot; title=&quot;默认参数&quot;&gt;&lt;/a&gt;默认参数&lt;/h2&gt;&lt;p&gt;省略实参时自动使用的值，必须通过函数原型(这是因为函数调用时通过函数原型将函数参数压入栈帧)，使用方法是将值赋给原型中的值(压入栈帧并初始化)。 &lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;内联函数&quot;&gt;&lt;a href=&quot;#内联函数&quot; class=&quot;headerlink&quot; title=&quot;内联函数&quot;&gt;&lt;/a&gt;内联函数&lt;/h2&gt;&lt;p&gt;常规函数和内联函数之间的主要区别是C++编译器如何将它们组合到程序中去。&lt;/p&gt;
&lt;h3 id=&quot;C语言的宏&quot;&gt;&lt;a href=&quot;#C语言的宏&quot; class=&quot;headerlink&quot; title=&quot;C语言的宏&quot;&gt;&lt;/a&gt;C语言的宏&lt;/h3&gt;&lt;p&gt;宏是内联代码的原始实现，它的本质是&lt;strong&gt;文本替换&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;普通宏定义中，预处理器将空格解释成分段标志；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;##&lt;/code&gt;是一种分隔连接方式，作用是先分隔后强制连接；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#&lt;/code&gt;表示变量替换后加双引号括起来。&lt;/li&gt;
&lt;li&gt;另外一些分隔符、操作符如&lt;code&gt;+&lt;/code&gt;、&lt;code&gt;-&lt;/code&gt;、&lt;code&gt;*&lt;/code&gt;、&lt;code&gt;/&lt;/code&gt;、&lt;code&gt;[&lt;/code&gt;、&lt;code&gt;]&lt;/code&gt;依然有意义。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#define A1(name,type) type name_##type##_type&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	A1(a1,int) &amp;lt;=&amp;gt; int name_int_type&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define A1(name,type) type name##_##type##_type&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	A1(a1,int) &amp;lt;=&amp;gt; int a1_int_type&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define stringify(x) #x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	stringify(linux) &amp;lt;=&amp;gt; &amp;quot;linux&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;C-内联函数&quot;&gt;&lt;a href=&quot;#C-内联函数&quot; class=&quot;headerlink&quot; title=&quot;C++内联函数&quot;&gt;&lt;/a&gt;C++内联函数&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;编译器将使用相应的函数代码替换函数调用(省略了来回跳跃并记录跳跃位置的过程)；&lt;/li&gt;
&lt;li&gt;运行速度较快，但占用更多的内存(同一个内联函数调用多少次，就有多少次副本)；&lt;/li&gt;
&lt;li&gt;一般省略原型(但原型特性仍在起作用)，将整个定义放在原本该提供原型的地方(这是首次使用前的函数定义，充当原型)，并使用&lt;code&gt;inline&lt;/code&gt;关键字&lt;/li&gt;
&lt;li&gt;编译器并不一定满足程序员内联函数的请求，比如函数过大或者函数调用了自己(递归不能内联)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意类成员函数中的内联函数并不一定使用&lt;code&gt;inline&lt;/code&gt;关键字。定义位于类声明中自动成为内联函数；否则使用&lt;code&gt;inline&lt;/code&gt;关键字作为内联函数。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;默认参数&quot;&gt;&lt;a href=&quot;#默认参数&quot; class=&quot;headerlink&quot; title=&quot;默认参数&quot;&gt;&lt;/a&gt;默认参数&lt;/h2&gt;&lt;p&gt;省略实参时自动使用的值，必须通过函数原型(这是因为函数调用时通过函数原型将函数参数压入栈帧)，使用方法是将值赋给原型中的值(
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="函数" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>函数原型与函数调用</title>
    <link href="http://yoursite.com/2016/04/18/%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/"/>
    <id>http://yoursite.com/2016/04/18/函数原型与函数调用/</id>
    <published>2016-04-18T11:25:05.000Z</published>
    <updated>2016-04-21T02:49:23.462Z</updated>
    
    <content type="html">&lt;h2 id=&quot;函数原型&quot;&gt;&lt;a href=&quot;#函数原型&quot; class=&quot;headerlink&quot; title=&quot;函数原型&quot;&gt;&lt;/a&gt;函数原型&lt;/h2&gt;&lt;h3 id=&quot;为什么需要原型&quot;&gt;&lt;a href=&quot;#为什么需要原型&quot; class=&quot;headerlink&quot; title=&quot;为什么需要原型&quot;&gt;&lt;/a&gt;为什么需要原型&lt;/h3&gt;&lt;p&gt;原型是函数到编译器的接口，他将函数返回值的类型以及参数的类型和数量告诉编译器。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;原型告诉编译器函数参数类型和数量，如果不准确，它让编译器捕获这种错误&lt;/li&gt;
&lt;li&gt;函数完成计算后，将返回值放在指定的位置(&lt;strong&gt;CPU寄存器或者内存&lt;/strong&gt;)以供调用函数取得。&lt;/li&gt;
&lt;li&gt;原型指出返回类型，让编译器知道应检索多少字节以及如何&lt;em&gt;解释&lt;/em&gt;他们。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;原型语法&quot;&gt;&lt;a href=&quot;#原型语法&quot; class=&quot;headerlink&quot; title=&quot;原型语法&quot;&gt;&lt;/a&gt;原型语法&lt;/h3&gt;&lt;p&gt;以&lt;code&gt;void cheers(int);&lt;/code&gt;为例，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;函数原型是一条语句，必须以分号结尾；&lt;/li&gt;
&lt;li&gt;函数原型不要求提供变量名，有类型列表就够了(这与函数调用有关，原型中的变量名其实就是栈中的占位符)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;原型功能&quot;&gt;&lt;a href=&quot;#原型功能&quot; class=&quot;headerlink&quot; title=&quot;原型功能&quot;&gt;&lt;/a&gt;原型功能&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;编译器正确处理函数返回值(就是说在&lt;strong&gt;指定位置如何解释&lt;/strong&gt;)；&lt;/li&gt;
&lt;li&gt;编译器检查使用的参数数目是否正确(&lt;strong&gt;不正确让编译器捕获错误&lt;/strong&gt;)；&lt;/li&gt;
&lt;li&gt;编译器检查参数类型是否正确，如果不正确，可能的话转换为正确类型(编译阶段进行的原型化，静态类型检查)。如下&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/5aaLwcA.png&quot; alt=&quot;函数原型进行类型转化&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;函数调用&quot;&gt;&lt;a href=&quot;#函数调用&quot; class=&quot;headerlink&quot; title=&quot;函数调用&quot;&gt;&lt;/a&gt;函数调用&lt;/h2&gt;&lt;p&gt;详细过程见&lt;a href=&quot;http://www.zhihu.com/question/22444939#answer-4080329&quot; title=&quot;函数调用中栈的变化&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;相关寄存器&quot;&gt;&lt;a href=&quot;#相关寄存器&quot; class=&quot;headerlink&quot; title=&quot;相关寄存器&quot;&gt;&lt;/a&gt;相关寄存器&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;栈指针寄存器：指向系统栈最上面一个帧栈栈底的指针；&lt;/li&gt;
&lt;li&gt;基址指针寄存器：指向系统栈最上面一个帧栈栈底的指针；&lt;/li&gt;
&lt;li&gt;指令寄存器：指向下一条待执行的指令地址。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;函数调用步骤&quot;&gt;&lt;a href=&quot;#函数调用步骤&quot; class=&quot;headerlink&quot; title=&quot;函数调用步骤&quot;&gt;&lt;/a&gt;函数调用步骤&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;参数入栈：C++将参数从右向左依次入栈；&lt;/li&gt;
&lt;li&gt;返回地址入栈：将&lt;em&gt;当前&lt;/em&gt;代码区调用指令的&lt;em&gt;下一条&lt;/em&gt;指令地址压入栈，函数返回时继续执行；&lt;/li&gt;
&lt;li&gt;代码区跳转：从当前代码区跳转到被调函数入口处；&lt;/li&gt;
&lt;li&gt;栈帧调整：&lt;ul&gt;
&lt;li&gt;当前栈帧的EPB入栈；&lt;/li&gt;
&lt;li&gt;切换到新栈帧,ESP装入EBP；&lt;/li&gt;
&lt;li&gt;给新栈帧分配空间；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;思考&quot;&gt;&lt;a href=&quot;#思考&quot; class=&quot;headerlink&quot; title=&quot;思考&quot;&gt;&lt;/a&gt;思考&lt;/h3&gt;&lt;h4 id=&quot;为什么参数要入栈？&quot;&gt;&lt;a href=&quot;#为什么参数要入栈？&quot; class=&quot;headerlink&quot; title=&quot;为什么参数要入栈？&quot;&gt;&lt;/a&gt;为什么参数要入栈？&lt;/h4&gt;&lt;p&gt;为了保存现场，例如一个递归：&lt;br&gt;    &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int sum(int n)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if (n == 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return sum(n-1)+n&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当&lt;code&gt;sum(n-1)&lt;/code&gt;返回，他的栈帧被释放，还原到&lt;code&gt;sum(n)&lt;/code&gt;的栈帧，那么n的值怎么获得？假如&lt;code&gt;sum&lt;/code&gt;是在&lt;code&gt;main()&lt;/code&gt;调用的，n在调用时压入了&lt;code&gt;main()&lt;/code&gt;的栈帧，并对一个匿名对象拷贝了n的值供&lt;code&gt;sum()&lt;/code&gt;计算，如果传地址或者引用就可以直接修改栈帧中的值。&lt;br&gt;这就可以解释为什么按值传递时不能修改上一级函数的数值，因为栈帧会还原，按值传递修改的也不是栈帧中的值。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;函数原型&quot;&gt;&lt;a href=&quot;#函数原型&quot; class=&quot;headerlink&quot; title=&quot;函数原型&quot;&gt;&lt;/a&gt;函数原型&lt;/h2&gt;&lt;h3 id=&quot;为什么需要原型&quot;&gt;&lt;a href=&quot;#为什么需要原型&quot; class=&quot;headerlink&quot; title=&quot;为什么
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="函数" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>类的复制构造函数和赋值运算符重载</title>
    <link href="http://yoursite.com/2016/04/18/%E7%B1%BB%E7%9A%84%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <id>http://yoursite.com/2016/04/18/类的复制构造函数和赋值运算符重载/</id>
    <published>2016-04-18T03:51:12.000Z</published>
    <updated>2016-04-18T08:54:33.333Z</updated>
    
    <content type="html">&lt;p&gt;C++会自动提供以下成员函数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;默认构造函数；&lt;/li&gt;
&lt;li&gt;默认析构函数&lt;/li&gt;
&lt;li&gt;复制构造函数&lt;/li&gt;
&lt;li&gt;赋值运算符&lt;/li&gt;
&lt;li&gt;地址运算符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之前讨论过构造函数与析构函数，今天讨论复制构造函数与赋值运算符。&lt;/p&gt;
&lt;h2 id=&quot;类的复制构造函数&quot;&gt;&lt;a href=&quot;#类的复制构造函数&quot; class=&quot;headerlink&quot; title=&quot;类的复制构造函数&quot;&gt;&lt;/a&gt;类的复制构造函数&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;作用：复制构造函数用于将一个对象复制到新创建的对象中。也就是用于初始化过程（包括按值传递）,而不是常规的赋值过程。&lt;strong&gt;隐式构造函数&lt;font color=&quot;red&quot;&gt;按值&lt;/font&gt;逐个复制非静态成员&lt;/strong&gt;,静态成员属于整个类，不属于某一个对象，因此不受影响。&lt;/li&gt;
&lt;li&gt;何时调用：新建一个对象并将其初始化为同类现有对象。有以下四种可能语法：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;StringBad ditto(motto)&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StringBad *pStringBad = new StringBad(motto)&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StringBad metoo = motto&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StringBad also = StringBad(motto)&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1、2两种声明没有临时匿名对象(或者说临时匿名对象有外部载体);3、4两种声明值是接创建metoo和also还是用复制构造函数构造临时对象然后对象赋值给metoo和also，取决于具体实现。&lt;font color=&quot;red&quot;&gt;特点是有赋值运算符的非指针构造&lt;/font&gt;，在本人的编译器上(VS2012 32)是有临时对象并析构的。&lt;/p&gt;
&lt;h4 id=&quot;注：&quot;&gt;&lt;a href=&quot;#注：&quot; class=&quot;headerlink&quot; title=&quot;注：&quot;&gt;&lt;/a&gt;注：&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;无论哪种编译器，按值传递和返回对象时，都将调用复制构造函数。&lt;/li&gt;
&lt;li&gt;由于1，复制构造函数必须&lt;strong&gt;接受类对象的常量引用&lt;/strong&gt;作为参数，否则会无限递归调用自身导致堆栈溢出。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;默认复制构造函数的缺陷-浅复制&quot;&gt;&lt;a href=&quot;#默认复制构造函数的缺陷-浅复制&quot; class=&quot;headerlink&quot; title=&quot;默认复制构造函数的缺陷(浅复制)&quot;&gt;&lt;/a&gt;默认复制构造函数的缺陷(浅复制)&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;对象计数器：默认构造函数+显式构造函数+显式构造函数=析构函数。&lt;/li&gt;
&lt;li&gt;隐式复制构造函数是&lt;strong&gt;按值复制&lt;/strong&gt;，对于指针指向的new出来的空间，它会使两个指针指向同一块内容，因此在析构时，编译器尝试两次释放同一块内存，这会导致不确定的可能有害的结果。必须定义一个显式复制构造函数给指针开辟新的内存、&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;类的复制运算符重载-深度复制&quot;&gt;&lt;a href=&quot;#类的复制运算符重载-深度复制&quot; class=&quot;headerlink&quot; title=&quot;类的复制运算符重载(深度复制)&quot;&gt;&lt;/a&gt;类的复制运算符重载(深度复制)&lt;/h2&gt;&lt;p&gt;C++的类对象赋值通过自动为类重载赋值运算符实现。赋值运算符是只能由类成员函数重载的运算符之一。&lt;br&gt;如上所说四种新建对象方法，&lt;em&gt;8初始化时总会调用复制构造函数，而是用&lt;code&gt;=&lt;/code&gt;运算符也允许调用赋值运算符。&lt;/em&gt;但是！赋值运算符的隐式实现也是对成员逐个赋值。那么如上也有两次析构的问题，因此应该提供赋值运算符进行深度复制。&lt;br&gt;其与复制构造函数的差别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;应该首先检查自我复制，相同返回自身。否则未复制前释放了自身；&lt;/li&gt;
&lt;li&gt;释放拷贝对象之前引用的数据，否则会内存泄露(因为要深度复制会申请新的内存空间并指向他进行数据拷贝，之前的内存指针就丢失了)。&lt;/li&gt;
&lt;li&gt;返回一个指向调用对象的引用以便连续赋值。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面这个例子同时犯了复制构造函数和赋值运算符重载的浅复制错误：&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/OwHR2qp.png&quot; alt=&quot;典型的浅复制错误&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;思考&quot;&gt;&lt;a href=&quot;#思考&quot; class=&quot;headerlink&quot; title=&quot;思考&quot;&gt;&lt;/a&gt;思考&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;为什么赋值运算符重载返回类型是引用？之前在&lt;code&gt;*this&lt;/code&gt;指针中提过，返回类型为引用意味着返回对象本身而不是其副本。这样在一些含有赋值运算符的初始化中也可以防止递归调用。&lt;/li&gt;
&lt;li&gt;为什么参数类型为引用？对&lt;em&gt;复制构造函数&lt;/em&gt;和&lt;em&gt;赋值运算符重载&lt;/em&gt;，都是为了防止递归调用。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;C++会自动提供以下成员函数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;默认构造函数；&lt;/li&gt;
&lt;li&gt;默认析构函数&lt;/li&gt;
&lt;li&gt;复制构造函数&lt;/li&gt;
&lt;li&gt;赋值运算符&lt;/li&gt;
&lt;li&gt;地址运算符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之前讨论过构造函数与析构函数，今天讨论复制构造函
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="类" scheme="http://yoursite.com/tags/%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>vector之resize方法和reverse方法</title>
    <link href="http://yoursite.com/2016/04/15/vector%E4%B9%8Bresize%E6%96%B9%E6%B3%95%E5%92%8Creverse%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/04/15/vector之resize方法和reverse方法/</id>
    <published>2016-04-15T06:39:13.000Z</published>
    <updated>2016-04-19T12:59:02.834Z</updated>
    
    <content type="html">&lt;h2 id=&quot;a-resize-和a-reverse&quot;&gt;&lt;a href=&quot;#a-resize-和a-reverse&quot; class=&quot;headerlink&quot; title=&quot;a.resize()和a.reverse();&quot;&gt;&lt;/a&gt;a.resize()和a.reverse();&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;首先介绍容器的两个属性&lt;code&gt;capacity&lt;/code&gt;和&lt;code&gt;size&lt;/code&gt;。&lt;code&gt;capacity&lt;/code&gt;存储区的大小；&lt;code&gt;size&lt;/code&gt;容器的大小。&lt;/li&gt;
&lt;li&gt;‘reverse()’是预分配存储区的大小，预分配存储区，但存储区不一定有容器对象。&lt;/li&gt;
&lt;li&gt;‘resize()’是改变容器大小，容器中一定有容器对象。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&quot;a-reverse&quot;&gt;&lt;a href=&quot;#a-reverse&quot; class=&quot;headerlink&quot; title=&quot;a.reverse();&quot;&gt;&lt;/a&gt;a.reverse();&lt;/h3&gt;&lt;p&gt;看源码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void reserve(size_type _Count)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;	// determine new minimum length of allocated storage&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if (capacity() &amp;lt; _Count)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#123;// something to do, check and reallocate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if (max_size() &amp;lt; _Count)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			Xlen();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		_Reallocate(_Count);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;没有&lt;code&gt;else&lt;/code&gt;，说明若当前的&lt;code&gt;capacity&lt;/code&gt;大于传入的值，&lt;strong&gt;&lt;code&gt;capacity&lt;/code&gt;是不会减小的&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;里层的if是错误检测机制；&lt;/li&gt;
&lt;li&gt;验证&lt;code&gt;vector&lt;/code&gt;的&lt;code&gt;reallocate&lt;/code&gt;原理，实际上每次新的&lt;code&gt;capacity&lt;/code&gt;是之前的1.5倍。因此在&lt;strong&gt;循环之前一定要&lt;code&gt;reserve&lt;/code&gt;保证效率&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&quot;a-resize&quot;&gt;&lt;a href=&quot;#a-resize&quot; class=&quot;headerlink&quot; title=&quot;a.resize();&quot;&gt;&lt;/a&gt;a.resize();&lt;/h3&gt;&lt;p&gt;模板类提供了两个函数重载：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;表达式&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;strong&gt;返回类型&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;a.resize(n)&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;void&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;容器大小设为n&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;a.resize(n,t)&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;void&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;容器大小设为n，必要时用t填充&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&quot;a-resize-n&quot;&gt;&lt;a href=&quot;#a-resize-n&quot; class=&quot;headerlink&quot; title=&quot;a.resize(n)&quot;&gt;&lt;/a&gt;a.resize(n)&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void resize(size_type _Newsize)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;	// determine new length, padding as needed&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if (_Newsize &amp;lt; size())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		erase(begin() + _Newsize, end());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	else if (size() &amp;lt; _Newsize)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#123;	// pad as needed&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		_Alty _Alval(this-&amp;gt;_Getal());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		_Reserve(_Newsize - size());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		_TRY_BEGIN&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		_Uninitialized_default_fill_n(this-&amp;gt;_Mylast, _Newsize - size(),_Alval);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		_CATCH_ALL&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		_Tidy();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		_RERAISE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		_CATCH_END&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		this-&amp;gt;_Mylast += _Newsize - size();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;若容器新大小小于现在的大小，毁掉多余的对象；&lt;/li&gt;
&lt;li&gt;新大小大于现在的大小：&lt;ul&gt;
&lt;li&gt;注意&lt;code&gt;_Reserve&lt;/code&gt;和&lt;code&gt;.reverse&lt;/code&gt;是两个不同的方法，一个比较&lt;code&gt;capacity&lt;/code&gt;，一个比较&lt;code&gt;_Unused_capacity&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;检查空间，不够则&lt;code&gt;reverse&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;填充未初始化的对象&lt;/li&gt;
&lt;li&gt;修改尾指针&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;####a.resize(n,t)&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void resize(size_type _Newsize, const value_type&amp;amp; _Val)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;	// determine new length, padding with _Val elements as needed&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if (_Newsize &amp;lt; size())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		erase(begin() + _Newsize, end());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	else if (size() &amp;lt; _Newsize)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		_Insert_n(end(), _Newsize - size(), _Val);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若容器新大小小于现在的大小，毁掉多余的对象；&lt;/li&gt;
&lt;li&gt;新大小大于现在的大小，直接执行&lt;code&gt;insert&lt;/code&gt;;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;a-resize-和a-reverse&quot;&gt;&lt;a href=&quot;#a-resize-和a-reverse&quot; class=&quot;headerlink&quot; title=&quot;a.resize()和a.reverse();&quot;&gt;&lt;/a&gt;a.resize()和a.reverse();&lt;/
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="STL-vector" scheme="http://yoursite.com/tags/STL-vector/"/>
    
  </entry>
  
  <entry>
    <title>vector之erase方法</title>
    <link href="http://yoursite.com/2016/04/14/vector%E4%B9%8Berase%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/04/14/vector之erase方法/</id>
    <published>2016-04-14T02:52:25.000Z</published>
    <updated>2016-04-26T08:27:42.210Z</updated>
    
    <content type="html">&lt;h2 id=&quot;a-erase&quot;&gt;&lt;a href=&quot;#a-erase&quot; class=&quot;headerlink&quot; title=&quot;a.erase();&quot;&gt;&lt;/a&gt;a.erase();&lt;/h2&gt;&lt;p&gt;模板类提供了两个函数重载：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;表达式&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;strong&gt;返回类型&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;a.erase(p)&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;strong&gt;迭代器&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;删除p指向的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;a.erase(p,q)&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;strong&gt;迭代器&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;删除区间[p,q)中的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;思考&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在之前内存之中讨论过，&lt;code&gt;vector&lt;/code&gt;是保证内存连续的，那么&lt;code&gt;erase&lt;/code&gt;之后他是如何保证内存连续的？答案是让该元素之后的所有元素前移补充“空位”。这一点在&lt;code&gt;erase()&lt;/code&gt;方法的代码中可以看到传入的p的形参是&lt;code&gt;const&lt;/code&gt;类型的，也就是说p指向的地址并不发生变化，只不过是元素前移了。测试如下：&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/TZxRRb6.png&quot; alt=&quot;STL的迭代器&quot;&gt;&lt;/li&gt;
&lt;li&gt;注意到&lt;code&gt;erase&lt;/code&gt;返回的都是迭代器，由1中的分析可知，删除p指向的元素之后，他返回的迭代器的&lt;strong&gt;地址不变&lt;/strong&gt;，值是删除之后可用的下一个元素，因此&lt;strong&gt;给人感觉是p指向了下一个元素&lt;/strong&gt;。那么在这里有一个值得注意的问题，如下：&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vector&amp;lt;int&amp;gt;::iterator p = b.begin();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for (;p!=b.end();p++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if (*p == 2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		b.erase(p);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这是错误的，&lt;code&gt;b.erase(p)&lt;/code&gt;没有迭代器来承接p的返回值，它的返回值被释放了。然后执行p++很显然会出现野指针。但是如果修改为&lt;code&gt;p = b.erase(p)&lt;/code&gt;也是不正确的。迭代器在进行删除的这一个循环里会&lt;code&gt;++&lt;/code&gt;两次（&lt;code&gt;erase&lt;/code&gt;可以当做&lt;code&gt;++&lt;/code&gt;一次）。但如果在&lt;code&gt;if&lt;/code&gt;语句中执行一次&lt;code&gt;p--&lt;/code&gt;，这是正确的。即&lt;code&gt;p = --b.erase(p);&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不能用&lt;code&gt;p-- = b.erase(p);&lt;/code&gt;，因为&lt;code&gt;p--&lt;/code&gt;是表达式，不能为左值；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不能用&lt;code&gt;p = b.erase(p--);&lt;/code&gt;，也是因为&lt;code&gt;p--&lt;/code&gt;是一个表达式，强调计算结果，不能作为左值，也不能取址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;迭代器的循环使用&lt;code&gt;while&lt;/code&gt;可以降低错误率。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;为简单，分析第一个表达式的源码如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;iterator erase(const_iterator _Where)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;	// erase element at where&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if (_VICONT(_Where) != this&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		|| _VIPTR(_Where) &amp;lt; this-&amp;gt;_Myfirst&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		|| this-&amp;gt;_Mylast &amp;lt;= _VIPTR(_Where))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		_DEBUG_ERROR(&amp;quot;vector erase iterator outside range&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	_Move(_VIPTR(_Where) + 1, this-&amp;gt;_Mylast, _VIPTR(_Where));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	_Destroy(this-&amp;gt;_Mylast - 1, this-&amp;gt;_Mylast);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	_Orphan_range(_VIPTR(_Where), this-&amp;gt;_Mylast);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	--this-&amp;gt;_Mylast;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return (_Make_iter(_Where));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以看到他做了哪些工作,首先元素前移，然后毁掉最后一个对象(&lt;code&gt;capacity&lt;/code&gt;不变)，之后&lt;font color=&quot;red&quot;&gt;_Orphan_range发生了什么？&lt;/font&gt;,接下来指针指向正确的位置，最后返回指向原地址的迭代器。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;a-erase&quot;&gt;&lt;a href=&quot;#a-erase&quot; class=&quot;headerlink&quot; title=&quot;a.erase();&quot;&gt;&lt;/a&gt;a.erase();&lt;/h2&gt;&lt;p&gt;模板类提供了两个函数重载：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th s
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="STL-vector" scheme="http://yoursite.com/tags/STL-vector/"/>
    
  </entry>
  
  <entry>
    <title>vector之insert方法和emplace方法</title>
    <link href="http://yoursite.com/2016/04/13/vector%E4%B9%8Binsert%E6%96%B9%E6%B3%95%E5%92%8Cemplace%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/04/13/vector之insert方法和emplace方法/</id>
    <published>2016-04-13T12:39:29.000Z</published>
    <updated>2016-04-19T12:58:59.205Z</updated>
    
    <content type="html">&lt;h2 id=&quot;a-insert&quot;&gt;&lt;a href=&quot;#a-insert&quot; class=&quot;headerlink&quot; title=&quot;a.insert();&quot;&gt;&lt;/a&gt;a.insert();&lt;/h2&gt;&lt;p&gt;模板类提供了三个函数重载,这是一种&lt;strong&gt;拷贝&lt;/strong&gt;插入方法：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;表达式&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;返回类型&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;a.insert(p,t)&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;迭代器&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;指向原本指向的元素,将t插入到p前面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;a.insert(p, n,t)&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将n个t插入到p前面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;a.insert(p,i,j)&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将区间[i,j)插入到p的前面，注意是左闭右开区间，j可以是超尾&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&quot;a-emplace&quot;&gt;&lt;a href=&quot;#a-emplace&quot; class=&quot;headerlink&quot; title=&quot;a.emplace();&quot;&gt;&lt;/a&gt;a.emplace();&lt;/h2&gt;&lt;p&gt;新标准引入的&lt;code&gt;emplace_front&lt;/code&gt;,&lt;code&gt;emplace&lt;/code&gt;,&lt;code&gt;emplace_back&lt;/code&gt;这些操作是构造而不是拷贝元素。当插入一个对象时，将会比&lt;code&gt;insert&lt;/code&gt;少拷贝构造，析构的步骤。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;注：&quot;&gt;&lt;a href=&quot;#注：&quot; class=&quot;headerlink&quot; title=&quot;注：&quot;&gt;&lt;/a&gt;注：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;调用&lt;code&gt;push&lt;/code&gt;或&lt;code&gt;insert&lt;/code&gt;成员函数，将元素类型对象传递进去，这些对象被拷贝到容器中；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;emplace()&lt;/code&gt;在容器中构造元素，因此效率更高；&lt;/li&gt;
&lt;li&gt;注意&lt;code&gt;a.insert(p,t)&lt;/code&gt;的源码提供了一个重载，若t是普通类型，则调用&lt;code&gt;a.emplace(p，t)&lt;/code&gt;，若t是&lt;code&gt;const&lt;/code&gt;类型，则调用&lt;code&gt;a.insert(p,t)&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;a-insert&quot;&gt;&lt;a href=&quot;#a-insert&quot; class=&quot;headerlink&quot; title=&quot;a.insert();&quot;&gt;&lt;/a&gt;a.insert();&lt;/h2&gt;&lt;p&gt;模板类提供了三个函数重载,这是一种&lt;strong&gt;拷贝&lt;/strong&gt;插入方法
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="STL-vector" scheme="http://yoursite.com/tags/STL-vector/"/>
    
  </entry>
  
  <entry>
    <title>vector简介及非STL函数用法-持续更新</title>
    <link href="http://yoursite.com/2016/04/12/vector%E7%AE%80%E4%BB%8B%E5%8F%8A%E9%9D%9ESTL%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <id>http://yoursite.com/2016/04/12/vector简介及非STL函数用法-持续更新/</id>
    <published>2016-04-12T06:54:50.000Z</published>
    <updated>2016-04-18T08:59:53.542Z</updated>
    
    <content type="html">&lt;h2 id=&quot;vector&quot;&gt;&lt;a href=&quot;#vector&quot; class=&quot;headerlink&quot; title=&quot;vector&quot;&gt;&lt;/a&gt;vector&lt;/h2&gt;&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;模板类是最简单的序列类型，除非其他类型的特殊有点能够满足程序的要求，否则应该默认使用这种类型。以后将记录一些在编程过程中常用的&lt;code&gt;vector&lt;/code&gt;方法作为笔记以便不时复习，必要时会分析源码。&lt;/p&gt;
&lt;p&gt;常见的方法有：&lt;br&gt;&lt;code&gt;.insert()&lt;/code&gt;，&lt;code&gt;a.emplace()&lt;/code&gt;，&lt;code&gt;.resize()&lt;/code&gt;，&lt;code&gt;.reverse()&lt;/code&gt;，&lt;code&gt;.begin()&lt;/code&gt;，&lt;code&gt;a.end()&lt;/code&gt;，&lt;code&gt;a.rbegin()&lt;/code&gt;，&lt;br&gt;&lt;code&gt;a.rend()&lt;/code&gt;，&lt;code&gt;a.size()&lt;/code&gt;，&lt;code&gt;a.swap(b)&lt;/code&gt;，&lt;code&gt;a.empty()&lt;/code&gt;，&lt;code&gt;a.front()&lt;/code&gt;，&lt;code&gt;a.back()&lt;/code&gt;，&lt;code&gt;a.clear()&lt;/code&gt;，&lt;br&gt;&lt;code&gt;a.push_back(t)&lt;/code&gt;，&lt;code&gt;a.popback(t)&lt;/code&gt;，&lt;code&gt;a[n]&lt;/code&gt;，&lt;code&gt;a.at(n)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;有&lt;code&gt;vector&amp;lt;int&amp;gt; a&lt;/code&gt;;&lt;code&gt;vector&amp;lt;int&amp;gt; b&lt;/code&gt;;即a,b是&lt;code&gt;vector&amp;lt;int&amp;gt;&lt;/code&gt;的对象。&lt;code&gt;vector&amp;lt;int&amp;gt; ::iterator p&lt;/code&gt;;p是指向&lt;code&gt;vector&amp;lt;int&amp;gt;&lt;/code&gt;的迭代器。i、j、q均和p一样是指向&lt;code&gt;vector&amp;lt;int&amp;gt;&lt;/code&gt;的迭代器。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;sort-用于vector&quot;&gt;&lt;a href=&quot;#sort-用于vector&quot; class=&quot;headerlink&quot; title=&quot;sort()用于vector;&quot;&gt;&lt;/a&gt;sort()用于vector;&lt;/h2&gt;&lt;p&gt;在&lt;code&gt;algorithm&amp;gt;&lt;/code&gt;头文件中提供了&lt;code&gt;sort&lt;/code&gt;的两个重载函数,查看源码可发现是用&lt;strong&gt;快排&lt;/strong&gt;实现的。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;表达式&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;strong&gt;返回类型&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;sort(p,q)&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;对[p,q)升序排序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;sort(p,q,cmp)&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;对[p,q)使用&lt;code&gt;cmp&lt;/code&gt;方法排序，&lt;code&gt;cmp&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol&gt;
&lt;li&gt;右闭左开区间，一般来讲&lt;code&gt;p = a.begin()&lt;/code&gt;;&lt;code&gt;q = a.end()&lt;/code&gt;完成了对容器的排序。&lt;/li&gt;
&lt;li&gt;升序排序直接用第一个方法，系统默认&lt;code&gt;a&amp;lt;b&lt;/code&gt;返回真，因此是升序。&lt;/li&gt;
&lt;li&gt;降序排序需要自定义&lt;code&gt;cmp&lt;/code&gt;方法,方法如下，只需要将默认值改为&lt;code&gt;a&amp;gt;b&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bool comp(const int &amp;amp;a,const int &amp;amp;b)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  		return a&amp;gt;b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;以上参考了&lt;a href=&quot;http://www.cnblogs.com/cj695/p/3863142.html&quot; title=&quot;这里&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;vector&quot;&gt;&lt;a href=&quot;#vector&quot; class=&quot;headerlink&quot; title=&quot;vector&quot;&gt;&lt;/a&gt;vector&lt;/h2&gt;&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;模板类是最简单的序列类型，除非其他类型的特殊有点能够满足程序的要求，否
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="STL-vector" scheme="http://yoursite.com/tags/STL-vector/"/>
    
  </entry>
  
</feed>
