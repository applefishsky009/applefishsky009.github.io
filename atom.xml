<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孤云两角，去天一握</title>
  <subtitle>山在地下，地山谦</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-04-19T12:54:21.229Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ryl</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>unordered_set简介</title>
    <link href="http://yoursite.com/2016/04/19/unordered_set%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2016/04/19/unordered_set简介/</id>
    <published>2016-04-19T11:42:25.000Z</published>
    <updated>2016-04-19T12:54:21.229Z</updated>
    
    <content type="html">&lt;h2 id=&quot;unordered-set简介&quot;&gt;&lt;a href=&quot;#unordered-set简介&quot; class=&quot;headerlink&quot; title=&quot;unordered_set简介&quot;&gt;&lt;/a&gt;unordered_set简介&lt;/h2&gt;&lt;p&gt;MSDN上有对&lt;a href=&quot;https://msdn.microsoft.com/zh-cn/library/bb982739.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;unordered_set&lt;/a&gt;描述，CSDN上有博客对&lt;a href=&quot;http://blog.csdn.net/oabid/article/details/4562577&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;unordered_set&lt;/a&gt;描述，这是一个哈希表。一般来说，一些简单功能可以当做STL里的容器来用：&lt;code&gt;insert()&lt;/code&gt;、&lt;font color=&quot;red&quot;&gt;&lt;code&gt;find()&lt;/code&gt;&lt;/font&gt;、&lt;code&gt;erase()&lt;/code&gt;、&lt;code&gt;size()&lt;/code&gt;、&lt;code&gt;empty()&lt;/code&gt;、&lt;code&gt;begin()&lt;/code&gt;、&lt;code&gt;end()&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;unordered-set与STL的异同&quot;&gt;&lt;a href=&quot;#unordered-set与STL的异同&quot; class=&quot;headerlink&quot; title=&quot;unordered_set与STL的异同&quot;&gt;&lt;/a&gt;unordered_set与STL的异同&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;_Pairib insert(const value_type&amp;amp; _Val)&lt;/code&gt;;基本与&lt;code&gt;vector&lt;/code&gt;用法相同，参数为要插入的值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iterator find(const key_type&amp;amp; _Keyval)&lt;/code&gt;;若找到该元素，返回的指针指向该元素，没找到返回的指针会指向超尾即&lt;code&gt;end()&lt;/code&gt;。与&lt;code&gt;size_type find(_Elem _Ch, size_type _Off = 0) const&lt;/code&gt;有区别，后者会返回下标(&lt;code&gt;size_type&lt;/code&gt;可以看做一种足够大的&lt;code&gt;unsigned&lt;/code&gt;类型来表示下标)，如果没找到，返回&lt;code&gt;string::npos&lt;/code&gt;。而&lt;/li&gt;
&lt;li&gt;&lt;code&gt;size_type erase(const key_type&amp;amp; _Keyval)&lt;/code&gt;;擦除指定值，返回该指定值的位置。&lt;code&gt;iterator erase(const_iterator _Where)&lt;/code&gt;擦除指针指向的值，容器重排，指针不变。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;unordered-set简介&quot;&gt;&lt;a href=&quot;#unordered-set简介&quot; class=&quot;headerlink&quot; title=&quot;unordered_set简介&quot;&gt;&lt;/a&gt;unordered_set简介&lt;/h2&gt;&lt;p&gt;MSDN上有对&lt;a href=&quot;ht
    
    </summary>
    
    
      <category term="unordered_set" scheme="http://yoursite.com/tags/unordered-set/"/>
    
  </entry>
  
  <entry>
    <title>整型提升</title>
    <link href="http://yoursite.com/2016/04/19/%E6%95%B4%E5%9E%8B%E6%8F%90%E5%8D%87/"/>
    <id>http://yoursite.com/2016/04/19/整型提升/</id>
    <published>2016-04-19T03:15:41.000Z</published>
    <updated>2016-04-19T03:34:29.362Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="函数原型" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>默认参数与内联函数</title>
    <link href="http://yoursite.com/2016/04/19/%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E4%B8%8E%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2016/04/19/默认参数与内联函数/</id>
    <published>2016-04-19T03:15:10.000Z</published>
    <updated>2016-04-19T07:08:55.502Z</updated>
    
    <content type="html">&lt;h2 id=&quot;默认参数&quot;&gt;&lt;a href=&quot;#默认参数&quot; class=&quot;headerlink&quot; title=&quot;默认参数&quot;&gt;&lt;/a&gt;默认参数&lt;/h2&gt;&lt;p&gt;省略实参时自动使用的值，必须通过函数原型(这是因为函数调用时通过函数原型将函数参数压入栈帧)，使用方法是将值赋给原型中的值(压入栈帧并初始化)。 &lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;内联函数&quot;&gt;&lt;a href=&quot;#内联函数&quot; class=&quot;headerlink&quot; title=&quot;内联函数&quot;&gt;&lt;/a&gt;内联函数&lt;/h2&gt;&lt;p&gt;常规函数和内联函数之间的主要区别是C++编译器如何将它们组合到程序中去。&lt;/p&gt;
&lt;h3 id=&quot;C语言的宏&quot;&gt;&lt;a href=&quot;#C语言的宏&quot; class=&quot;headerlink&quot; title=&quot;C语言的宏&quot;&gt;&lt;/a&gt;C语言的宏&lt;/h3&gt;&lt;p&gt;宏是内联代码的原始实现，它的本质是&lt;strong&gt;文本替换&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;普通宏定义中，预处理器将空格解释成分段标志；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;##&lt;/code&gt;是一种分隔连接方式，作用是先分隔后强制连接；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#&lt;/code&gt;表示变量替换后加双引号括起来。&lt;/li&gt;
&lt;li&gt;另外一些分隔符、操作符如&lt;code&gt;+&lt;/code&gt;、&lt;code&gt;-&lt;/code&gt;、&lt;code&gt;*&lt;/code&gt;、&lt;code&gt;/&lt;/code&gt;、&lt;code&gt;[&lt;/code&gt;、&lt;code&gt;]&lt;/code&gt;依然有意义。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#define A1(name,type) type name_##type##_type&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	A1(a1,int) &amp;lt;=&amp;gt; int name_int_type&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define A1(name,type) type name##_##type##_type&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	A1(a1,int) &amp;lt;=&amp;gt; int a1_int_type&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define stringify(x) #x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	stringify(linux) &amp;lt;=&amp;gt; &amp;quot;linux&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;C-内联函数&quot;&gt;&lt;a href=&quot;#C-内联函数&quot; class=&quot;headerlink&quot; title=&quot;C++内联函数&quot;&gt;&lt;/a&gt;C++内联函数&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;编译器将使用相应的函数代码替换函数调用(省略了来回跳跃并记录跳跃位置的过程)；&lt;/li&gt;
&lt;li&gt;运行速度较快，但占用更多的内存(同一个内联函数调用多少次，就有多少次副本)；&lt;/li&gt;
&lt;li&gt;一般省略原型(但原型特性仍在起作用)，将整个定义放在原本该提供原型的地方(这是首次使用前的函数定义，充当原型)，并使用&lt;code&gt;inline&lt;/code&gt;关键字&lt;/li&gt;
&lt;li&gt;编译器并不一定满足程序员内联函数的请求，比如函数过大或者函数调用了自己(递归不能内联)。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;默认参数&quot;&gt;&lt;a href=&quot;#默认参数&quot; class=&quot;headerlink&quot; title=&quot;默认参数&quot;&gt;&lt;/a&gt;默认参数&lt;/h2&gt;&lt;p&gt;省略实参时自动使用的值，必须通过函数原型(这是因为函数调用时通过函数原型将函数参数压入栈帧)，使用方法是将值赋给原型中的值(
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="函数原型" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>函数原型与函数调用</title>
    <link href="http://yoursite.com/2016/04/18/%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/"/>
    <id>http://yoursite.com/2016/04/18/函数原型与函数调用/</id>
    <published>2016-04-18T11:25:05.000Z</published>
    <updated>2016-04-19T07:04:42.318Z</updated>
    
    <content type="html">&lt;h2 id=&quot;函数原型&quot;&gt;&lt;a href=&quot;#函数原型&quot; class=&quot;headerlink&quot; title=&quot;函数原型&quot;&gt;&lt;/a&gt;函数原型&lt;/h2&gt;&lt;h3 id=&quot;为什么需要原型&quot;&gt;&lt;a href=&quot;#为什么需要原型&quot; class=&quot;headerlink&quot; title=&quot;为什么需要原型&quot;&gt;&lt;/a&gt;为什么需要原型&lt;/h3&gt;&lt;p&gt;原型是函数到编译器的接口，他将函数返回值的类型以及参数的类型和数量告诉编译器。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;原型告诉编译器函数参数类型和数量，如果不准确，它让编译器捕获这种错误&lt;/li&gt;
&lt;li&gt;函数完成计算后，将返回值放在指定的位置(&lt;strong&gt;CPU寄存器或者内存&lt;/strong&gt;)以供调用函数取得。&lt;/li&gt;
&lt;li&gt;原型指出返回类型，让编译器知道应检索多少字节以及如何&lt;em&gt;解释&lt;/em&gt;他们。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;原型语法&quot;&gt;&lt;a href=&quot;#原型语法&quot; class=&quot;headerlink&quot; title=&quot;原型语法&quot;&gt;&lt;/a&gt;原型语法&lt;/h3&gt;&lt;p&gt;以&lt;code&gt;void cheers(int);&lt;/code&gt;为例，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;函数原型是一条语句，必须以分号结尾；&lt;/li&gt;
&lt;li&gt;函数原型不要求提供变量名，有类型列表就够了(这与函数调用有关，原型中的变量名其实就是栈中的占位符)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;原型功能&quot;&gt;&lt;a href=&quot;#原型功能&quot; class=&quot;headerlink&quot; title=&quot;原型功能&quot;&gt;&lt;/a&gt;原型功能&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;编译器正确处理函数返回值(就是说在&lt;strong&gt;指定位置如何解释&lt;/strong&gt;)；&lt;/li&gt;
&lt;li&gt;编译器检查使用的参数数目是否正确(&lt;strong&gt;不正确让编译器捕获错误&lt;/strong&gt;)；&lt;/li&gt;
&lt;li&gt;编译器检查参数类型是否正确，如果不正确，可能的话转换为正确类型(编译阶段进行的原型化，静态类型检查)。如下&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/5aaLwcA.png&quot; alt=&quot;函数原型进行类型转化&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;函数调用&quot;&gt;&lt;a href=&quot;#函数调用&quot; class=&quot;headerlink&quot; title=&quot;函数调用&quot;&gt;&lt;/a&gt;函数调用&lt;/h2&gt;&lt;p&gt;详细过程见&lt;a href=&quot;http://www.zhihu.com/question/22444939#answer-4080329&quot; title=&quot;函数调用中栈的变化&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;相关寄存器&quot;&gt;&lt;a href=&quot;#相关寄存器&quot; class=&quot;headerlink&quot; title=&quot;相关寄存器&quot;&gt;&lt;/a&gt;相关寄存器&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;栈指针寄存器：指向系统栈最上面一个帧栈栈底的指针；&lt;/li&gt;
&lt;li&gt;基址指针寄存器：指向系统栈最上面一个帧栈栈底的指针；&lt;/li&gt;
&lt;li&gt;指令寄存器：指向下一条待执行的指令地址。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;函数调用步骤&quot;&gt;&lt;a href=&quot;#函数调用步骤&quot; class=&quot;headerlink&quot; title=&quot;函数调用步骤&quot;&gt;&lt;/a&gt;函数调用步骤&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;参数入栈：C++将参数从右向左依次入栈；&lt;/li&gt;
&lt;li&gt;返回地址入栈：将&lt;em&gt;当前&lt;/em&gt;代码区调用指令的&lt;em&gt;下一条&lt;/em&gt;指令地址压入栈，函数返回时继续执行；&lt;/li&gt;
&lt;li&gt;代码区跳转：从当前代码区跳转到被调函数入口处；&lt;/li&gt;
&lt;li&gt;栈帧调整：&lt;ul&gt;
&lt;li&gt;当前栈帧的EPB入栈；&lt;/li&gt;
&lt;li&gt;切换到新栈帧,ESP装入EBP；&lt;/li&gt;
&lt;li&gt;给新栈帧分配空间；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;思考&quot;&gt;&lt;a href=&quot;#思考&quot; class=&quot;headerlink&quot; title=&quot;思考&quot;&gt;&lt;/a&gt;思考&lt;/h3&gt;&lt;h4 id=&quot;为什么参数要入栈？&quot;&gt;&lt;a href=&quot;#为什么参数要入栈？&quot; class=&quot;headerlink&quot; title=&quot;为什么参数要入栈？&quot;&gt;&lt;/a&gt;为什么参数要入栈？&lt;/h4&gt;&lt;p&gt;为了保存现场，例如一个递归：&lt;br&gt;    &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int sum(int n)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if (n == 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return sum(n-1)+n&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当&lt;code&gt;sum(n-1)&lt;/code&gt;返回，他的栈帧被释放，还原到&lt;code&gt;sum(n)&lt;/code&gt;的栈帧，那么n的值怎么获得？假如&lt;code&gt;sum&lt;/code&gt;是在&lt;code&gt;main()&lt;/code&gt;调用的，n在调用时压入了&lt;code&gt;main()&lt;/code&gt;的栈帧，并对一个匿名对象拷贝了n的值供&lt;code&gt;sum()&lt;/code&gt;计算，如果传地址或者引用就可以直接修改栈帧中的值。&lt;br&gt;这就可以解释为什么按值传递时不能修改上一级函数的数值，因为栈帧会还原，按值传递修改的也不是栈帧中的值。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;函数原型&quot;&gt;&lt;a href=&quot;#函数原型&quot; class=&quot;headerlink&quot; title=&quot;函数原型&quot;&gt;&lt;/a&gt;函数原型&lt;/h2&gt;&lt;h3 id=&quot;为什么需要原型&quot;&gt;&lt;a href=&quot;#为什么需要原型&quot; class=&quot;headerlink&quot; title=&quot;为什么
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="函数原型" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>类的复制构造函数和赋值运算符重载</title>
    <link href="http://yoursite.com/2016/04/18/%E7%B1%BB%E7%9A%84%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <id>http://yoursite.com/2016/04/18/类的复制构造函数和赋值运算符重载/</id>
    <published>2016-04-18T03:51:12.000Z</published>
    <updated>2016-04-18T08:54:33.333Z</updated>
    
    <content type="html">&lt;p&gt;C++会自动提供以下成员函数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;默认构造函数；&lt;/li&gt;
&lt;li&gt;默认析构函数&lt;/li&gt;
&lt;li&gt;复制构造函数&lt;/li&gt;
&lt;li&gt;赋值运算符&lt;/li&gt;
&lt;li&gt;地址运算符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之前讨论过构造函数与析构函数，今天讨论复制构造函数与赋值运算符。&lt;/p&gt;
&lt;h2 id=&quot;类的复制构造函数&quot;&gt;&lt;a href=&quot;#类的复制构造函数&quot; class=&quot;headerlink&quot; title=&quot;类的复制构造函数&quot;&gt;&lt;/a&gt;类的复制构造函数&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;作用：复制构造函数用于将一个对象复制到新创建的对象中。也就是用于初始化过程（包括按值传递）,而不是常规的赋值过程。&lt;strong&gt;隐式构造函数&lt;font color=&quot;red&quot;&gt;按值&lt;/font&gt;逐个复制非静态成员&lt;/strong&gt;,静态成员属于整个类，不属于某一个对象，因此不受影响。&lt;/li&gt;
&lt;li&gt;何时调用：新建一个对象并将其初始化为同类现有对象。有以下四种可能语法：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;StringBad ditto(motto)&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StringBad *pStringBad = new StringBad(motto)&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StringBad metoo = motto&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StringBad also = StringBad(motto)&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1、2两种声明没有临时匿名对象(或者说临时匿名对象有外部载体);3、4两种声明值是接创建metoo和also还是用复制构造函数构造临时对象然后对象赋值给metoo和also，取决于具体实现。&lt;font color=&quot;red&quot;&gt;特点是有赋值运算符的非指针构造&lt;/font&gt;，在本人的编译器上(VS2012 32)是有临时对象并析构的。&lt;/p&gt;
&lt;h4 id=&quot;注：&quot;&gt;&lt;a href=&quot;#注：&quot; class=&quot;headerlink&quot; title=&quot;注：&quot;&gt;&lt;/a&gt;注：&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;无论哪种编译器，按值传递和返回对象时，都将调用复制构造函数。&lt;/li&gt;
&lt;li&gt;由于1，复制构造函数必须&lt;strong&gt;接受类对象的常量引用&lt;/strong&gt;作为参数，否则会无限递归调用自身导致堆栈溢出。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;默认复制构造函数的缺陷-浅复制&quot;&gt;&lt;a href=&quot;#默认复制构造函数的缺陷-浅复制&quot; class=&quot;headerlink&quot; title=&quot;默认复制构造函数的缺陷(浅复制)&quot;&gt;&lt;/a&gt;默认复制构造函数的缺陷(浅复制)&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;对象计数器：默认构造函数+显式构造函数+显式构造函数=析构函数。&lt;/li&gt;
&lt;li&gt;隐式复制构造函数是&lt;strong&gt;按值复制&lt;/strong&gt;，对于指针指向的new出来的空间，它会使两个指针指向同一块内容，因此在析构时，编译器尝试两次释放同一块内存，这会导致不确定的可能有害的结果。必须定义一个显式复制构造函数给指针开辟新的内存、&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;类的复制运算符重载-深度复制&quot;&gt;&lt;a href=&quot;#类的复制运算符重载-深度复制&quot; class=&quot;headerlink&quot; title=&quot;类的复制运算符重载(深度复制)&quot;&gt;&lt;/a&gt;类的复制运算符重载(深度复制)&lt;/h2&gt;&lt;p&gt;C++的类对象赋值通过自动为类重载赋值运算符实现。赋值运算符是只能由类成员函数重载的运算符之一。&lt;br&gt;如上所说四种新建对象方法，&lt;em&gt;8初始化时总会调用复制构造函数，而是用&lt;code&gt;=&lt;/code&gt;运算符也允许调用赋值运算符。&lt;/em&gt;但是！赋值运算符的隐式实现也是对成员逐个赋值。那么如上也有两次析构的问题，因此应该提供赋值运算符进行深度复制。&lt;br&gt;其与复制构造函数的差别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;应该首先检查自我复制，相同返回自身。否则未复制前释放了自身；&lt;/li&gt;
&lt;li&gt;释放拷贝对象之前引用的数据，否则会内存泄露(因为要深度复制会申请新的内存空间并指向他进行数据拷贝，之前的内存指针就丢失了)。&lt;/li&gt;
&lt;li&gt;返回一个指向调用对象的引用以便连续赋值。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面这个例子同时犯了复制构造函数和赋值运算符重载的浅复制错误：&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/OwHR2qp.png&quot; alt=&quot;典型的浅复制错误&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;思考&quot;&gt;&lt;a href=&quot;#思考&quot; class=&quot;headerlink&quot; title=&quot;思考&quot;&gt;&lt;/a&gt;思考&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;为什么赋值运算符重载返回类型是引用？之前在&lt;code&gt;*this&lt;/code&gt;指针中提过，返回类型为引用意味着返回对象本身而不是其副本。这样在一些含有赋值运算符的初始化中也可以防止递归调用。&lt;/li&gt;
&lt;li&gt;为什么参数类型为引用？对&lt;em&gt;复制构造函数&lt;/em&gt;和&lt;em&gt;赋值运算符重载&lt;/em&gt;，都是为了防止递归调用。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;C++会自动提供以下成员函数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;默认构造函数；&lt;/li&gt;
&lt;li&gt;默认析构函数&lt;/li&gt;
&lt;li&gt;复制构造函数&lt;/li&gt;
&lt;li&gt;赋值运算符&lt;/li&gt;
&lt;li&gt;地址运算符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之前讨论过构造函数与析构函数，今天讨论复制构造函
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="类" scheme="http://yoursite.com/tags/%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>vector之resize方法和reverse方法</title>
    <link href="http://yoursite.com/2016/04/15/vector%E4%B9%8Bresize%E6%96%B9%E6%B3%95%E5%92%8Creverse%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/04/15/vector之resize方法和reverse方法/</id>
    <published>2016-04-15T06:39:13.000Z</published>
    <updated>2016-04-19T12:59:02.834Z</updated>
    
    <content type="html">&lt;h2 id=&quot;a-resize-和a-reverse&quot;&gt;&lt;a href=&quot;#a-resize-和a-reverse&quot; class=&quot;headerlink&quot; title=&quot;a.resize()和a.reverse();&quot;&gt;&lt;/a&gt;a.resize()和a.reverse();&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;首先介绍容器的两个属性&lt;code&gt;capacity&lt;/code&gt;和&lt;code&gt;size&lt;/code&gt;。&lt;code&gt;capacity&lt;/code&gt;存储区的大小；&lt;code&gt;size&lt;/code&gt;容器的大小。&lt;/li&gt;
&lt;li&gt;‘reverse()’是预分配存储区的大小，预分配存储区，但存储区不一定有容器对象。&lt;/li&gt;
&lt;li&gt;‘resize()’是改变容器大小，容器中一定有容器对象。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&quot;a-reverse&quot;&gt;&lt;a href=&quot;#a-reverse&quot; class=&quot;headerlink&quot; title=&quot;a.reverse();&quot;&gt;&lt;/a&gt;a.reverse();&lt;/h3&gt;&lt;p&gt;看源码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void reserve(size_type _Count)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;	// determine new minimum length of allocated storage&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if (capacity() &amp;lt; _Count)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#123;// something to do, check and reallocate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if (max_size() &amp;lt; _Count)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			Xlen();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		_Reallocate(_Count);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;没有&lt;code&gt;else&lt;/code&gt;，说明若当前的&lt;code&gt;capacity&lt;/code&gt;大于传入的值，&lt;strong&gt;&lt;code&gt;capacity&lt;/code&gt;是不会减小的&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;里层的if是错误检测机制；&lt;/li&gt;
&lt;li&gt;验证&lt;code&gt;vector&lt;/code&gt;的&lt;code&gt;reallocate&lt;/code&gt;原理，实际上每次新的&lt;code&gt;capacity&lt;/code&gt;是之前的1.5倍。因此在&lt;strong&gt;循环之前一定要&lt;code&gt;reserve&lt;/code&gt;保证效率&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&quot;a-resize&quot;&gt;&lt;a href=&quot;#a-resize&quot; class=&quot;headerlink&quot; title=&quot;a.resize();&quot;&gt;&lt;/a&gt;a.resize();&lt;/h3&gt;&lt;p&gt;模板类提供了两个函数重载：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;表达式&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;strong&gt;返回类型&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;a.resize(n)&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;void&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;容器大小设为n&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;a.resize(n,t)&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;void&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;容器大小设为n，必要时用t填充&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&quot;a-resize-n&quot;&gt;&lt;a href=&quot;#a-resize-n&quot; class=&quot;headerlink&quot; title=&quot;a.resize(n)&quot;&gt;&lt;/a&gt;a.resize(n)&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void resize(size_type _Newsize)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;	// determine new length, padding as needed&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if (_Newsize &amp;lt; size())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		erase(begin() + _Newsize, end());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	else if (size() &amp;lt; _Newsize)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#123;	// pad as needed&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		_Alty _Alval(this-&amp;gt;_Getal());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		_Reserve(_Newsize - size());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		_TRY_BEGIN&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		_Uninitialized_default_fill_n(this-&amp;gt;_Mylast, _Newsize - size(),_Alval);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		_CATCH_ALL&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		_Tidy();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		_RERAISE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		_CATCH_END&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		this-&amp;gt;_Mylast += _Newsize - size();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;若容器新大小小于现在的大小，毁掉多余的对象；&lt;/li&gt;
&lt;li&gt;新大小大于现在的大小：&lt;ul&gt;
&lt;li&gt;注意&lt;code&gt;_Reserve&lt;/code&gt;和&lt;code&gt;.reverse&lt;/code&gt;是两个不同的方法，一个比较&lt;code&gt;capacity&lt;/code&gt;，一个比较&lt;code&gt;_Unused_capacity&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;检查空间，不够则&lt;code&gt;reverse&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;填充未初始化的对象&lt;/li&gt;
&lt;li&gt;修改尾指针&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;####a.resize(n,t)&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void resize(size_type _Newsize, const value_type&amp;amp; _Val)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;	// determine new length, padding with _Val elements as needed&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if (_Newsize &amp;lt; size())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		erase(begin() + _Newsize, end());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	else if (size() &amp;lt; _Newsize)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		_Insert_n(end(), _Newsize - size(), _Val);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若容器新大小小于现在的大小，毁掉多余的对象；&lt;/li&gt;
&lt;li&gt;新大小大于现在的大小，直接执行&lt;code&gt;insert&lt;/code&gt;;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;a-resize-和a-reverse&quot;&gt;&lt;a href=&quot;#a-resize-和a-reverse&quot; class=&quot;headerlink&quot; title=&quot;a.resize()和a.reverse();&quot;&gt;&lt;/a&gt;a.resize()和a.reverse();&lt;/
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="STL-vector" scheme="http://yoursite.com/tags/STL-vector/"/>
    
  </entry>
  
  <entry>
    <title>vector之erase方法</title>
    <link href="http://yoursite.com/2016/04/14/vector%E4%B9%8Berase%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/04/14/vector之erase方法/</id>
    <published>2016-04-14T02:52:25.000Z</published>
    <updated>2016-04-19T12:58:01.742Z</updated>
    
    <content type="html">&lt;h2 id=&quot;a-erase&quot;&gt;&lt;a href=&quot;#a-erase&quot; class=&quot;headerlink&quot; title=&quot;a.erase();&quot;&gt;&lt;/a&gt;a.erase();&lt;/h2&gt;&lt;p&gt;模板类提供了两个函数重载：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;表达式&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;strong&gt;返回类型&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;a.erase(p)&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;strong&gt;迭代器&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;删除p指向的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;a.erase(p,q)&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;strong&gt;迭代器&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;删除区间[p,q)中的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;思考&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在之前内存之中讨论过，&lt;code&gt;vector&lt;/code&gt;是保证内存连续的，那么&lt;code&gt;erase&lt;/code&gt;之后他是如何保证内存连续的？答案是让该元素之后的所有元素前移补充“空位”。这一点在&lt;code&gt;erase()&lt;/code&gt;方法的代码中可以看到传入的p的形参是&lt;code&gt;const&lt;/code&gt;类型的，也就是说p指向的地址并不发生变化，只不过是元素前移了。测试如下：&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/TZxRRb6.png&quot; alt=&quot;STL的迭代器&quot;&gt;&lt;/li&gt;
&lt;li&gt;注意到&lt;code&gt;erase&lt;/code&gt;返回的都是迭代器，由1中的分析可知，删除p指向的元素之后，他返回的迭代器的&lt;strong&gt;地址不变&lt;/strong&gt;，值是删除之后可用的下一个元素，因此&lt;strong&gt;给人感觉是p指向了下一个元素&lt;/strong&gt;。那么在这里有一个值得注意的问题，如下：&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vector&amp;lt;int&amp;gt;::iterator p = b.begin();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for (;p!=b.end();p++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if (*p == 2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		b.erase(p);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这是错误的，&lt;code&gt;b.erase(p)&lt;/code&gt;没有迭代器来承接p的返回值，它的返回值被释放了。然后执行p++很显然会出现野指针。但是如果修改为&lt;code&gt;p = b.erase(p)&lt;/code&gt;也是不正确的。迭代器在进行删除的这一个循环里会&lt;code&gt;++&lt;/code&gt;两次（&lt;code&gt;erase&lt;/code&gt;可以当做&lt;code&gt;++&lt;/code&gt;一次）。但如果在&lt;code&gt;if&lt;/code&gt;语句中执行一次&lt;code&gt;p--&lt;/code&gt;，这是正确的。即&lt;code&gt;p = b.erase(p--);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;迭代器的循环使用&lt;code&gt;while&lt;/code&gt;可以降低错误率。&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;为简单，分析第一个表达式的源码如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;iterator erase(const_iterator _Where)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;	// erase element at where&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if (_VICONT(_Where) != this&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		|| _VIPTR(_Where) &amp;lt; this-&amp;gt;_Myfirst&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		|| this-&amp;gt;_Mylast &amp;lt;= _VIPTR(_Where))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		_DEBUG_ERROR(&amp;quot;vector erase iterator outside range&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	_Move(_VIPTR(_Where) + 1, this-&amp;gt;_Mylast, _VIPTR(_Where));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	_Destroy(this-&amp;gt;_Mylast - 1, this-&amp;gt;_Mylast);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	_Orphan_range(_VIPTR(_Where), this-&amp;gt;_Mylast);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	--this-&amp;gt;_Mylast;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return (_Make_iter(_Where));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以看到他做了哪些工作,首先元素前移，然后毁掉最后一个对象(&lt;code&gt;capacity&lt;/code&gt;不变)，之后&lt;font color=&quot;red&quot;&gt;_Orphan_range发生了什么？&lt;/font&gt;,接下来指针指向正确的位置，最后返回指向原地址的迭代器。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;a-erase&quot;&gt;&lt;a href=&quot;#a-erase&quot; class=&quot;headerlink&quot; title=&quot;a.erase();&quot;&gt;&lt;/a&gt;a.erase();&lt;/h2&gt;&lt;p&gt;模板类提供了两个函数重载：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th s
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="STL-vector" scheme="http://yoursite.com/tags/STL-vector/"/>
    
  </entry>
  
  <entry>
    <title>vector之insert方法和emplace方法</title>
    <link href="http://yoursite.com/2016/04/13/vector%E4%B9%8Binsert%E6%96%B9%E6%B3%95%E5%92%8Cemplace%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/04/13/vector之insert方法和emplace方法/</id>
    <published>2016-04-13T12:39:29.000Z</published>
    <updated>2016-04-19T12:58:59.205Z</updated>
    
    <content type="html">&lt;h2 id=&quot;a-insert&quot;&gt;&lt;a href=&quot;#a-insert&quot; class=&quot;headerlink&quot; title=&quot;a.insert();&quot;&gt;&lt;/a&gt;a.insert();&lt;/h2&gt;&lt;p&gt;模板类提供了三个函数重载,这是一种&lt;strong&gt;拷贝&lt;/strong&gt;插入方法：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;表达式&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;返回类型&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;a.insert(p,t)&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;迭代器&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;指向原本指向的元素,将t插入到p前面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;a.insert(p, n,t)&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将n个t插入到p前面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;a.insert(p,i,j)&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将区间[i,j)插入到p的前面，注意是左闭右开区间，j可以是超尾&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&quot;a-emplace&quot;&gt;&lt;a href=&quot;#a-emplace&quot; class=&quot;headerlink&quot; title=&quot;a.emplace();&quot;&gt;&lt;/a&gt;a.emplace();&lt;/h2&gt;&lt;p&gt;新标准引入的&lt;code&gt;emplace_front&lt;/code&gt;,&lt;code&gt;emplace&lt;/code&gt;,&lt;code&gt;emplace_back&lt;/code&gt;这些操作是构造而不是拷贝元素。当插入一个对象时，将会比&lt;code&gt;insert&lt;/code&gt;少拷贝构造，析构的步骤。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;注：&quot;&gt;&lt;a href=&quot;#注：&quot; class=&quot;headerlink&quot; title=&quot;注：&quot;&gt;&lt;/a&gt;注：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;调用&lt;code&gt;push&lt;/code&gt;或&lt;code&gt;insert&lt;/code&gt;成员函数，将元素类型对象传递进去，这些对象被拷贝到容器中；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;emplace()&lt;/code&gt;在容器中构造元素，因此效率更高；&lt;/li&gt;
&lt;li&gt;注意&lt;code&gt;a.insert(p,t)&lt;/code&gt;的源码提供了一个重载，若t是普通类型，则调用&lt;code&gt;a.emplace(p，t)&lt;/code&gt;，若t是&lt;code&gt;const&lt;/code&gt;类型，则调用&lt;code&gt;a.insert(p,t)&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;a-insert&quot;&gt;&lt;a href=&quot;#a-insert&quot; class=&quot;headerlink&quot; title=&quot;a.insert();&quot;&gt;&lt;/a&gt;a.insert();&lt;/h2&gt;&lt;p&gt;模板类提供了三个函数重载,这是一种&lt;strong&gt;拷贝&lt;/strong&gt;插入方法
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="STL-vector" scheme="http://yoursite.com/tags/STL-vector/"/>
    
  </entry>
  
  <entry>
    <title>vector简介及非STL函数用法-持续更新</title>
    <link href="http://yoursite.com/2016/04/12/vector%E7%AE%80%E4%BB%8B%E5%8F%8A%E9%9D%9ESTL%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <id>http://yoursite.com/2016/04/12/vector简介及非STL函数用法-持续更新/</id>
    <published>2016-04-12T06:54:50.000Z</published>
    <updated>2016-04-18T08:59:53.542Z</updated>
    
    <content type="html">&lt;h2 id=&quot;vector&quot;&gt;&lt;a href=&quot;#vector&quot; class=&quot;headerlink&quot; title=&quot;vector&quot;&gt;&lt;/a&gt;vector&lt;/h2&gt;&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;模板类是最简单的序列类型，除非其他类型的特殊有点能够满足程序的要求，否则应该默认使用这种类型。以后将记录一些在编程过程中常用的&lt;code&gt;vector&lt;/code&gt;方法作为笔记以便不时复习，必要时会分析源码。&lt;/p&gt;
&lt;p&gt;常见的方法有：&lt;br&gt;&lt;code&gt;.insert()&lt;/code&gt;，&lt;code&gt;a.emplace()&lt;/code&gt;，&lt;code&gt;.resize()&lt;/code&gt;，&lt;code&gt;.reverse()&lt;/code&gt;，&lt;code&gt;.begin()&lt;/code&gt;，&lt;code&gt;a.end()&lt;/code&gt;，&lt;code&gt;a.rbegin()&lt;/code&gt;，&lt;br&gt;&lt;code&gt;a.rend()&lt;/code&gt;，&lt;code&gt;a.size()&lt;/code&gt;，&lt;code&gt;a.swap(b)&lt;/code&gt;，&lt;code&gt;a.empty()&lt;/code&gt;，&lt;code&gt;a.front()&lt;/code&gt;，&lt;code&gt;a.back()&lt;/code&gt;，&lt;code&gt;a.clear()&lt;/code&gt;，&lt;br&gt;&lt;code&gt;a.push_back(t)&lt;/code&gt;，&lt;code&gt;a.popback(t)&lt;/code&gt;，&lt;code&gt;a[n]&lt;/code&gt;，&lt;code&gt;a.at(n)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;有&lt;code&gt;vector&amp;lt;int&amp;gt; a&lt;/code&gt;;&lt;code&gt;vector&amp;lt;int&amp;gt; b&lt;/code&gt;;即a,b是&lt;code&gt;vector&amp;lt;int&amp;gt;&lt;/code&gt;的对象。&lt;code&gt;vector&amp;lt;int&amp;gt; ::iterator p&lt;/code&gt;;p是指向&lt;code&gt;vector&amp;lt;int&amp;gt;&lt;/code&gt;的迭代器。i、j、q均和p一样是指向&lt;code&gt;vector&amp;lt;int&amp;gt;&lt;/code&gt;的迭代器。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;sort-用于vector&quot;&gt;&lt;a href=&quot;#sort-用于vector&quot; class=&quot;headerlink&quot; title=&quot;sort()用于vector;&quot;&gt;&lt;/a&gt;sort()用于vector;&lt;/h2&gt;&lt;p&gt;在&lt;code&gt;algorithm&amp;gt;&lt;/code&gt;头文件中提供了&lt;code&gt;sort&lt;/code&gt;的两个重载函数,查看源码可发现是用&lt;strong&gt;快排&lt;/strong&gt;实现的。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;表达式&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;strong&gt;返回类型&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;sort(p,q)&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;对[p,q)升序排序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;sort(p,q,cmp)&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;对[p,q)使用&lt;code&gt;cmp&lt;/code&gt;方法排序，&lt;code&gt;cmp&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol&gt;
&lt;li&gt;右闭左开区间，一般来讲&lt;code&gt;p = a.begin()&lt;/code&gt;;&lt;code&gt;q = a.end()&lt;/code&gt;完成了对容器的排序。&lt;/li&gt;
&lt;li&gt;升序排序直接用第一个方法，系统默认&lt;code&gt;a&amp;lt;b&lt;/code&gt;返回真，因此是升序。&lt;/li&gt;
&lt;li&gt;降序排序需要自定义&lt;code&gt;cmp&lt;/code&gt;方法,方法如下，只需要将默认值改为&lt;code&gt;a&amp;gt;b&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bool comp(const int &amp;amp;a,const int &amp;amp;b)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  		return a&amp;gt;b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;以上参考了&lt;a href=&quot;http://www.cnblogs.com/cj695/p/3863142.html&quot; title=&quot;这里&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;vector&quot;&gt;&lt;a href=&quot;#vector&quot; class=&quot;headerlink&quot; title=&quot;vector&quot;&gt;&lt;/a&gt;vector&lt;/h2&gt;&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;模板类是最简单的序列类型，除非其他类型的特殊有点能够满足程序的要求，否
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="STL-vector" scheme="http://yoursite.com/tags/STL-vector/"/>
    
  </entry>
  
  <entry>
    <title>类的this指针</title>
    <link href="http://yoursite.com/2016/04/12/%E7%B1%BB%E7%9A%84this%E6%8C%87%E9%92%88/"/>
    <id>http://yoursite.com/2016/04/12/类的this指针/</id>
    <published>2016-04-12T01:08:44.000Z</published>
    <updated>2016-04-18T08:58:12.335Z</updated>
    
    <content type="html">&lt;h2 id=&quot;C-类的this指针&quot;&gt;&lt;a href=&quot;#C-类的this指针&quot; class=&quot;headerlink&quot; title=&quot;C++类的this指针&quot;&gt;&lt;/a&gt;C++类的this指针&lt;/h2&gt;&lt;p&gt;如图，假设有一个类&lt;code&gt;Stock&lt;/code&gt;，他有一个&lt;code&gt;private：int val&lt;/code&gt;。他还有一个方法&lt;code&gt;const Stock&amp;amp; Stock::compare(const Stock &amp;amp;classIn) const&lt;/code&gt;;这个方法要实现这样的功能：对于两个类&lt;code&gt;Stock&lt;/code&gt;的对象a和b，比较a的&lt;code&gt;val&lt;/code&gt;和b的&lt;code&gt;val&lt;/code&gt;，返回&lt;code&gt;val&lt;/code&gt;大的对象(a或者b)，可能性的写法如下：&lt;code&gt;a.compare(b)&lt;/code&gt;。由于在类的方法定义中，还没有具体对象(a)。那么有这样一个问题，在方法&lt;code&gt;compare&lt;/code&gt;中，如何返回以后才初始化的对象本身(也就是a)？&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/qChOATG.png&quot; alt=&quot;为什么使用this指针&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一般来说，所有类方法都将&lt;code&gt;this&lt;/code&gt;指针设置为调用它的&lt;strong&gt;地址&lt;/strong&gt;。(因此返回对象使用&lt;strong&gt;&lt;code&gt;*this&lt;/code&gt;&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compare&lt;/code&gt;方法返回类型是&lt;em&gt;指针意味着返回的是调用对象本身，而不是其副本&lt;/em&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compare&lt;/code&gt;方法的最后一个&lt;code&gt;const&lt;/code&gt;表示该方法不会修改隐式访问对象(即调用该方法的对象本身)，这在之前的博客中提到过。&lt;/li&gt;
&lt;li&gt;形参列表中的&lt;code&gt;const&lt;/code&gt;表示该函数不会修改被显示访问的对象(即图中的s)。&lt;/li&gt;
&lt;li&gt;由于该函数返回了两个&lt;code&gt;const&lt;/code&gt;对象之一的引用，因此&lt;strong&gt;返回类型也应该是&lt;code&gt;const&lt;/code&gt;引用&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/CzuJ4fG.png&quot; alt=&quot;this的实例&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;C-类的this指针&quot;&gt;&lt;a href=&quot;#C-类的this指针&quot; class=&quot;headerlink&quot; title=&quot;C++类的this指针&quot;&gt;&lt;/a&gt;C++类的this指针&lt;/h2&gt;&lt;p&gt;如图，假设有一个类&lt;code&gt;Stock&lt;/code&gt;，他有一个&lt;cod
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="类" scheme="http://yoursite.com/tags/%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>溢出</title>
    <link href="http://yoursite.com/2016/04/11/%E6%BA%A2%E5%87%BA/"/>
    <id>http://yoursite.com/2016/04/11/溢出/</id>
    <published>2016-04-11T12:35:24.000Z</published>
    <updated>2016-04-18T08:59:18.191Z</updated>
    
    <content type="html">&lt;h2 id=&quot;数值溢出原理&quot;&gt;&lt;a href=&quot;#数值溢出原理&quot; class=&quot;headerlink&quot; title=&quot;数值溢出原理&quot;&gt;&lt;/a&gt;数值溢出原理&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/W3CYdOb.png&quot; alt=&quot;数值圆图&quot;&gt;&lt;br&gt;C++Plus在P44已经说的很清楚，如下。&lt;br&gt;有几点需要注意的地方：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;上图下图中的圆在进行&lt;strong&gt;强制类型转化&lt;/strong&gt;时也是&lt;strong&gt;对应&lt;/strong&gt;的，这就是说&lt;code&gt;(uchar)-1 = 65535&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;无符号数没有溢出，只有&lt;strong&gt;进/借位&lt;/strong&gt;(微机原理&lt;code&gt;CF&lt;/code&gt;标示)，因为C++确保无符号数类型超越限制后在另一极端取值的行为。&lt;/li&gt;
&lt;li&gt;有符号数没有进/借位，只有&lt;strong&gt;溢出&lt;/strong&gt;(微机原理&lt;code&gt;OF&lt;/code&gt;标示)，因为C++无法确保有符号数上溢下溢后在另一极端取值的行为。(在我测试的时候并没有发现违背这一现象，可能有特殊情况)。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;运算溢出&quot;&gt;&lt;a href=&quot;#运算溢出&quot; class=&quot;headerlink&quot; title=&quot;运算溢出&quot;&gt;&lt;/a&gt;运算溢出&lt;/h2&gt;&lt;h3 id=&quot;判断加法溢出&quot;&gt;&lt;a href=&quot;#判断加法溢出&quot; class=&quot;headerlink&quot; title=&quot;判断加法溢出&quot;&gt;&lt;/a&gt;判断加法溢出&lt;/h3&gt;&lt;p&gt;可以像这里一样分情况或者根据圆图分析，会发现&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;所有上溢结果都小于任何一个操作数；&lt;/li&gt;
&lt;li&gt;所有下溢结果都大于任何一个操作数。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;判断乘法溢出&quot;&gt;&lt;a href=&quot;#判断乘法溢出&quot; class=&quot;headerlink&quot; title=&quot;判断乘法溢出&quot;&gt;&lt;/a&gt;判断乘法溢出&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;在这里提到，可以用检测&lt;code&gt;a*b/b&lt;/code&gt;是否等于a来判断是否乘法溢出；&lt;/li&gt;
&lt;li&gt;在这里提到，可以先扩展再强制类型转化到低位，在判断是否相等来判断。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;值得注意的是，在之前的帖子中提到过判断是否相等对&lt;strong&gt;浮点数&lt;/strong&gt;和整型的判断方式是不一样的。&lt;/p&gt;
&lt;h3 id=&quot;除零是不是溢出？&quot;&gt;&lt;a href=&quot;#除零是不是溢出？&quot; class=&quot;headerlink&quot; title=&quot;除零是不是溢出？&quot;&gt;&lt;/a&gt;除零是不是溢出？&lt;/h3&gt;&lt;p&gt;任何数除以零的计算“不是”算术溢出的一种。在数学上只能明显算是不明确的定义；它计算出来的结果只能当成是“没有”值，而不是非常大的无限数值。&lt;/p&gt;
&lt;p&gt;应付溢出最佳的方法还是防范，充分了解数据类型，选择恰当的变量类型。比如，&lt;code&gt;c = a*b&lt;/code&gt;一般都会选择c的长度为a的长度与b的长度之和。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;堆栈溢出&quot;&gt;&lt;a href=&quot;#堆栈溢出&quot; class=&quot;headerlink&quot; title=&quot;堆栈溢出&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%A0%86%E7%96%8A%E6%BA%A2%E4%BD%8D&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;堆栈溢出&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;一般编译器默认的堆栈内存是1MB，若使用过多的堆栈内存时就会导致调用堆栈产生的溢出。一般产生于递归，或者静态申请过多的临时变量，比如&lt;code&gt;int a[1024[1024]&lt;/code&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若是静态内存导致的堆栈溢出，可以用动态申请使用堆内存。&lt;/li&gt;
&lt;li&gt;若是递归调用导致递归堆栈无法容纳调用的返回地址，要添加错误检查机制。注意数据类型或用循环处理来避免堆栈溢出。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;缓冲区溢出&quot;&gt;&lt;a href=&quot;#缓冲区溢出&quot; class=&quot;headerlink&quot; title=&quot;缓冲区溢出&quot;&gt;&lt;/a&gt;缓冲区溢出&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://jingyan.baidu.com/article/e9fb46e1acc1267521f76633.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;缓冲区溢出&lt;/a&gt;源于这样一个编程错误：复制一个内存区域的内容到另一个内存区域，而目标内存区域容量太小无法容纳。它允许传入函数的内存块以一种特定方式修改堆栈。&lt;/p&gt;
&lt;p&gt;此外的溢出还包括&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%AE%97%E6%9C%AF%E4%B8%8B%E6%BA%A2&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;算术下溢&lt;/a&gt;(浮点数溢出)等。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数值溢出原理&quot;&gt;&lt;a href=&quot;#数值溢出原理&quot; class=&quot;headerlink&quot; title=&quot;数值溢出原理&quot;&gt;&lt;/a&gt;数值溢出原理&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/W3CYdOb.png&quot; alt=&quot;数值圆图&quot;&gt;&lt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="溢出" scheme="http://yoursite.com/tags/%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>数据存储与二进制运算</title>
    <link href="http://yoursite.com/2016/04/09/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BF%90%E7%AE%97/"/>
    <id>http://yoursite.com/2016/04/09/数据存储与二进制运算/</id>
    <published>2016-04-09T12:07:02.000Z</published>
    <updated>2016-04-18T09:01:30.103Z</updated>
    
    <content type="html">&lt;h2 id=&quot;数据存储&quot;&gt;&lt;a href=&quot;#数据存储&quot; class=&quot;headerlink&quot; title=&quot;数据存储&quot;&gt;&lt;/a&gt;数据存储&lt;/h2&gt;&lt;h3 id=&quot;原、反、补码&quot;&gt;&lt;a href=&quot;#原、反、补码&quot; class=&quot;headerlink&quot; title=&quot;原、反、补码&quot;&gt;&lt;/a&gt;原、反、补码&lt;/h3&gt;&lt;p&gt;计算机为方便计算，内存中的数据都是以补码的形式储存、运算。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;数&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;原码&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;反码&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;补码&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;正数&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;二进制表示&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;与原码相同&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;与原码相同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;负数&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;对应正数符号位（最高位）置1&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;负数原码&lt;strong&gt;非符号位&lt;/strong&gt;按位取反&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;负数反码加1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;举个例子，数据类型为&lt;code&gt;char&lt;/code&gt;：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;原数字&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;原码&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;反码&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;补码&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;+3&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;00000011&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;00000011&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;00000011&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;-3&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;10000011&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;11111100&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;11111101&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;值得注意的是，如果这个数据为&lt;code&gt;unsigned char&lt;/code&gt;，&lt;code&gt;11111101&lt;/code&gt;对应的是253，这里涉及到溢出，详细讨论见下一博客。&lt;/p&gt;
&lt;h3 id=&quot;消失的原码&quot;&gt;&lt;a href=&quot;#消失的原码&quot; class=&quot;headerlink&quot; title=&quot;消失的原码&quot;&gt;&lt;/a&gt;消失的原码&lt;/h3&gt;&lt;p&gt;对于&lt;code&gt;unsigned char&lt;/code&gt;原反补相同，计算机存储的补码就是原码，原码二进制经典编码有256个；但是对于&lt;code&gt;signed char&lt;/code&gt;，最高位是符号位，因此原码的取值范围是-127-127，只有&lt;strong&gt;255个编码&lt;/strong&gt;，但是对内存来说，8bits可以编码256个，那多余的补码与消失的原码去了哪里？&lt;/p&gt;
&lt;p&gt;考虑到编码效率，补码与原码必须是一一对应的关系。很容易想到在有符号数中有&lt;code&gt;00000000&lt;/code&gt;、&lt;code&gt;10000000&lt;/code&gt;两个原码表示+0与-0，而这是没有意义的。我们保证&lt;code&gt;00000000&lt;/code&gt;这个原码与&lt;code&gt;00000000&lt;/code&gt;这个补码相对应来表示0就可以。这样找到了消失的原码：&lt;code&gt;10000000&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在这个基于256的数值域中，观察补码的&lt;strong&gt;重置点（溢出中非常重要的概念）&lt;/strong&gt;127的补码&lt;code&gt;01111111&lt;/code&gt;，-127的补码&lt;code&gt;10000001&lt;/code&gt;，那么可以清楚的看到&lt;code&gt;127+1=？&lt;/code&gt;、&lt;code&gt;？+1=127&lt;/code&gt;。因此很好理解，多余的补码是&lt;code&gt;10000000&lt;/code&gt;（与消失的原码相同，通过计算他的原码可以得到验证）。那么剩下的事情就是设置重置点了，有两个选择，128或者-128。考虑到符号位是1，我们人为规定-128是重置点。即&lt;strong&gt;-128的原码&lt;/strong&gt;是&lt;code&gt;10000000&lt;/code&gt;，&lt;strong&gt;补码&lt;/strong&gt;也是&lt;code&gt;10000000&lt;/code&gt;（它的&lt;strong&gt;反码&lt;/strong&gt;是&lt;code&gt;11111111&lt;/code&gt;？）。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;二进制运算（移位得到CHAR-MAX和CHAR-MIN）&quot;&gt;&lt;a href=&quot;#二进制运算（移位得到CHAR-MAX和CHAR-MIN）&quot; class=&quot;headerlink&quot; title=&quot;二进制运算（移位得到CHAR_MAX和CHAR_MIN）&quot;&gt;&lt;/a&gt;二进制运算（移位得到CHAR_MAX和CHAR_MIN）&lt;/h2&gt;&lt;p&gt;明白上述数据存储概念之后，可以通过位运算来获得&lt;code&gt;char&lt;/code&gt;的最大最小值。注意，其实在&lt;code&gt;climit&lt;/code&gt;文件中有各种宏定义的最大最小值，比如&lt;code&gt;CHAR_MAX = 127&lt;/code&gt;;&lt;code&gt;UCHAR_MAX = 0xff&lt;/code&gt;;等。但是这里想利用位运算来实现这一目标(注意重置点)：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;CHAR_MAX&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;CHAR_MIN&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;unsigned char max = 0-1&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;unsigned char min = 0&lt;/code&gt;;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;char max = (1&amp;lt;&amp;lt;7)-1&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;char min = 1&amp;lt;&amp;lt;7&lt;/code&gt;(得到&lt;code&gt;10000000&lt;/code&gt;);&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol&gt;
&lt;li&gt;上述表格中&lt;code&gt;unsigned char max&lt;/code&gt;本质为&lt;code&gt;signed char = -1&lt;/code&gt;的强制类型转化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;char max&lt;/code&gt; 是利用重置点&lt;code&gt;CHAR_MIN&lt;/code&gt;得到&lt;code&gt;01111111&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;char min&lt;/code&gt; 是利用-128的特殊补码(而且与原码相同)赋值的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt;、&lt;code&gt;-&lt;/code&gt;运算的优先级是高于&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;、&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;的，因此&lt;code&gt;1&amp;lt;&amp;lt;7&lt;/code&gt;要加括号&lt;br&gt;注意右值中运算表达式中的数字默认都是&lt;code&gt;int&lt;/code&gt;类型的，这与C++整型提升有关，详情见另一篇博客。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另，由以上解读可以很容易的得出&lt;code&gt;abs(int_X)&lt;/code&gt;的工作原理，正数不变，负数求得原码后符号位取反，即原码也是补码。但是有&lt;strong&gt;例外&lt;/strong&gt;：&lt;code&gt;abs(INT_MIN) = INT_MIN&lt;/code&gt;。他是不变的。&lt;/p&gt;
&lt;p&gt;解读下边两式的区别（使用中&lt;code&gt;unsigned&lt;/code&gt;与&lt;code&gt;signed&lt;/code&gt;操作注意符号位扩充）：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;code&gt;char a = abs((char)(1&amp;lt;&amp;lt;7)-1)&lt;/code&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;code&gt;char b = abs((1&amp;lt;&amp;lt;7)-1)&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;(char)(1&amp;lt;&amp;lt;7)-1 = (int)-129&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;(1&amp;lt;&amp;lt;7)-1 = (int)127&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;1·&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;2·&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;a = -127&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;b = 127&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;11111111 11111111 11111111 10000000&lt;/code&gt;+&lt;code&gt;11111111 11111111 11111111 11111111&lt;/code&gt;=&lt;code&gt;11111111 11111111 11111111 01111111&lt;/code&gt;(&lt;code&gt;char&lt;/code&gt; 原码&lt;code&gt;10000001&lt;/code&gt;)    &lt;/li&gt;
&lt;li&gt;&lt;code&gt;00000000 00000000 00000000 1000000&lt;/code&gt;-&lt;code&gt;00000000 00000000 00000000 0000001&lt;/code&gt;=&lt;code&gt;00000000 00000000 00000000 01111111&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据存储&quot;&gt;&lt;a href=&quot;#数据存储&quot; class=&quot;headerlink&quot; title=&quot;数据存储&quot;&gt;&lt;/a&gt;数据存储&lt;/h2&gt;&lt;h3 id=&quot;原、反、补码&quot;&gt;&lt;a href=&quot;#原、反、补码&quot; class=&quot;headerlink&quot; title=&quot;原、反、补
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="存储" scheme="http://yoursite.com/tags/%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第一章：编程技巧说明</title>
    <link href="http://yoursite.com/2016/04/08/LeetCode%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%E8%AF%B4%E6%98%8E/"/>
    <id>http://yoursite.com/2016/04/08/LeetCode第一章：编程技巧说明/</id>
    <published>2016-04-08T11:44:02.000Z</published>
    <updated>2016-04-19T12:57:32.437Z</updated>
    
    <content type="html">&lt;h2 id=&quot;判断两个值a-b是否相等&quot;&gt;&lt;a href=&quot;#判断两个值a-b是否相等&quot; class=&quot;headerlink&quot; title=&quot;判断两个值a,b是否相等&quot;&gt;&lt;/a&gt;判断两个值a,b是否相等&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;若为整型，应该为&lt;code&gt;a==b&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;若为浮点型，应该用&lt;code&gt;fabs(a-b)&amp;lt;1e-9&lt;/code&gt;。(因为&lt;a href=&quot;http://0.30000000000000004.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;计算机中浮点型是不准确的&lt;/a&gt;，&lt;strong&gt;与因数有关&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;另外，对于&lt;code&gt;bool&lt;/code&gt;型，应该用&lt;code&gt;if(a)&lt;/code&gt;，&lt;code&gt;if(!b)&lt;/code&gt;这样的形式来强调变量&lt;code&gt;bool&lt;/code&gt;类型。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;判断一个整数是否为奇数&quot;&gt;&lt;a href=&quot;#判断一个整数是否为奇数&quot; class=&quot;headerlink&quot; title=&quot;判断一个整数是否为奇数&quot;&gt;&lt;/a&gt;判断一个整数是否为奇数&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;x%2 != 0&lt;/code&gt;用来判断一个整数是否是奇数，&lt;strong&gt;不能用&lt;code&gt;x%2 = 1&lt;/code&gt;&lt;/strong&gt;，因为x可能是负数，余数就是-1。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-3 = 2*-1+(-1)&lt;/code&gt;，即&lt;code&gt;-3/2 = -1&lt;/code&gt;;&lt;code&gt;-3%2= -1&lt;/code&gt;;说明负奇数余数是-1。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;char值做数组下标的强制类型转化&quot;&gt;&lt;a href=&quot;#char值做数组下标的强制类型转化&quot; class=&quot;headerlink&quot; title=&quot;char值做数组下标的强制类型转化&quot;&gt;&lt;/a&gt;char值做数组下标的强制类型转化&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;应该强制转化为&lt;code&gt;uchar&lt;/code&gt;，作为数组下标。不能直接转化为&lt;code&gt;uint&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;因为高位扩充有两种，有符号数扩充，在高位补符号位；无符号数高位直接用0。例如&lt;code&gt;char c = -1&lt;/code&gt;。c在计算机中的补码是&lt;code&gt;11111111&lt;/code&gt;。&lt;code&gt;uint a = c&lt;/code&gt;，那么&lt;code&gt;a = 4294967295&lt;/code&gt;。因为c有符号，扩充后高位补1。&lt;code&gt;uint b = (uchar) c&lt;/code&gt;。那么&lt;code&gt;b = 255&lt;/code&gt;。因为&lt;code&gt;(uchar) c&lt;/code&gt;是无符号数，高位用0扩充。&lt;/li&gt;
&lt;li&gt;二进制中有符号向无符号数的强制转化非常简单，将&lt;strong&gt;符号位置为0&lt;/strong&gt;。比如-2，原码是&lt;code&gt;10000010&lt;/code&gt;，反码是&lt;code&gt;11111101&lt;/code&gt;，补码是&lt;code&gt;11111110&lt;/code&gt;。将符号位置0，得到&lt;code&gt;01111110&lt;/code&gt;，为254。即&lt;code&gt;char -2&lt;/code&gt;强制转化成&lt;code&gt;uchar&lt;/code&gt;值为254。&lt;/li&gt;
&lt;li&gt;参照维基百科和C++plusP44&lt;strong&gt;圆图&lt;/strong&gt;可以更清楚了解更多数据储存与二进制运算。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;vector和string优先于动态数组的分配&quot;&gt;&lt;a href=&quot;#vector和string优先于动态数组的分配&quot; class=&quot;headerlink&quot; title=&quot;vector和string优先于动态数组的分配&quot;&gt;&lt;/a&gt;vector和string优先于动态数组的分配&lt;/h2&gt;&lt;p&gt;性能上，&lt;code&gt;vector&lt;/code&gt;保证内存（分配在堆）连续，一旦分配后，性能和原始数组相当；&lt;br&gt;用&lt;code&gt;new&lt;/code&gt;必须&lt;code&gt;delete&lt;/code&gt;，不然会&lt;code&gt;bug&lt;/code&gt;，代码行数不够短；&lt;br&gt;多维数组定义方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;new/delete&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int** array = new int*[row];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for(int i=0;i&amp;lt;row;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	array[i] = new int [col];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;:    &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; = array(row,vector&amp;lt;int&amp;gt;(col,0));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;使用reverse来避免不必要的重新分配&quot;&gt;&lt;a href=&quot;#使用reverse来避免不必要的重新分配&quot; class=&quot;headerlink&quot; title=&quot;使用reverse来避免不必要的重新分配&quot;&gt;&lt;/a&gt;使用reverse来避免&lt;a href=&quot;http://blog.csdn.net/bichenggui/article/details/4690175&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;不必要的重新分配&lt;/a&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;vector&lt;/code&gt;需要更多空间，以类似&lt;code&gt;realloc&lt;/code&gt;的思想来增长大小。分配，回收，拷贝和析构，这些步骤都很昂贵。并且每次这些步骤发生时，所有指向&lt;code&gt;vector&lt;/code&gt;或&lt;code&gt;string&lt;/code&gt;中的迭代器、指针和引用都会失效。&lt;/li&gt;
&lt;li&gt;据博客中所说，vector重新分配时容量翻倍。我在VS2012，WIN32编译器下结果如下，容量是翻&lt;em&gt;1.5&lt;/em&gt;倍的。因此在1000次&lt;code&gt;push_back&lt;/code&gt;中导致了18次重新分配。&lt;img src=&quot;http://i.imgur.com/ooqb6by.png&quot; alt=&quot;reverse()&quot;&gt;&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;容器被构造之后&lt;/strong&gt;进行&lt;strong&gt;&lt;code&gt;reserve&lt;/code&gt;设置容器容量&lt;/strong&gt;可以避免不必要的重新分配。&lt;code&gt;a.reserve(1000)&lt;/code&gt;即把a的容量设置为1000。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;判断两个值a-b是否相等&quot;&gt;&lt;a href=&quot;#判断两个值a-b是否相等&quot; class=&quot;headerlink&quot; title=&quot;判断两个值a,b是否相等&quot;&gt;&lt;/a&gt;判断两个值a,b是否相等&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;若为整型，应该为&lt;code&gt;a==b&lt;/code
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>类的构造函数与析构函数初探</title>
    <link href="http://yoursite.com/2016/04/07/%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%88%9D%E6%8E%A2/"/>
    <id>http://yoursite.com/2016/04/07/类的构造函数与析构函数初探/</id>
    <published>2016-04-07T11:03:11.000Z</published>
    <updated>2016-04-19T11:28:38.979Z</updated>
    
    <content type="html">&lt;h2 id=&quot;类的简介&quot;&gt;&lt;a href=&quot;#类的简介&quot; class=&quot;headerlink&quot; title=&quot;类的简介&quot;&gt;&lt;/a&gt;类的简介&lt;/h2&gt;&lt;h3 id=&quot;类的规范由两部分组成：&quot;&gt;&lt;a href=&quot;#类的规范由两部分组成：&quot; class=&quot;headerlink&quot; title=&quot;类的规范由两部分组成：&quot;&gt;&lt;/a&gt;类的规范由两部分组成：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;类声明（declaration） – 类的蓝图&lt;ul&gt;
&lt;li&gt;以数据成员的方式描述数据，以成员函数的方式描述公有接口；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据&lt;/strong&gt;通常放在私有部分，组成类接口的&lt;strong&gt;成员函数&lt;/strong&gt;放在公有部分，另外&lt;strong&gt;私有成员函数&lt;/strong&gt;用来处理不属于公有接口的实现细节。&lt;/li&gt;
&lt;li&gt;定义位于声明中的函数都将自动成为内联函数，若定义位于声明之外，使用&lt;code&gt;inline&lt;/code&gt;关键字成为内联函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;类方法定义 – 类的实现细节&lt;ul&gt;
&lt;li&gt;C++通常把接口（类声明）放在头文件中，并将实现（类方法代码）放在源代码中；&lt;/li&gt;
&lt;li&gt;定义成员函数时，使用作用域解析符（&lt;code&gt;::&lt;/code&gt;）来表示函数所属的类；&lt;/li&gt;
&lt;li&gt;类方法可以访问类的&lt;code&gt;private&lt;/code&gt;组件。&lt;/li&gt;
&lt;li&gt;只要类方法不修改调用对象，就应将其声明为&lt;code&gt;const&lt;/code&gt;，如&lt;code&gt;void Stock::show() const&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;类所创建的每个新对象都有自己的存储空间，用于存储其内部变量和类成员；但同一个类的所有对象&lt;strong&gt;共享同一组类方法&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;类成员的访问控制（封装）&quot;&gt;&lt;a href=&quot;#类成员的访问控制（封装）&quot; class=&quot;headerlink&quot; title=&quot;类成员的访问控制（封装）&quot;&gt;&lt;/a&gt;类成员的访问控制（封装）&lt;/h3&gt;&lt;p&gt;数据隐藏：防止程序直接访问数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如&lt;code&gt;int a&lt;/code&gt;是类的私有数据成员，&lt;code&gt;cout&amp;lt;&amp;lt;a&lt;/code&gt;是不对的，只有公有成员函数或友元函数才能访问。可以定义一个&lt;code&gt;show()&lt;/code&gt;方法访问a用来输出。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据封装：实现细节放在一起并与抽象分开。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据隐藏（数据放在类的私有部分）&lt;/li&gt;
&lt;li&gt;私有成员函数（实现细节隐藏在私有部分）&lt;/li&gt;
&lt;li&gt;类函数定义和类声明放在不同的文件中。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;类的构造函数与析构函数&quot;&gt;&lt;a href=&quot;#类的构造函数与析构函数&quot; class=&quot;headerlink&quot; title=&quot;类的构造函数与析构函数&quot;&gt;&lt;/a&gt;类的构造函数与析构函数&lt;/h2&gt;&lt;h3 id=&quot;类的构造函数&quot;&gt;&lt;a href=&quot;#类的构造函数&quot; class=&quot;headerlink&quot; title=&quot;类的构造函数&quot;&gt;&lt;/a&gt;类的构造函数&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;如果没有提供任何构造函数，C++自动提供默认构造函数，他不做任何工作，也就是说&lt;strong&gt;他的值在初始化时是未知的&lt;/strong&gt;；但是如果定义了构造函数，程序员必须为他提供默认构造函数，用户定义的默认构造函数通常给所有成员提供隐式初始值（已知合理值）。&lt;/li&gt;
&lt;li&gt;构造函数被用来创造对象，而不能通过对象来调用。（因为在通过构造函数构造出对象之前，对象是不存在的）。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;类的析构函数&quot;&gt;&lt;a href=&quot;#类的析构函数&quot; class=&quot;headerlink&quot; title=&quot;类的析构函数&quot;&gt;&lt;/a&gt;类的析构函数&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;对象过期时，程序自动调用析构函数；如果程序员没有声明，编译器隐式声明一个默认析构函数。&lt;/li&gt;
&lt;li&gt;注意窗口环境中，窗口关闭之前的代码包含在同一个代码块中，才能保证析构函数在窗口关闭之前执行。&lt;/li&gt;
&lt;li&gt;若构造函数中有&lt;code&gt;new&lt;/code&gt;，则析构函数必须&lt;code&gt;delete&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;构造函数的语法&quot;&gt;&lt;a href=&quot;#构造函数的语法&quot; class=&quot;headerlink&quot; title=&quot;构造函数的语法&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/applefishsky009/Leetcode/blob/master/26%20-%20Remove%20Duplicates%20from%20Sorted%20Array/26%20-%20Remove%20Duplicates%20from%20Sorted%20Array.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;构造函数的语法&lt;/a&gt;&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1. Num nums(initVector);
2. nums = Num(initVector)。
3. Num();
4. Num nums = Num();
5. Num nums = Num(initVector)；
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;1一定不会创建一个临时对象并析构；&lt;/li&gt;
&lt;li&gt;2是赋值语句一定会创建临时对象并析构(&lt;strong&gt;虽然有匿名对象但作用域限制&lt;/strong&gt;)；&lt;/li&gt;
&lt;li&gt;3也会创建一个临时对象并析构(因为没有匿名对象的载体)；&lt;/li&gt;
&lt;li&gt;4不会(因为有匿名对象载体)；&lt;/li&gt;
&lt;li&gt;5在本人编译器上会（这是&lt;strong&gt;拷贝构造&lt;/strong&gt;）。但是对于5这种创建&lt;strong&gt;有指定值的对象&lt;/strong&gt;，是否有临时对象是不确定的(取决于具体的实现)。&lt;/li&gt;
&lt;li&gt;总之，1的效率最高。&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类的简介&quot;&gt;&lt;a href=&quot;#类的简介&quot; class=&quot;headerlink&quot; title=&quot;类的简介&quot;&gt;&lt;/a&gt;类的简介&lt;/h2&gt;&lt;h3 id=&quot;类的规范由两部分组成：&quot;&gt;&lt;a href=&quot;#类的规范由两部分组成：&quot; class=&quot;headerlink&quot; ti
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="类" scheme="http://yoursite.com/tags/%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>五种变量存储方式与external关键字</title>
    <link href="http://yoursite.com/2016/04/06/%E4%BA%94%E7%A7%8D%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E4%B8%8Eexternal%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2016/04/06/五种变量存储方式与external关键字/</id>
    <published>2016-04-06T09:15:14.000Z</published>
    <updated>2016-04-18T08:58:58.184Z</updated>
    
    <content type="html">&lt;h2 id=&quot;五种变量存储方式&quot;&gt;&lt;a href=&quot;#五种变量存储方式&quot; class=&quot;headerlink&quot; title=&quot;五种变量存储方式&quot;&gt;&lt;/a&gt;五种变量存储方式&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;存储描述&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;持续性&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;作用域&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;链接性&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;如何声明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;自动&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;自动&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;代码块&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;无&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;代码块中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;寄存器&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;自动&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;代码块&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;无&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;代码块中，&lt;code&gt;register&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;静态，无链接性&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;静态&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;代码块&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;无&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;代码块中，&lt;code&gt;static&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;静态，外部连接性&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;静态&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;文件&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;外部&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;不在任何代码块中，无关键字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;静态，内部链接性&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;静态&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;文件&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;内部&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;不在任何代码块中，&lt;code&gt;static&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;register&lt;/code&gt;用于显示指出自动变量，没什么用处，C++11保留的目的是向下兼容；&lt;/li&gt;
&lt;li&gt;静态无链接性变量与自动变量的异同：&lt;ul&gt;
&lt;li&gt;静态无链接性变量在编译器&lt;strong&gt;编译&lt;/strong&gt;时，编译器在&lt;strong&gt;静态/全局存储区&lt;/strong&gt;分配内存；&lt;/li&gt;
&lt;li&gt;自动变量在代码块&lt;strong&gt;运行&lt;/strong&gt;时，编译器在&lt;strong&gt;栈&lt;/strong&gt;中分配内存；&lt;/li&gt;
&lt;li&gt;二者均只能在代码块中运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;external关键字&quot;&gt;&lt;a href=&quot;#external关键字&quot; class=&quot;headerlink&quot; title=&quot;external关键字&quot;&gt;&lt;/a&gt;external关键字&lt;/h2&gt;&lt;p&gt;变量的声明有两种：定义声明（简称为定义）与引用声明（简称为声明）。如果要在一个文件中使用另一个文件中定义声明的变量，仅仅将这个变量储存为外部链接性的静态变量是不够的，还要在引用的文件中使用&lt;code&gt;external&lt;/code&gt;关键字做&lt;strong&gt;引用声明&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;外部变量在&lt;code&gt;main()&lt;/code&gt;前面或头文件中定义它，在文件中定义之后的任何位置使用它；&lt;/li&gt;
&lt;li&gt;单定义规则：变量只能定义声明一次；&lt;/li&gt;
&lt;li&gt;局部变量隐藏同名的全局变量。如果要访问全局变量，可用作用域解析符&lt;code&gt;：：&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;静态变量将隐藏常规外部变量（使用&lt;code&gt;external&lt;/code&gt;关键字引用）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关于&lt;code&gt;external&lt;/code&gt;关键字的测试是很简单的，这里不给出代码。另外提到单定义规则，有一点需要注意。任何一个包含头文件的cpp都要重新编译这个头文件，因此头文件绝对不能包含函数体与变量。不然，两个或两个以上cpp包含它会出现重定义错误。&lt;/p&gt;
&lt;hr&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;五种变量存储方式&quot;&gt;&lt;a href=&quot;#五种变量存储方式&quot; class=&quot;headerlink&quot; title=&quot;五种变量存储方式&quot;&gt;&lt;/a&gt;五种变量存储方式&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="存储" scheme="http://yoursite.com/tags/%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>内存存储区</title>
    <link href="http://yoursite.com/2016/04/05/%E5%86%85%E5%AD%98%E5%AD%98%E5%82%A8%E5%8C%BA/"/>
    <id>http://yoursite.com/2016/04/05/内存存储区/</id>
    <published>2016-04-05T02:17:33.000Z</published>
    <updated>2016-04-18T08:58:39.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;C-内存分配方式有五种：&quot;&gt;&lt;a href=&quot;#C-内存分配方式有五种：&quot; class=&quot;headerlink&quot; title=&quot;C++内存分配方式有五种：&quot;&gt;&lt;/a&gt;C++内存分配方式有五种：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;栈：局部变量、函数参数等&lt;ul&gt;
&lt;li&gt;可以实现函数调用；&lt;/li&gt;
&lt;li&gt;动态扩展、收缩；&lt;/li&gt;
&lt;li&gt;位于用户虚拟地址空间顶部。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;堆：&lt;code&gt;new&lt;/code&gt;分配的内存块，&lt;code&gt;delete&lt;/code&gt;释放。&lt;/li&gt;
&lt;li&gt;自由存储区：&lt;code&gt;malloc&lt;/code&gt;分配，&lt;code&gt;free&lt;/code&gt;释放。&lt;/li&gt;
&lt;li&gt;全局/静态存储区：全局变量与静态变量&lt;/li&gt;
&lt;li&gt;常量存储区：存放常量&lt;ul&gt;
&lt;li&gt;如 &lt;code&gt;string s1 = “abcd”&lt;/code&gt;；&lt;code&gt;s1&lt;/code&gt;是代码块中的指针，在栈中；&lt;code&gt;“abcd”&lt;/code&gt;是常量，在常量存储区。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;new和malloc的区别：&quot;&gt;&lt;a href=&quot;#new和malloc的区别：&quot; class=&quot;headerlink&quot; title=&quot;new和malloc的区别：&quot;&gt;&lt;/a&gt;new和malloc的区别：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;new&lt;/code&gt;可以认为是&lt;code&gt;malloc&lt;/code&gt;加构造函数的执行；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;new&lt;/code&gt;出来的指针是直接带类型信息的，&lt;code&gt;malloc&lt;/code&gt;返回&lt;code&gt;void&lt;/code&gt;指针；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;delete&lt;/code&gt;会相应调用对象的析构函数。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&quot;堆和栈的区别：&quot;&gt;&lt;a href=&quot;#堆和栈的区别：&quot; class=&quot;headerlink&quot; title=&quot;堆和栈的区别：&quot;&gt;&lt;/a&gt;堆和栈的区别：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;管理方式：栈是编译器自助管理；堆是程序员控制，容易内存泄漏；&lt;ul&gt;
&lt;li&gt;内存泄漏：申请指针，指针指向内存，作用域或生命周期到了，指针释 放，但内存并没有释放，也无法访问，变成“死内存”。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;空间大小：堆内存几乎没有限制；栈一般有一定大小（编译器有默认值，可修改）&lt;/li&gt;
&lt;li&gt;碎片问题：堆频繁&lt;code&gt;new/delete&lt;/code&gt;会产生大量碎片（&lt;code&gt;delete&lt;/code&gt;出来的空间几乎不可能恰好等于&lt;code&gt;new&lt;/code&gt;的空间）；栈不会；&lt;/li&gt;
&lt;li&gt;生长方向：堆向上；栈向下。&lt;/li&gt;
&lt;li&gt;分配方式：堆动态；栈动态（&lt;code&gt;alloca&lt;/code&gt;，但他不需人工释放）或静态（编译器完成）&lt;/li&gt;
&lt;li&gt;分配效率：栈高于堆（栈：计算机系统提供，有底层支持；堆：C/C++库提供）&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;以上内容主要来自于&lt;a href=&quot;http://www.cnblogs.com/daocaoren/archive/2011/06/29/2092957.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;C-内存分配方式有五种：&quot;&gt;&lt;a href=&quot;#C-内存分配方式有五种：&quot; class=&quot;headerlink&quot; title=&quot;C++内存分配方式有五种：&quot;&gt;&lt;/a&gt;C++内存分配方式有五种：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;栈：局部变量、函数参数等&lt;ul&gt;
&lt;li&gt;可
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="存储" scheme="http://yoursite.com/tags/%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
</feed>
